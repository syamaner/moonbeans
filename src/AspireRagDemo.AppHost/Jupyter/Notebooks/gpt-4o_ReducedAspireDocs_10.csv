,user_input,reference_contexts,reference,synthesizer_name
0,What are the key features of MSTest in the context of .NET Aspire testing frameworks?,"['title: Write your first .NET Aspire test description: Learn how to test your .NET Aspire solutions using the xUnit, NUnit, and MSTest testing frameworks. ms.date: 11/11/2024 zone_pivot_groups: unit-testing-framework Write your first .NET Aspire test In this article, you learn how to create a test project, write tests, and run them for your .NET Aspire solutions. The tests in this article aren\'t unit tests, but rather functional or integration tests. .NET Aspire includes several variations of testing project templates that you can use to test your .NET Aspire resource dependenciesâ€”and their communications. The testing project templates are available for MSTest, NUnit, and xUnit testing frameworks and include a sample test that you can use as a starting point for your tests. The .NET Aspire test project templates rely on the ðŸ“¦ Aspire.Hosting.Testing NuGet package. This package exposes the Create a test project The easiest way to create a .NET Aspire test project is to use the testing project template. If you\'re starting a new .NET Aspire project and want to include test projects, the Visual Studio tooling supports that option. If you\'re adding a test project to an existing .NET Aspire project, you can use the dotnet new command to create a test project: :::zone pivot=""xunit"" dotnetcli dotnet new aspire-xunit :::zone-end :::zone pivot=""mstest"" dotnetcli dotnet new aspire-mstest :::zone-end :::zone pivot=""nunit"" dotnetcli dotnet new aspire-nunit :::zone-end For more information, see the .NET CLI dotnet new command documentation. Explore the test project The following example test project was created as part of the .NET Aspire Starter Application template. If you\'re unfamiliar with it, see Quickstart: Build your first .NET Aspire project. The .NET Aspire test project takes a project reference dependency on the target app host. Consider the template project: :::zone pivot=""xunit"" :::code language=""xml"" source=""snippets/testing/xunit/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end :::zone pivot=""mstest"" :::code language=""xml"" source=""snippets/testing/mstest/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end :::zone pivot=""nunit"" :::code language=""xml"" source=""snippets/testing/nunit/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end The preceding project file is fairly standard. There\'s a PackageReference to the ðŸ“¦ Aspire.Hosting.Testing NuGet package, which includes the required types to write tests for .NET Aspire projects. The template test project includes a IntegrationTest1 class with a single test. The test verifies the following scenario: The app host is successfully created and started. The webfrontend resource is available and running. An HTTP request can be made to the webfrontend resource and returns a successful response (HTTP 200 OK). Consider the following test class: :::zone pivot=""xunit"" :::code language=""csharp"" source=""snippets/testing/xunit/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end :::zone pivot=""mstest"" :::code language=""csharp"" source=""snippets/testing/mstest/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end :::zone pivot=""nunit"" :::code language=""csharp"" source=""snippets/testing/nunit/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end The preceding code: Relies on the The appHost is an instance of IDistributedApplicationTestingBuilder that represents the app host. The appHost instance has its service collection configured with the standard HTTP resilience handler. For more information, see Build resilient HTTP apps: Key development patterns. The appHost has its The app has its service provider get the The app is started asynchronously. An The resourceNotificationService is used to wait for the webfrontend resource to be available and running. A simple HTTP GET request is made to the root of the webfrontend resource. The test asserts that the response status code is OK.']","MSTest is one of the testing frameworks available for .NET Aspire, allowing users to create test projects that can verify the functionality of .NET Aspire solutions. The testing project templates for MSTest include a sample test that serves as a starting point. The MSTest template project relies on the Aspire.Hosting.Testing NuGet package, which provides the necessary types to write tests. An example test class in MSTest verifies that the app host is successfully created and started, checks the availability of the webfrontend resource, and ensures that an HTTP request to the webfrontend returns a successful response (HTTP 200 OK).",single_hop_specifc_query_synthesizer
1,What does the DistributedApplicationTestingBuilder do in .NET Aspire solutions?,"['Test resource environment variables To further test resources and their expressed dependencies in your .NET Aspire solution, you can assert that environment variables are injected correctly. The following example demonstrates how to test that the webfrontend resource has an HTTPS environment variable that resolves to the apiservice resource: :::zone pivot=""xunit"" :::code language=""csharp"" source=""snippets/testing/xunit/AspireApp.Tests/EnvVarTests.cs""::: :::zone-end :::zone pivot=""mstest"" :::code language=""csharp"" source=""snippets/testing/mstest/AspireApp.Tests/EnvVarTests.cs""::: :::zone-end :::zone pivot=""nunit"" :::code language=""csharp"" source=""snippets/testing/nunit/AspireApp.Tests/EnvVarTests.cs""::: :::zone-end The preceding code: Relies on the The builder instance is used to retrieve an The webfrontend resource is used to call The With the returned environment variables, the test asserts that the webfrontend resource has an HTTPS environment variable that resolves to the apiservice resource. Summary The .NET Aspire testing project template makes it easier to create test projects for .NET Aspire solutions. The template project includes a sample test that you can use as a starting point for your tests. The DistributedApplicationTestingBuilder follows a familiar pattern to the Finally, when using the DistributedApplicationTestingBuilder all resource logs are redirected to the DistributedApplication by default. The redirection of resource logs enables scenarios where you want to assert that a resource is logging correctly. See also Unit testing C# in .NET using dotnet test and xUnit MSTest overview Unit testing C# with NUnit and .NET Core']","The DistributedApplicationTestingBuilder follows a familiar pattern to help create test projects for .NET Aspire solutions. It allows for the redirection of all resource logs to the DistributedApplication by default, enabling scenarios where you can assert that a resource is logging correctly.",single_hop_specifc_query_synthesizer
2,What is the purpose of the DOTNET_DASHBOARD_OTLP_ENDPOINT_URL in the .NET Aspire dashboard?,"['title: Enable browser telemetry description: Learn how to enable browser telemetry in the .NET Aspire dashboard. ms.date: 11/11/2024 Enable browser telemetry The .NET Aspire dashboard can be configured to receive telemetry sent from browser apps. This feature is useful for monitoring client-side performance and user interactions. Browser telemetry requires additional dashboard configuration and that the JavaScript OTEL SDK is added to the browser apps. This article discusses how to enable browser telemetry in the .NET Aspire dashboard. Dashboard configuration Browser telemetry requires the dashboard to enable these features: OTLP HTTP endpoint. This endpoint is used by the dashboard to receive telemetry from browser apps. Cross-origin resource sharing (CORS). CORS allows browser apps to make requests to the dashboard. OTLP configuration The .NET Aspire dashboard receives telemetry through OTLP endpoints. HTTP OTLP endpoints and gRPC OTLP endpoints are supported by the dashboard. Browser apps must use HTTP OLTP to send telemetry to the dashboard because browser apps don\'t support gRPC. To configure the gPRC or HTTP endpoints, specify the following environment variables: DOTNET_DASHBOARD_OTLP_ENDPOINT_URL: The gRPC endpoint to which the dashboard connects for its data. DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL: The HTTP endpoint to which the dashboard connects for its data. Configuration of the HTTP OTLP endpoint depends on whether the dashboard is started by the app host or is run standalone. Configure OTLP HTTP with app host If the dashboard and your app are started by the app host, the dashboard OTLP endpoints are configured in the app host\'s launchSettings.json file. Consider the following example JSON file: :::code language=""json"" source=""snippets/BrowserTelemetry/BrowserTelemetry.AppHost/Properties/launchSettings.json"" highlight=""12,25""::: The preceding launch settings JSON file configures all profiles to include the DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL environment variable. Configure OTLP HTTP with standalone dashboard If the dashboard is used standalone, without the rest of .NET Aspire, the OTLP HTTP endpoint is enabled by default on port 18890. However, the port must be mapped when the dashboard container is started: Bash bash docker run --rm -it -d \\ -p 18888:18888 \\ -p 4317:18889 \\ -p 4318:18890 \\ --name aspire-dashboard \\ mcr.microsoft.com/dotnet/aspire-dashboard:9.0 PowerShell powershell docker run --rm -it -d ` -p 18888:18888 ` -p 4317:18889 ` -p 4318:18890 ` --name aspire-dashboard ` mcr.microsoft.com/dotnet/aspire-dashboard:9.0 The preceding command runs the dashboard container and maps gRPC OTLP to port 4317 and HTTP OTLP to port 4318. CORS configuration By default, browser apps are restricted from making cross domain API calls. This impacts sending telemetry to the dashboard because the dashboard and the browser app are always on different domains. Configuring CORS in the .NET Aspire dashboard removes the restriction. If the dashboard and your app are started by the app host, no CORS configuration is required. .NET Aspire automatically configures the dashboard to allow all resource origins. If the dashboard is used standlone then CORS must be configured manually. The domain used to view the browser app must be configured as an allowed origin by specifing the DASHBOARD__OTLP__CORS__ALLOWEDORIGINS environment variable when the dashboard container is started: Bash bash docker run --rm -it -d \\ -p 18888:18888 \\ -p 4317:18889 \\ -p 4318:18890 \\ -e DASHBOARD__OTLP__CORS__ALLOWEDORIGINS=https://localhost:8080 \\ --name aspire-dashboard \\ mcr.microsoft.com/dotnet/aspire-dashboard:9.0 PowerShell powershell docker run --rm -it -d ` -p 18888:18888 ` -p 4317:18889 ` -p 4318:18890 ` -e DASHBOARD__OTLP__CORS__ALLOWEDORIGINS=https://localhost:8080 ` --name aspire-dashboard ` mcr.microsoft.com/dotnet/aspire-dashboard:9.0 The preceding command runs the dashboard container and configures https://localhost:8080 as an allowed origin. That means a browser app that is accessed using https://localhost:8080 has permission to send the dashboard telemetry. Multiple origins can be allowed with a comma separated value. Or all origins can be allowed with the * wildcard. For example, DASHBOARD__OTLP__CORS__ALLOWEDORIGINS=*. For more information, see .NET Aspire dashboard configuration: OTLP CORS.']",The DOTNET_DASHBOARD_OTLP_ENDPOINT_URL is the gRPC endpoint to which the .NET Aspire dashboard connects for its data. It is used to receive telemetry from browser apps.,single_hop_specifc_query_synthesizer
3,How does HTTP work with OTLP endpoints in the context of dashboard security and telemetry?,"['OTLP endpoint security Dashboard OTLP endpoints can be secured with API key authentication. When enabled, HTTP OTLP requests to the dashboard must include the API key as the x-otlp-api-key header. By default a new API key is generated each time the dashboard is run. API key authentication is automatically enabled when the dashboard is run from the app host. Dashboard authentication can be disabled by setting DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS to true in the app host\'s launchSettings.json file. OTLP endpoints are unsecured by default in the standalone dashboard. Browser app configuration A browser app uses the JavaScript OTEL SDK to send telemetry to the dashboard. Successfully sending telemetry to the dashboard requires the SDK to be correctly configured. OTLP exporter OTLP exporters must be included in the browser app and configured with the SDK. For example, exporting distributed tracing with OTLP uses the @opentelemetry/exporter-trace-otlp-proto package. When OTLP is added to the SDK, OTLP options must be specified. OTLP options includes: url: The address that HTTP OTLP requests are made to. The address should be the dashboard HTTP OTLP endpoint and the path to the OTLP HTTP API. For example, https://localhost:4318/v1/traces for the trace OTLP exporter. If the browser app is launched by the app host then the HTTP OTLP endpoint is available from the OTEL_EXPORTER_OTLP_ENDPOINT environment variable. headers: The headers sent with requests. If OTLP endpoint API key authentication is enabled the x-otlp-api-key header must be sent with OTLP requests. If the browser app is launched by the app host then the API key is available from the OTEL_EXPORTER_OTLP_HEADERS environment variable. Browser metadata When a browser app is configured to collect distributed traces, the browser app can set the trace parent a browser\'s spans using the meta element in the HTML. The value of the name=""traceparent"" meta element should correspond to the current trace. In a .NET app, for example, the trace parent value would likely be assigned from the razor <head> @if (Activity.Current is { } currentActivity) { <meta name=""traceparent"" content=""@currentActivity.Id"" /> } <!-- Other elements omitted for brevity... --> </head> The preceding code sets the traceparent meta element to the current activity ID. Example browser telemetry code The following JavaScript code demonstrates the initialization of the OpenTelemetry JavaScript SDK and the sending of telemetry data to the dashboard: :::code language=""javascript"" source=""snippets/BrowserTelemetry/BrowserTelemetry.Web/Scripts/index.js""::: The preceding JavaScript code defines an initializeTelemetry function that expects the OTLP endpoint URL, the headers, and the resource attributes. These parameters are provided by the consuming browser app that pulls them from the environment variables set by the app host. Consider the following Razor code: :::code language=""razor"" source=""snippets/BrowserTelemetry/BrowserTelemetry.Web/Pages/Shared/_Layout.cshtml"" highlight=""31-38""::: [!TIP] The bundling and minification of the JavaScript code is beyond the scope of this article. For the complete working example of how to configure the JavaScript OTEL SDK to send telemetry to the dashboard, see the browser telemetry sample. See also .NET Aspire dashboard configuration Standalone .NET Aspire dashboard Browser telemetry sample']","HTTP OTLP requests to the dashboard must include the API key as the x-otlp-api-key header when API key authentication is enabled. A new API key is generated each time the dashboard is run, and this authentication is automatically enabled when the dashboard is run from the app host. If the browser app is launched by the app host, the HTTP OTLP endpoint is available from the OTEL_EXPORTER_OTLP_ENDPOINT environment variable, and the API key can be accessed from the OTEL_EXPORTER_OTLP_HEADERS environment variable. The address for HTTP OTLP requests should point to the dashboard HTTP OTLP endpoint, such as https://localhost:4318/v1/traces for the trace OTLP exporter.",single_hop_specifc_query_synthesizer
4,What Qdrant do?,"['title: .NET Aspire Qdrant integration description: Learn how to use the .NET Aspire Qdrant integration, which includes both hosting and client integrations. ms.date: 01/13/2025 uid: database/qdrant-integration .NET Aspire Qdrant integration [!INCLUDE includes-hosting-and-client] Qdrant is an open-source vector similarity search engine that efficiently stores, indexes, and searches large-scale vector data. It\'s commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Qdrant integration. The .NET Aspire Qdrant integration enables you to connect to existing Qdrant databases or create new instances with the qdrant/qdrant container image. Hosting integration The Qdrant hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Qdrant PackageReference xml <PackageReference Include=""Aspire.Hosting.Qdrant"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Qdrant resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Qdrant container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the qdrant/qdrant image, it creates a new Qdrant instance on your local machine. The resource is named qdrant and then added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing Qdrant server, call [!TIP] The qdrant/qdrant container image includes a web UI that you can use to explore your vectors and administer the database. To access this tool, start your .NET Aspire solution and then, in the .NET Aspire dashboard, select the endpoint for the Qdrant resource. In your browser\'s address bar, append /dashboard and press Enter. Handling API keys and passing other parameters for the Qdrant resource To connect to Qdrant a client must pass the right API key. In the above code, when .NET Aspire adds a Qdrant resource to your solution, it sets the API key to a random string. If you want to use a specific API key instead, you can pass it as an apiKey parameter: ```csharp var apiKey = builder.AddParameter(""apiKey"", secret: true); var qdrant = builder.AddQdrant(""qdrant"", apiKey); builder.AddProject Qdrant supports configuration-based default API keys by using the environment variable QDRANT__SERVICE__API_KEY. The preceding code gets a parameter to pass to the AddQdrant API, and internally assigns the parameter to the QDRANT__SERVICE__API_KEY environment variable of the Qdrant container. The apiKey parameter is usually specified as a user secret: json { ""Parameters"": { ""apiKey"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Qdrant resource with data volume To add a data volume to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Qdrant data outside the lifecycle of its container. The data volume is mounted at the /qdrant/storage path in the Qdrant container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Qdrant resource with data bind mount To add a data bind mount to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataBindMount(source: @""C:\\Qdrant\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Qdrant data across container restarts. The data bind mount is mounted at the C:\\Qdrant\\Data folder on Windows (or /Qdrant/Data on Unix) on the host machine in the Qdrant container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Qdrant hosting integration automatically adds a health check for the Qdrant resource. The health check verifies that Qdrant is running and that a connection can be established to it.']","Qdrant is an open-source vector similarity search engine that efficiently stores, indexes, and searches large-scale vector data. It's commonly used in machine learning, artificial intelligence, and data science applications.",single_hop_specifc_query_synthesizer
5,"How do you integrate the Qdrant client in a .NET project, and what are the steps involved?","['Client integration To get started with the .NET Aspire Qdrant client integration, install the ðŸ“¦ Aspire.Qdrant.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Qdrant client. The Qdrant client integration registers a Qdrant.Client.QdrantClient instance that you can use to interact with Qdrant vector data. .NET CLI dotnetcli dotnet add package Aspire.Qdrant.Client PackageReference xml <PackageReference Include=""Aspire.Qdrant.Client"" Version=""*"" /> Add a Qdrant client In the Program.cs file of your client-consuming project, call the csharp builder.AddQdrantClient(""qdrant""); [!TIP] The connectionName parameter must match the name used when adding the Qdrant resource in the app host project. In other words, when you call AddQdrant and provide a name of qdrant that same name should be used when calling AddQdrantClient. For more information, see Add Qdrant resource. You can then retrieve the QdrantClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(QdrantClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Qdrant client There might be situations where you want to register multiple QdrantClient instances with different connection names. To register keyed Qdrant clients, call the csharp builder.AddKeyedQdrantClient(name: ""mainQdrant""); builder.AddKeyedQdrantClient(name: ""loggingQdrant""); Then you can retrieve the QdrantClient instances using dependency injection. For example, to retrieve the connections from an example service: csharp public class ExampleService( [FromKeyedServices(""mainQdrant"")] QdrantClient mainQdrantClient, [FromKeyedServices(""loggingQdrant"")] QdrantClient loggingQdrantClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Qdrant client integration provides multiple options to configure the connection to Qdrant based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddQdrantClient(): csharp builder.AddQdrantClient(""qdrant""); Then .NET Aspire retrieves the connection string from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""qdrant"": ""Endpoint=http://localhost:6334;Key=123456!@#$%"" } } By default the QdrantClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Qdrant client integration supports json { ""Aspire"": { ""Qdrant"": { ""Client"": { ""Endpoint"": ""http://localhost:6334/"", ""Key"": ""123456!@#$%"" } } } } For the complete Qdrant client integration JSON schema, see Aspire.Qdrant.Client/ConfigurationSchema.json. Use inline delegates You can also pass the Action<QdrantClientSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddQdrantClient( ""qdrant"", settings => settings.Key = ""12345!@#$%""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Qdrant integration uses standard .NET logging, and you\'ll see log entries from the following category: Qdrant.Client Tracing The .NET Aspire Qdrant integration doesn\'t currently emit tracing activities because they are not supported by the Qdrant.Client library. Metrics The .NET Aspire Qdrant integration doesn\'t currently emit metrics because they are not supported by the Qdrant.Client library. See also Qdrant Qdrant documentation Qdrant GitHub repo Qdrant .NET SDK .NET Aspire integrations .NET Aspire GitHub repo']","To integrate the Qdrant client in a .NET project, you need to install the Aspire.Qdrant.Client NuGet package in your client-consuming project. This integration registers a Qdrant.Client.QdrantClient instance for interacting with Qdrant vector data. In the Program.cs file, you should call builder.AddQdrantClient(""qdrant""). Ensure that the connectionName parameter matches the name used when adding the Qdrant resource in the app host project. You can retrieve the QdrantClient instance using dependency injection. If you need multiple QdrantClient instances with different connection names, you can register them using builder.AddKeyedQdrantClient(name: ""mainQdrant"") and builder.AddKeyedQdrantClient(name: ""loggingQdrant""). The integration also allows configuration through connection strings, configuration providers, or inline delegates to set up options like the API key. By default, health checks are enabled for all services.",single_hop_specifc_query_synthesizer
6,What does Action<EntityFrameworkCoreCosmosSettings> do in the context of .NET Aspire Cosmos DB integration?,"['title: .NET Aspire Cosmos DB Entity Framework Core integration description: Learn how to install and configure the .NET Aspire Cosmos DB Entity Framework Core integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-entity-framework-integration .NET Aspire Cosmos DB Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.Cosmos"" Version=""*"" /> Add Cosmos DB context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmosdb that same name should be used when calling AddCosmosDbContext. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(MyDbContext context) { // Use context... } For more information on using Entity Framework Core with Azure Cosmos DB, see the Examples for Azure Cosmos DB for NoSQL SDK for .NET. Configuration The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddCosmosDbContext: csharp builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information, see the ConnectionString documentation. Use configuration providers The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""Cosmos"": { ""DisableTracing"": true } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json. Use inline delegates You can also pass the Action<EntityFrameworkCoreCosmosSettings> configureSettings delegate to set up some or all the csharp builder.AddCosmosDbContext<MyDbContext>( ""cosmosdb"", settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn\'t implement health checks, though this may change in future releases. [!INCLUDE integration-observability-and-telemetry]']","The Action<EntityFrameworkCoreCosmosSettings> delegate can be passed to configure some or all settings when calling builder.AddCosmosDbContext<MyDbContext>(""cosmosdb"", settings => settings.DisableTracing = true);",single_hop_specifc_query_synthesizer
7,What logging categories are used in Entity Framework Core integration with Cosmos DB?,['Logging The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration uses the following log categories: Azure-Cosmos-Operation-Request-Diagnostics Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Query Tracing The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration will emit the following tracing activities using OpenTelemetry: Azure.Cosmos.Operation OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently supports the following metrics: Microsoft.EntityFrameworkCore ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second See also Azure Cosmos DB docs .NET Aspire integrations .NET Aspire GitHub repo'],"The logging categories used in the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration include: Azure-Cosmos-Operation-Request-Diagnostics, Microsoft.EntityFrameworkCore.ChangeTracking, Microsoft.EntityFrameworkCore.Database.Command, Microsoft.EntityFrameworkCore.Infrastructure, and Microsoft.EntityFrameworkCore.Query.",single_hop_specifc_query_synthesizer
8,What is the purpose of Aspire.Microsoft.EntityFrameworkCore.SqlServer in .NET applications?,"['title: .NET Aspire SQL Server Entity Framework Core integration description: Learn how to use the .NET Aspire SQL Server Entity Framework integration, which includes both hosting and client integrations. ms.date: 12/02/2024 uid: database/sql-server-ef-core-integration .NET Aspire SQL Server Entity Framework Core integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server Entity Framework Core integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server Entity Framework Core integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server Entity Framework Core client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.SqlServer"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add SQL Server database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerDbContext. For more information, see Add SQL Server resource and database resource. To retrieve ExampleDbContext object from a service: csharp public class ExampleService(ExampleDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add SQL Server database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichSqlServerDbContext<ExampleDbContext>( connectionName: ""database"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the Configuration The .NET Aspire SQL Server Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling builder.AddSqlServerDbContext<TContext>(): csharp builder.AddSqlServerDbContext<ExampleDbContext>(""sql""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""sql"": ""Data Source=myserver;Initial Catalog=master"" } } The EnrichSqlServerDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it\'s called. For more information, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server Entity Framework Core integration supports The following is an example of an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""SqlServer"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableMetrics"": false } } } } } Use inline configurations You can also pass the Action<MicrosoftEntityFrameworkCoreSqlServerSettings> delegate to set up some or all the options inline, for example to turn off the metrics: csharp builder.AddSqlServerDbContext<YourDbContext>( ""sql"", static settings => settings.DisableMetrics = true); Configure multiple DbContext connections If you want to register more than one DbContext with different configuration, you can use $""Aspire.Microsoft.EntityFrameworkCore.SqlServer:{typeof(TContext).Name}"" configuration section name. The json configuration would look like: json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""SqlServer"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableMetrics"": false, ""AnotherDbContext"": { ""ConnectionString"": ""AnotherDbContext_CONNECTIONSTRING"", ""DisableTracing"": false } } } } } } Then calling the AddSqlServerDbContext method with AnotherDbContext type parameter would load the settings from Aspire:Microsoft:EntityFrameworkCore:SqlServer:AnotherDbContext section. csharp builder.AddSqlServerDbContext<AnotherDbContext>(""another-sql""); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the SQL Server database to connect to. DbContextPooling A boolean value that indicates whether the db context will be pooled or explicitly created every time it\'s requested MaxRetryCount The maximum number of retry attempts. Default value is 6, set it to 0 to disable the retry mechanism. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. DisableMetrics A boolean value that indicates whether the OpenTelemetry metrics are disabled or not. Timeout The time in seconds to wait for the command to execute. [!INCLUDE integration-health-checks] By default, the .NET Aspire Sql Server Entity Framework Core integration handles the following: Adds the DbContextHealthCheck, which calls EF Core\'s Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]']","Aspire.Microsoft.EntityFrameworkCore.SqlServer is a NuGet package that enables .NET applications to connect to existing SQL Server instances or create new instances from .NET, facilitating the integration of SQL Server with Entity Framework Core.",single_hop_specifc_query_synthesizer
9,What are the logging categories associated with Microsoft.EntityFrameworkCore.Migrations?,"['Logging The .NET Aspire SQL Server Entity Framework Core integration uses the following Log categories: Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Database.Connection Microsoft.EntityFrameworkCore.Database.Transaction Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Migrations Microsoft.EntityFrameworkCore.Model Microsoft.EntityFrameworkCore.Model.Validation Microsoft.EntityFrameworkCore.Query Microsoft.EntityFrameworkCore.Update Tracing The .NET Aspire SQL Server Entity Framework Core integration will emit the following Tracing activities using OpenTelemetry: ""OpenTelemetry.Instrumentation.EntityFrameworkCore"" Metrics The .NET Aspire SQL Server Entity Framework Core integration will emit the following metrics using OpenTelemetry: Microsoft.EntityFrameworkCore: ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second See also Azure SQL Database documentation .NET Aspire integrations .NET Aspire GitHub repo']","The logging categories associated with Microsoft.EntityFrameworkCore.Migrations include Microsoft.EntityFrameworkCore.ChangeTracking, Microsoft.EntityFrameworkCore.Database.Command, Microsoft.EntityFrameworkCore.Database.Connection, Microsoft.EntityFrameworkCore.Database.Transaction, Microsoft.EntityFrameworkCore.Infrastructure, Microsoft.EntityFrameworkCore.Migrations, Microsoft.EntityFrameworkCore.Model, Microsoft.EntityFrameworkCore.Model.Validation, Microsoft.EntityFrameworkCore.Query, and Microsoft.EntityFrameworkCore.Update.",single_hop_specifc_query_synthesizer
10,What are the key features of .NET Aspire's inner-loop networking?,"['title: .NET Aspire inner loop networking overview description: Learn how .NET Aspire handles networking and endpoints, and how you can use them in your app code. ms.date: 10/29/2024 ms.topic: overview .NET Aspire inner-loop networking overview One of the advantages of developing with .NET Aspire is that it enables you to develop, test, and debug cloud-native apps locally. Inner-loop networking is a key aspect of .NET Aspire that allows your apps to communicate with each other in your development environment. In this article, you learn how .NET Aspire handles various networking scenarios with proxies, endpoints, endpoint configurations, and launch profiles. Networking in the inner loop The inner loop is the process of developing and testing your app locally before deploying it to a target environment. .NET Aspire provides several tools and features to simplify and enhance the networking experience in the inner loop, such as: Launch profiles: Launch profiles are configuration files that specify how to run your app locally. You can use launch profiles (such as the launchSettings.json file) to define the endpoints, environment variables, and launch settings for your app. Kestrel configuration: Kestrel configuration allows you to specify the endpoints that the Kestrel web server listens on. You can configure Kestrel endpoints in your app settings, and .NET Aspire automatically uses these settings to create endpoints. Endpoints/Endpoint configurations: Endpoints are the connections between your app and the services it depends on, such as databases, message queues, or APIs. Endpoints provide information such as the service name, host port, scheme, and environment variable. You can add endpoints to your app either implicitly (via launch profiles) or explicitly by calling Proxies: .NET Aspire automatically launches a proxy for each service binding you add to your app, and assigns a port for the proxy to listen on. The proxy then forwards the requests to the port that your app listens on, which might be different from the proxy port. This way, you can avoid port conflicts and access your app and services using consistent and predictable URLs. How endpoints work A service binding in .NET Aspire involves two integrations: a service representing an external resource your app requires (for example, a database, message queue, or API), and a binding that establishes a connection between your app and the service and provides necessary information. .NET Aspire supports two service binding types: implicit, automatically created based on specified launch profiles defining app behavior in different environments, and explicit, manually created using Upon creating a binding, whether implicit or explicit, .NET Aspire launches a lightweight reverse proxy on a specified port, handling routing and load balancing for requests from your app to the service. The proxy is a .NET Aspire implementation detail, requiring no configuration or management concern. To help visualize how endpoints work, consider the .NET Aspire starter templates inner-loop networking diagram: :::image type=""content"" source=""media/networking/networking-proxies-1x.png"" lightbox=""media/networking/networking-proxies.png"" alt-text="".NET Aspire Starter Application template inner loop networking diagram.""::: Launch profiles When you call An explicit launchProfileName argument passed when calling AddProject. The DOTNET_LAUNCH_PROFILE environment variable. For more information, see .NET environment variables. The first launch profile defined in launchSettings.json. Consider the following launchSettings.json file: :::code language=""json"" source=""snippets/networking/Networking.Frontend/Networking.Frontend/Properties/launchSettings.json""::: For the remainder of this article, imagine that you\'ve created an csharp var builder = DistributedApplication.CreateBuilder(args); To specify the http and https launch profiles, configure the applicationUrl values for both in the launchSettings.json file. These URLs are used to create endpoints for this project. This is the equivalent of: :::code source=""snippets/networking/Networking.AppHost/Program.WithLaunchProfile.cs"" id=""verbose""::: [!IMPORTANT] If there\'s no launchSettings.json (or launch profile), there are no bindings by default. For more information, see .NET Aspire and launch profiles.']",".NET Aspire's inner-loop networking allows apps to communicate in the development environment, enabling the development, testing, and debugging of cloud-native apps locally. Key features include launch profiles for configuring how to run apps, Kestrel configuration for specifying server endpoints, and automatic proxy creation for service bindings to avoid port conflicts.",single_hop_specifc_query_synthesizer
11,"How does Kestrel endpoint configuration work in .NET Aspire, particularly regarding HTTPS and port settings?","['Kestrel configured endpoints .NET Aspire supports Kestrel endpoint configuration. For example, consider an appsettings.json file for a project that defines a Kestrel endpoint with the HTTPS scheme and port 5271: :::code language=""json"" source=""snippets/networking/Networking.Frontend/Networking.Frontend/appsettings.Development.json"" highlight=""8-14""::: The preceding configuration specifies an Https endpoint. The Url property is set to https://*:5271, which means the endpoint listens on all interfaces on port 5271. For more information, see Configure endpoints for the ASP.NET Core Kestrel web server. With the Kestrel endpoint configured, the project should remove any configured applicationUrl from the launchSettings.json file. [!NOTE] If the applicationUrl is present in the launchSettings.json file and the Kestrel endpoint is configured, the app host will throw an exception. When you add a project resource, there\'s an overload that lets you specify that the Kestrel endpoint should be used instead of the launchSettings.json file: :::code source=""snippets/networking/Networking.AppHost/Program.KestrelConfiguration.cs"" id=""kestrel""::: For more information, see Ports and proxies When defining a service binding, the host port is always given to the proxy that sits in front of the service. This allows single or multiple replicas of a service to behave similarly. Additionally, all resource dependencies that use the Consider the following method chain that calls :::code source=""snippets/networking/Networking.AppHost/Program.WithReplicas.cs"" id=""withreplicas""::: The preceding code results in the following networking diagram: :::image type=""content"" source=""media/networking/proxy-with-replicas-1x.png"" lightbox=""media/networking/proxy-with-replicas.png"" alt-text="".NET Aspire frontend app networking diagram with specific host port and two replicas.""::: The preceding diagram depicts the following: A web browser as an entry point to the app. A host port of 5066. The frontend proxy sitting between the web browser and the frontend service replicas, listening on port 5066. The frontend_0 frontend service replica listening on the randomly assigned port 65001. The frontend_1 frontend service replica listening on the randomly assigned port 65002. Without the call to WithReplicas, there\'s only one frontend service. The proxy still listens on port 5066, but the frontend service listens on a random port: :::code source=""snippets/networking/Networking.AppHost/Program.HostPortAndRandomPort.cs"" id=""hostport""::: There are two ports defined: A host port of 5066. A random proxy port that the underlying service will be bound to. :::image type=""content"" source=""media/networking/proxy-host-port-and-random-port-1x.png"" lightbox=""media/networking/proxy-host-port-and-random-port.png"" alt-text="".NET Aspire frontend app networking diagram with specific host port and random port.""::: The preceding diagram depicts the following: A web browser as an entry point to the app. A host port of 5066. The frontend proxy sitting between the web browser and the frontend service, listening on port 5066. The frontend service listening on random port of 65001. The underlying service is fed this port via ASPNETCORE_URLS for project resources. Other resources access to this port by specifying an environment variable on the service binding: :::code source=""snippets/networking/Networking.AppHost/Program.EnvVarPort.cs"" id=""envvarport""::: The previous code makes the random port available in the PORT environment variable. The app uses this port to listen to incoming connections from the proxy. Consider the following diagram: :::image type=""content"" source=""media/networking/proxy-with-env-var-port-1x.png"" lightbox=""media/networking/proxy-with-env-var-port.png"" alt-text="".NET Aspire frontend app networking diagram with specific host port and environment variable port.""::: The preceding diagram depicts the following: A web browser as an entry point to the app. A host port of 5067. The frontend proxy sitting between the web browser and the frontend service, listening on port 5067. The frontend service listening on an environment 65001. [!TIP] To avoid an endpoint being proxied, set the IsProxied property to false when calling the WithEndpoint extension method. For more information, see Endpoint extensions: additional considerations. Omit the host port When you omit the host port, .NET Aspire generates a random port for both host and service port. This is useful when you want to avoid port conflicts and don\'t care about the host or service port. Consider the following code: :::code source=""snippets/networking/Networking.AppHost/Program.OmitHostPort.cs"" id=""omithostport""::: In this scenario, both the host and service ports are random, as shown in the following diagram: :::image type=""content"" source=""media/networking/proxy-with-random-ports-1x.png"" lightbox=""media/networking/proxy-with-random-ports.png"" alt-text="".NET Aspire frontend app networking diagram with random host port and proxy port.""::: The preceding diagram depicts the following: A web browser as an entry point to the app. A random host port of 65000. The frontend proxy sitting between the web browser and the frontend service, listening on port 65000. The frontend service listening on a random port of 65001. Container ports When you add a container resource, .NET Aspire automatically assigns a random port to the container. To specify a container port, configure the container resource with the desired port: :::code source=""snippets/networking/Networking.AppHost/Program.ContainerPort.cs"" id=""containerport""::: The preceding code: Creates a container resource named frontend, from the mcr.microsoft.com/dotnet/samples:aspnetapp image. Exposes an http endpoint by binding the host to port 8000 and mapping it to the container\'s port 8080. Consider the following diagram: :::image type=""content"" source=""media/networking/proxy-with-docker-port-mapping-1x.png"" alt-text="".NET Aspire frontend app networking diagram with a docker host."":::']","Kestrel endpoint configuration in .NET Aspire supports defining an HTTPS endpoint through the appsettings.json file. For instance, the configuration specifies a URL property set to https://*:5271, allowing the endpoint to listen on all interfaces on port 5271. It's important to note that if a Kestrel endpoint is configured, any applicationUrl in the launchSettings.json file should be removed to avoid exceptions. Additionally, when defining service bindings, the host port is given to the proxy in front of the service, enabling multiple replicas to behave similarly. The configuration can also allow for random ports to be assigned to services, which is useful for avoiding port conflicts.",single_hop_specifc_query_synthesizer
12,What role does ASPNETCORE_URLS play in configuring endpoints in .NET Aspire projects?,"['Endpoint extension methods Any resource that implements the There\'s also an overload that allows you to specify a delegate to configure the endpoint. This is useful when you need to configure the endpoint based on the environment or other factors. Consider the following code: :::code source=""snippets/networking/Networking.AppHost/Program.WithEndpoint.cs"" id=""withendpoint""::: The preceding code provides a callback delegate to configure the endpoint. The endpoint is named admin and configured to use the http scheme and transport, as well as the 17003 host port. The consumer references this endpoint by name, consider the following AddHttpClient call: csharp builder.Services.AddHttpClient<WeatherApiClient>( client => client.BaseAddress = new Uri(""http://_admin.apiservice"")); The Uri is constructed using the admin endpoint name prefixed with the _ sentinel. This is a convention to indicate that the admin segment is the endpoint name belonging to the apiservice service. For more information, see .NET Aspire service discovery. Additional considerations When calling the WithEndpoint extension method, the callback overload exposes the raw The AllocatedEndpoint property allows you to get or set the endpoint for a service. The IsExternal and IsProxied properties determine how the endpoint is managed and exposed: IsExternal decides if it should be publicly accessible, while IsProxied ensures DCP manages it, allowing for internal port differences and replication. [!TIP] If you\'re hosting an external executable that runs its own proxy and encounters port binding issues due to DCP already binding the port, try setting the IsProxied property to false. This prevents DCP from managing the proxy, allowing your executable to bind the port successfully. The Name property identifies the service, whereas the Port and TargetPort properties specify the desired and listening ports, respectively. For network communication, the Protocol property supports TCP and UDP, with potential for more in the future, and the Transport property indicates the transport protocol (HTTP, HTTP2, HTTP3). Lastly, if the service is URI-addressable, the UriScheme property provides the URI scheme for constructing the service URI. For more information, see the available properties of the EndpointAnnotation properties. Endpoint filtering All .NET Aspire project resource endpoints follow a set of default heuristics. Some endpoints are included in ASPNETCORE_URLS at runtime, some are published as HTTP/HTTPS_PORTS, and some configurations are resolved from Kestrel configuration. Regardless of the default behavior, you can filter the endpoints that are included in environment variables by using the :::code source=""snippets/networking/Networking.AppHost/Program.EndpointFilter.cs"" id=""filter""::: The preceding code adds a default HTTPS endpoint, as well as an admin endpoint on port 19227. However, the admin endpoint is excluded from the environment variables. This is useful when you want to expose an endpoint for internal use only.']","ASPNETCORE_URLS is involved in determining which endpoints are included at runtime in .NET Aspire projects. Some endpoints are published as HTTP/HTTPS_PORTS, while others are resolved from Kestrel configuration. Additionally, you can filter the endpoints included in environment variables, allowing for more control over which endpoints are exposed.",single_hop_specifc_query_synthesizer
13,How does .NET Aspire facilitate the use of Application Insights for telemetry?,"['title: Use .NET Aspire with Application Insights description: Learn how to send .NET Aspire telemetry to Application Insights. ms.date: 04/12/2024 ms.topic: how-to Use Application Insights for .NET Aspire telemetry Azure Application Insights, a feature of Azure Monitor, excels in Application Performance Management (APM) for live web applications. .NET Aspire projects are designed to use OpenTelemetry for application telemetry. OpenTelemetry supports an extension model to support sending data to different APMs. .NET Aspire uses OTLP by default for telemetry export, which is used by the dashboard during development. Azure Monitor doesn\'t (yet) support OTLP, so the applications need to be modified to use the Azure Monitor exporter, and configured with the connection string. To use Application insights, you specify its configuration in the app host project and use the Azure Monitor distro in the service defaults project. Choosing how Application Insights is provisioned .NET Aspire has the capability to provision cloud resources as part of cloud deployment, including Application Insights. In your .NET Aspire project, you can decide if you want .NET Aspire to provision an Application Insights resource when deploying to Azure. You can also select to use an existing Application Insights resource by providing its connection string. The connection information is managed by the resource configuration in the app host project. Provisioning Application insights during Azure deployment With this option, an instance of Application Insights will be created for you when the application is deployed using the Azure Developer CLI (azd). To use automatic provisioning, you specify a dependency in the app host project, and reference it in each project/resource that needs to send telemetry to Application Insights. The steps include: Add a Nuget package reference to Aspire.Hosting.Azure.ApplicationInsights in the app host project. Update the app host code to use the Application Insights resource, and reference it from each project: ```csharp var builder = DistributedApplication.CreateBuilder(args); // Automatically provision an Application Insights resource var insights = builder.AddAzureApplicationInsights(""MyApplicationInsights""); // Reference the resource from each project var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` Follow the steps in Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide) to deploy the application to Azure Container Apps. azd will create an Application Insights resource as part of the same resource group, and configure the connection string for each container. Manual provisioning of Application Insights resource Application Insights uses a connection string to tell the OpenTelemetry exporter where to send the telemetry data. The connection string is specific to the instance of Application Insights you want to send the telemetry to. It can be found in the Overview page for the application insights instance. :::image type=""content"" loc-scope=""azure"" source=""../media/app-insights-connection-string.png"" lightbox=""../media/app-insights-connection-string.png"" alt-text=""Connection string placement in the Azure Application Insights portal UI.""::: If you wish to use an instance of Application Insights that you have provisioned manually, then you should use the AddConnectionString API in the app host project to tell the projects/containers where to send the telemetry data. The Azure Monitor distro expects the environment variable to be APPLICATIONINSIGHTS_CONNECTION_STRING, so that needs to be explicitly set when defining the connection string. ```csharp var builder = DistributedApplication.CreateBuilder(args); var insights = builder.AddConnectionString( ""myInsightsResource"", ""APPLICATIONINSIGHTS_CONNECTION_STRING""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ```']",".NET Aspire facilitates the use of Application Insights for telemetry by allowing projects to use OpenTelemetry for application telemetry. It supports automatic provisioning of Application Insights resources during cloud deployment, enabling developers to specify whether to create a new Application Insights resource or use an existing one by providing its connection string. The configuration for Application Insights is managed in the app host project, and developers can reference the resource from each project that needs to send telemetry data.",single_hop_specifc_query_synthesizer
14,How do you manage secrets for the .NET Aspire project during development and deployment?,"['Resource usage during development When running the .NET Aspire project locally, the preceding code reads the connection string from configuration. As this is a secret, you should store the value in app secrets. Right click on the app host project and choose Manage Secrets from the context menu to open the secrets file for the app host project. In the file add the key and your specific connection string, the example below is for illustration purposes. json { ""ConnectionStrings"": { ""myInsightsResource"": ""InstrumentationKey=12345678-abcd-1234-abcd-1234abcd5678;IngestionEndpoint=https://westus3-1.in.applicationinsights.azure.com"" } } [!NOTE] The name specified in the app host code needs to match a key inside the ConnectionStrings section in the settings file. Resource usage during deployment When deploying an Aspire application with Azure Developer CLI (azd), it will recognize the connection string resource and prompt for a value. This enables a different resource to be used for the deployment from the value used for local development. Mixed deployment If you wish to use a different deployment mechanism per execution context, use the appropriate API conditionally. For example, the following code uses a pre-supplied connection at development time, and an automatically provisioned resource at deployment time. ``` csharp var builder = DistributedApplication.CreateBuilder(args); var insights = builder.ExecutionContext.IsPublishMode ? builder.AddAzureApplicationInsights(""myInsightsResource"") : builder.AddConnectionString(""myInsightsResource"", ""APPLICATIONINSIGHTS_CONNECTION_STRING""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` [!TIP] The preceding code requires you to supply the connection string information in app secrets for development time usage, and will be prompted for the connection string by azd at deployment time. Use the Azure Monitor distro To make exporting to Azure Monitor simpler, this example uses the Azure Monitor Exporter Repo. This is a wrapper package around the Azure Monitor OpenTelemetry Exporter package that makes it easier to export to Azure Monitor with a set of common defaults. Add the following package to the ServiceDefaults project, so that it will be included in each of the .NET Aspire services. For more information, see .NET Aspire service defaults. xml <PackageReference Include=""Azure.Monitor.OpenTelemetry.AspNetCore"" Version=""*"" /> Add a using statement to the top of the project. csharp using Azure.Monitor.OpenTelemetry.AspNetCore; Uncomment the line in AddOpenTelemetryExporters to use the Azure Monitor exporter: ```csharp private static IHostApplicationBuilder AddOpenTelemetryExporters( this IHostApplicationBuilder builder) { // Omitted for brevity... // Uncomment the following lines to enable the Azure Monitor exporter // (requires the Azure.Monitor.OpenTelemetry.AspNetCore package) if (!string.IsNullOrEmpty(builder.Configuration[""APPLICATIONINSIGHTS_CONNECTION_STRING""])) { builder.Services.AddOpenTelemetry().UseAzureMonitor(); } return builder; } ``` It\'s possible to further customize the Azure Monitor exporter, including customizing the resource name and changing the sampling. For more information, see Customize the Azure Monitor exporter. Using the parameterless version of UseAzureMonitor(), will pickup the connection string from the APPLICATIONINSIGHTS_CONNECTION_STRING environment variable, we configured via the app host project.']","When running the .NET Aspire project locally, you should store the connection string in app secrets because it is a secret. To do this, right-click on the app host project and choose Manage Secrets from the context menu to open the secrets file. In this file, you add the key and your specific connection string. For deployment, when deploying an Aspire application with Azure Developer CLI (azd), it recognizes the connection string resource and prompts for a value, allowing a different resource to be used for deployment compared to local development.",single_hop_specifc_query_synthesizer
15,What is the significance of using Rediss in a .NET Aspire project?,"['Resources page The Resources page is the default home page of the .NET Aspire dashboard. This page lists all of the .NET projects, containers, and executables included in your .NET Aspire solution. For example, the starter application includes two projects: apiservice: A back-end API project built using Minimal APIs. webfrontend: The front-end UI project built using Blazor. The dashboard also provides essential details about each resource: Type: Displays whether the resource is a project, container, or executable. Name: The name of the resource. State: Displays whether or not the resource is currently running. Errors: Within the State column, errors are displayed as a badge with the error count. It\'s useful to understand quickly what resources are reporting errors. Selecting the badge takes you to the semantic logs for that resource with the filter at an error level. Start time: When the resource started running. Source: The location of the resource on the device. Endpoints: One or more URLs to reach the running resource directly. Logs: A link to the resource logs page. Actions: A set of actions that can be performed on the resource: Stop / Start: Stop (or Start) the resourceâ€”depending on the current State. Console logs: Navigate to the resource\'s console logs. Ellipsis: A submenu with extra resource specific actions: View details: View the resource details. Console log: Navigate to the resource\'s console logs. Structured logs: Navigate to the resource\'s structured logs. Traces: Navigate to the resource\'s traces. Metrics: Navigate to the resource\'s metrics. Restart: Stop and then start the resource. Consider the following screenshot of the resources page: :::image type=""content"" source=""media/explore/projects.png"" lightbox=""media/explore/projects.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page.""::: Resource actions Each resource has a set of available actions that are conditionally enabled based on the resource\'s current state. For example, if a resource is running, the Stop action is enabled. If the resource is stopped, the Start action is enabled. Likewise, some actions are disabled when they\'re unavailable, for example, some resources don\'t have structured logs. In these situations, the Structured logs action is disabled. Stop or Start a resource The .NET Aspire dashboard allows you to stop or start a resource by selecting the Stop or Start button in the Actions column. Consider the following screenshot of the resources page with the Stop button selected: :::image type=""content"" source=""media/explore/resource-stop-action.png"" lightbox=""media/explore/resource-stop-action.png"" alt-text="".NET Aspire dashboard stop resource.""::: When you select Stop, the resource stops running, and the State column updates to reflect the change. [!NOTE] For project resources, when the debugger is attached, it\'s reattached on restart. The Start button is then enabled, allowing you to start the resource again. Additionally, the dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-stopped-action.png"" lightbox=""media/explore/resource-stopped-action.png"" alt-text="".NET Aspire dashboard resource stopped.""::: When a resource is in a non-running state, the Start button is enabled. Selecting Start starts the resource, and the State column updates to reflect the change. The Stop button is then enabled, allowing you to stop the resource again. The dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-started-action.png"" lightbox=""media/explore/resource-started-action.png"" alt-text="".NET Aspire dashboard started resource.""::: [!TIP] Resources that depend on other resources that are stopped, or restarted, might experience temporary errors. This is expected behavior and is typically resolved when the dependent resources are in a Running state once again. Resource submenu actions Selecting the horizontal ellipsis icon in the Actions column opens a submenu with additional resource-specific actions. In addition to the built-in resource submenu actions, you can also define custom resource actions by defining custom commands. For more information, see Custom resource commands in .NET Aspire. For the built-in resource submenu actions, consider the following screenshot: :::image type=""content"" source=""media/explore/resource-actions.png"" lightbox=""media/explore/resource-actions.png"" alt-text="".NET Aspire dashboard resource submenu actions.""::: The following submenu actions are available: View details: View the resource details. Console log: Navigate to the resource\'s console logs. Structured logs: Navigate to the resource\'s structured logs. Traces: Navigate to the resource\'s traces. Metrics: Navigate to the resource\'s metrics. Restart: Stop and then start the resource. [!IMPORTANT] There might be resources with disabled submenu actions. They\'re greyed out when they\'re disabled. For example, the following screenshot shows the submenu actions disabled: :::image type=""content"" source=""media/explore/resource-submenu-actions.png"" lightbox=""media/explore/resource-submenu-actions.png"" border=""true"" alt-text="".NET Aspire dashboard disabled submenu actions.""::: Copy or Open in text visualizer To view a text visualizer of certain columns, on hover you see a vertical ellipsis icon. Select the icon to display the available options: Copy to clipboard Open in text visualizer Consider the following screenshot of the ellipsis menu options: :::image type=""content"" source=""media/explore/text-visualizer-selection-menu.png"" lightbox=""media/explore/text-visualizer-selection-menu.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing the ellipsis menu options.""::: When you select the Open in text visualizer option, a modal dialog opens with the text displayed in a larger format. Consider the following screenshot of the text visualizer modal dialog: :::image type=""content"" source=""media/explore/text-visualizer-resources.png"" lightbox=""media/explore/text-visualizer-resources.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing the text visualizer.""::: Some values are formatted as JSON or XML. In these cases, the text visualizer enables the Select format dropdown to switch between the different formats. Resource details You can obtain full details about each resource by selecting the ellipsis button in the Actions column and then selecting View details. The Details page provides a comprehensive view of the resource: :::image type=""content"" source=""media/explore/resource-details.png"" lightbox=""media/explore/resource-details.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page with the details of a selected resource displayed.""::: The search bar in the upper right of the dashboard also provides the option to filter the list, which is useful for .NET Aspire projects with many resources. To select the types of resources that are displayed, drop down the arrow to the left of the filter textbox: :::image type=""content"" source=""media/explore/select-resource-type.png"" alt-text=""A screenshot of the resource type selector list in the .NET Aspire dashboard Resources page.""::: In this example, only containers are displayed in the list. For example, if you enable Use Redis for caching when creating a .NET Aspire project, you should see a Redis container listed: :::image type=""content"" source=""media/explore/resources-filtered-containers.png"" lightbox=""media/explore/resources-filtered-containers.png"" alt-text=""A screenshot of']","If you enable Use Redis for caching when creating a .NET Aspire project, you should see a Redis container listed.",single_hop_specifc_query_synthesizer
16,"How does Blazor integrate with the .NET Aspire dashboard, particularly in terms of resource management and user authentication?","['Theme selection. Dashboard authentication When you run a .NET Aspire app host, the orchestrator starts up all the app\'s dependent resources and then opens a browser window to the dashboard. The .NET Aspire dashboard requires token-based authentication for its users because it displays environment variables and other sensitive information. When the dashboard is launched from Visual Studio or Visual Studio Code (with the C# Dev Kit extension), the browser is automatically logged in, and the dashboard opens directly. This is the typical developer F5 experience, and the authentication login flow is automated by the .NET Aspire tooling. However, if you start the app host from the command line, you\'re presented with the login page. The console window displays a URL that you can select on to open the dashboard in your browser. :::image type=""content"" source=""media/explore/dotnet-run-login-url.png"" lightbox=""media/explore/dotnet-run-login-url.png"" alt-text="".NET CLI run command output, showing the login URL with token query string.""::: The URL contains a token query string (with the token value mapped to the t name part) that\'s used to log in to the dashboard. If your console supports it, you can hold the Ctrl key and then select the link to open the dashboard in your browser. This method is easier than copying the token from the console and pasting it into the login page. If you end up on the dashboard login page without either of the previously described methods, you can always return to the console to copy the token. :::image type=""content"" source=""media/explore/aspire-login.png"" lightbox=""media/explore/aspire-login.png"" alt-text="".NET Aspire dashboard login page.""::: The login page accepts a token and provides helpful instructions on how to obtain the token, as shown in the following screenshot: :::image type=""content"" source=""media/explore/aspire-login-help.png"" lightbox=""media/explore/aspire-login-help.png"" alt-text="".NET Aspire dashboard login page with instructions on how to obtain the token.""::: After copying the token from the console and pasting it into the login page, select the Log in button. :::image type=""content"" source=""media/explore/aspire-login-filled.png"" lightbox=""media/explore/aspire-login-filled.png"" alt-text="".NET Aspire dashboard login page with the token pasted into the textbox.""::: The dashboard persists the token as a browser persistent cookie, which remains valid for three days. Persistent cookies have an expiration date and remain valid even after closing the browser. This means that users don\'t need to log in again if they close and reopen the browser. For more information, see the Security considerations for running the .NET Aspire dashboard documentation. Resources page The Resources page is the default home page of the .NET Aspire dashboard. This page lists all of the .NET projects, containers, and executables included in your .NET Aspire solution. For example, the starter application includes two projects: apiservice: A back-end API project built using Minimal APIs. webfrontend: The front-end UI project built using Blazor. The dashboard also provides essential details about each resource: Type: Displays whether the resource is a project, container, or executable. Name: The name of the resource. State: Displays whether or not the resource is currently running. Errors: Within the State column, errors are displayed as a badge with the error count. It\'s useful to understand quickly what resources are reporting errors. Selecting the badge takes you to the semantic logs for that resource with the filter at an error level. Start time: When the resource started running. Source: The location of the resource on the device. Endpoints: One or more URLs to reach the running resource directly. Logs: A link to the resource logs page. Actions: A set of actions that can be performed on the resource: Stop / Start: Stop (or Start) the resourceâ€”depending on the current State. Console logs: Navigate to the resource\'s console logs. Ellipsis: A submenu with extra resource specific actions: View details: View the resource details. Console log: Navigate to the resource\'s console logs. Structured logs: Navigate to the resource\'s structured logs. Traces: Navigate to the resource\'s traces. Metrics: Navigate to the resource\'s metrics. Restart: Stop and then start the resource. Consider the following screenshot of the resources page: :::image type=""content"" source=""media/explore/projects.png"" lightbox=""media/explore/projects.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page.""::: Resource actions Each resource has a set of available actions that are conditionally enabled based on the resource\'s current state. For example, if a resource is running, the Stop action is enabled. If the resource is stopped, the Start action is enabled. Likewise, some actions are disabled when they\'re unavailable, for example, some resources don\'t have structured logs. In these situations, the Structured logs action is disabled. Stop or Start a resource The .NET Aspire dashboard allows you to stop or start a resource by selecting the Stop or Start button in the Actions column. Consider the following screenshot of the resources page with the Stop button selected: :::image type=""content"" source=""media/explore/resource-stop-action.png"" lightbox=""media/explore/resource-stop-action.png"" alt-text="".NET Aspire dashboard stop resource.""::: When you select Stop, the resource stops running, and the State column updates to reflect the change. [!NOTE] For project resources, when the debugger is attached, it\'s reattached on restart. The Start button is then enabled, allowing you to start the resource again. Additionally, the dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-stopped-action.png"" lightbox=""media/explore/resource-stopped-action.png"" alt-text="".NET Aspire dashboard resource stopped.""::: When a resource is in a non-running state, the Start button is enabled. Selecting Start starts the resource, and the State column updates to reflect the change. The Stop button is then enabled, allowing you to stop the resource again. The dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-started-action.png"" lightbox=""media/explore/resource-started-action.png"" alt-text="".NET Aspire dashboard started resource.""::: [!TIP] Resources that depend on other resources that are stopped, or restarted, might experience temporary errors. This is expected behavior and is typically resolved when the dependent resources are in a Running state once again. Resource submenu actions Selecting the horizontal ellipsis icon in the Actions column opens a submenu with additional resource-specific actions. In addition to the built-in resource submenu actions, you can also define custom resource actions by defining custom commands. For more information, see Custom resource commands in .NET Aspire. For the built-in resource submenu actions, consider the following screenshot: :::image type=""content"" source=""media/explore/resource-actions.png"" lightbox=""media/explore/resource-actions.png""']","In the .NET Aspire dashboard, Blazor is utilized for the front-end UI project, which is part of the overall application structure. The dashboard requires token-based authentication for users, ensuring that sensitive information is protected. When the dashboard is launched, it automates the login flow if started from Visual Studio or Visual Studio Code, allowing users to access the dashboard directly. If started from the command line, users must manually log in using a token provided in the console. The dashboard lists all .NET projects, including the Blazor front-end, and provides essential details about each resource, such as its state and available actions. Users can manage resources by starting or stopping them through the dashboard, which reflects changes in real-time.",single_hop_specifc_query_synthesizer
17,What is the purpose of the Details column in the logs?,"['You notice a clean structure for the different logs displayed on the page using columns: Resource: The resource the log originated from. Level: The log level of the entry, such as information, warning, or error. Timestamp: The time that the log occurred. Message: The details of the log. Trace: A link to the relevant trace for the log, if applicable. Details: Additional details or metadata about the log entry. Consider the following example screenshot of semantic logs: :::image type=""content"" source=""media/explore/structured-logs.png"" lightbox=""media/explore/structured-logs.png"" alt-text=""A screenshot of the .NET Aspire dashboard Semantic logs page.""::: Filter structured logs The structured logs page also provides a search bar to filter the logs by service, level, or message. You use the Level drop down to filter by log level. You can also filter by any log property by selecting the filter icon button, which opens the advanced filter dialog. Consider the following screenshots showing the structured logs, filtered to display items with ""Hosting"" in the message text: :::image type=""content"" source=""media/explore/structured-logs-filtered.png"" lightbox=""media/explore/structured-logs-filtered.png"" alt-text=""A screenshot of the .NET Aspire dashboard Structured logs page, showing a filter that displayed only items with Hosting in the message text.""::: Traces page Navigate to the Traces page to view all of the traces for your app. .NET Aspire automatically configures tracing for the different projects in your app. Distributed tracing is a diagnostic technique that helps engineers localize failures and performance issues within applications, especially those that might be distributed across multiple machines or processes. For more information, see .NET distributed tracing. This technique tracks requests through an application and correlates work done by different application integrations. Traces also help identify how long different stages of the request took to complete. The traces page displays the following information: Timestamp: When the trace completed. Name: The name of the trace, prefixed with the project name. Spans: The resources involved in the request. Duration: The time it took to complete the request. This column includes a radial icon that illustrates the duration of the request in comparison with the others in the list. :::image type=""content"" source=""media/explore/traces.png"" lightbox=""media/explore/traces.png"" alt-text=""A screenshot of the .NET Aspire dashboard Traces page.""::: Filter traces The traces page also provides a search bar to filter the traces by name or span. Apply a filter, and notice the trace results are updated immediately. Consider the following screenshot of traces with a filter applied to weather and notice how the search term is highlighted in the results: :::image type=""content"" source=""media/explore/trace-view-filter.png"" lightbox=""media/explore/trace-view-filter.png"" alt-text=""A screenshot of the .NET Aspire dashboard Traces page, showing a filter applied to show only traces with the term \'weather\'.""::: When filtering traces in the Add filter dialog, after selecting a Parameter and corresponding Condition, the Value selection is pre-populated with the available values for the selected parameter. Consider the following screenshot of the Add filter dialog with the http.route parameter selected: :::image type=""content"" source=""media/explore/traces-filtering.png"" lightbox=""media/explore/traces-filtering.png"" alt-text=""A screenshot of the .NET Aspire dashboard Traces page, showing the Add filter dialog with the http.route parameter selected.""::: Combine telemetry from multiple resources When a resource has multiple replicas, you can filter telemetry to view data from all instances at once. Select the parent resource, labeled (application), as shown in the following screenshot: :::image type=""content"" source=""media/explore/telemetry-resource-filter.png"" lightbox=""media/explore/telemetry-resource-filter.png"" alt-text=""Filter by all instances of a resource""::: After selecting the parent resource, the traces page displays telemetry from all instances of the resource. Trace details The trace details page contains various details pertinent to the request, including: Trace Detail: When the trace started. Duration: The time it took to complete the request. Resources: The number of resources involved in the request. Depth: The number of layers involved in the request. Total Spans: The total number of spans involved in the request. Each span is represented as a row in the table, and contains a Name. Spans also display the error icon if an error occurred within that particular span of the trace. Spans that have a type of client/consumer, but don\'t have a span on the server, show an arrow icon and then the destination address. This represents a client call to a system outside of the .NET Aspire project. For example, an HTTP request an external web API, or a database call. Within the trace details page, there\'s a View Logs button that takes you to the structured logs page with a filter applied to show only the logs relevant to the request. Consider an example screenshot depicting the structured logs page with a filter applied to show only the logs relevant to the trace: :::image type=""content"" source=""media/explore/structured-logs-trace-errors.png"" lightbox=""media/explore/structured-logs-trace-errors.png"" alt-text=""A screenshot of the .NET Aspire dashboard Structured logs page, showing a filter applied to show only the logs relevant to the trace.""::: The structured logs page is discussed in more detail in the Structured logs page section. Trace examples Each trace has a color, which is generated to help differentiate between spansâ€”one color for each resource. The colors are reflected in both the traces page and the trace detail page. When traces depict an arrow icon, those icons are colorized as well to match the span of the target trace. Consider the following example screenshot of traces: :::image type=""content"" source=""media/explore/traces.png"" lightbox=""media/explore/traces.png"" alt-text=""A screenshot of the .NET Aspire dashboard Traces page.""::: You can also select the View button to navigate to a detailed view of the request and the duration of time it spent traveling through each application layer. Consider an example selection of a trace to view its details: :::image type=""content"" source=""media/explore/trace.png"" lightbox=""media/explore/trace.png"" alt-text=""A screenshot of the .NET Aspire dashboard Trace details page.""::: For each span in the trace, select View to see more details: :::image type=""content"" source=""media/explore/trace-span-details.png"" lightbox=""media/explore/trace-span-details.png"" alt-text=""A screenshot of the .NET Aspire dashboard Trace details page with the details of a span displayed.""::: Scroll down in the span details pain to see full information. At the bottom of the span details pane, some span types, such as this call to a cache, show span event timings: :::image type=""content"" source=""media/explore/trace-span-event-details.png"" lightbox=""media/explore/trace-span-event-details.png"" alt-text=""A screenshot of the .NET Aspire dashboard Trace details page with the event']",The Details column provides additional details or metadata about the log entry.,single_hop_specifc_query_synthesizer
18,Can you explain how .NET Aspire helps in monitoring application performance and what features it offers?,"['timings for a span displayed.""::: When errors are present, the page renders an error icon next to the trace name. Consider an example screenshot of traces with errors: :::image type=""content"" source=""media/explore/traces-errors.png"" lightbox=""media/explore/traces-errors.png"" alt-text=""A screenshot of the .NET Aspire dashboard Traces page, showing traces with errors.""::: And the corresponding detailed view of the trace with errors: :::image type=""content"" source=""media/explore/trace-view-errors.png"" lightbox=""media/explore/trace-view-errors.png"" alt-text=""A screenshot of the .NET Aspire dashboard Trace details page, showing a trace with errors.""::: Metrics page Navigate to the Metrics page to view the metrics for your app. .NET Aspire automatically configures metrics for the different projects in your app. Metrics are a way to measure the health of your application and can be used to monitor the performance of your app over time. Each metric-publishing project in your app has its own metrics. The metrics page displays a selection pane for each top-level meter and the corresponding instruments that you can select to view the metric. Consider the following example screenshot of the metrics page, with the webfrontend project selected and the System.Net.Http meter\'s http.client.request.duration metric selected: :::image type=""content"" source=""media/explore/metrics-view.png"" lightbox=""media/explore/metrics-view.png"" alt-text=""A screenshot of the .NET Aspire dashboard Metrics page.""::: In addition to the metrics chart, the metrics page includes an option to view the data as a table instead. Consider the following screenshot of the metrics page with the table view selected: :::image type=""content"" source=""media/explore/metrics-table-view.png"" lightbox=""media/explore/metrics-table-view.png"" alt-text=""A screenshot of the .NET Aspire dashboard Metrics page with the table view selected.""::: Under the chart, there\'s a list of filters you can apply to focus on the data that interests you. For example, in the following screenshot, the http.request.method field is filtered to show only GET requests: :::image type=""content"" source=""media/explore/metrics-view-filtered.png"" lightbox=""media/explore/metrics-view-filtered.png"" alt-text=""A screenshot of the .NET Aspire dashboard Metrics page with a filter applied to the chart.""::: You can also choose to select the count of the displayed metric on the vertical access, instead of its values: :::image type=""content"" source=""media/explore/metrics-view-count.png"" lightbox=""media/explore/metrics-view-count.png"" alt-text=""A screenshot of the .NET Aspire dashboard Metrics page with the count option applied.""::: For more information about metrics, see Built-in Metrics in .NET. Exemplars The .NET Aspire dashboard supports and displays OpenTelemetry Exemplars. An exemplar links a metric data point to the operation that recorded it, serving as a bridge between metrics and traces. Exemplars are useful because they provide additional context about why a specific metric value was recorded. For example, if you notice a spike in latency in the http.client.request.duration metric, an exemplar could point to a specific trace or span that caused the spike, helping you understand the root cause. Exemplars are displayed in the metrics chart as a small round dot next to the data point. When you hover over the indicator, a tooltip displays the exemplar details as shown in the following screenshot: :::image type=""content"" source=""media/explore/metrics-page-exemplars.png"" lightbox=""media/explore/metrics-page-exemplars.png"" alt-text="".NET Aspire Dashboard: Metrics Page, with exemplar indicator hover details.""::: The preceding screenshot shows the exemplar details for the http.client.request.duration metric. The exemplar details include the: Resource name. Operation performed, in this case an HTTP GET to the /catalog/images/{id}. Corresponding value and the time stamp. Selecting the exemplar indicator opens the trace details page, where you can view the trace associated, for example consider the following screenshot: :::image type=""content"" source=""media/explore/trace-page-from-exemplars.png"" lightbox=""media/explore/trace-page-from-exemplars.png"" alt-text="".NET Aspire Dashboard: Trace Page, navigated to from the corresponding Metrics Page exemplar.""::: For more information, see OpenTelemetry Docs: Exemplars. Theme selection By default, the theme is set to follow the System theme, which means the dashboard uses the same theme as your operating system. You can also select the Light or Dark theme to override the system theme. Theme selections are persisted. The following screenshot shows the theme selection dialog, with the default System theme selected: :::image type=""content"" source=""media/explore/theme-selection.png"" lightbox=""media/explore/theme-selection.png"" alt-text=""The .NET Aspire dashboard Settings dialog, showing the System theme default selection.""::: If you prefer the Light theme, you can select it from the theme selection dialog: :::image type=""content"" source=""media/explore/theme-selection-light.png"" lightbox=""media/explore/theme-selection-light.png"" alt-text=""The .NET Aspire dashboard Settings dialog, showing the Light theme selection.""::: Dashboard shortcuts The .NET Aspire dashboard provides various shortcuts to help you navigate and control different parts of the dashboard. To display the keyboard shortcuts, press Shift + ?, or select the question mark icon in the top-right corner of the dashboard: :::image type=""content"" source=""media/explore/dashboard-help.png"" lightbox=""media/explore/dashboard-help.png"" alt-text="".NET Aspire dashboard Help modal dialog.""::: The following shortcuts are available: Panels: +: Increase panel size. -: Decrease panel size. Shift + r: Reset panel size. Shift + t: Toggle panel orientation. Shift + x: Close panel. Page navigation: r: Go to Resources. c: Go to Console Logs. s: Go to Structured Logs. t: Go to Traces. m: Go to Metrics. Site-wide navigation: ?: Got to Help. Shift + s: Go to Settings. Next steps [!div class=""nextstepaction""] Standalone .NET Aspire dashboard']",".NET Aspire automatically configures metrics for the different projects in your app, allowing you to view the metrics on the Metrics page. Metrics are essential for measuring the health of your application and monitoring its performance over time. Each project has its own metrics, and the Metrics page displays a selection pane for each top-level meter along with the corresponding instruments. You can view the data as a chart or a table, apply filters to focus on specific data, and even select the count of the displayed metric. Additionally, .NET Aspire supports OpenTelemetry Exemplars, which link metric data points to the operations that recorded them, providing context for specific metric values. This feature helps in understanding the root cause of performance issues by connecting metrics to traces.",single_hop_specifc_query_synthesizer
19,What is DistributedApplication in context of adding Oracle server?,"['Add Oracle server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Oracle database container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the container-registry.oracle.com/database/free image, it creates a new Oracle server on your local machine. A reference to your Oracle resource builder (the oracle variable) is used to add a database. The database is named oracledb and then added to the ExampleProject. The Oracle resource includes a random password generated using the The [!TIP] If you\'d rather connect to an existing Oracle server, call Add Oracle resource with password parameter The Oracle resource includes default credentials with a random password. Oracle supports configuration-based default passwords by using the environment variable ORACLE_PWD. When you want to provide a password explicitly, you can provide it as a parameter: ```csharp var password = builder.AddParameter(""password"", secret: true); var oracle = builder.AddOracle(""oracle"", password) .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddOracle API, and internally assigns the parameter to the ORACLE_PWD environment variable of the Oracle container. The password parameter is usually specified as a user secret: json { ""Parameters"": { ""password"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Oracle resource with data volume To add a data volume to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataVolume() .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracle""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Oracle data outside the lifecycle of its container. The data volume is mounted at the /opt/oracle/oradata path in the Oracle container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add Oracle resource with data bind mount To add a data bind mount to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataBindMount(source: @""C:\\Oracle\\Data""); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Oracle data across container restarts. The data bind mount is mounted at the C:\\Oracle\\Data on Windows (or /Oracle/Data on Unix) path on the host machine in the Oracle container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Oracle hosting integration automatically adds a health check for the Oracle resource. The health check verifies that the Oracle server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Oracle NuGet package.']","DistributedApplication is used to create a builder for your application, allowing you to add resources like an Oracle server and database. For example, you can call `var builder = DistributedApplication.CreateBuilder(args);` to start the process of adding an Oracle resource.",single_hop_specifc_query_synthesizer
20,What is GitHub used for in the context of .NET Aspire Oracle integration?,"['Client integration You need an Oracle database and connection string for accessing the database. To get started with the .NET Aspire Oracle client integration, install the ðŸ“¦ Aspire.Oracle.EntityFrameworkCore NuGet package in the client-consuming project, that is, the project for the application that uses the Oracle client. The Oracle client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Oracle.EntityFrameworkCore PackageReference xml <PackageReference Include=""Aspire.Oracle.EntityFrameworkCore"" Version=""*"" /> Add Oracle client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(connectionName: ""oracledb""); [!TIP] The connectionName parameter must match the name used when adding the Oracle database resource in the app host project. In other words, when you call AddDatabase and provide a name of oracledb that same name should be used when calling AddOracleDatabaseDbContext. For more information, see Add Oracle server and database resources. You can then retrieve the csharp public class ExampleService(ExampleDbContext context) { // Use database context... } For more information on dependency injection, see .NET dependency injection. Add Oracle database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( connectionName: ""oracledb"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the Configuration The .NET Aspire Oracle Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling builder.AddOracleDatabaseDbContext<TContext>(): csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(""oracleConnection""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""oracleConnection"": ""Data Source=TORCL;User Id=OracleUser;Password=Non-default-P@ssw0rd;"" } } The EnrichOracleDatabaseDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it is called. For more information, see the ODP.NET documentation. Use configuration providers The .NET Aspire Oracle Entity Framework Core integration supports The following is an example of an :::no-loc text=""appsettings.json""::: that configures some of the available options: json { ""Aspire"": { ""Oracle"": { ""EntityFrameworkCore"": { ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableRetry"": false, ""CommandTimeout"": 30 } } } } [!TIP] The CommandTimeout property is in seconds. When set as shown in the preceding example, the timeout is 30 seconds. Use inline delegates You can also pass the Action<OracleEntityFrameworkCoreSettings> delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>( ""oracle"", static settings => settings.DisableHealthChecks = true); or csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( static settings => settings.DisableHealthChecks = true); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the Oracle database to connect to. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. DisableRetry A boolean value that indicates whether command retries should be disabled or not. CommandTimeout The time in seconds to wait for the command to execute. [!INCLUDE integration-health-checks] By default, the .NET Aspire Oracle Entity Framework Core integration handles the following: Checks if the If so, adds the DbContextHealthCheck, which calls EF Core\'s [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Oracle Entity Framework Core integration uses the following log categories: Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Database.Connection Microsoft.EntityFrameworkCore.Database.Transaction Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Migrations Microsoft.EntityFrameworkCore.Model Microsoft.EntityFrameworkCore.Model.Validation Microsoft.EntityFrameworkCore.Query Microsoft.EntityFrameworkCore.Update Tracing The .NET Aspire Oracle Entity Framework Core integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Oracle Entity Framework Core integration currently supports the following metrics: Microsoft.EntityFrameworkCore See also Oracle Database Oracle Database Documentation Entity Framework Core docs .NET Aspire integrations .NET Aspire GitHub repo']",The context does not specifically mention GitHub or its use in .NET Aspire Oracle integration.,single_hop_specifc_query_synthesizer
21,How can Azure Storage be utilized in local development environments?,"['title: Local Azure provisioning description: Learn how to use Azure resources in your local development environment. ms.date: 12/13/2024 uid: dotnet/aspire/local-azure-provisioning Local Azure provisioning .NET Aspire simplifies local cloud-native app development with its compelling app host model. This model allows you to run your app locally with the same configuration and services as in Azure. In this article you learn how to provision Azure resources from your local development environment through the .NET Aspire app host. [!NOTE] To be clear, resources are provisioned in Azure, but the provisioning process is initiated from your local development environment. To optimize your local development experience, consider using emulator or containers when available. For more information, see Typical developer experience. Requirements This article assumes that you have an Azure account and subscription. If you don\'t have an Azure account, you can create a free one at Azure Free Account. For provisioning functionality to work correctly, you\'ll need to be authenticated with Azure. Ensure that you have the Azure Developer CLI installed. Additionally, you\'ll need to provide some configuration values so that the provisioning logic can create resources on your behalf. App host provisioning APIs The app host provides a set of APIs to express Azure resources. These APIs are available as extension methods in .NET Aspire Azure hosting libraries, extending the When the app host starts, the following provisioning logic is executed: The Azure configuration section is validated. When invalid the dashboard and app host output provides hints as to what\'s missing. For more information, see Missing configuration value hints. When valid Azure resources are conditionally provisioned: If an Azure deployment for a given resource doesn\'t exist, it\'s created and configured as a deployment. The configuration of said deployment is stamped with a checksum as a means to support only provisioning resources as necessary. Use existing Azure resources The app host automatically manages provisioning of Azure resources. The first time the app host runs, it provisions the resources specified in the app host. Subsequent runs don\'t provision the resources again unless the app host configuration changes. If you\'ve already provisioned Azure resources outside of the app host and want to use them, you can provide the connection string with the ```csharp // Service registration var secrets = builder.ExecutionContext.IsPublishMode ? builder.AddAzureKeyVault(""secrets"") : builder.AddConnectionString(""secrets""); // Service consumption builder.AddProject The preceding code snippet shows how to add an Azure Key Vault to the app host. The Alternatively, for some Azure resources, you can opt-in to running them as an emulator with the RunAsEmulator API. This API is available for Azure Cosmos DB and Azure Storage integrations. For example, to run Azure Cosmos DB as an emulator, you can use the following code snippet: csharp var cosmos = builder.AddAzureCosmosDB(""cosmos"") .RunAsEmulator(); The']",Azure Storage can be utilized in local development environments by opting to run it as an emulator using the RunAsEmulator API. This allows developers to simulate Azure Storage functionalities locally while developing their applications.,single_hop_specifc_query_synthesizer
22,How does Visual Studio facilitate the configuration of Azure provisioning settings in a .NET Aspire app host project?,"['.NET Aspire Azure hosting integrations If you\'re using Azure resources in your app host, you\'re using one or more of the .NET Aspire Azure hosting integrations. These hosting libraries provide extension methods to the Configuration When utilizing Azure resources in your local development environment, you need to provide the necessary configuration values. Configuration values are specified under the Azure section: SubscriptionId: The Azure subscription ID. AllowResourceGroupCreation: A boolean value that indicates whether to create a new resource group. ResourceGroup: The name of the resource group to use. Location: The Azure region to use. Consider the following example :::no-loc text=""appsettings.json""::: configuration: json { ""Azure"": { ""SubscriptionId"": ""<Your subscription id>"", ""AllowResourceGroupCreation"": true, ""ResourceGroup"": ""<Valid resource group name>"", ""Location"": ""<Valid Azure location>"" } } [!IMPORTANT] It\'s recommended to store these values as app secrets. For more information, see Manage app secrets. After you\'ve configured the necessary values, you can start provisioning Azure resources in your local development environment. Azure provisioning credential store The .NET Aspire app host uses a credential store for Azure resource authentication and authorization. Depending on your subscription, the correct credential store may be needed for multi-tenant provisioning scenarios. With the ðŸ“¦ Aspire.Hosting.Azure NuGet package installed, and if your app host depends on Azure resources, the default Azure credential store relies on the json { ""Azure"": { ""CredentialSource"": ""AzureCli"" } } As with all configuration-based settings, you can configure these with alternative providers, such as user secrets or environment variables. The Azure:CredentialSource value can be set to one of the following values: AzureCli: Delegates to the AzurePowerShell: Delegates to the VisualStudio: Delegates to the VisualStudioCode: Delegates to the AzureDeveloperCli: Delegates to the InteractiveBrowser: Delegates to the [!TIP] For more information about the Azure SDK authentication and authorization, see Credential chains in the Azure Identity library for .NET. Tooling support In Visual Studio, you can use Connected Services to configure the default Azure provisioning settings. Select the app host project, right-click on the Connected Services node, and select Azure Resource Provisioning Settings: :::image type=""content"" loc-scope=""visual-studio"" source=""media/azure-resource-provisioning-settings.png"" lightbox=""media/azure-resource-provisioning-settings.png"" alt-text=""Visual Studio 2022: .NET Aspire App Host project, Connected Services context menu.""::: This will open a dialog where you can configure the Azure provisioning settings, as shown in the following screenshot: :::image type=""content"" loc-scope=""visual-studio"" source=""media/azure-provisioning-settings-dialog.png"" lightbox=""media/azure-provisioning-settings-dialog.png"" alt-text=""Visual Studio 2022: Azure Resource Provisioning Settings dialog.""::: Missing configuration value hints When the Azure configuration section is missing, has missing values, or is invalid, the .NET Aspire dashboard provides useful hints. For example, consider an app host that\'s missing the SubscriptionId configuration value that\'s attempting to use an Azure Key Vault resource. The Resources page indicates the State as Missing subscription configuration: :::image type=""content"" source=""media/resources-kv-missing-subscription.png"" alt-text="".NET Aspire dashboard: Missing subscription configuration.""::: Additionally, the Console logs display this information as well, consider the following screenshot: :::image type=""content"" source=""media/console-logs-kv-missing-subscription.png"" lightbox=""media/console-logs-kv-missing-subscription.png"" alt-text="".NET Aspire dashboard: Console logs, missing subscription configuration.""::: Known limitations After provisioning Azure resources in this way, you must manually clean up the resources in the Azure portal as .NET Aspire doesn\'t provide a built-in mechanism to delete Azure resources. The easiest way to achieve this is by deleting the configured resource group. This can be done in the Azure portal or by using the Azure CLI: azurecli az group delete --name <ResourceGroupName> Replace <ResourceGroupName> with the name of the resource group you want to delete. For more information, see az group delete.']","In Visual Studio, you can use Connected Services to configure the default Azure provisioning settings for a .NET Aspire app host project. By selecting the app host project, right-clicking on the Connected Services node, and choosing Azure Resource Provisioning Settings, a dialog will open where you can configure the Azure provisioning settings.",single_hop_specifc_query_synthesizer
23,How can Visual Studio Code be configured for Azure development with .NET in the context of Azure Functions integration?,"['title: .NET Aspire Azure Functions integration (Preview) description: Learn how to integrate Azure Functions with .NET Aspire. ms.date: 11/13/2024 zone_pivot_groups: dev-environment .NET Aspire Azure Functions integration (Preview) [!INCLUDE includes-hosting] [!IMPORTANT] The .NET Aspire Azure Functions integration is currently in preview and is subject to change. Azure Functions is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. The .NET Aspire Azure Functions integration enables you to develop, debug, and orchestrate an Azure Functions .NET project as part of the app host. It\'s expected that you\'ve installed the required Azure tooling: :::zone pivot=""visual-studio"" Configure Visual Studio for Azure development with .NET :::zone-end :::zone pivot=""vscode"" Configure Visual Studio Code for Azure development with .NET :::zone-end :::zone pivot=""dotnet-cli"" Install the Azure Functions Core Tools :::zone-end Supported scenarios The .NET Aspire Azure Functions integration has several key supported scenarios. This section outlines the scenarios and provides details related to the implementation of each approach. Supported triggers The following table lists the supported triggers for Azure Functions in the .NET Aspire integration: Trigger Attribute Details Azure Event Hubs trigger EventHubTrigger ðŸ“¦ Aspire.Hosting.Azure.EventHubs Azure Service Bus trigger ServiceBusTrigger ðŸ“¦ Aspire.Hosting.Azure.ServiceBus Azure Storage Blobs trigger BlobTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage Azure Storage Queues trigger QueueTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage HTTP trigger HttpTrigger Supported without any additional resource dependencies. Timer trigger TimerTrigger Supported without any additional resource dependenciesâ€”relies on implicit host storage. [!IMPORTANT] Other Azure Functions triggers and bindings aren\'t currently supported in the .NET Aspire Azure Functions integration. Deployment Currently, deployment is supported only to containers on Azure Container Apps (ACA) using the SDK container publish function in Microsoft.Azure.Functions.Worker.Sdk. This deployment methodology doesn\'t currently support KEDA-based autoscaling. Configure external HTTP endpoints To make HTTP triggers publicly accessible, call the']","To configure Visual Studio Code for Azure development with .NET, you need to follow the guidelines provided in the .NET Aspire Azure Functions integration documentation. This includes ensuring that you have installed the required Azure tooling and setting up your development environment accordingly.",single_hop_specifc_query_synthesizer
24,What are the requirements for using .NET 9 SDK in an Azure Functions project?,"['Azure Function project constraints The .NET Aspire Azure Functions integration has the following project constraints: You must target .NET 8.0 or later. You must use a .NET 9 SDK. It currently only supports .NET workers with the isolated worker model. Requires the following NuGet packages: ðŸ“¦ Microsoft.Azure.Functions.Worker: Use the FunctionsApplicationBuilder. ðŸ“¦ Microsoft.Azure.Functions.Worker.Sdk: Adds support for dotnet run and azd publish. ðŸ“¦ Microsoft.Azure.Functions.Http.AspNetCore: Adds HTTP trigger-supporting APIs. :::zone pivot=""visual-studio"" If you encounter issues with the Azure Functions project, such as: There is no Functions runtime available that matches the version specified in the project In Visual Studio, try checking for an update on the Azure Functions tooling. Open the Options dialog, navigate to Projects and Solutions, and then select Azure Functions. Select the Check for updates button to ensure you have the latest version of the Azure Functions tooling: :::image type=""content"" source=""media/visual-studio-auzre-functions-options.png"" alt-text=""Visual Studio: Options / Projects and Solutions / Azure Functions.""::: :::zone-end Hosting integration The Azure Functions hosting integration models an Azure Functions resource as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Functions --prerelease PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Functions"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Azure Functions resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var functions = builder.AddAzureFunctionsProject builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds an Azure Functions project resource the app host, as shown in the preceding example, the functions resource can be referenced by other project resources. The Add Azure Functions resource with host storage If you want to modify the default host storage account that the Azure Functions host uses, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"") .RunAsEmulator(); var functions = builder.AddAzureFunctionsProject builder.AddProject // After adding all resources, run the app... ``` The preceding code relies on the ðŸ“¦ Aspire.Hosting.Azure.Storage NuGet package to add an Azure Storage resource that runs as an emulator. The storage resource is then passed to the WithHostStorage API, explicitly setting the host storage to the emulated resource. [!NOTE] If you\'re not using the implicit host storage, you must manually assign the StorageAccountContributor role to your resource for deployed instances. This role is automatically assigned for the implicitly generated host storage. Reference resources in Azure Functions To reference other Azure resources in an Azure Functions project, chain a call to WithReference on the Azure Functions project resource and provide the resource to reference: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator(); var blobs = storage.AddBlobs(""blobs""); builder.AddAzureFunctionsProject builder.Build().Run(); ``` The preceding code adds an Azure Storage resource to the app host and references it in the Azure Functions project. The blobs resource is added to the storage resource and then referenced by the functions resource. The connection information required to connect to the blobs resource is automatically injected into the Azure Functions project and enables the project to define a BlobTrigger that relies on blobs resource. See also .NET Aspire integrations .NET Aspire GitHub repo Azure Functions documentation .NET Aspire and Functions image gallery sample']","To use the .NET 9 SDK in an Azure Functions project, you must target .NET 8.0 or later and specifically use the .NET 9 SDK. Additionally, it currently only supports .NET workers with the isolated worker model and requires certain NuGet packages such as Microsoft.Azure.Functions.Worker, Microsoft.Azure.Functions.Worker.Sdk, and Microsoft.Azure.Functions.Http.AspNetCore.",single_hop_specifc_query_synthesizer
25,"How are HTTP endpoints utilized in .NET Aspire health checks, and what is their significance in monitoring application health?","['title: .NET Aspire health checks description: Explore .NET Aspire health checks ms.date: 09/24/2024 ms.topic: quickstart uid: dotnet/aspire/health-checks Health checks in .NET Aspire Health checks provide availability and state information about an app. Health checks are often exposed as HTTP endpoints, but can also be used internally by the app to write logs or perform other tasks based on the current health. Health checks are typically used in combination with an external monitoring service or container orchestrator to check the status of an app. The data reported by health checks can be used for various scenarios: Influence decisions made by container orchestrators, load balancers, API gateways, and other management services. For instance, if the health check for a containerized app fails, it might be skipped by a load balancer routing traffic. Verify that underlying dependencies are available, such as a database or cache, and return an appropriate status message. Trigger alerts or notifications when an app isn\'t responding as expected. .NET Aspire health check endpoints .NET Aspire exposes two default health check HTTP endpoints in Development environments when the AddServiceDefaults and MapDefaultEndpoints methods are called from the :::no-loc text=""Program.cs""::: file: The /health endpoint indicates if the app is running normally where it\'s ready to receive requests. All health checks must pass for app to be considered ready to accept traffic after starting. http GET /health The /health endpoint returns an HTTP status code 200 and a text/plain value of The /alive indicates if an app is running or has crashed and must be restarted. Only health checks tagged with the live tag must pass for app to be considered alive. http GET /alive The /alive endpoint returns an HTTP status code 200 and a text/plain value of The AddServiceDefaults and MapDefaultEndpoints methods also apply various configurations to your app beyond just health checks, such as OpenTelemetry and service discovery configurations. Non-development environments In non-development environments, the /health and /alive endpoints are disabled by default. If you need to enable them, its recommended to protect these endpoints with various routing features, such as host filtering and/or authorization. For more information, see Health checks in ASP.NET Core. Additionally, it may be advantageous to configure request timeouts and output caching for these endpoints to prevent abuse or denial-of-service attacks. To do so, consider the following modified AddDefaultHealthChecks method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""healthchecks""::: The preceding code: Adds a timeout of 5 seconds to the health check requests with a policy named HealthChecks. Adds a 10-second cache to the health check responses with a policy named HealthChecks. Now consider the updated MapDefaultEndpoints method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""mapendpoints""::: The preceding code: Groups the health check endpoints under the / path. Caches the output and specifies a request time with the corresponding HealthChecks policy. In addition to the updated AddDefaultHealthChecks and MapDefaultEndpoints methods, you must also add the corresponding services for both request timeouts and output caching. In the appropriate consuming app\'s entry point (usually the :::no-loc text=""Program.cs""::: file), add the following code: ```csharp // Wherever your services are being registered. // Before the call to Build(). builder.Services.AddRequestTimeouts(); builder.Services.AddOutputCache(); var app = builder.Build(); // Wherever your app has been built, before the call to Run(). app.UseRequestTimeouts(); app.UseOutputCache(); app.Run(); ``` For more information, see Request timeouts middleware in ASP.NET Core and Output caching middleware in ASP.NET Core.']","In .NET Aspire, health checks are often exposed as HTTP endpoints, which provide availability and state information about an application. Specifically, two default health check HTTP endpoints are available in Development environments: the /health endpoint and the /alive endpoint. The /health endpoint indicates if the app is running normally and ready to receive requests, returning an HTTP status code 200 when all health checks pass. Conversely, the /alive endpoint indicates if the app is running or has crashed, requiring only health checks tagged with the live tag to pass for the app to be considered alive. These endpoints are significant as they allow external monitoring services or container orchestrators to check the status of the app, influencing decisions made by load balancers and management services, verifying the availability of underlying dependencies, and triggering alerts when the app is not responding as expected.",single_hop_specifc_query_synthesizer
26,What role does Microsoft.Extensions.Configurations play in configuring health checks for .NET Aspire integrations?,"['Integration health checks .NET Aspire integrations can also register additional health checks for your app. These health checks contribute to the returned status of the /health and /alive endpoints. For example, the .NET Aspire PostgreSQL integration automatically adds a health check to verify the following conditions: A database connection could be established A database query could be executed successfully If either of these operations fail, the corresponding health check also fails. Configure health checks You can disable health checks for a given integration using one of the available configuration options. .NET Aspire integrations support Microsoft.Extensions.Configurations to apply settings through config files such as :::no-loc text=""appsettings.json"":::: json { ""Aspire"": { ""Npgsql"": { ""DisableHealthChecks"": true, } } } You can also use an inline delegate to configure health checks: csharp builder.AddNpgsqlDbContext<MyDbContext>( ""postgresdb"", static settings => settings.DisableHealthChecks = true); See also .NET app health checks in C# Health checks in ASP.NET Core']","Microsoft.Extensions.Configurations is used to apply settings through configuration files, such as appsettings.json, allowing for the configuration of health checks in .NET Aspire integrations. For instance, you can disable health checks for a given integration by specifying options in the configuration file.",single_hop_specifc_query_synthesizer
27,How can I integrate Python apps into a .NET Aspire project?,"['title: Orchestrate Python apps in .NET Aspire description: Learn how to integrate Python apps into a .NET Aspire app host project. ms.date: 11/11/2024 Orchestrate Python apps in .NET Aspire In this article, you learn how to use Python apps in a .NET Aspire app host. The sample app in this article demonstrates launching a Python application. The Python extension for .NET Aspire requires the use of virtual environments. [!INCLUDE aspire-prereqs] Additionally, you need to install Python on your machine. The sample app in this article was built with Python version 3.12.4 and pip version 24.1.2. To verify your Python and pip versions, run the following commands: python python --version python pip --version To download Python (including pip), see the Python download page. Create a .NET Aspire project using the template To get started launching a Python project in .NET Aspire first use the starter template to create a .NET Aspire application host: dotnetcli dotnet new aspire -o PythonSample In the same terminal session, change directories into the newly created project: dotnetcli cd PythonSample Once the template has been created launch the app host with the following command to ensure that the app host and the .NET Aspire dashboard launches successfully: dotnetcli dotnet run --project PythonSample.AppHost/PythonSample.AppHost.csproj Once the app host starts it should be possible to click on the dashboard link in the console output. At this point the dashboard will not show any resources. Stop the app host by pressing Ctrl + C in the terminal. Prepare a Python app From your previous terminal session where you created the .NET Aspire solution, create a new directory to contain the Python source code. Console mkdir hello-python Change directories into the newly created hello-python directory: Console cd hello-python Initialize the Python virtual environment To work with Python apps, they need to be within a virtual environment. To create a virtual environment, run the following command: python python -m venv .venv For more information on virtual environments, see the Python: Install packages in a virtual environment using pip and venv. To activate the virtual environment, enabling installation and usage of packages, run the following command: Unix/macOS bash source .venv/bin/activate Windows powershell .venv\\Scripts\\Activate.ps1 Ensure that pip within the virtual environment is up-to-date by running the following command: python python -m pip install --upgrade pip Install Python packages Install the Flask package by creating a requirements.txt file in the hello-python directory and adding the following line: python Flask==3.0.3 Then, install the Flask package by running the following command: python python -m pip install -r requirements.txt After Flask is installed, create a new file named main.py in the hello-python directory and add the following code: ```python import os import flask app = flask.Flask(name) @app.route(\'/\', methods=[\'GET\']) def hello_world(): return \'Hello, World!\' if name == \'main\': port = int(os.environ.get(\'PORT\', 8111)) app.run(host=\'0.0.0.0\', port=port) ``` The preceding code creates a simple Flask app that listens on port 8111 and returns the message ""Hello, World!"" when the root endpoint is accessed. Update the app host project Install the Python hosting package by running the following command: dotnetcli dotnet add ../PythonSample.AppHost/PythonSample.AppHost.csproj package Aspire.Hosting.Python --version 9.0.0 After the package is installed, the project XML should have a new package reference similar to the following: :::code language=""xml"" source=""snippets/PythonSample/PythonSample.AppHost/PythonSample.AppHost.csproj""::: Update the app host Program.cs file to include the Python project, by calling the AddPythonApp API and specifying the project name, project path, and the entry point file: :::code source=""snippets/PythonSample/PythonSample.AppHost/Program.cs""::: [!IMPORTANT] The AddPythonApp API is experimental and may change in future releases. For more information, see ASPIREHOSTINGPYTHON001. Run the app Now that you\'ve added the Python hosting package, updated the app host Program.cs file, and created a Python project, you can run the app host: dotnetcli dotnet run --project ../PythonSample.AppHost/PythonSample.AppHost.csproj Launch the dashboard by clicking the link in the console output. The dashboard should display the Python project as a resource. :::image source=""media/python-dashboard.png"" lightbox=""media/python-dashboard.png"" alt-text="".NET Aspire dashboard: Python sample app.""::: Select the Endpoints link to open the hello-python endpoint in a new browser tab. The browser should display the message ""Hello, World!"": :::image source=""media/python-hello-world.png"" lightbox=""media/python-hello-world.png"" alt-text="".NET Aspire dashboard: Python sample app endpoint.""::: Stop the app host by pressing Ctrl + C in the terminal.']","To integrate Python apps into a .NET Aspire project, you need to create a .NET Aspire application host using the command 'dotnet new aspire -o PythonSample'. After changing directories into the newly created project, launch the app host with 'dotnet run --project PythonSample.AppHost/PythonSample.AppHost.csproj'. Then, create a new directory for your Python source code, initialize a Python virtual environment, and install the necessary packages like Flask. Finally, update the app host project to include the Python project and run the app host again.",single_hop_specifc_query_synthesizer
28,What is the purpose of the ASPIRE_ALLOW_UNSECURED_TRANSPORT variable in the context of the Python app?,"['Add telemetry support. To add a bit of observability, add telemetry to help monitor the dependant Python app. In the Python project, add the following OpenTelemetry package as a dependency in the requirements.txt file: :::code language=""python"" source=""snippets/PythonSample/hello-python/requirements.txt"" highlight=""2-5""::: The preceding requirement update, adds the OpenTelemetry package and the OTLP exporter. Next, re-install the Python app requirements into the virtual environment by running the following command: python python -m pip install -r requirements.txt The preceding command installs the OpenTelemetry package and the OTLP exporter, in the virtual environment. Update the Python app to include the OpenTelemetry code, by replacing the existing main.py code with the following: :::code language=""python"" source=""snippets/PythonSample/hello-python/main.py""::: Update the app host project\'s launchSettings.json file to include the ASPIRE_ALLOW_UNSECURED_TRANSPORT environment variable: :::code language=""json"" source=""snippets/PythonSample/PythonSample.AppHost/Properties/launchSettings.json""::: The ASPIRE_ALLOW_UNSECURED_TRANSPORT variable is required because when running locally the OpenTelemetry client in Python rejects the local development certificate. Launch the app host again: dotnetcli dotnet run --project ../PythonSample.AppHost/PythonSample.AppHost.csproj Once the app host has launched navigate to the dashboard and note that in addition to console log output, structured logging is also being routed through to the dashboard. :::image source=""media/python-telemetry-in-dashboard.png"" lightbox=""media/python-telemetry-in-dashboard.png"" alt-text="".NET Aspire dashboard: Structured logging from Python process.""::: Summary While there are several considerations that are beyond the scope of this article, you learned how to build .NET Aspire solution that integrates with Python. You also learned how to use the AddPythonApp API to host Python apps. See also GitHub: .NET Aspire Samplesâ€”Python hosting integration']","The ASPIRE_ALLOW_UNSECURED_TRANSPORT variable is required because when running locally, the OpenTelemetry client in Python rejects the local development certificate.",single_hop_specifc_query_synthesizer
29,What tooling does .NET Aspire provide for Visual Studio?,"['title: .NET Aspire overview description: Learn about .NET Aspire, an application stack designed to improve the experience of building distributed applications. ms.date: 11/12/2024 .NET Aspire overview :::row::: :::column::: :::image type=""icon"" border=""false"" source=""../../assets/dotnet-aspire-logo-128.svg""::: :::column-end::: :::column span=""3""::: .NET Aspire is a set of tools, templates, and packages for building observable, production ready apps.\u200b\u200b .NET Aspire is delivered through a collection of NuGet packages that bootstrap or improve specific challenges with modern app development. Today\'s apps generally consume a large number of services, such as databases, messaging, and caching, many of which are supported via .NET Aspire Integrations. For information on support, see the .NET Aspire Support Policy. :::column-end::: :::row-end::: Why .NET Aspire? .NET Aspire improves the experience of building apps that have a variety of projects and resources. With dev-time productivity enhancements that emulate deployed scenarios, you can quickly develop interconnected apps. Designed for flexibility, .NET Aspire allows you to replace or extend parts with your preferred tools and workflows. Key features include: Dev-Time Orchestration: .NET Aspire provides features for running and connecting multi-project applications, container resources, and other dependencies for local development environments. Integrations: .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects.  .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects. Dev-time orchestration In .NET Aspire, ""orchestration"" primarily focuses on enhancing the local development experience by simplifying the management of your app\'s configuration and interconnections. It\'s important to note that .NET Aspire\'s orchestration isn\'t intended to replace the robust systems used in production environments, such as Kubernetes. Instead, it\'s a set of abstractions that streamline the setup of service discovery, environment variables, and container configurations, eliminating the need to deal with low-level implementation details. With .NET Aspire, your code has a consistent bootstrapping experience on any dev machine without the need for complex manual steps, making it easier to manage during the development phase. .NET Aspire orchestration assists with the following concerns: App composition: Specify the .NET projects, containers, executables, and cloud resources that make up the application. Service discovery and connection string management: The app host injects the right connection strings, network configurations, and service discovery information to simplify the developer experience. For example, using .NET Aspire, the following code creates a local Redis container resource, waits for it to become available, and then configures the appropriate connection string in the ""frontend"" project with a few helper method calls: ```csharp // Create a distributed application builder given the command line arguments. var builder = DistributedApplication.CreateBuilder(args); // Add a Redis server to the application. var cache = builder.AddRedis(""cache""); // Add the frontend project to the application and configure it to use the // Redis server, defined as a referenced dependency. builder.AddProject For more information, see .NET Aspire orchestration overview. [!IMPORTANT] The call to .NET Aspire integrations .NET Aspire integrations are NuGet packages designed to simplify connections to popular services and platforms, such as Redis or PostgreSQL. .NET Aspire integrations handle cloud resource setup and interaction for you through standardized patterns, such as adding health checks and telemetry. Integrations are two-fold - ""hosting"" integrations represents the service you\'re connecting to, and ""client"" integrations represents the client or consumer of that service. In other words, for many hosting packages there\'s a corresponding client package that handles the service connection within your code. Each integration is designed to work with the .NET Aspire app host, and their configurations are injected automatically by referencing named resources. In other words, if Example.ServiceFoo references Example.ServiceBar, Example.ServiceFoo inherits the integration\'s required configurations to allow them to communicate with each other automatically. For example, consider the following code using the .NET Aspire Service Bus integration: csharp builder.AddAzureServiceBusClient(""servicebus""); The Registers a Applies Enables corresponding health checks, logging, and telemetry specific to the Azure Service Bus usage. A full list of available integrations is detailed on the .NET Aspire integrations overview page.']",".NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects.",single_hop_specifc_query_synthesizer
30,How does C# relate to health checks in .NET Aspire?,"['Project templates and tooling .NET Aspire provides a set of project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI. These templates are designed to help you create and interact with .NET Aspire projects, or add .NET Aspire into your existing codebase. The templates include a set of opinionated defaults to help you get started quickly - for example, it has boilerplate code for turning on health checks and logging in .NET apps. These defaults are fully customizable, so you can edit and adapt them to suit your needs. .NET Aspire templates also include boilerplate extension methods that handle common service configurations for you: csharp builder.AddServiceDefaults(); For more information on what AddServiceDefaults does, see .NET Aspire service defaults. When added to your :::no-loc text=""Program.cs""::: file, the preceding code handles the following concerns: OpenTelemetry: Sets up formatted logging, runtime metrics, built-in meters, and tracing for ASP.NET Core, gRPC, and HTTP. For more information, see .NET Aspire telemetry. Default health checks: Adds default health check endpoints that tools can query to monitor your app. For more information, see .NET app health checks in C#. Service discovery: Enables service discovery for the app and configures Next steps [!div class=""nextstepaction""] Quickstart: Build your first .NET Aspire project']","In .NET Aspire, default health checks are added that tools can query to monitor your app. For more information, see .NET app health checks in C#.",single_hop_specifc_query_synthesizer
31,Wut is the role of artificial intellgence in Milvus?,"[""title: .NET Aspire Milvus database integration description: Learn how to use the .NET Aspire Milvus database integration, which includes both hosting and client integrations. ms.date: 08/22/2024 uid: database/milvus-integration .NET Aspire Milvus database integration [!INCLUDE includes-hosting-and-client] Milvus is an open-source vector database system that efficiently stores, indexes, and searches large-scale vector data. It's commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Milvus database integration. The .NET Aspire Milvus database integration enables you to connect to existing Milvus databases or create new instances with the milvusdb/milvus container image.""]","Artificial intelligence is commonly used in machine learning and data science applications, where Milvus serves as an open-source vector database system that efficiently stores, indexes, and searches large-scale vector data.",single_hop_specifc_query_synthesizer
32,What is Attu in relation to Milvus?,"['Hosting integration The Milvus database hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Milvus PackageReference xml <PackageReference Include=""Aspire.Hosting.Milvus"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Milvus server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithLifetime(ContainerLifetime.Persistent); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Milvus container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the milvusdb/milvus image, it creates a new Milvus instance on your local machine. A reference to your Milvus resource builder (the milvus variable) is used to add a database. The database is named milvusdb and then added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing Milvus server, call Handling credentials and passing other parameters for the Milvus resource The Milvus resource includes default credentials with a username of root and the password Milvus. Milvus supports configuration-based default passwords by using the environment variable COMMON_SECURITY_DEFAULTROOTPASSWORD. To change the default password in the container, pass an apiKey parameter when calling the AddMilvus hosting API: ```csharp var apiKey = builder.AddParameter(""apiKey"", secret: true); var milvus = builder.AddMilvus(""milvus"", apiKey); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddMilvus API, and internally assigns the parameter to the COMMON_SECURITY_DEFAULTROOTPASSWORD environment variable of the Milvus container. The apiKey parameter is usually specified as a user secret: json { ""Parameters"": { ""apiKey"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add a Milvus resource with a data volume To add a data volume to the Milvus service resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithDataVolume(); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Milvus data outside the lifecycle of its container. The data volume is mounted at the /var/lib/milvus path in the SQL Server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add a Milvus resource with a data bind mount To add a data bind mount to the Milvus resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithDataBindMount(source: @""C:\\Milvus\\Data""); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Milvus data across container restarts. The data bind mount is mounted at the C:\\Milvus\\Data on Windows (or /Milvus/Data on Unix) path on the host machine in the Milvus container. For more information on data bind mounts, see Docker docs: Bind mounts. Create an Attu resource Attu is a graphical user interface (GUI) and management tool designed to interact with Milvus and its databases. It includes rich visualization features that can help you investigate and understand your vector data. If you want to use Attu to manage Milvus in your .NET Aspire solution, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithAttu() .WithLifetime(ContainerLifetime.Persistent); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` When you debug the .NET Aspire solution, you\'ll see an Attu container listed in the solution\'s resources. Select the resource\'s endpoint to open the GUI and start managing databases.']",Attu is a graphical user interface (GUI) and management tool designed to interact with Milvus and its databases. It includes rich visualization features that can help you investigate and understand your vector data.,single_hop_specifc_query_synthesizer
33,"Can you elaborate on the steps required for integrating the .NET Aspire Milvus client into a project, including the necessary configurations and health checks?","['Client integration To get started with the .NET Aspire Milvus client integration, install the ðŸ“¦ Aspire.Milvus.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Milvus database client. The Milvus client integration registers a Milvus.Client.MilvusClient instance that you can use to interact with Milvus databases. .NET CLI dotnetcli dotnet add package Aspire.Milvus.Client PackageReference xml <PackageReference Include=""Aspire.Milvus.Client"" Version=""*"" /> Add a Milvus client In the Program.cs file of your client-consuming project, call the csharp builder.AddMilvusClient(""milvusdb""); [!TIP] The connectionName parameter must match the name used when adding the Milvus database resource in the app host project. In other words, when you call AddDatabase and provide a name of milvusdb that same name should be used when calling AddMilvusClient. For more information, see Add a Milvus server resource and database resource. You can then retrieve the MilvusClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(MilvusClient client) { // Use the Milvus Client... } For more information on dependency injection, see .NET dependency injection. Add a keyed Milvus client There might be situations where you want to register multiple MilvusClient instances with different connection names. To register keyed Milvus clients, call the csharp builder.AddKeyedMilvusClient(name: ""mainDb""); builder.AddKeyedMilvusClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Milvus resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the MilvusClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] MilvusClient mainDbClient, [FromKeyedServices(""loggingDb"")] MilvusClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Milvus client integration provides multiple options to configure the connection to Milvus based on the requirements and conventions of your project. [!TIP] The default use is root and the default password is Milvus. To configure a different password in the Milvus container, see Handling credentials and passing other parameters for the Milvus resource. Use the following techniques to configure consuming client apps in your .NET Aspire solution with the same password or other settings. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddMilvusClient(): csharp builder.AddMilvusClient(""milvus""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""milvus"": ""Endpoint=http://localhost:19530/;Key=root:Non-default-P@ssw0rd"" } } By default the MilvusClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Milvus client integration supports json { ""Aspire"": { ""Milvus"": { ""Client"": { ""Endpoint"": ""http://localhost:19530/"", ""Database"": ""milvusdb"", ""Key"": ""root:Non-default-P@ssw0rd"", ""DisableHealthChecks"": false } } } } For the complete Milvus client integration JSON schema, see Aspire.Milvus.Client/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MilvusSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddMilvusClient( ""milvus"", static settings => settings.Key = ""root:Non-default-P@ssw0rd""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Milvus database integration: Adds the health check when Uses the configured client to perform a HealthAsync. If the result is healthy, the health check is considered healthy, otherwise it\'s unhealthy. Likewise, if there\'s an exception, the health check is considered unhealthy with the error propagating through the health check failure. [!INCLUDE integration-observability-and-telemetry]']","To integrate the .NET Aspire Milvus client into your project, you need to follow several steps. First, install the Aspire.Milvus.Client NuGet package in your client-consuming project. This package registers a Milvus.Client.MilvusClient instance for interacting with Milvus databases. In your Program.cs file, call builder.AddMilvusClient(""milvusdb""); ensuring that the connectionName matches the name used when adding the Milvus database resource in the app host project. You can retrieve the MilvusClient instance using dependency injection in your services. If you need to register multiple MilvusClient instances with different connection names, use builder.AddKeyedMilvusClient(name: ""mainDb""); and builder.AddKeyedMilvusClient(name: ""loggingDb"");. For configuration, you can use a connection string from the ConnectionStrings section or configuration providers to set up the Milvus client options. By default, health checks are enabled for all services, and the Milvus database integration performs health checks using the configured client. If the health check is successful, it is considered healthy; otherwise, it is unhealthy.",single_hop_specifc_query_synthesizer
34,Can you tell me about GitHub and how it relates to the .NET Aspire Milvus database integration?,"[""Logging The .NET Aspire Milvus database integration uses standard .NET logging, and you'll see log entries from the following category: Milvus.Client Tracing The .NET Aspire Milvus database integration doesn't currently emit tracing activities because they are not supported by the Milvus.Client library. Metrics The .NET Aspire Milvus database integration doesn't currently emit metrics because they are not supported by the Milvus.Client library. See also Milvus Milvus GitHub repo Milvus .NET SDK .NET Aspire integrations .NET Aspire GitHub repo""]","GitHub is mentioned in the context of the Milvus GitHub repo and the .NET Aspire GitHub repo, which are relevant for accessing the source code and documentation related to the Milvus database integration with .NET Aspire.",single_hop_specifc_query_synthesizer
35,How do you apply EF Core migrations in .NET Aspire?,"['title: Apply EF Core migrations in .NET Aspire description: Learn about how to to apply Entity Framework Core migrations in .NET Aspire ms.date: 07/31/2024 ms.topic: how-to Apply Entity Framework Core migrations in .NET Aspire Since .NET Aspire projects use a containerized architecture, databases are ephemeral and can be recreated at any time. Entity Framework Core (EF Core) uses a feature called migrations to create and update database schemas. Since databases are recreated when the app starts, you need to apply migrations to initialize the database schema each time your app starts. This is accomplished by registering a migration service project in your app that runs migrations during startup. In this tutorial, you learn how to configure .NET Aspire projects to run EF Core migrations during app startup. [!INCLUDE aspire-prereqs] Obtain the starter app This tutorial uses a sample app that demonstrates how to apply EF Core migrations in .NET Aspire. Use Visual Studio to clone the sample app from GitHub or use the following command: bash git clone https://github.com/MicrosoftDocs/aspire-docs-samples/ The sample app is in the SupportTicketApi folder. Open the solution in Visual Studio or VS Code and take a moment to review the sample app and make sure it runs before proceeding. The sample app is a rudimentary support ticket API, and it contains the following projects: SupportTicketApi.Api: The ASP.NET Core project that hosts the API. SupportTicketApi.Data: Contains the EF Core contexts and models. SupportTicketApi.AppHost: Contains the .NET Aspire app host and configuration. SupportTicketApi.ServiceDefaults: Contains the default service configurations. Run the app to ensure it works as expected. From the .NET Aspire dashboard, select the https Swagger endpoint and test the API\'s GET /api/SupportTickets endpoint by expanding the operation and selecting Try it out. Select Execute to send the request and view the response: json [ { ""id"": 1, ""title"": ""Initial Ticket"", ""description"": ""Test ticket, please ignore."" } ] Create migrations Start by creating some migrations to apply. Open a terminal (Ctrl+` in Visual Studio). Set :::no-loc text=""SupportTicketApi\\SupportTicketApi.Api""::: as the current directory. Use the dotnet ef command-line tool to create a new migration to capture the initial state of the database schema: dotnetcli dotnet ef migrations add InitialCreate --project ..\\SupportTicketApi.Data\\SupportTicketApi.Data.csproj The proceeding command: Runs EF Core migration command-line tool in the SupportTicketApi.Api directory. dotnet ef is run in this location because the API service is where the DB context is used. Creates a migration named InitialCreate. Creates the migration in the in the Migrations folder in the SupportTicketApi.Data project. Modify the model so that it includes a new property. Open :::no-loc text=""SupportTicketApi.Data\\Models\\SupportTicket.cs""::: and add a new property to the SupportTicket class: :::code source=""~/aspire-docs-samples-solution/SupportTicketApi/SupportTicketApi.Data/Models/SupportTicket.cs"" range=""5-13"" highlight=""8"" ::: Create another new migration to capture the changes to the model: dotnetcli dotnet ef migrations add AddCompleted --project ..\\SupportTicketApi.Data\\SupportTicketApi.Data.csproj Now you\'ve got some migrations to apply. Next, you\'ll create a migration service that applies these migrations during app startup. Create the migration service To run the migrations at startup, you need to create a service that applies the migrations. Add a new Worker Service project to the solution. If using Visual Studio, right-click the solution in Solution Explorer and select :::no-loc text=""Add""::: > :::no-loc text=""New Project"":::. Select :::no-loc text=""Worker Service""::: and name the project :::no-loc text=""SupportTicketApi.MigrationService"":::. If using the command line, use the following commands from the solution directory: dotnetcli dotnet new worker -n SupportTicketApi.MigrationService dotnet sln add SupportTicketApi.MigrationService Add the :::no-loc text=""SupportTicketApi.Data""::: and :::no-loc text=""SupportTicketApi.ServiceDefaults""::: project references to the :::no-loc text=""SupportTicketApi.MigrationService""::: project using Visual Studio or the command line: dotnetcli dotnet add SupportTicketApi.MigrationService reference SupportTicketApi.Data dotnet add SupportTicketApi.MigrationService reference SupportTicketApi.ServiceDefaults Add the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package reference to the :::no-loc text=""SupportTicketApi.MigrationService""::: project using Visual Studio or the command line: dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer Add the highlighted lines to the :::no-loc text=""Program.cs""::: file in the :::no-loc text=""SupportTicketApi.MigrationService""::: project: :::code source=""~/aspire-docs-samples-solution/SupportTicketApi/SupportTicketApi.MigrationService/Program.cs"" highlight=""1,6,9-12"" ::: In the preceding code: The AddServiceDefaults extension method adds service defaults functionality. The AddOpenTelemetry extension method configures OpenTelemetry functionality. The AddSqlServerDbContext extension method adds the TicketContext service to the service collection. This service is used to run migrations and seed the database. Replace the contents of the :::no-loc text=""Worker.cs""::: file in the :::no-loc text=""SupportTicketApi.MigrationService""::: project with the following code: :::code source=""~/aspire-docs-samples-solution/SupportTicketApi/SupportTicketApi.MigrationService/Worker.cs"" ::: In the preceding code: The ExecuteAsync method is called when the worker starts. It in turn performs the following steps: Gets a reference to the TicketContext service from the service provider. Calls EnsureDatabaseAsync to create the database if it doesn\'t exist. Calls RunMigrationAsync to apply any pending migrations. Calls SeedDataAsync to seed the database with initial data. Stops the worker with StopApplication. The EnsureDatabaseAsync, RunMigrationAsync, and SeedDataAsync methods all encapsulate their respective database operations using execution strategies to handle transient errors that may occur when interacting with the database. To learn more about execution strategies, see Connection Resiliency. Add the migration service to the orchestrator The migration service is created, but it needs to be added to the .NET Aspire app host so that it runs when the app starts. In the :::no-loc text=""SupportTicketApi.AppHost""::: project, open the :::no-loc text=""Program.cs""::: file. Add the following highlighted code to the ConfigureServices method: :::code source=""~/aspire-docs-samples-solution/SupportTicketApi/SupportTicketApi.AppHost/Program.cs"" highlight=""9-10"" ::: This enlists the :::no-loc text=""SupportTicketApi.MigrationService""::: project as a service in the .NET Aspire app host. [!IMPORTANT] If you are using Visual Studio, and you selected the :::no-loc text=""Enlist in Aspire orchestration""::: option when creating the Worker Service project, similar code is added automatically with the service name supportticketapi-migrationservice. Replace that code with the preceding code. Remove existing seeding code Since the migration service seeds the database, you should remove the existing data seeding code from the API project. In the :::no-loc text=""SupportTicketApi.Api""::: project, open the :::no-loc text=""Program.cs""::: file. Delete the highlighted lines. :::code source=""~/aspire-docs-samples-main/SupportTicketApi/SupportTicketApi.Api/Program.cs"" range=""20-36"" highlight=""6-16"" :::']","To apply EF Core migrations in .NET Aspire, you need to register a migration service project in your app that runs migrations during startup. This involves creating a Worker Service project that applies the migrations when the application starts. You can create migrations using the dotnet ef command-line tool and ensure that the database schema is initialized each time the app starts.",single_hop_specifc_query_synthesizer
36,How can I test the SupportTicketApi after configuring the migration service?,"['Test the migration service Now that the migration service is configured, run the app to test the migrations. Run the app and observe the :::no-loc text=""SupportTicketApi""::: dashboard. After a short wait, the migrations service state will display Finished. :::image type=""content"" source=""media/ef-core-migrations/dashboard-post-migration.png"" lightbox=""media/ef-core-migrations/dashboard-post-migration.png"" alt-text=""A screenshot of the .NET Aspire dashboard with the migration service in a Finished state."" ::: Select the :::no-loc text=""View""::: link on the migration service to investigate the logs showing the SQL commands that were executed. Get the code You can find the completed sample app on GitHub. More sample code The Aspire Shop sample app uses this approach to apply migrations. See the AspireShop.CatalogDbManager project for the migration service implementation.']","To test the SupportTicketApi after configuring the migration service, run the app and observe the SupportTicketApi dashboard. After a short wait, the migrations service state will display 'Finished'. You can then select the 'View' link on the migration service to investigate the logs showing the SQL commands that were executed.",single_hop_specifc_query_synthesizer
37,Can you explain the significance of the .NET Aspire manifest format for deployment tool builders and how it aids in the deployment of .NET Aspire projects?,"['title: .NET Aspire manifest format for deployment tool builders description: Learn about the .NET Aspire manifest format in this comprehensive deployment tool builder guide. ms.date: 03/29/2024 ms.topic: reference .NET Aspire manifest format for deployment tool builders In this article, you learn about the .NET Aspire manifest format. This article serves as a reference guide for deployment tool builders, aiding in the creation of tooling to deploy .NET Aspire projects on specific hosting platforms, whether on-premises or in the cloud. .NET Aspire simplifies the local development experience by helping to manage interdependencies between application integrations. To help simplify the deployment of applications, .NET Aspire projects can generate a manifest of all the resources defined as a JSON formatted file. Generate a manifest A valid .NET Aspire project is required to generate a manifest. To get started, create a .NET Aspire project using the aspire-starter .NET template: dotnetcli dotnet new aspire-starter --use-redis-cache ` -o AspireApp && ` cd AspireApp Manifest generation is achieved by running dotnet build with a special target: dotnetcli dotnet run --project AspireApp.AppHost\\AspireApp.AppHost.csproj ` --publisher manifest ` --output-path ../aspire-manifest.json [!TIP] The --output-path supports relative paths. The previous command uses ../aspire-manifest.json to place the manifest file in the root of the project directory. For more information, see dotnet run. The previous command produces the following output: Output Building... info: Aspire.Hosting.Publishing.ManifestPublisher[0] Published manifest to: .\\AspireApp.AppHost\\aspire-manifest.json The file generated is the .NET Aspire manifest and is used by tools to support deploying into target cloud environments. [!NOTE] You can also generate a manifest as part of the launch profile. Consider the following launchSettings.json: json { ""$schema"": ""http://json.schemastore.org/launchsettings.json"", ""profiles"": { ""generate-manifest"": { ""commandName"": ""Project"", ""launchBrowser"": false, ""dotnetRunMessages"": true, ""commandLineArgs"": ""--publisher manifest --output-path aspire-manifest.json"" } } }']",".NET Aspire manifest format is significant for deployment tool builders as it serves as a reference guide for creating tooling that deploys .NET Aspire projects on various hosting platforms, whether on-premises or in the cloud. It simplifies the local development experience by managing interdependencies between application integrations. The format allows .NET Aspire projects to generate a manifest of all resources defined as a JSON formatted file, which is essential for supporting deployment into target cloud environments.",single_hop_specifc_query_synthesizer
38,What is the role of Redis in the manifest format for .NET Aspire?,"['Basic manifest format Publishing the manifest from the default starter template for .NET Aspire produces the following JSON output: json { ""resources"": { ""cache"": { ""type"": ""container.v0"", ""connectionString"": ""{cache.bindings.tcp.host}:{cache.bindings.tcp.port}"", ""image"": ""redis:7.2.4"", ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 6379 } } }, ""apiservice"": { ""type"": ""project.v0"", ""path"": ""../AspireApp.ApiService/AspireApp.ApiService.csproj"", ""env"": { ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES"": ""true"", ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES"": ""true"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"" }, ""https"": { ""scheme"": ""https"", ""protocol"": ""tcp"", ""transport"": ""http"" } } }, ""webfrontend"": { ""type"": ""project.v0"", ""path"": ""../AspireApp.Web/AspireApp.Web.csproj"", ""env"": { ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES"": ""true"", ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES"": ""true"", ""ConnectionStrings__cache"": ""{cache.connectionString}"", ""services__apiservice__0"": ""{apiservice.bindings.http.url}"", ""services__apiservice__1"": ""{apiservice.bindings.https.url}"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"" }, ""https"": { ""scheme"": ""https"", ""protocol"": ""tcp"", ""transport"": ""http"" } } } } } The manifest format JSON consists of a single object called resources, which contains a property for each resource specified in :::no-loc text=""Program.cs""::: (the name argument for each name is used as the property for each of the child resource objects in JSON). Connection string and binding references In the previous example, there are two project resources and one Redis cache resource. The webfrontend depends on both the apiservice (project) and cache (Redis) resources. This dependency is known because the environment variables for the webfrontend contain placeholders that reference the two other resources: json ""env"": { // ... other environment variables omitted for clarity ""ConnectionStrings__cache"": ""{cache.connectionString}"", ""services__apiservice__0"": ""{apiservice.bindings.http.url}"", ""services__apiservice__1"": ""{apiservice.bindings.https.url}"" }, The apiservice resource is referenced by webfrontend using the call WithReference(apiservice) in the app host :::no-loc text=""Program.cs""::: file and redis is referenced using the call WithReference(cache): ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` References between project resource types result in service discovery variables being injected into the referencing project. References to well known reference types such as Redis result in connection strings being injected. :::image type=""content"" source=""media/manifest-placeholder-strings.png"" lightbox=""media/manifest-placeholder-strings.png"" alt-text=""A diagram showing which resources contribute to which corresponding placeholder strings.""::: For more information on how resources in the app model and references between them work, see, .NET Aspire orchestration overview. Placeholder string structure Placeholder strings reference the structure of the .NET Aspire manifest: :::image type=""content"" source=""media/placeholder-mappings.png"" lightbox=""media/placeholder-mappings.png"" alt-text=""A diagram showing how the manifest JSON structure maps to placeholder strings.""::: The final segment of the placeholder string (url in this case) is generated by the tool processing the manifest. There are several suffixes that could be used on the placeholder string: connectionString: For well-known resource types such as Redis. Deployment tools translate the resource in the most appropriate infrastructure for the target cloud environment and then produce a .NET Aspire compatible connection string for the consuming application to use. On container.v0 resources the connectionString field may be present and specified explicitly. This is to support scenarios where a container resource type is referenced using the url: For service-to-service references where a well-formed URL is required. The deployment tool produces the url based on the scheme, protocol, and transport defined in the manifest and the underlying compute/networking topology that was deployed. host: The host segment of the URL. port: The port segment of the URL.']","In the manifest format for .NET Aspire, Redis serves as a cache resource. It is referenced by the webfrontend, which depends on both the apiservice and the Redis cache resources. The connection string for Redis is injected into the environment variables of the webfrontend, allowing it to connect to the cache.",single_hop_specifc_query_synthesizer
39,What is the significance of NuGet in the context of .NET Aspire?,"['Resource types Each resource has a type field. When a deployment tool reads the manifest, it should read the type to verify whether it can correctly process the manifest. During the .NET Aspire preview period, all resource types have a v0 suffix to indicate that they\'re subject to change. As .NET Aspire approaches release a v1 suffix will be used to signify that the structure of the manifest for that resource type should be considered stable (subsequent updates increment the version number accordingly). Common resource fields The type field is the only field that is common across all resource types, however, the project.v0, container.v0, and executable.v0 resource types also share the env and bindings fields. [!NOTE] The executable.v0 resource type isn\'t fully implemented in the manifest due to its lack of utility in deployment scenarios. For more information on containerizing executables, see Dockerfile resource types. The env field type is a basic key/value mapping where the values might contain placeholder strings. Bindings are specified in the bindings field with each binding contained within its own field under the bindings JSON object. The fields omitted by the .NET Aspire manifest in the bindings node include: scheme: One of the following values tcp, udp, http, or https. protocol: One of the following values tcp or udp transport: Same as scheme, but used to disambiguate between http and http2. containerPort: Optional, if omitted defaults to port 80. The inputs field Some resources generate an inputs field. This field is used to specify input parameters for the resource. The inputs field is a JSON object where each property is an input parameter that\'s used in placeholder structure resolution. Resources that have a connectionString, for example, might use the inputs field to specify a password for the connection string: json ""connectionString"": ""Host={<resourceName>.bindings.tcp.host};Port={<resourceName>.bindings.tcp.port};Username=admin;Password={<resourceName>.inputs.password};"" The connection string placeholder references the password input parameter from the inputs field: json ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } The preceding JSON snippet shows the inputs field for a resource that has a connectionString field. The password input parameter is a string type and is marked as a secret. The default field is used to specify a default value for the input parameter. In this case, the default value is generated using the generate field, with random string of a minimum length. Built-in resources The following table is a list of resource types that are explicitly generated by .NET Aspire and extensions developed by the .NET Aspire team: Cloud-agnostic resource types These resources are available in the ðŸ“¦ Aspire.Hosting NuGet package. App model usage Manifest resource type Heading link container.v0 Container resource type PublishAsDockerFile dockerfile.v0 Dockerfile resource types value.v0 MongoDB Server resource types container.v0 MongoDB resource types value.v0 MySQL Server resource types container.v0 MySQL resource types value.v0 Postgres resource types container.v0 Postgres resource types project.v0 Project resource type container.v0 RabbitMQ resource types container.v0 Redis resource type value.v0 SQL Server resource types container.v0 SQL Server resource types Project resource type Example code: csharp var builder = DistributedApplication.CreateBuilder(args); var apiservice = builder.AddProject<Projects.AspireApp_ApiService>(""apiservice""); Example manifest: json ""apiservice"": { ""type"": ""project.v0"", ""path"": ""../AspireApp.ApiService/AspireApp.ApiService.csproj"", ""env"": { ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES"": ""true"", ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES"": ""true"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"" }, ""https"": { ""scheme"": ""https"", ""protocol"": ""tcp"", ""transport"": ""http"" } } } Container resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddContainer(""mycontainer"", ""myimage"") .WithEnvironment(""LOG_LEVEL"", ""WARN"") .WithHttpEndpoint(3000); ``` Example manifest: json { ""resources"": { ""mycontainer"": { ""type"": ""container.v0"", ""image"": ""myimage:latest"", ""env"": { ""LOG_LEVEL"": ""WARN"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 3000 } } } } } Dockerfile resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddNodeApp(""nodeapp"", ""../nodeapp/app.js"") .WithHttpEndpoint(hostPort: 5031, env: ""PORT"") .PublishAsDockerFile(); ``` [!TIP] The PublishAsDockerFile call is required to generate the Dockerfile resource type in the manifest, and this extension method is only available on the Example manifest: json { ""resources"": { ""nodeapp"": { ""type"": ""dockerfile.v0"", ""path"": ""../nodeapp/Dockerfile"", ""context"": ""../nodeapp"", ""env"": { ""NODE_ENV"": ""development"", ""PORT"": ""{nodeapp.bindings.http.port}"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 5031 } } } } } Postgres resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddPostgres(""postgres1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""postgres1"": { ""type"": ""container.v0"", ""connectionString"": ""Host={postgres1.bindings.tcp.host};Port={postgres1.bindings.tcp.port};Username=postgres;Password={postgres1.inputs.password}"", ""image"": ""postgres:16.2"", ""env"": { ""POSTGRES_HOST_AUTH_METHOD"": ""scram-sha-256"", ""POSTGRES_INITDB_ARGS"": ""--auth-host=scram-sha-256 --auth-local=scram-sha-256"", ""POSTGRES_PASSWORD"": ""{postgres1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5432 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{postgres1.connectionString};Database=shipping"" } } } RabbitMQ resource types RabbitMQ is modeled as a container resource container.v0. The following sample shows how they\'re added to the app model. ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRabbitMQ(""rabbitmq1""); ``` The previous code produces the following manifest: json { ""resources"": { ""rabbitmq1"": { ""type"": ""container.v0"", ""connectionString"": ""amqp://guest:{rabbitmq1.inputs.password}@{rabbitmq1.bindings.tcp.host}:{rabbitmq1.bindings.tcp.port}"", ""image"": ""rabbitmq:3"", ""env"": { ""RABBITMQ_DEFAULT_USER"": ""guest"", ""RABBITMQ_DEFAULT_PASS"": ""{rabbitmq1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5672 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } } } } Redis resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRedis(""redis1""); ``` Example manifest: json { ""resources"": { ""redis1"": { ""type"": ""container.v0"", ""connectionString"": ""{redis1.bindings.tcp.host}:{redis1.bindings.tcp.port}"", ""image"": ""redis:7.2.4"", ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 6379 } } } } } SQL Server resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddSqlServer(""sql1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""sql1"": { ""type"": ""container.v0"", ""connectionString"": ""Server={sql1.bindings.tcp.host},{sql1.bindings.tcp.port};User ID=sa;Password={sql1.inputs.password};TrustServerCertificate=true"", ""image"": ""mcr.microsoft.com/mssql/server:2022-latest"", ""env"": { ""ACCEPT_EULA"": ""Y"", ""MSSQL_SA_PASSWORD"": ""{sql1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 1433 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{sql1.connectionString};Database=shipping"" } } } MongoDB resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddMongoDB(""mongodb1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""mongodb1"": { ""type"": ""container.v0"", ""connectionString"": ""mongodb://{mongodb1.bindings.tcp.host}:{mongodb1.bindings.tcp.port}"", ""image"": ""mongo:7.0.5"", ""bindings"": { ""tcp"": { ""scheme"":']",NuGet is significant in the context of .NET Aspire as it provides cloud-agnostic resource types that are available in the Aspire.Hosting NuGet package.,single_hop_specifc_query_synthesizer
40,How does the use of Azurite in the development environment affect the processing of messages in the Azure Storage queue?,"['<1-hop>\n\nAdd the Worker Service project Next, add a Worker Service project to the solution to retrieve and process messages as they are added to the Azure Storage queue. Visual Studio In the solution explorer, right click on the top level AspireStorage solution node and select Add > New project. Search for and select the Worker Service template and choose Next. For the Project name, enter AspireStorage.WorkerService and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Make sure Enlist in .NET Aspire orchestration is checked and select Create. Visual Studio adds the project to your solution and updates the :::no-loc text=""Program.cs""::: file of the AspireStorage.AppHost project with a new line of code: csharp builder.AddProject<Projects.AspireStorage_WorkerService>( ""aspirestorage-workerservice""); Visual Studio tooling added this line of code to register your new project with the .NET CLI In the root directory of the app, use the dotnet new command to create a new Worker Service app: dotnetcli dotnet new worker --name AspireStorage.WorkerService Use the dotnet sln command to add the project to the solution: dotnet sln AspireStorage.sln add AspireStorage.WorkerService/AspireStorage.WorkerService.csproj Use the dotnet add reference command to add project reference between the .AppHost and .WorkerService project: dotnetcli dotnet add AspireStorage.AppHost/AspireStorage.AppHost.csproj reference AspireStorage.WorkerService/AspireStorage.WorkerService.csproj Add the following line of code to the :::no-loc text=""Program.cs""::: file in the AspireStorage.AppHost project: csharp builder.AddProject<Projects.AspireStorage_WorkerService>( ""aspirestorage-workerservice""); The completed solution structure should resemble the following: :::image type=""content"" loc-scope=""visual-studio"" source=""media/storage-project.png"" alt-text=""A screenshot showing the structure of the .NET Aspire storage sample solution.""::: Add the .NET Aspire integrations to the Blazor app Add the .NET Aspire Azure Blob Storage integration and .NET Aspire Azure Queue Storage integration packages to your AspireStorage.Web project: dotnetcli dotnet add package Aspire.Azure.Storage.Blobs dotnet add package Aspire.Azure.Storage.Queues Your AspireStorage.Web project is now set up to use .NET Aspire integrations. Here\'s the updated AspireStorage.Web.csproj file: :::code language=""xml"" source=""snippets/tutorial/AspireStorage/AspireStorage.Web/AspireStorage.Web.csproj"" highlight=""14-15""::: The next step is to add the integrations to the app. In the :::no-loc text=""Program.cs""::: file of the AspireStorage.Web project, add calls to the :::zone pivot=""azurite"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.Web/Program.cs"" highlight=""4-5,9-10,36-48""::: :::zone-end :::zone pivot=""azure-portal,azure-cli"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.Web/Program.cs"" range=""1-35,49-63"" highlight=""2-3,7-8""::: :::zone-end With the additional using statements, these methods accomplish the following tasks: Register a Automatically enable corresponding health checks, logging, and telemetry for the respective services. :::zone pivot=""azurite"" When the AspireStorage.Web project starts, it will create a fileuploads container in Azurite Blob Storage and a tickets queue in Azurite Queue Storage. This is conditional when the app is running in a development environment. When the app is running in a production environment, the container and queue are assumed to have already been created. :::zone-end Add the .NET Aspire integration to the Worker Service The worker service handles pulling messages off of the Azure Storage queue for processing. Add the .NET Aspire Azure Queue Storage integration integration package to your AspireStorage.WorkerService app: dotnetcli dotnet add package Aspire.Azure.Storage.Queues In the :::no-loc text=""Program.cs""::: file of the AspireStorage.WorkerService project, add a call to the :::code source=""snippets/tutorial/AspireStorage/AspireStorage.WorkerService/Program.cs"" highlight=""5""::: This method handles the following tasks: Register a Automatically enable corresponding health checks, logging, and telemetry for the respective services. Create the form The app requires a form for the user to be able to submit support ticket information and upload an attachment. The app uploads the attached file on the Document ( Use the following Razor markup to create a basic form, replacing the contents of the Home.razor file in the AspireStorage.Web/Components/Pages directory: :::code language=""razor"" source=""snippets/tutorial/AspireStorage/AspireStorage.Web/Components/Pages/Home.razor""::: For more information about creating forms in Blazor, see ASP.NET Core Blazor forms overview. Update the AppHost The AspireStorage.AppHost project is the orchestrator for your app. It\'s responsible for connecting and configuring the different projects and services of your app. The orchestrator should be set as the startup project. To add Azure Storage hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Storage PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Storage"" Version=""*"" /> Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireStorage.AppHost project with the following code: :::zone pivot=""azurite"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.AppHost/Program.cs""::: The preceding code adds Azure storage, blobs, and queues, and when in development mode, it uses the emulator. Each project defines references for these resources that they depend on. :::zone-end :::zone pivot=""azure-portal,azure-cli"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.AppHost/Program.cs"" range=""1-6,12-27""::: The preceding code adds Azure storage, blobs, and queues, and defines references for these resources within each project that depend on them. :::zone-end Process the items in the queue When a new message is placed on the tickets queue, the worker service should retrieve, process, and delete the message. Update the Worker.cs class, replacing the contents with the following code: :::zone pivot=""azurite"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.WorkerService/Worker.cs""::: Before the worker service can process messages, it needs to be able to connect to the Azure Storage queue. With Azurite, you need to ensure that the queue is available before the worker service starts executing message queue processing. :::zone-end :::zone pivot=""azure-portal,azure-cli"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.WorkerService/Worker.cs"" range=""1-12,15-37""::: The worker service processes messages by connecting to the Azure Storage queue, and pulling messages off the queue. :::zone-end The worker service processes message in the queue and deletes them when they\'ve been processed. :::zone pivot=""azure-portal,azure-cli,azure-developer-cli"" Configure the connection strings The AspireStorage and AspireStorage.Worker projects must be configured to connect to the correct Azure Storage Account you created earlier. You can specify the endpoints for the blob and queue services in the storage account using the :::no-loc text=""appsettings.json""::: file in each project. In the AspireStorage project, add the following configuration to the appsettings.Development.json file: json ""ConnectionStrings"": { ""BlobConnection"": ""https://<your-storage-account-name>.blob.core.windows.net/"", ""QueueConnection"": ""https://<your-storage-account-name>.queue.core.windows.net/"" } In the AspireStorage.Worker project, add the following configuration to the appsettings.Development.json file: json ""ConnectionStrings"": { ""QueueConnection"": ""https://<your-storage-account-name>.queue.core.windows.net/"" } :::zone-end', '<2-hop>\n\nRun and test the app locally The sample app is now ready for testing. Verify that the submitted form data is sent to Azure Blob Storage and Azure Queue Storage by completing the following steps: Visual Studio Press the run button at the top of Visual Studio to launch your .NET Aspire project dashboard in the browser. On the resources page, in the aspirestorage.web row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: .NET CLI In a terminal window at the root of your project, use the dotnet run command to start the app: dotnetcli dotnet run --project AspireStorage.AppHost On the resources page, in the aspirestorage row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: Summary The example app that you built demonstrates persisting blobs from an ASP.NET Core Blazor Web App and processing queues in a .NET Worker Service. Your app connects to Azure Storage using .NET Aspire integrations. The app sends the support tickets to a queue for processing and uploads an attachment to storage. :::zone pivot=""azurite"" Since you choose to use Azurite, there\'s no need to clean up these resources when you\'re done testing them, as you created them locally in the context of an emulator. The emulator enabled you to test your app locally without incurring any costs, as no Azure resources were provisioned or created. :::zone-end :::zone pivot=""azure-portal,azure-cli"" [!INCLUDE clean-up-resources] :::zone-end']","The use of Azurite in the development environment allows the AspireStorage.Web project to create a fileuploads container and a tickets queue in Azurite Blob Storage and Queue Storage when the app starts. This setup is conditional, meaning it only occurs in development mode. When the worker service processes messages from the Azure Storage queue, it connects to the Azurite queue, ensuring that the queue is available before processing begins. This local emulation enables testing without incurring costs, as no actual Azure resources are provisioned.",multi_hop_specific_query_synthesizer
41,Whts the Meilisearch client intgration in .NET Aspire?,"['<1-hop>\n\ntitle: "" .NET Aspire docs: What\'s new for October 2024"" description: ""What\'s new in the .NET Aspire docs for October 2024."" ms.custom: October-2024 ms.date: 11/01/2024 .NET Aspire docs: What\'s new for October 2024 Welcome to what\'s new in the .NET Aspire docs for October 2024. This article lists some of the major changes to docs during this period. Get started Updated articles Orchestrate Node.js apps in .NET Aspire - Fix broken links Quickstart: Build your first .NET Aspire solution - Make it easier to onboard with VS Code. Fundamentals New articles Enable browser telemetry Updated articles .NET Aspire dashboard overview Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. .NET Aspire integrations overview Add Meilisearch integeration docs Using nuget.org links for', '<2-hop>\n\nConfiguration The .NET Aspire Meilisearch client integration provides multiple options to configure the server connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddMeilisearchClient: csharp builder.AddMeilisearchClient(""meilisearch""); Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""meilisearch"": ""Endpoint=http://localhost:19530/;MasterKey=123456!@#$%"" } } Use configuration providers The .NET Aspire Meilisearch Client integration supports json { ""Aspire"": { ""Meilisearch"": { ""Client"": { ""Endpoint"": ""http://localhost:19530/"", ""MasterKey"": ""123456!@#$%"" } } } } Use inline delegates Also you can pass the Action<MeilisearchClientSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddMeilisearchClient( ""meilisearch"", static settings => settings.MasterKey = ""123456!@#$%""); Client integration health checks The .NET Aspire Meilisearch integration uses the configured client to perform a IsHealthyAsync. If the result is true, the health check is considered healthy, otherwise it\'s unhealthy. Likewise, if there\'s an exception, the health check is considered unhealthy with the error propagating through the health check failure. See also Meilisearch Meilisearch Client .NET Aspire Community Toolkit GitHub repo']","The Meilisearch client integration in .NET Aspire provides multiple options to configure the server connection based on the requirements and conventions of your project. You can use a connection string from the ConnectionStrings configuration section, configuration providers, or inline delegates to set up the client. Additionally, the integration includes health checks to ensure the client is functioning properly.",multi_hop_specific_query_synthesizer
42,How can you configure the Azurite container to persist data and test the app locally using .NET Aspire?,"['<1-hop>\n\nAdd Azure Storage emulator resource To add an Azure Storage emulator resource, chain a call on an IResourceBuilder<AzureStorageResource> to the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"") .RunAsEmulator(); // After adding all resources, run the app... ``` When you call RunAsEmulator, it configures your storage resources to run locally using an emulator. The emulator in this case is Azurite. The Azurite open-source emulator provides a free local environment for testing your Azure Blob, Queue Storage, and Table Storage apps and it\'s a perfect companion to the .NET Aspire Azure hosting integration. Azurite isn\'t installed, instead, it\'s accessible to .NET Aspire as a container. When you add a container to the app host, as shown in the preceding example with the mcr.microsoft.com/azure-storage/azurite image, it creates and starts the container when the app host starts. For more information, see Container resource lifecycle. Configure Azurite container There are various configurations available to container resources, for example, you can configure the container\'s ports, environment variables, it\'s lifetime, and more. Configure Azurite container ports By default, the Azurite container when configured by .NET Aspire, exposes the following endpoints: Endpoint Container port Host port blob 10000 dynamic queue 10001 dynamic table 10002 dynamic The port that they\'re listening on is dynamic by default. When the container starts, the ports are mapped to a random port on the host machine. To configure the endpoint ports, chain calls on the container resource builder provided by the RunAsEmulator method as shown in the following example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithBlobPort(""blob"", 27000) .WithQueuePort(""queue"", 27001) .WithTablePort(""table"", 27002); }); // After adding all resources, run the app... ``` The preceding code configures the Azurite container\'s existing blob, queue, and table endpoints to listen on ports 27000, 27001, and 27002, respectively. The Azurite container\'s ports are mapped to the host ports as shown in the following table: Endpoint name Port mapping ( container:host ) blob 10000:27000 queue 10001:27001 table 10002:27002 Configure Azurite container with persistent lifetime To configure the Azurite container with a persistent lifetime, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithLifetime(ContainerLifetime.Persistent); }); // After adding all resources, run the app... ``` For more information, see Container resource lifetime. Configure Azurite container with data volume To add a data volume to the Azure Storage emulator resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithDataVolume(); }); // After adding all resources, run the app... ``` The data volume is used to persist the Azurite data outside the lifecycle of its container. The data volume is mounted at the /data path in the Azurite container and when a name parameter isn\'t provided, the name is formatted as .azurite/{resource name}. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Configure Azurite container with data bind mount To add a data bind mount to the Azure Storage emulator resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithDataBindMount(""../Azurite/Data""); }); // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Azurite data across container restarts. The data bind mount is mounted at the ../Azurite/Data path on the host machine relative to the app host directory ( Connect to storage resources When the .NET Aspire app host runs, the storage resources can be accessed by external tools, such as the Azure Storage Explorer. If your storage resource is running locally using Azurite, it will automatically be picked up by the Azure Storage Explorer. [!NOTE] The Azure Storage Explorer discovers Azurite storage resources assuming the default ports are used. If you\'ve configured the Azurite container to use different ports, you\'ll need to configure the Azure Storage Explorer to connect to the correct ports. To connect to the storage resource from Azure Storage Explorer, follow these steps: Run the .NET Aspire app host. Open the Azure Storage Explorer. View the Explorer pane. Select the Refresh all link to refresh the list of storage accounts. Expand the Emulator & Attached node. Expand the Storage Accounts node. You should see a storage account with your resource\'s name as a prefix: :::image type=""content"" source=""../media/azure-storage-explorer.png"" lightbox=""../media/azure-storage-explorer.png"" alt-text=""Azure Storage Explorer: Azurite storage resource discovered.""::: You\'re free to explore the storage account and its contents using the Azure Storage Explorer. For more information on using the Azure Storage Explorer, see Get started with Storage Explorer.', '<2-hop>\n\nRun and test the app locally The sample app is now ready for testing. Verify that the submitted form data is sent to Azure Blob Storage and Azure Queue Storage by completing the following steps: Visual Studio Press the run button at the top of Visual Studio to launch your .NET Aspire project dashboard in the browser. On the resources page, in the aspirestorage.web row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: .NET CLI In a terminal window at the root of your project, use the dotnet run command to start the app: dotnetcli dotnet run --project AspireStorage.AppHost On the resources page, in the aspirestorage row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: Summary The example app that you built demonstrates persisting blobs from an ASP.NET Core Blazor Web App and processing queues in a .NET Worker Service. Your app connects to Azure Storage using .NET Aspire integrations. The app sends the support tickets to a queue for processing and uploads an attachment to storage. :::zone pivot=""azurite"" Since you choose to use Azurite, there\'s no need to clean up these resources when you\'re done testing them, as you created them locally in the context of an emulator. The emulator enabled you to test your app locally without incurring any costs, as no Azure resources were provisioned or created. :::zone-end :::zone pivot=""azure-portal,azure-cli"" [!INCLUDE clean-up-resources] :::zone-end']","To configure the Azurite container to persist data, you can call the method `WithDataVolume()` when setting up the Azure Storage emulator resource. This mounts the data volume at the /data path in the Azurite container, allowing data to persist outside the lifecycle of the container. Additionally, to test the app locally, you can run the .NET Aspire project using Visual Studio or the .NET CLI. After running the app, you can submit sample data through the app's UI, which will send the data to Azure Blob Storage and Azure Queue Storage. You can verify the uploaded files in the Azure portal by navigating to the Storage browser and checking the Documents container.",multi_hop_specific_query_synthesizer
43,"What are the key features and integration steps for using Azure Blob Storage with .NET Aspire, and how does this integration ensure compliance and data protection?","['<1-hop>\n\nCommunity Toolkit packages Moving from Aspire.CommunityToolkit to CommunityToolkit.Aspire Moving package links to be Azure Artifacts not GitHub Packages Rewrite the non-Azure messaging integration articles Community Toolkit .NET Aspire orchestration overview - Rewrite the non-Azure messaging integration articles Dashboard configuration Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Enable browser telemetry minor text fixes Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Security considerations for running the .NET Aspire dashboard - Various dashboard and telemetry docs updates Standalone .NET Aspire dashboard - Various dashboard and telemetry docs updates Tutorial: Use the .NET Aspire dashboard with Python apps - Various dashboard and telemetry docs updates Storage Updated articles .NET Aspire Azure Blob Storage integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Data Tables integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Queue Storage integration - Rewrite the non-Azure messaging integration articles Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations - Rewrite the non-Azure messaging integration articles Database Updated articles .NET Aspire Azure Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Microsoft Entity Framework Core Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Milvus database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MongoDB database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MySQL database integration - Rewrite the non-Azure messaging integration articles .NET Aspire Oracle Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire Pomelo MySQL Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL Entity Framework Core integration Rewrite both PostgreSQL integration docs Update postgresql-entity-framework-integration.md Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL integration Rewrite both PostgreSQL integration docs Rewrite the non-Azure messaging integration articles .NET Aspire Qdrant integration - Rewrite the non-Azure messaging integration articles .NET Aspire SQL Server integration - Rewrite the non-Azure messaging integration articles .NET Aspire SqlServer Entity Framework Core integration - Rewrite the non-Azure messaging integration articles Messaging New articles .NET Aspire RabbitMQ integration Updated articles .NET Aspire Apache Kafka integration Fix Kafka integration documentation Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire Azure Event Hubs integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Service Bus integration Rewrite the non-Azure messaging integration articles Use correct method name in ServiceBus .NET Aspire Azure Web PubSub integration - Rewrite the non-Azure messaging integration articles .NET Aspire NATS integration Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire RabbitMQ integration Rewrite both PostgreSQL integration docs Redis rewrite Demote messaging integration headings Rewrite the non-Azure messaging integration articles Caching Updated articles .NET Aspire Redis distributed caching integration Updates to other Redis-protocol docs Rewrite the non-Azure messaging integration articles .NET Aspire Redis integration Updates to other Redis-protocol docs Redis rewrite Rewrite the non-Azure messaging integration articles .NET Aspire Redis output caching integration Updates to other Redis-protocol docs Rewrite the non-Azure messaging integration articles Stack Exchange Redis caching overview - Updates to other Redis-protocol docs Tutorial: Implement caching with .NET Aspire integrations - Rewrite the non-Azure messaging integration articles Security Updated articles .NET Aspire Azure Key Vault integration - Rewrite the non-Azure messaging integration articles Deployment Updated articles Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide) - Fix typo in aca-deployment-azd-in-depth.md Use Application Insights for .NET Aspire telemetry - Rewrite the non-Azure messaging integration articles Use custom Bicep templates - Rewrite the non-Azure messaging integration articles', '<2-hop>\n\ntitle: .NET Aspire Azure Blob Storage integration description: Learn how to use the .NET Aspire Azure Blob Storage integration, which includes both hosting and client integrations. ms.date: 12/09/2024 uid: storage/azure-blob-storage-integration .NET Aspire Azure Blob Storage integration [!INCLUDE includes-hosting-and-client] Azure Blob Storage is a service for storing large amounts of unstructured data. The .NET Aspire Azure Blob Storage integration enables you to connect to existing Azure Blob Storage instances or create new instances from .NET applications. Hosting integration [!INCLUDE storage-app-host] Add Azure Blob Storage resource In your app host project, register the Azure Blob Storage integration by chaining a call to ```csharp var builder = DistributedApplication.CreateBuilder(args); var blobs = builder.AddAzureStorage(""storage"") .RunAsEmulator(); .AddBlobs(""blobs""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Adds an Azure Storage resource named storage. Chains a call to Adds a blob container named blobs to the storage resource. Adds the blobs resource to the ExampleProject and waits for it to be ready before starting the project. [!INCLUDE storage-hosting-health-checks] Client integration To get started with the .NET Aspire Azure Blob Storage client integration, install the ðŸ“¦ Aspire.Azure.Storage.Blobs NuGet package in the client-consuming project, that is, the project for the application that uses the Azure Blob Storage client. The Azure Blob Storage client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Azure.Storage.Blobs PackageReference xml <PackageReference Include=""Aspire.Azure.Storage.Blobs"" Version=""*"" /> Add Azure Blob Storage client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureBlobClient(""blobs""); You can then retrieve the BlobServiceClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(BlobServiceClient client) { // Use client... } Configuration The .NET Aspire Azure Blob Storage integration provides multiple options to configure the BlobServiceClient based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddAzureBlobClient(""blobs""); Then the connection string is retrieved from the ConnectionStrings configuration section, and two connection formats are supported: Service URI The recommended approach is to use a ServiceUri, which works with the json { ""ConnectionStrings"": { ""blobs"": ""https://{account_name}.blob.core.windows.net/"" } } Connection string Alternatively, an Azure Storage connection string can be used. json { ""ConnectionStrings"": { ""blobs"": ""AccountName=myaccount;AccountKey=myaccountkey"" } } For more information, see Configure Azure Storage connection strings. Use configuration providers The .NET Aspire Azure Blob Storage integration supports json { ""Aspire"": { ""Azure"": { ""Storage"": { ""Blobs"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Diagnostics"": { ""ApplicationId"": ""myapp"" } } } } } } } For the complete Azure Blob Storage client integration JSON schema, see Aspire.Azure.Storage.Blobs/ConfigurationSchema.json. Use inline delegates You can also pass the Action<AzureStorageBlobsSettings> configureSettings delegate to set up some or all the options inline, for example to configure health checks: csharp builder.AddAzureBlobClient( ""blobs"", settings => settings.DisableHealthChecks = true); You can also set up the csharp builder.AddAzureBlobClient( ""blobs"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Diagnostics.ApplicationId = ""myapp"")); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Blob Storage integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","The .NET Aspire Azure Blob Storage integration provides a comprehensive solution for connecting to Azure Blob Storage, which is designed for storing large amounts of unstructured data. Key features include both hosting and client integrations, allowing developers to register Azure Blob Storage resources and utilize them within their applications. To get started, developers must add the Azure Blob Storage resource in their app host project by chaining a call to the builder, which registers the storage and blob container. For client integration, the Aspire.Azure.Storage.Blobs NuGet package must be installed, and the BlobServiceClient can be retrieved using dependency injection. Additionally, the integration supports various configuration options, including the use of connection strings and inline delegates for setting up health checks. This ensures that the application adheres to compliance and data protection standards by enabling health checks for all services, which are integrated with the /health HTTP endpoint, ensuring that the application is ready to accept traffic only when all health checks pass.",multi_hop_specific_query_synthesizer
44,"What health checks are automatically added for the NATS and SQL Server resources in the .NET Aspire integrations, and how do they ensure the services are running?","['<1-hop>\n\ntitle: .NET Aspire NATS integration description: Learn how to use the .NET Aspire NATS integration to send logs and traces to a NATS Server. ms.date: 10/11/2024 uid: messaging/nats-integration .NET Aspire NATS integration [!INCLUDE includes-hosting-and-client] NATS is a high-performance, secure, distributed messaging system. The .NET Aspire NATS integration enables you to connect to existing NATS instances, or create new instances from .NET with the docker.io/library/nats container image. Hosting integration NATS hosting integration for .NET Aspire models a NATS server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Nats PackageReference xml <PackageReference Include=""Aspire.Hosting.Nats"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add NATS server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/nats image, it creates a new NATS server instance on your local machine. A reference to your NATS server (the nats variable) is added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing NATS server, call Add NATS server resource with JetStream To add the NATS JetStream to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithJetStream(); builder.AddProject // After adding all resources, run the app... ``` The NATS JetStream functionality provides a built-in persistence engine called JetStream which enables messages to be stored and replayed at a later time. You can optionally provide a srcMountPath parameter to specify the path to the JetStream data directory on the host machine (the provided mount path maps to the container\'s -sd argument). Add NATS server resource with data volume To add a data volume to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the NATS server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/nats path in the NATS server container. A name is generated at random unless you provide a set the name parameter. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add NATS server resource with data bind mount To add a data bind mount to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataBindMount( source: @""C:\\NATS\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the NATS server data across container restarts. The data bind mount is mounted at the C:\\NATS\\Data on Windows (or /NATS/Data on Unix) path on the host machine in the NATS server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The NATS hosting integration automatically adds a health check for the NATS server resource. The health check verifies that the NATS server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Nats NuGet package.', '<2-hop>\n\ntitle: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","The .NET Aspire integrations automatically add health checks for both the NATS and SQL Server resources. For the NATS server resource, the health check verifies that the NATS server is running and that a connection can be established to it, relying on the AspNetCore.HealthChecks.Nats NuGet package. Similarly, the SQL Server hosting integration adds a health check that ensures the SQL Server is operational and that a connection can be established, utilizing the AspNetCore.HealthChecks.SqlServer NuGet package. These health checks are crucial for confirming that the respective services are ready to accept traffic.",multi_hop_specific_query_synthesizer
45,How do you add a RabbitMQ server resource using the docker.io/library/rabbitmq image and also add a MongoDB server resource using the docker.io/library/mongo image in your .NET application?,"['<1-hop>\n\nHosting integration The RabbitMQ hosting integration models a RabbitMQ server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.RabbitMQ PackageReference xml <PackageReference Include=""Aspire.Hosting.RabbitMQ"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add RabbitMQ server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/rabbitmq image, it creates a new RabbitMQ server instance on your local machine. A reference to your RabbitMQ server (the rabbitmq variable) is added to the ExampleProject. The RabbitMQ server resource includes default credentials with a username of ""guest"" and randomly generated password using the The [!TIP] If you\'d rather connect to an existing RabbitMQ server, call Add RabbitMQ server resource with management plugin To add the RabbitMQ management plugin to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithManagementPlugin(); builder.AddProject // After adding all resources, run the app... ``` The RabbitMQ management plugin provides an HTTP-based API for management and monitoring of your RabbitMQ server. .NET Aspire adds another container image docker.io/library/rabbitmq-management to the app host that runs the management plugin. Add RabbitMQ server resource with data volume To add a data volume to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the RabbitMQ server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/rabbitmq path in the RabbitMQ server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add RabbitMQ server resource with data bind mount To add a data bind mount to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataBindMount( source: @""C:\\RabbitMQ\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the RabbitMQ server data across container restarts. The data bind mount is mounted at the C:\\RabbitMQ\\Data on Windows (or /RabbitMQ/Data on Unix) path on the host machine in the RabbitMQ server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add RabbitMQ server resource with parameters When you want to explicitly provide the username and password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username"", secret: true); var password = builder.AddParameter(""password"", secret: true); var rabbitmq = builder.AddRabbitMQ(""messaging"", username, password); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Hosting integration health checks The RabbitMQ hosting integration automatically adds a health check for the RabbitMQ server resource. The health check verifies that the RabbitMQ server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Rabbitmq NuGet package.', '<2-hop>\n\nAdd MongoDB server resource and database resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithLifetime(ContainerLifetime.Persistent); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The MongoDB container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/mongo image, it creates a new MongoDB instance on your local machine. A reference to your MongoDB server resource builder (the mongo variable) is used to add a database. The database is named mongodb and then added to the ExampleProject. The MongoDB server resource includes default credentials: MONGO_INITDB_ROOT_USERNAME: A value of admin. MONGO_INITDB_ROOT_PASSWORD: Random password generated using the When the app host runs, the password is stored in the app host\'s secret store. It\'s added to the Parameters section, for example: json { ""Parameters:mongo-password"": ""<THE_GENERATED_PASSWORD>"" } The name of the parameter is mongo-password, but really it\'s just formatting the resource name with a -password suffix. For more information, see Safe storage of app secrets in development in ASP.NET Core and Add MongoDB server resource with parameters. The [!TIP] If you\'d rather connect to an existing MongoDB server, call Add MongoDB server resource with data volume To add a data volume to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithDataVolume(); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the MongoDB server data outside the lifecycle of its container. The data volume is mounted at the /data/db path in the MongoDB server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add MongoDB server resource with data bind mount To add a data bind mount to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithDataBindMount(@""C:\\MongoDB\\Data""); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the MongoDB server data across container restarts. The data bind mount is mounted at the C:\\MongoDB\\Data on Windows (or /MongoDB/Data on Unix) path on the host machine in the MongoDB server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add MongoDB server resource with initialization data bind mount To add an initialization folder data bind mount to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithInitBindMount(@""C:\\MongoDB\\Init""); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` The initialization data bind mount is used to initialize the MongoDB server with data. The initialization data bind mount is mounted at the C:\\MongoDB\\Init on Windows (or /MongoDB/Init on Unix) path on the host machine in the MongoDB server container and maps to the /docker-entrypoint-initdb.d path in the MongoDB server container. MongoDB executes the scripts found in this folder, which is useful for loading data into the database. Add MongoDB server resource with parameters When you want to explicitly provide the password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username""); var password = builder.AddParameter(""password"", secret: true); var mongo = builder.AddMongoDB(""mongo"", username, password); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Add MongoDB Express resource MongoDB Express is a web-based MongoDB admin user interface. To add a MongoDB Express resource that corresponds to the docker.io/library/mongo-express container image, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithMongoExpress(); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!TIP] To configure the host port for the The preceding code adds a MongoDB Express resource that is configured to connect to the MongoDB server resource. The default credentials are: ME_CONFIG_MONGODB_SERVER: The name assigned to the parent MongoDBServerResource, in this case it would be mongo. ME_CONFIG_BASICAUTH: A value of false. ME_CONFIG_MONGODB_PORT: Assigned from the primary endpoint\'s target port of the parent MongoDBServerResource. ME_CONFIG_MONGODB_ADMINUSERNAME: The same username as configured in the parent MongoDBServerResource. ME_CONFIG_MONGODB_ADMINPASSWORD: The same password as configured in the parent MongoDBServerResource. Additionally, the WithMongoExpress API exposes an optional configureContainer parameter of type Action<IResourceBuilder<MongoExpressContainerResource>> that you use to configure the MongoDB Express container resource. Hosting integration health checks The MongoDB hosting integration automatically adds a health check for the MongoDB server resource. The health check verifies that the MongoDB server resource is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.MongoDb NuGet package.']","To add a RabbitMQ server resource using the docker.io/library/rabbitmq image in your .NET application, you can call the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging""); builder.AddProject // After adding all resources, run the app... ``` This creates a new RabbitMQ server instance on your local machine. For adding a MongoDB server resource using the docker.io/library/mongo image, you would use the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithLifetime(ContainerLifetime.Persistent); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` This creates a new MongoDB instance on your local machine.",multi_hop_specific_query_synthesizer
46,What are the key differences in the integration features of Aspire.Azure.Messaging.ServiceBus and Aspire.Azure.Messaging.EventHubs?,"['<1-hop>\n\ntitle: .NET Aspire Azure Event Hubs integration description: This article describes the .NET Aspire Azure Event Hubs integration features and capabilities. ms.topic: how-to ms.date: 08/26/2024 .NET Aspire Azure Event Hubs integration In this article, you learn how to use the .NET Aspire Azure Event Hubs integration. The Aspire.Azure.Messaging.EventHubs library offers options for registering the following types: These type are registered in the DI container for connecting to Azure Event Hubs. Prerequisites Azure subscription: create one for free. Azure Event Hubs namespace: for more information, see add an Event Hubs namespace. Alternatively, you can use a connection string, which isn\'t recommended in production environments. Get started To get started with the .NET Aspire Azure Event Hubs integration, install the ðŸ“¦ Aspire.Azure.Messaging.EventHubs NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Event Hubs client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.EventHubs PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.EventHubs"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Supported clients with options classes The following clients are supported by the library, along with their corresponding options and settings classes: Azure Client type Azure Options class .NET Aspire Settings class EventHubProducerClient EventHubProducerClientOptions AzureMessagingEventHubsProducerSettings EventHubBufferedProducerClient EventHubBufferedProducerClientOptions AzureMessagingEventHubsBufferedProducerSettings EventHubConsumerClient EventHubConsumerClientOptions AzureMessagingEventHubsConsumerSettings EventProcessorClient EventProcessorClientOptions AzureMessagingEventHubsProcessorSettings PartitionReceiver PartitionReceiverOptions AzureMessagingEventHubsPartitionReceiverSettings The client type are from the Azure SDK for .NET, as are the corresponding options classes. The settings classes are provided by the .NET Aspire Azure Event Hubs integration library.', '<2-hop>\n\ntitle: .NET Aspire Azure Service Bus integration description: This article describes the .NET Aspire Azure Service Bus integration features and capabilities ms.topic: how-to ms.date: 08/12/2024 .NET Aspire Azure Service Bus integration Cloud-native apps often require communication with messaging services such as Azure Service Bus. Messaging services help decouple applications and enable scenarios that rely on features such as queues, topics and subscriptions, atomic transactions, load balancing, and more. The .NET Aspire Service Bus integration handles the following concerns to connect your app to Azure Service Bus: A Applies ServiceBusClient configurations either inline through code or through configuration file settings. Prerequisites Azure subscription - create one for free Azure Service Bus namespace, learn more about how to add a Service Bus namespace. Alternatively, you can use a connection string, which is not recommended in production environments. Get started To get started with the .NET Aspire Azure Service Bus integration, install the ðŸ“¦ Aspire.Azure.Messaging.ServiceBus NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Service Bus client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.ServiceBus"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Example usage In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureServiceBusClient(""messaging""); To retrieve the configured csharp public class ExampleService(ServiceBusClient client) { // ... } App host usage To add Azure Service Bus hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.ServiceBus"" Version=""*"" /> In your app host project, register the Service Bus integration and consume the service using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var serviceBus = builder.ExecutionContext.IsPublishMode ? builder.AddAzureServiceBus(""messaging"") : builder.AddConnectionString(""messaging""); builder.AddProject Configuration The .NET Aspire Service Bus integration provides multiple options to configure the ServiceBusClient based on the requirements and conventions of your project. Use configuration providers The Service Bus integration supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""ServiceBus"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Identifier"": ""CLIENT_ID"" } } } } } } If you have set up your configurations in the Aspire:Azure:Messaging:ServiceBus section of your :::no-loc text=""appsettings.json""::: file you can just call the method AddAzureServiceBusClient without passing any parameters. Use inline delegates You can also pass the Action<AzureMessagingServiceBusSettings> delegate to set up some or all the options inline, for example to set the FullyQualifiedNamespace: csharp builder.AddAzureServiceBusClient( ""messaging"", static settings => settings.FullyQualifiedNamespace = ""YOUR_SERVICE_BUS_NAMESPACE""); You can also set up the ServiceBusClientOptions using Action<IAzureClientBuilder<ServiceBusClient, ServiceBusClientOptions>> delegate, the second parameter of the AddAzureServiceBus method. For example to set the ServiceBusClient ID to identify the client: csharp builder.AddAzureServiceBusClient( ""messaging"", static clientBuilder => clientBuilder.ConfigureOptions( static options => options.Identifier = ""CLIENT_ID"")); Configuration options The following configurable options are exposed through the Name Description ConnectionString The connection string used to connect to the Service Bus namespace. Credential The credential used to authenticate to the Service Bus namespace. FullyQualifiedNamespace The fully qualified Service Bus namespace. DisableTracing Disables tracing for the Service Bus client. â€  HealthCheckQueueName The name of the queue used for health checks. â€  HealthCheckTopicName The name of the topic used for health checks. â€  At least one of the name options are mandatory when enabling health checks. [!INCLUDE integration-observability-and-telemetry]']","The key differences in the integration features of Aspire.Azure.Messaging.ServiceBus and Aspire.Azure.Messaging.EventHubs lie in their functionalities and use cases. The .NET Aspire Azure Service Bus integration focuses on messaging services that help decouple applications and support features such as queues, topics, and subscriptions, which are essential for cloud-native applications. In contrast, the .NET Aspire Azure Event Hubs integration is designed for high-throughput data streaming and event ingestion, allowing for the registration of various client types and their corresponding options for connecting to Azure Event Hubs. Both integrations require an Azure subscription and provide NuGet packages for installation, but they cater to different messaging and event processing needs.",multi_hop_specific_query_synthesizer
47,"How do you create a custom .NET Aspire client integration using MailKit, and what are the benefits of using MailKit over the official .NET SmtpClient?","['<1-hop>\n\nrunning, navigate to the Swagger UI at https://localhost:7251/swagger and test the /subscribe and /unsubscribe endpoints. Select the down arrow to expand the endpoint: :::image type=""content"" source=""./media/swagger-ui.png"" lightbox=""./media/swagger-ui.png"" alt-text=""Swagger UI: Subscribe endpoint.""::: Then select the Try it out button. Enter an email address, and then select the Execute button. :::image type=""content"" source=""./media/swagger-ui-try.png"" lightbox=""./media/swagger-ui-try.png"" alt-text=""Swagger UI: Subscribe endpoint with email address.""::: Repeat this several times, to add multiple email addresses. You should see the email sent to the MailDev inbox: :::image type=""content"" source=""./media/maildev-inbox.png"" alt-text=""MailDev inbox with multiple emails.""::: Stop the application by selecting Ctrl+C in the terminal window where the application is running, or by selecting the stop button in your IDE. View MailKit telemetry The MailKit client library exposes telemetry that can be viewed in the .NET Aspire dashboard. To view the telemetry, navigate to the .NET Aspire dashboard at https://localhost:7251. Select the newsletter resource to view the telemetry on the Metrics page: :::image type=""content"" source=""./media/mailkit-metrics-dashboard.png"" lightbox=""./media/mailkit-metrics-dashboard.png"" alt-text="".NET Aspire dashboard: MailKit telemetry.""::: Open up the Swagger UI again, and make some requests to the /subscribe and /unsubscribe endpoints. Then, navigate back to the .NET Aspire dashboard and select the newsletter resource. Select a metric under the mailkit.net.smtp node, such as mailkit.net.smtp.client.operation.count. You should see the telemetry for the MailKit client: :::image type=""content"" source=""./media/mailkit-metrics-graph-dashboard.png"" lightbox=""./media/mailkit-metrics-graph-dashboard.png"" alt-text="".NET Aspire dashboard: MailKit telemetry for operation count.""::: Summary In this article, you learned how to create a .NET Aspire integration that uses MailKit to send emails. You also learned how to integrate this integration into the Newsletter app you previously built. You learned about the core principles of .NET Aspire integrations, such as exposing the underlying client library to consumers through dependency injection, and how to add health checks and telemetry to the integration. You also learned how to update the Newsletter service to use the MailKit client. Go forth and build your own .NET Aspire integrations. If you believe that there\'s enough community value in the integration you\'re building, consider publishing it as a NuGet package for others to use. Furthermore, consider submitting a pull request to the .NET Aspire GitHub repository for consideration to be included in the official .NET Aspire integrations. Next steps [!div class=""nextstepaction""] Secure communication between hosting and client integrations', '<2-hop>\n\ntitle: Create custom .NET Aspire client integrations description: Learn how to create a custom .NET Aspire client integration for an existing containerized application. ms.date: 09/12/2024 ms.topic: how-to Create custom .NET Aspire client integrations This article is a continuation of the Create custom .NET Aspire hosting integrations article. It guides you through creating a .NET Aspire client integration that uses MailKit to send emails. This integration is then added into the Newsletter app you previously built. The previous example omitted the creation of a client integration and instead relied on the existing .NET SmtpClient. It\'s best to use MailKit\'s SmtpClient over the official .NET SmtpClient for sending emails, as it\'s more modern and supports more features/protocols. For more information, see .NET SmtpClient: Remarks. Prerequisites If you\'re following along, you should have a Newsletter app from the steps in the Create custom .NET Aspire hosting integration article. [!TIP] This article is inspired by existing .NET Aspire integrations, and based on the team\'s official guidance. There are places where said guidance varies, and it\'s important to understand the reasoning behind the differences. For more information, see .NET Aspire integration requirements. Create library for integration .NET Aspire integrations are delivered as NuGet packages, but in this example, it\'s beyond the scope of this article to publish a NuGet package. Instead, you create a class library project that contains the integration and reference it as a project. .NET Aspire integration packages are intended to wrap a client library, such as MailKit, and provide production-ready telemetry, health checks, configurability, and testability. Let\'s start by creating a new class library project. Create a new class library project named MailKit.Client in the same directory as the MailDevResource.sln from the previous article. dotnetcli dotnet new classlib -o MailKit.Client Add the project to the solution. dotnetcli dotnet sln ./MailDevResource.sln add MailKit.Client/MailKit.Client.csproj The next step is to add all the NuGet packages that the integration relies on. Rather than having you add each package one-by-one from the .NET CLI, it\'s likely easier to copy and paste the following XML into the MailKit.Client.csproj file. :::code language=""xml"" source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKit.Client.csproj"" range=""9-16""::: Define integration settings Whenever you\'re creating a .NET Aspire integration, it\'s best to understand the client library that you\'re mapping to. With MailKit, you need to understand the configuration settings that are required to connect to a Simple Mail Transfer Protocol (SMTP) server. But it\'s also important to understand if the library has support for health checks, tracing and metrics. MailKit supports tracing and metrics, through its Telemetry.SmtpClient class. When adding health checks, you should use any established or existing health checks where possible. Otherwise, you might consider implementing your own in the integration. Add the following code to the MailKit.Client project in a file named MailKitClientSettings.cs: :::code source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKitClientSettings.cs""::: The preceding code defines the MailKitClientSettings class with: Endpoint property that represents the connection string to the SMTP server. DisableHealthChecks property that determines whether health checks are enabled. DisableTracing property that determines whether tracing is enabled. DisableMetrics property that determines whether metrics are enabled. Parse connection string logic The settings class also contains a ParseConnectionString method that parses the connection string into a valid Uri. The configuration is expected to be provided in the following format: ConnectionStrings:<connectionName>: The connection string to the SMTP server. MailKit:Client:ConnectionString: The connection string to the SMTP server. If neither of these values are provided, an exception is thrown.']","To create a custom .NET Aspire client integration using MailKit, you start by creating a class library project named MailKit.Client and adding it to your existing solution. You then need to add the necessary NuGet packages that the integration relies on. It's important to understand the configuration settings required to connect to an SMTP server, as well as the support for health checks, tracing, and metrics that MailKit provides through its Telemetry.SmtpClient class. The benefits of using MailKit over the official .NET SmtpClient include its modern features and support for more protocols, making it a better choice for sending emails in .NET Aspire integrations.",multi_hop_specific_query_synthesizer
48,"What actions can be performed on resources built using Minimal APIs in the .NET Aspire dashboard, and how does the dashboard handle authentication for these resources?","['<1-hop>\n\nResources page The Resources page is the default home page of the .NET Aspire dashboard. This page lists all of the .NET projects, containers, and executables included in your .NET Aspire solution. For example, the starter application includes two projects: apiservice: A back-end API project built using Minimal APIs. webfrontend: The front-end UI project built using Blazor. The dashboard also provides essential details about each resource: Type: Displays whether the resource is a project, container, or executable. Name: The name of the resource. State: Displays whether or not the resource is currently running. Errors: Within the State column, errors are displayed as a badge with the error count. It\'s useful to understand quickly what resources are reporting errors. Selecting the badge takes you to the semantic logs for that resource with the filter at an error level. Start time: When the resource started running. Source: The location of the resource on the device. Endpoints: One or more URLs to reach the running resource directly. Logs: A link to the resource logs page. Actions: A set of actions that can be performed on the resource: Stop / Start: Stop (or Start) the resourceâ€”depending on the current State. Console logs: Navigate to the resource\'s console logs. Ellipsis: A submenu with extra resource specific actions: View details: View the resource details. Console log: Navigate to the resource\'s console logs. Structured logs: Navigate to the resource\'s structured logs. Traces: Navigate to the resource\'s traces. Metrics: Navigate to the resource\'s metrics. Restart: Stop and then start the resource. Consider the following screenshot of the resources page: :::image type=""content"" source=""media/explore/projects.png"" lightbox=""media/explore/projects.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page.""::: Resource actions Each resource has a set of available actions that are conditionally enabled based on the resource\'s current state. For example, if a resource is running, the Stop action is enabled. If the resource is stopped, the Start action is enabled. Likewise, some actions are disabled when they\'re unavailable, for example, some resources don\'t have structured logs. In these situations, the Structured logs action is disabled. Stop or Start a resource The .NET Aspire dashboard allows you to stop or start a resource by selecting the Stop or Start button in the Actions column. Consider the following screenshot of the resources page with the Stop button selected: :::image type=""content"" source=""media/explore/resource-stop-action.png"" lightbox=""media/explore/resource-stop-action.png"" alt-text="".NET Aspire dashboard stop resource.""::: When you select Stop, the resource stops running, and the State column updates to reflect the change. [!NOTE] For project resources, when the debugger is attached, it\'s reattached on restart. The Start button is then enabled, allowing you to start the resource again. Additionally, the dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-stopped-action.png"" lightbox=""media/explore/resource-stopped-action.png"" alt-text="".NET Aspire dashboard resource stopped.""::: When a resource is in a non-running state, the Start button is enabled. Selecting Start starts the resource, and the State column updates to reflect the change. The Stop button is then enabled, allowing you to stop the resource again. The dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-started-action.png"" lightbox=""media/explore/resource-started-action.png"" alt-text="".NET Aspire dashboard started resource.""::: [!TIP] Resources that depend on other resources that are stopped, or restarted, might experience temporary errors. This is expected behavior and is typically resolved when the dependent resources are in a Running state once again. Resource submenu actions Selecting the horizontal ellipsis icon in the Actions column opens a submenu with additional resource-specific actions. In addition to the built-in resource submenu actions, you can also define custom resource actions by defining custom commands. For more information, see Custom resource commands in .NET Aspire. For the built-in resource submenu actions, consider the following screenshot: :::image type=""content"" source=""media/explore/resource-actions.png"" lightbox=""media/explore/resource-actions.png"" alt-text="".NET Aspire dashboard resource submenu actions.""::: The following submenu actions are available: View details: View the resource details. Console log: Navigate to the resource\'s console logs. Structured logs: Navigate to the resource\'s structured logs. Traces: Navigate to the resource\'s traces. Metrics: Navigate to the resource\'s metrics. Restart: Stop and then start the resource. [!IMPORTANT] There might be resources with disabled submenu actions. They\'re greyed out when they\'re disabled. For example, the following screenshot shows the submenu actions disabled: :::image type=""content"" source=""media/explore/resource-submenu-actions.png"" lightbox=""media/explore/resource-submenu-actions.png"" border=""true"" alt-text="".NET Aspire dashboard disabled submenu actions.""::: Copy or Open in text visualizer To view a text visualizer of certain columns, on hover you see a vertical ellipsis icon. Select the icon to display the available options: Copy to clipboard Open in text visualizer Consider the following screenshot of the ellipsis menu options: :::image type=""content"" source=""media/explore/text-visualizer-selection-menu.png"" lightbox=""media/explore/text-visualizer-selection-menu.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing the ellipsis menu options.""::: When you select the Open in text visualizer option, a modal dialog opens with the text displayed in a larger format. Consider the following screenshot of the text visualizer modal dialog: :::image type=""content"" source=""media/explore/text-visualizer-resources.png"" lightbox=""media/explore/text-visualizer-resources.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing the text visualizer.""::: Some values are formatted as JSON or XML. In these cases, the text visualizer enables the Select format dropdown to switch between the different formats. Resource details You can obtain full details about each resource by selecting the ellipsis button in the Actions column and then selecting View details. The Details page provides a comprehensive view of the resource: :::image type=""content"" source=""media/explore/resource-details.png"" lightbox=""media/explore/resource-details.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page with the details of a selected resource displayed.""::: The search bar in the upper right of the dashboard also provides the option to filter the list, which is useful for .NET Aspire projects with many resources. To select the types of resources that are displayed, drop down the arrow to the left of the filter textbox: :::image type=""content"" source=""media/explore/select-resource-type.png"" alt-text=""A screenshot of the resource type selector list in the .NET Aspire dashboard Resources page.""::: In this example, only containers are displayed in the list. For example, if you enable Use Redis for caching when creating a .NET Aspire project, you should see a Redis container listed: :::image type=""content"" source=""media/explore/resources-filtered-containers.png"" lightbox=""media/explore/resources-filtered-containers.png"" alt-text=""A screenshot of', '<2-hop>\n\nTheme selection. Dashboard authentication When you run a .NET Aspire app host, the orchestrator starts up all the app\'s dependent resources and then opens a browser window to the dashboard. The .NET Aspire dashboard requires token-based authentication for its users because it displays environment variables and other sensitive information. When the dashboard is launched from Visual Studio or Visual Studio Code (with the C# Dev Kit extension), the browser is automatically logged in, and the dashboard opens directly. This is the typical developer F5 experience, and the authentication login flow is automated by the .NET Aspire tooling. However, if you start the app host from the command line, you\'re presented with the login page. The console window displays a URL that you can select on to open the dashboard in your browser. :::image type=""content"" source=""media/explore/dotnet-run-login-url.png"" lightbox=""media/explore/dotnet-run-login-url.png"" alt-text="".NET CLI run command output, showing the login URL with token query string.""::: The URL contains a token query string (with the token value mapped to the t name part) that\'s used to log in to the dashboard. If your console supports it, you can hold the Ctrl key and then select the link to open the dashboard in your browser. This method is easier than copying the token from the console and pasting it into the login page. If you end up on the dashboard login page without either of the previously described methods, you can always return to the console to copy the token. :::image type=""content"" source=""media/explore/aspire-login.png"" lightbox=""media/explore/aspire-login.png"" alt-text="".NET Aspire dashboard login page.""::: The login page accepts a token and provides helpful instructions on how to obtain the token, as shown in the following screenshot: :::image type=""content"" source=""media/explore/aspire-login-help.png"" lightbox=""media/explore/aspire-login-help.png"" alt-text="".NET Aspire dashboard login page with instructions on how to obtain the token.""::: After copying the token from the console and pasting it into the login page, select the Log in button. :::image type=""content"" source=""media/explore/aspire-login-filled.png"" lightbox=""media/explore/aspire-login-filled.png"" alt-text="".NET Aspire dashboard login page with the token pasted into the textbox.""::: The dashboard persists the token as a browser persistent cookie, which remains valid for three days. Persistent cookies have an expiration date and remain valid even after closing the browser. This means that users don\'t need to log in again if they close and reopen the browser. For more information, see the Security considerations for running the .NET Aspire dashboard documentation. Resources page The Resources page is the default home page of the .NET Aspire dashboard. This page lists all of the .NET projects, containers, and executables included in your .NET Aspire solution. For example, the starter application includes two projects: apiservice: A back-end API project built using Minimal APIs. webfrontend: The front-end UI project built using Blazor. The dashboard also provides essential details about each resource: Type: Displays whether the resource is a project, container, or executable. Name: The name of the resource. State: Displays whether or not the resource is currently running. Errors: Within the State column, errors are displayed as a badge with the error count. It\'s useful to understand quickly what resources are reporting errors. Selecting the badge takes you to the semantic logs for that resource with the filter at an error level. Start time: When the resource started running. Source: The location of the resource on the device. Endpoints: One or more URLs to reach the running resource directly. Logs: A link to the resource logs page. Actions: A set of actions that can be performed on the resource: Stop / Start: Stop (or Start) the resourceâ€”depending on the current State. Console logs: Navigate to the resource\'s console logs. Ellipsis: A submenu with extra resource specific actions: View details: View the resource details. Console log: Navigate to the resource\'s console logs. Structured logs: Navigate to the resource\'s structured logs. Traces: Navigate to the resource\'s traces. Metrics: Navigate to the resource\'s metrics. Restart: Stop and then start the resource. Consider the following screenshot of the resources page: :::image type=""content"" source=""media/explore/projects.png"" lightbox=""media/explore/projects.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page.""::: Resource actions Each resource has a set of available actions that are conditionally enabled based on the resource\'s current state. For example, if a resource is running, the Stop action is enabled. If the resource is stopped, the Start action is enabled. Likewise, some actions are disabled when they\'re unavailable, for example, some resources don\'t have structured logs. In these situations, the Structured logs action is disabled. Stop or Start a resource The .NET Aspire dashboard allows you to stop or start a resource by selecting the Stop or Start button in the Actions column. Consider the following screenshot of the resources page with the Stop button selected: :::image type=""content"" source=""media/explore/resource-stop-action.png"" lightbox=""media/explore/resource-stop-action.png"" alt-text="".NET Aspire dashboard stop resource.""::: When you select Stop, the resource stops running, and the State column updates to reflect the change. [!NOTE] For project resources, when the debugger is attached, it\'s reattached on restart. The Start button is then enabled, allowing you to start the resource again. Additionally, the dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-stopped-action.png"" lightbox=""media/explore/resource-stopped-action.png"" alt-text="".NET Aspire dashboard resource stopped.""::: When a resource is in a non-running state, the Start button is enabled. Selecting Start starts the resource, and the State column updates to reflect the change. The Stop button is then enabled, allowing you to stop the resource again. The dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-started-action.png"" lightbox=""media/explore/resource-started-action.png"" alt-text="".NET Aspire dashboard started resource.""::: [!TIP] Resources that depend on other resources that are stopped, or restarted, might experience temporary errors. This is expected behavior and is typically resolved when the dependent resources are in a Running state once again. Resource submenu actions Selecting the horizontal ellipsis icon in the Actions column opens a submenu with additional resource-specific actions. In addition to the built-in resource submenu actions, you can also define custom resource actions by defining custom commands. For more information, see Custom resource commands in .NET Aspire. For the built-in resource submenu actions, consider the following screenshot: :::image type=""content"" source=""media/explore/resource-actions.png"" lightbox=""media/explore/resource-actions.png""']","In the .NET Aspire dashboard, resources built using Minimal APIs can have several actions performed on them, such as stopping or starting the resource, navigating to console logs, and accessing structured logs. The dashboard provides a set of actions that are conditionally enabled based on the resource's current state. For example, if a resource is running, the Stop action is enabled, and if it is stopped, the Start action is enabled. Additionally, users can view details, navigate to traces, metrics, and restart the resource. Regarding authentication, the .NET Aspire dashboard requires token-based authentication for its users, which is automatically handled when the dashboard is launched from Visual Studio or Visual Studio Code. If started from the command line, users must log in using a token provided in the console output.",multi_hop_specific_query_synthesizer
49,What are the differences in container management commands between Docker and Podman when using the Ollama integration in .NET Aspire?,"['<1-hop>\n\nBuilt-in resource types .NET Aspire projects are made up of a set of resources. The primary base resource types in the ðŸ“¦ Aspire.Hosting.AppHost NuGet package are described in the following table: Method Resource type Description A .NET project, for example, an ASP.NET Core web app. A container image, such as a Docker image. An executable file, such as a Node.js app . A parameter resource that can be used to express external parameters . Project resources represent .NET projects that are part of the app model. When you add a project reference to the app host project, the .NET Aspire SDK generates a type in the Projects namespace for each referenced project. For more information, see .NET Aspire SDK: Project references. To add a project to the app model, use the ```csharp var builder = DistributedApplication.CreateBuilder(args); // Adds the project ""apiservice"" of type ""Projects.AspireApp_ApiService"". var apiservice = builder.AddProject Projects can be replicated and scaled out by adding multiple instances of the same project to the app model. To configure replicas, use the ```csharp var builder = DistributedApplication.CreateBuilder(args); // Adds the project ""apiservice"" of type ""Projects.AspireApp_ApiService"". var apiservice = builder.AddProject The preceding code adds three replicas of the ""apiservice"" project resource to the app model. For more information, see .NET Aspire dashboard: Resource replicas. Reference resources A reference represents a dependency between resources. For example, you can probably imagine a scenario where you a web frontend depends on a Redis cache. Consider the following example app host Program C# code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); builder.AddProject The ""webfrontend"" project resource uses Waiting for resources In some cases, you might want to wait for a resource to be ready before starting another resource. For example, you might want to wait for a database to be ready before starting an API that depends on it. To express this dependency, use the ```csharp var builder = DistributedApplication.CreateBuilder(args); var postgres = builder.AddPostgres(""postgres""); var postgresdb = postgres.AddDatabase(""postgresdb""); builder.AddProject In the preceding code, the ""apiservice"" project resource waits for the ""postgresdb"" database resource to enter the Other cases might warrant waiting for a resource to run to completion, either ```csharp var builder = DistributedApplication.CreateBuilder(args); var postgres = builder.AddPostgres(""postgres""); var postgresdb = postgres.AddDatabase(""postgresdb""); var migration = builder.AddProject builder.AddProject In the preceding code, the ""apiservice"" project resource waits for the ""migration"" project resource to run to completion before starting. The ""migration"" project resource waits for the ""postgresdb"" database resource to enter the APIs for adding and expressing resources .NET Aspire hosting integrations and client integrations are both delivered as NuGet packages, but they serve different purposes. While client integrations provide client library configuration for consuming apps outside the scope of the app host, hosting integrations provide APIs for expressing resources and dependencies within the app host. For more information, see .NET Aspire integrations overview: Integration responsibilities. Express container resources To express a Docker ```csharp var builder = DistributedApplication.CreateBuilder(args); var ollama = builder.AddContainer(""ollama"", ""ollama/ollama"") .WithBindMount(""ollama"", ""/root/.ollama"") .WithBindMount(""./ollamaconfig"", ""/usr/config"") .WithHttpEndpoint(port: 11434, targetPort: 11434, name: ""ollama"") .WithEntrypoint(""/usr/config/entrypoint.sh"") .WithContainerRuntimeArgs(""--gpus=all""); ``` For more information, see GPU support in Docker Desktop. Podman ```csharp var builder = DistributedApplication.CreateBuilder(args); var ollama = builder.AddContainer(""ollama"", ""ollama/ollama"") .WithBindMount(""ollama"", ""/root/.ollama"") .WithBindMount(""./ollamaconfig"", ""/usr/config"") .WithHttpEndpoint(port: 11434, targetPort: 11434, name: ""ollama"") .WithEntrypoint(""/usr/config/entrypoint.sh"") .WithContainerRuntimeArgs(""--device"", ""nvidia.com/gpu=all""); ``` For more information, see GPU support in Podman. The preceding code adds a container resource named ""ollama"" with the image ollama/ollama. The container resource is configured with multiple bind mounts, a named HTTP endpoint, an entrypoint that resolves to Unix shell script, and container run arguments with the Customize container resources All To help exemplify this, imagine a scenario where you\'re using the .NET Aspire Redis integration. If the Redis integration relies on the 7.4 tag and you want to use the latest tag instead, you can chain a call to the ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache"") .WithImageTag(""latest""); // Instead of using the ""7.4"" tag, the ""cache"" // container resource now uses the ""latest"" tag. ``` For more information and additional APIs available, see Container resource lifecycle When the app host is run, the Docker First, the container is created using the docker container create command. Then, the container is started using the docker container start command. docker container create: Creates a new container from the specified image, without starting it. docker container start: Start one or more stopped containers. These commands are used instead of docker run to manage attached container networks, volumes, and ports. Calling these commands in this order allows any IP (network configuration) to already be present at initial startup. Podman First, the container is created using the podman container create command. Then, the container is started using the podman container start command. podman container create: Creates a writable container layer over the specified image and prepares it for running. podman container start: Start one or more stopped containers. These commands are used instead of podman run to manage attached container networks, volumes, and ports. Calling these commands in this order allows any IP (network configuration) to already be present at initial startup. Beyond the base resource types, Container resource lifetime By default, container resources use the session container lifetime. This means that every time the app host process is started, the container is created and started. When the app host stops, the container is stopped and removed. Container resources can opt-in to a persistent lifetime to avoid unnecessary restarts and use persisted container state. To achieve this, chain a call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var ollama = builder.AddContainer(""ollama"", ""ollama/ollama"") .WithLifetime(ContainerLifetime.Persistent); ``` The preceding code adds a container resource named ""ollama"" with the image ""ollama/ollama"" and a persistent lifetime. Connection string and endpoint references It\'s common to express dependencies between project resources. Consider the following example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject Project-to-project references are handled differently than resources that have well-defined connection strings. Instead of connection string being injected into the ""webfrontend"" resource, environment variables to support service discovery are injected. Method Environment variable WithReference(cache)', '<2-hop>\n\ntitle: .NET Aspire Community Toolkit Ollama integration description: Learn how to use the .NET Aspire Ollama hosting and client integration to host Ollama models using the Ollama container and accessing it via the OllamaSharp client. ms.date: 10/24/2024 .NET Aspire Community Toolkit Ollama integration [!INCLUDE includes-hosting-and-client] [!INCLUDE banner] Ollama is a powerful, open source language model that can be used to generate text based on a given prompt. The .NET Aspire Ollama integration provides a way to host Ollama models using the docker.io/ollama/ollama container image and access them via the OllamaSharp client. Hosting integration The Ollama hosting integration models an Ollama server as the OllamaResource type, and provides the ability to add models to the server using the AddModel extension method, which represents the model as an OllamaModelResource type. To access these types and APIs that allow you to add the ðŸ“¦ CommunityToolkit.Aspire.Hosting.Ollama NuGet package in the app host project. .NET CLI dotnetcli dotnet add package CommunityToolkit.Aspire.Hosting.Ollama PackageReference xml <PackageReference Include=""CommunityToolkit.Aspire.Hosting.Ollama"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Ollama resource In the app host project, register and consume the Ollama integration using the AddOllama extension method to add the Ollama container to the application builder. You can then add models to the container, which downloads and run when the container starts, using the AddModel extension method. ```csharp var builder = DistributedApplication.CreateBuilder(args); var ollama = builder.AddOllama(""ollama""); var phi35 = ollama.AddModel(""phi3.5""); var exampleProject = builder.AddProject Alternatively, if you want to use a model from the Hugging Face model hub, you can use the AddHuggingFaceModel extension method. csharp var llama = ollama.AddHuggingFaceModel(""llama"", ""bartowski/Llama-3.2-1B-Instruct-GGUF:IQ4_XS""); When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/ollama/ollama image, it creates a new Ollama instance on your local machine. For more information, see Container resource lifecycle. Download the LLM When the Ollama container for this integration first spins up, it downloads the configured LLMs. The progress of this download displays in the State column for this integration on the .NET Aspire dashboard. [!IMPORTANT] Keep the .NET Aspire orchestration app open until the download is complete, otherwise the download will be cancelled. Cache the LLM One or more LLMs are downloaded into the container which Ollama is running from, and by default this container is ephemeral. If you need to persist one or more LLMs across container restarts, you need to mount a volume into the container using the WithDataVolume method. ```csharp var ollama = builder.AddOllama(""ollama"") .WithDataVolume(); var llama = ollama.AddModel(""llama3""); ``` Use GPUs when available One or more LLMs are downloaded into the container which Ollama is running from, and by default this container runs on CPU. If you need to run the container in GPU you need to pass a parameter to the container runtime args. Docker csharp var ollama = builder.AddOllama(""ollama"") .AddModel(""llama3"") .WithContainerRuntimeArgs(""--gpus=all""); For more information, see GPU support in Docker Desktop. Podman csharp var ollama = builder.AddOllama(""ollama"") .AddModel(""llama3"") .WithContainerRuntimeArgs(""--device"", ""nvidia.com/gpu=all""); For more information, see GPU support in Podman. Hosting integration health checks The Ollama hosting integration automatically adds a health check for the Ollama server and model resources. For the Ollama server, a health check is added to verify that the Ollama server is running and that a connection can be established to it. For the Ollama model resources, a health check is added to verify that the model is running and that the model is available, meaning the resource will be marked as unhealthy until the model has been downloaded. Open WebUI support The Ollama integration also provided support for running Open WebUI and having it communicate with the Ollama container. csharp var ollama = builder.AddOllama(""ollama"") .AddModel(""llama3"") .WithOpenWebUI();']","In .NET Aspire, the commands for managing containers differ between Docker and Podman. For Docker, the container is created using the command `docker container create` and started with `docker container start`. In contrast, Podman uses `podman container create` to create a writable container layer over the specified image and `podman container start` to start one or more stopped containers. Both sets of commands are used instead of `docker run` or `podman run` to manage attached container networks, volumes, and ports, ensuring that any IP configuration is present at initial startup.",multi_hop_specific_query_synthesizer
50,What is the role of the Aspire.Hosting.Testing package in creating a .NET Aspire test project and how does it relate to the Aspire.Hosting.Azure package?,"['<1-hop>\n\ntitle: Write your first .NET Aspire test description: Learn how to test your .NET Aspire solutions using the xUnit, NUnit, and MSTest testing frameworks. ms.date: 11/11/2024 zone_pivot_groups: unit-testing-framework Write your first .NET Aspire test In this article, you learn how to create a test project, write tests, and run them for your .NET Aspire solutions. The tests in this article aren\'t unit tests, but rather functional or integration tests. .NET Aspire includes several variations of testing project templates that you can use to test your .NET Aspire resource dependenciesâ€”and their communications. The testing project templates are available for MSTest, NUnit, and xUnit testing frameworks and include a sample test that you can use as a starting point for your tests. The .NET Aspire test project templates rely on the ðŸ“¦ Aspire.Hosting.Testing NuGet package. This package exposes the Create a test project The easiest way to create a .NET Aspire test project is to use the testing project template. If you\'re starting a new .NET Aspire project and want to include test projects, the Visual Studio tooling supports that option. If you\'re adding a test project to an existing .NET Aspire project, you can use the dotnet new command to create a test project: :::zone pivot=""xunit"" dotnetcli dotnet new aspire-xunit :::zone-end :::zone pivot=""mstest"" dotnetcli dotnet new aspire-mstest :::zone-end :::zone pivot=""nunit"" dotnetcli dotnet new aspire-nunit :::zone-end For more information, see the .NET CLI dotnet new command documentation. Explore the test project The following example test project was created as part of the .NET Aspire Starter Application template. If you\'re unfamiliar with it, see Quickstart: Build your first .NET Aspire project. The .NET Aspire test project takes a project reference dependency on the target app host. Consider the template project: :::zone pivot=""xunit"" :::code language=""xml"" source=""snippets/testing/xunit/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end :::zone pivot=""mstest"" :::code language=""xml"" source=""snippets/testing/mstest/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end :::zone pivot=""nunit"" :::code language=""xml"" source=""snippets/testing/nunit/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end The preceding project file is fairly standard. There\'s a PackageReference to the ðŸ“¦ Aspire.Hosting.Testing NuGet package, which includes the required types to write tests for .NET Aspire projects. The template test project includes a IntegrationTest1 class with a single test. The test verifies the following scenario: The app host is successfully created and started. The webfrontend resource is available and running. An HTTP request can be made to the webfrontend resource and returns a successful response (HTTP 200 OK). Consider the following test class: :::zone pivot=""xunit"" :::code language=""csharp"" source=""snippets/testing/xunit/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end :::zone pivot=""mstest"" :::code language=""csharp"" source=""snippets/testing/mstest/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end :::zone pivot=""nunit"" :::code language=""csharp"" source=""snippets/testing/nunit/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end The preceding code: Relies on the The appHost is an instance of IDistributedApplicationTestingBuilder that represents the app host. The appHost instance has its service collection configured with the standard HTTP resilience handler. For more information, see Build resilient HTTP apps: Key development patterns. The appHost has its The app has its service provider get the The app is started asynchronously. An The resourceNotificationService is used to wait for the webfrontend resource to be available and running. A simple HTTP GET request is made to the root of the webfrontend resource. The test asserts that the response status code is OK.', '<2-hop>\n\nIt aims to drastically simplify the authoring experience with a cleaner syntax and better support for modularity and code reuse. While .NET Aspire provides a set of prebuilt Bicep templates, there might be times when you either want to customize the templates or create your own. This section explains the concepts and corresponding APIs that you can use to customize the Bicep templates. [!IMPORTANT] This section isn\'t intended to teach you Bicep, but rather to provide guidance on how to create custom Bicep templates for use with .NET Aspire. As part of the Azure deployment story for .NET Aspire, the Azure Developer CLI (azd) provides an understanding of your .NET Aspire project and the ability to deploy it to Azure. The azd CLI uses the Bicep templates to deploy the application to Azure. Install Aspire.Hosting.Azure package When you want to reference Bicep files, it\'s possible that you\'re not using any of the Azure hosting integrations. In this case, you can still reference Bicep files by installing the Aspire.Hosting.Azure package. This package provides the necessary APIs to reference Bicep files and customize the Azure resources. [!TIP] If you\'re using any of the Azure hosting integrations, you don\'t need to install the Aspire.Hosting.Azure package, as it\'s a transitive dependency. To use any of this functionality, the ðŸ“¦ Aspire.Hosting.Azure NuGet package must be installed: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. What to expect from the examples All the examples in this section assume that you\'re using the ```csharp using Aspire.Hosting.Azure; var builder = DistributedApplication.CreateBuilder(args); // Examples go here... builder.Build().Run(); ``` By default, when you call any of the Bicep-related APIs, a call is also made to Reference Bicep files Imagine that you have a Bicep template in a file named storage.bicep that provisions an Azure Storage Account: :::code language=""bicep"" source=""snippets/AppHost.Bicep/storage.bicep""::: To add a reference to the Bicep file on disk, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.ReferenceBicep.cs"" id=""addfile""::: The preceding code adds a reference to a Bicep file located at ../infra/storage.bicep. The file paths should be relative to the app host project. This reference results in an Reference Bicep inline While having a Bicep file on disk is the most common scenario, you can also add Bicep templates inline. Inline templates can be useful when you want to define a template in code or when you want to generate the template dynamically. To add an inline Bicep template, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.InlineBicep.cs"" id=""addinline""::: In this example, the Bicep template is defined as an inline string and added to the application\'s resources collection with the name ""ai"". This example provisions an Azure AI resource. Pass parameters to Bicep templates Bicep supports accepting parameters, which can be used to customize the behavior of the template. To pass parameters to a Bicep template from .NET Aspire, chain calls to the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.PassParameter.cs"" id=""addparameter""::: The preceding code: Adds a parameter named ""region"" to the builder instance. Adds a reference to a Bicep file located at ../infra/storage.bicep. Passes the ""region"" parameter to the Bicep template, which is resolved using the standard parameter resolution. Passes the ""storageName"" parameter to the Bicep template with a hardcoded value. Passes the ""tags"" parameter to the Bicep template with an array of strings. For more information, see External parameters. Well-known parameters .NET Aspire provides a set of well-known parameters that can be passed to Bicep templates. These parameters are used to provide information about the application and the environment to the Bicep templates. The following well-known parameters are available: Field Description Value The name of the key vault resource used to store secret outputs. ""keyVaultName"" The location of the resource. This is required for all resources. ""location"" The resource ID of the log analytics workspace. ""logAnalyticsWorkspaceId"" The principal ID of the current user or managed identity. ""principalId"" The principal name of the current user or managed identity. ""principalName"" The principal type of the current user or managed identity. Either User or ServicePrincipal . ""principalType"" To use a well-known parameter, pass the parameter name to the Consider an example where you want to set up an Azure Event Grid webhook. You might define the Bicep template as follows: :::code language=""bicep"" source=""snippets/AppHost.Bicep/event-grid-webhook.bicep"" highlight=""3-4,27-35""::: This Bicep template defines several parameters, including the topicName, webHookEndpoint, principalId, principalType, and the optional location. To pass these parameters to the Bicep template, you can use the following code snippet: :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.PassParameter.cs"" id=""addwellknownparams""::: The webHookApi project is added as a reference to the builder. The topicName parameter is passed a hardcoded name value. The webHookEndpoint parameter is passed as an expression that resolves to the URL from the api project references\' ""https"" endpoint with the /hook route. The principalId and principalType parameters are passed as well-known parameters. The well-known parameters are convention-based and shouldn\'t be accompanied with a corresponding value when passed using the WithParameter API. Well-known parameters simplify some common functionality, such as role assignments, when added to the Bicep templates, as shown in the preceding example. Role assignments are required for the Event Grid webhook to send events to the specified endpoint. For more information, see Event Grid Data Sender role assignment. Get outputs from Bicep references In addition to passing parameters to Bicep templates, you can also get outputs from the Bicep templates. Consider the following Bicep template, as it defines an output named endpoint: :::code language=""bicep"" source=""snippets/AppHost.Bicep/storage-out.bicep""::: The Bicep defines an output named endpoint. To get the output from the Bicep template, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.GetOutputReference.cs"" id=""getoutput""::: In this example, the output from the Bicep template is retrieved and stored in an endpoint variable. Typically, you would pass this output as an environment variable to another resource that relies on it. For instance, if you had an ASP.NET Core Minimal API project that depended on this endpoint, you could pass the output as an environment variable to the project using the following code snippet: ```csharp var storage = builder.AddBicepTemplate( name: ""storage"", bicepFile: ""../infra/storage.bicep"" );']","The Aspire.Hosting.Testing package plays a crucial role in creating a .NET Aspire test project by providing the necessary types to write tests for .NET Aspire projects. It is used in conjunction with various testing frameworks like MSTest, NUnit, and xUnit to facilitate the testing process. On the other hand, the Aspire.Hosting.Azure package is essential for referencing Bicep files and customizing Azure resources. While the Aspire.Hosting.Testing package is focused on testing functionalities, the Aspire.Hosting.Azure package supports the deployment and management of Azure resources, indicating that both packages serve different but complementary purposes within the .NET Aspire ecosystem.",multi_hop_specific_query_synthesizer
51,"What are the key configurations for using gRPC in a .NET Aspire project, and how does it relate to service discovery with the apiservice?","['<1-hop>\n\nAdd Dapr sidecar to .NET Aspire resources Dapr uses the sidecar pattern. The Dapr sidecar runs alongside your app as a lightweight, portable, and stateless HTTP server that listens for incoming HTTP requests from your app. To add a sidecar to a .NET Aspire resource, call the :::code language=""csharp"" source=""snippets/Dapr/Dapr.AppHost/Program.cs"" range=""1-7"" highlight=""7""::: Configure Dapr sidecars The WithDaprSidecar method offers overloads to configure your Dapr sidecar options like AppId and various ports. In the following example, the Dapr sidecar is configured with specific ports for GRPC, HTTP, metrics, and a specific app ID. :::code language=""csharp"" source=""snippets/Dapr/Dapr.AppHost/Program.cs"" range=""9-20"" highlight=""1-7,12""::: Complete Dapr app host example Putting everything together, consider the following example of a .NET Aspire app host project that includes: A backend API service that declares a Dapr sidecar with defaults. A web frontend project that declares a Dapr sidecar with specific options, such as explict ports. :::code language=""csharp"" source=""snippets/Dapr/Dapr.AppHost/Program.cs""::: When you start the .NET Aspire solution, the dashboard shows the Dapr sidecar as a resource, with its status and logs. :::image type=""content"" source=""media/aspire-dashboard-dapr-sidecar-resources.png"" lightbox=""media/aspire-dashboard-dapr-sidecar-resources.png"" alt-text="".NET Aspire dashboard showing Dapr sidecar resources""::: Use Dapr sidecars in consuming .NET Aspire projects To use Dapr APIs from .NET Aspire resources, you can use the ðŸ“¦ Dapr.AspNetCore/ NuGet package. The Dapr SDK provides a set of APIs to interact with Dapr sidecars. [!NOTE] Use the Dapr.AspNetCore library for the Dapr integration with ASP.NET (DI integration, registration of subscriptions, etc.). Non-ASP.NET apps (such as console apps) can just use the ðŸ“¦ Dapr.Client to make calls through the Dapr sidecar. .NET CLI dotnetcli dotnet add package Dapr.AspNetCore PackageReference xml <PackageReference Include=""Dapr.AspNetCore"" Version=""*"" /> Add Dapr client Once installed into an ASP.NET Core project, the SDK can be added to the service builder. :::code language=""csharp"" source=""snippets/Dapr/Dapr.Web/Program.cs"" range=""15""::: Invoke Dapr methods An instance of DaprClient can now be injected into your services to interact with the Dapr sidecar through the Dapr SDK: :::code language=""csharp"" source=""snippets/Dapr/Dapr.Web/WeatherApiClient.cs"" highlight=""5,11-15""::: InvokeMethodAsync is the method that sends an HTTP request to the Dapr sidecar. It is a generic method that takes: An HTTP verb. The Dapr app ID of the service to call. The method name. A cancellation token. Depending on the HTTP verb, it can also take a request body and headers. The generic type parameter is the type of the response body. The full :::no-loc text=""Program.cs""::: file for the frontend project shows: The Dapr client being added to the service builder. The WeatherApiClient class that uses the Dapr client to call the backend service. :::code language=""csharp"" source=""snippets/Dapr/Dapr.Web/Program.cs"" highlight=""15,17""::: For example, in a Blazor project, you can inject the WeatherApiClient class into a razor page and use it to call the backend service: :::code language=""csharp"" source=""snippets/Dapr/Dapr.Web/Components/Pages/Weather.razor"" highlight=""5,47""::: When the Dapr SDK is used, the Dapr sidecar is called over HTTP. The Dapr sidecar then forwards the request to the target service. While the target service runs in a separate process from the sidecar, the integration related to the service runs in the Dapr sidecar and is responsible for service discovery and routing the request to the target service. Next steps Dapr Dapr documentation Dapr GitHub repo .NET Aspire Dapr sample app .NET Aspire integrations .NET Aspire GitHub repo', '<2-hop>\n\nConnectionStrings__cache=""localhost:62354"" WithReference(apiservice) services__apiservice__http__0=""http://localhost:5455"" services__apiservice__https__0=""https://localhost:7356"" Adding a reference to the ""apiservice"" project results in service discovery environment variables being added to the frontend. This is because typically, project-to-project communication occurs over HTTP/gRPC. For more information, see .NET Aspire service discovery. To get specific endpoints from a Then call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var customContainer = builder.AddContainer(""myapp"", ""mycustomcontainer"") .WithHttpEndpoint(port: 9043, name: ""endpoint""); var endpoint = customContainer.GetEndpoint(""endpoint""); var apiservice = builder.AddProject Method Environment variable WithReference(endpoint) services__myapp__endpoint__0=https://localhost:9043 The port parameter is the port that the container is listening on. For more information on container ports, see Container ports. For more information on service discovery, see .NET Aspire service discovery. Service endpoint environment variable format In the preceding section, the When one resource depends on another resource, the app host injects environment variables into the dependent resource. These environment variables configure the dependent resource to connect to the resource it depends on. The format of the environment variables is specific to .NET Aspire and expresses service endpoints in a way that is compatible with Service Discovery. Service endpoint environment variable names are prefixed with services__ (double underscore), then the service name, the endpoint name, and finally the index. The index supports multiple endpoints for a single service, starting with 0 for the first endpoint and incrementing for each endpoint. Consider the following environment variable examples: Environment services__apiservice__http__0 The preceding environment variable expresses the first HTTP endpoint for the apiservice service. The value of the environment variable is the URL of the service endpoint. A named endpoint might be expressed as follows: Environment services__apiservice__myendpoint__0 In the preceding example, the apiservice service has a named endpoint called myendpoint. The value of the environment variable is the URL of the service endpoint.']","To use gRPC in a .NET Aspire project, you need to configure the Dapr sidecar with specific ports for gRPC, HTTP, and metrics. This is done using the WithDaprSidecar method, which allows you to set options like AppId and various ports. Additionally, when you add a reference to the 'apiservice' project, it results in service discovery environment variables being added to the frontend. This is because project-to-project communication typically occurs over HTTP/gRPC, enabling the frontend to discover and connect to the backend services effectively.",multi_hop_specific_query_synthesizer
52,What are the key components of the .NET Aspire orchestration model and how does it relate to .NET 9.0?,"['<1-hop>\n\n.NET Aspire dashboard Install .NET Aspire To work with .NET Aspire, you need the following installed locally: .NET 8.0 or .NET 9.0. An OCI compliant container runtime, such as: Docker Desktop or Podman. For more information, see Container runtime. An Integrated Developer Environment (IDE) or code editor, such as: Visual Studio 2022 version 17.9 or higher (Optional) Visual Studio Code (Optional) C# Dev Kit: Extension (Optional) JetBrains Rider with .NET Aspire plugin (Optional) :::zone pivot=""visual-studio"" Visual Studio 2022 17.9 or higher includes the latest .NET Aspire SDK by default when you install the Web & Cloud workload. If you have an earlier version of Visual Studio 2022, you can either upgrade to Visual Studio 2022 17.9 or you can install the .NET Aspire SDK using the following steps: To install the .NET Aspire workload in Visual Studio 2022, use the Visual Studio installer. Open the Visual Studio Installer. Select Modify next to Visual Studio 2022. Select the ASP.NET and web development workload. On the Installation details panel, select .NET Aspire SDK. Select Modify to install the .NET Aspire integration. :::image type=""content"" loc-scope=""visual-studio"" source=""media/setup-tooling/web-workload-with-aspire.png"" lightbox=""media/setup-tooling/web-workload-with-aspire.png"" alt-text=""A screenshot showing how to install the .NET Aspire workload with the Visual Studio installer.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" :::zone-end Container runtime .NET Aspire projects are designed to run in containers. You can use either Docker Desktop or Podman as your container runtime. Docker Desktop is the most common container runtime. Podman is an open-source daemonless alternative to Docker, that can build and run Open Container Initiative (OCI) containers. If your host environment has both Docker and Podman installed, .NET Aspire defaults to using Docker. You can instruct .NET Aspire to use Podman instead, by setting the DOTNET_ASPIRE_CONTAINER_RUNTIME environment variable to podman: Linux bash export DOTNET_ASPIRE_CONTAINER_RUNTIME=podman For more information, see Install Podman on Linux. Windows ```powershell ``` For more information, see Install Podman on Windows. .NET Aspire templates .NET Aspire provides a set of solution and project templates. These templates are available in your favorite .NET developer integrated environment. You can use these templates to create full .NET Aspire solutions, or add individual projects to existing .NET Aspire solutions. For more information, see .NET Aspire templates. .NET Aspire dashboard .NET Aspire templates that expose the app host project also include a useful developer dashboard that\'s used to monitor and inspect various aspects of your app, such as logs, traces, and environment configurations. This dashboard is designed to improve the local development experience and provides an overview of the overall state and structure of your app. The .NET Aspire dashboard is only visible while the app is running and starts automatically when you start the *.AppHost project. Visual Studio and Visual Studio Code launch both your app and the .NET Aspire dashboard for you automatically in your browser. If you start the app using the .NET CLI, copy and paste the dashboard URL from the output into your browser, or hold Ctrl and select the link (if your terminal supports hyperlinks). :::image type=""content"" source=""dashboard/media/explore/dotnet-run-login-url.png"" lightbox=""dashboard/media/explore/dotnet-run-login-url.png"" alt-text=""A screenshot showing how to launch the dashboard using the CLI.""::: The left navigation provides links to the different parts of the dashboard, each of which you explore in the following sections. :::image type=""content"" source=""../get-started/media/aspire-dashboard.png"" lightbox=""../get-started/media/aspire-dashboard.png"" alt-text=""A screenshot of the .NET Aspire dashboard Projects page.""::: The .NET Aspire dashboard is also available in a standalone mode. For more information, see Standalone .NET Aspire dashboard. :::zone pivot=""visual-studio"" Visual Studio tooling Visual Studio provides additional features for working with .NET Aspire integrations and the App Host orchestrator project. Not all of these features are currently available in Visual Studio Code or through the CLI. Add an integration package You add .NET Aspire integrations to your app like any other NuGet package using Visual Studio. However, Visual Studio also provides UI options to add .NET Aspire integrations directly. In Visual Studio, right select on the project you want to add an .NET Aspire integration to and select Add > .NET Aspire package.... :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-package.png"" lightbox=""../media/visual-studio-add-aspire-package.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire Component option.""::: The package manager opens with search results preconfigured (populating filter criteria) for .NET Aspire integrations, allowing you to easily browse and select the desired integration. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-comp-nuget.png"" lightbox=""../media/visual-studio-add-aspire-comp-nuget.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire integration options.""::: For more information on .NET Aspire integrations, see .NET Aspire integrations overview. Add hosting packages .NET Aspire hosting packages are used to configure various resources and dependencies an app may depend on or consume. Hosting packages are differentiated from other integration packages in that they\'re added to the *.AppHost project. To add a hosting package to your app, follow these steps: In Visual Studio, right select on the _.AppHost_ project and select Add > .NET Aspire package...*. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-hosting-package.png"" lightbox=""../media/visual-studio-add-aspire-hosting-package.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire Hosting Resource option.""::: The package manager opens with search results preconfigured (populating filter criteria) for .NET Aspire hosting packages, allowing you to easily browse and select the desired package. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-hosting-nuget.png"" lightbox=""../media/visual-studio-add-aspire-hosting-nuget.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire resource options.""::: Add orchestration projects You can add .NET Aspire orchestration projects to an existing app using the following steps: In Visual Studio, right select on an existing project and select Add > .NET Aspire Orchestrator Support... :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-orchestrator.png"" lightbox=""../media/visual-studio-add-aspire-orchestrator.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire Orchestrator Support option.""::: A dialog window opens with a summary of the .AppHost_ and _.ServiceDefaults projects that are added to your solution. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/add-orchestrator-app.png"" alt-text=""A screenshot showing the Visual Studio add .NET Aspire orchestration summary.""::: Select OK and the following changes are applied: The .AppHost_ and _.ServiceDefaults orchestration projects are added to your solution. A call to builder.AddServiceDefaults will be added to the :::no-loc text=""Program.cs""::: file of your original project. A reference to your original project will be added to the :::no-loc text=""Program.cs""::: file of the *.AppHost project. For more information on .NET Aspire orchestration,', '<2-hop>\n\ntitle: .NET Aspire orchestration overview description: Learn the fundamental concepts of .NET Aspire orchestration and explore the various APIs for adding resources and expressing dependencies. ms.date: 12/13/2024 ms.topic: overview uid: dotnet/aspire/app-host .NET Aspire orchestration overview .NET Aspire provides APIs for expressing resources and dependencies within your distributed application. In addition to these APIs, there\'s tooling that enables several compelling scenarios. The orchestrator is intended for local development purposes and isn\'t supported in production environments. Before continuing, consider some common terminology used in .NET Aspire: App model: A collection of resources that make up your distributed application ( App host/Orchestrator project: The .NET project that orchestrates the app model, named with the *.AppHost suffix (by convention). Resource: A resource is a dependent part of an application, such as a .NET project, container, executable, database, cache, or cloud service. It represents any part of the application that can be managed or referenced. Integration: An integration is a NuGet package for either the app host that models a resource or a package that configures a client for use in a consuming app. For more information, see .NET Aspire integrations overview. Reference: A reference defines a connection between resources, expressed as a dependency using the [!NOTE] .NET Aspire\'s orchestration is designed to enhance your local development experience by simplifying the management of your cloud-native app\'s configuration and interconnections. While it\'s an invaluable tool for development, it\'s not intended to replace production environment systems like Kubernetes, which are specifically designed to excel in that context. Define the app model .NET Aspire empowers you to seamlessly build, provision, deploy, configure, test, run, and observe your distributed applications. All of these capabilities are achieved through the utilization of an app model that outlines the resources in your .NET Aspire solution and their relationships. These resources encompass projects, executables, containers, and external services and cloud resources that your app depends on. Within every .NET Aspire solution, there\'s a designated App host project, where the app model is precisely defined using methods available on the ```csharp // Create a new app model builder var builder = DistributedApplication.CreateBuilder(args); // TODO: // Add resources to the app model // Express dependencies between resources builder.Build().Run(); ``` App host project The app host project handles running all of the projects that are part of the .NET Aspire project. In other words, it\'s responsible for orchestrating all apps within the app model. The project itself is a .NET executable project that references the ðŸ“¦ Aspire.Hosting.AppHost NuGet package, sets the IsAspireHost property to true, and references the .NET Aspire SDK: ```xml <Sdk Name=""Aspire.AppHost.Sdk"" Version=""9.0.0"" /> <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net9.0</TargetFramework> <IsAspireHost>true</IsAspireHost> <!-- Omitted for brevity --> </PropertyGroup> <ItemGroup> <PackageReference Include=""Aspire.Hosting.AppHost"" Version=""9.0.0"" /> </ItemGroup> <!-- Omitted for brevity --> ``` The following code describes an app host Program with two project references and a Redis cache: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code: Creates a new app model builder using the Adds a Redis cache resource named ""cache"" using the Adds a project resource named ""apiservice"" using the Adds a project resource named ""webfrontend"" using the Specifies that the project has external HTTP endpoints using the Adds a reference to the cache resource and waits for it to be ready using the Adds a reference to the apiservice resource and waits for it to be ready using the Builds and runs the app model using the The example code uses the .NET Aspire Redis hosting integration. To help visualize the relationship between the app host project and the resources it describes, consider the following diagram: :::image type=""content"" source=""../media/app-host-resource-diagram.png"" lightbox=""../media/app-host-resource-diagram.png"" alt-text=""The relationship between the projects in the .NET Aspire Starter Application template.""::: Each resource must be uniquely named. This diagram shows each resource and the relationships between them. The container resource is named ""cache"" and the project resources are named ""apiservice"" and ""webfrontend"". The web frontend project references the cache and API service projects. When you\'re expressing references in this way, the web frontend project is saying that it depends on these two resources, the ""cache"" and ""apiservice"" respectively.']",".NET Aspire orchestration is designed to enhance local development by simplifying the management of cloud-native applications. It utilizes an app model that outlines the resources in a .NET Aspire solution, including projects, executables, containers, and external services. The app host project, which is a .NET executable project, orchestrates all apps within the app model and must reference the .NET Aspire SDK. Specifically, the app host project is named with the *.AppHost suffix and includes a reference to the Aspire.Hosting.AppHost NuGet package. The orchestration model allows developers to define resources and their dependencies, which is crucial for building distributed applications. Additionally, .NET Aspire requires .NET 8.0 or .NET 9.0 to function, ensuring compatibility with the latest features and improvements in the .NET ecosystem.",multi_hop_specific_query_synthesizer
53,"How does Microsoft Entra ID enhance security in .NET Aspire applications, particularly in relation to Azure Database for PostgreSQL and Azure Cache for Redis?","['<1-hop>\n\nFramework Specific Instrumentation This instrumentation has only focused on adding OpenTelemetry to our code. For more detailed instrumentation, you can use the OpenTelemetry Instrumentation packages for the specific frameworks that you are using. Flask Install the Flask instrumentation package: console pip install opentelemetry-instrumentation-flask Add the following code to your application: ```python from opentelemetry.instrumentation.flask import FlaskInstrumentor add this line after configure_otel_otlp() call FlaskInstrumentor().instrument() ``` FastAPI Install the FastAPI instrumentation package: console pip install opentelemetry-instrumentation-fastapi Add the following code to your application: ```python from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor add this line after configure_otel_otlp() call FastAPIInstrumentor.instrument_app(app) ``` Start the Aspire dashboard To start the Aspire dashboard in standalone mode, run the following Docker command: bash docker run --rm -it -p 18888:18888 -p 4317:18889 --name aspire-dashboard \\ mcr.microsoft.com/dotnet/aspire-dashboard:9.0 In the Docker logs, the endpoint and key for the dashboard are displayed. Copy the key and navigate to http://localhost:18888 in a web browser. Enter the key to log in to the dashboard. View Structured Logs Navigate around the Python application, and you\'ll see structured logs in the Aspire dashboard. The structured logs page displays logs from your application, and you can filter and search the logs. :::image type=""content"" source=""./media/standalone/aspire-dashboard-python-logs.png"" alt-text=""Screenshot of the Aspire dashboard showing the Python application logs""::: Next steps You have successfully used the .NET Aspire dashboard with a Python application. To learn more about the .NET Aspire dashboard, see the Aspire dashboard overview and how to orchestrate a Python application with the .NET Aspire app host.', '<2-hop>\n\nclient integration registers the OpenAIClient as a singleton service in the service collection. The client can be used to interact with the OpenAI REST API. ðŸ“¦ Aspire.OpenAI (Preview) Moreover, the already available .NET Aspire Azure OpenAI integration was improved to provide a flexible way to configure an OpenAIClient for either an Azure AI OpenAI service or a dedicated OpenAI REST API one with the new csharp builder.AddOpenAIClientFromConfiguration(""openai""); For instance, if the openai connection looked like Endpoint=https://{account}.azure.com;Key={key}; it would guess it can register an Azure AI OpenAI client because of the domain name. Otherwise a common OpenAIClient would be used. Read Azure-agnostic client resolution for more details. MongoDB Added support for specifying the MongoDB username and password when using the ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""mongousername""); var password = builder.AddParameter(""mongopassword"", secret: true); var db = builder.AddMongo(""db"", username, password); ``` Important Azure improvements The following sections describe Azure improvements added in .NET Aspire 9. For a complete listing of all the breaking changes, see Breaking changes in .NET Aspire 9. Azure resource customization In .NET Aspire 8, customizing Azure resources were marked experimental because the underlying Azure.Provisioning libraries were new and gathering feedback before they could be marked stable. In .NET Aspire 9 these APIs were updated and removes the experimental attribute. Azure Resource naming breaking change As part of the update to the ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.Services.Configure Azure SQL, PostgreSQL, and Redis Update Azure SQL, PostgreSQL, and Redis resources are different than other Azure resources because there are local container resources for these technologies. In .NET Aspire 8, in order to create these Azure resources you needed to start with a local container resource and then either ""As"" or ""PublishAs"" it to an Azure resource. This design introduced problems and didn\'t fit with other APIs. For example, you might have this code in .NET Aspire 8: ```csharp var builder = DistributedApplication.CreateBuilder(args); var sql = builder.AddSqlServer(""sql"") .PublishAsAzureSqlDatabase(); var pgsql = builder.AddPostgres(""pgsql"") .PublishAsAzurePostgresFlexibleServer(); var cache = builder.AddRedis(""cache"") .PublishAsAzureSqlDatabase(); ``` In .NET Aspire 9 these APIs were marked as obsolete and a new API pattern implemented: ```csharp var builder = DistributedApplication.CreateBuilder(args); var sql = builder.AddAzureSqlServer(""sql"") .RunAsContainer(); var pgsql = builder.AddAzurePostgresFlexibleServer(""pgsql"") .RunAsContainer(); var cache = builder.AddAzureRedis(""cache"") .RunAsContainer(); ``` Microsoft Entra ID by default In order to make .NET Aspire applications more secure, Azure Database for PostgreSQL and Azure Cache for Redis resources were updated to use Microsoft Entra ID by default. This requires changes to applications that need to connect to these resources. See the following for updating applications to use Microsoft Entra ID to connect to these resources: Azure Database for PostgreSQL Azure Cache for Redis The following examples demonstrate how to configure your application to connect to the Azure resources using Microsoft Entra ID: .NET Aspire: Azure PostgreSQL hosting integration. .NET Aspire: Azure Redis hosting integration. If you need to use password or access key authentication (not recommended), you can opt-in with the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var pgsql = builder.AddAzurePostgresFlexibleServer(""pgsql"") .WithPasswordAuthentication(); var cache = builder.AddAzureRedis(""cache"") .WithAccessKeyAuthentication(); ``` Support for Azure Functions (Preview) Support for Azure Functions is one of the most widely requested features on the .NET Aspire issue tracker and we\'re excited to introduce preview support for it in this release. To demonstrate this support, let\'s use .NET Aspire to create and deploy a webhook. To get started, create a new Azure Functions project using the Visual Studio New Project dialog. When prompted, select the Enlist in Aspire orchestration checkbox when creating the project. :::image type=""content"" source=""media/functions-step-1.gif"" lightbox=""media/functions-step-1.gif"" alt-text=""Create new .NET Aspire Azure Functions project.""::: In the app host project, observe that there\'s a PackageReference to the new ðŸ“¦ Aspire.Hosting.Azure.Functions NuGet package: xml <ItemGroup> <PackageReference Include=""Aspire.Hosting.AppHost"" Version=""9.0.0"" /> <PackageReference Include=""Aspire.Hosting.Azure.Functions"" Version=""9.0.0"" /> </ItemGroup> This package provides an ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureFunctionsProject builder.Build().Run(); ``` In this example, the webhook is responsible for translating an input string into Pig Latin. Update the contents of our trigger with the following code: ```csharp using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; using Microsoft.Azure.Functions.Worker; using Microsoft.Extensions.Logging; using System.Text; using FromBodyAttribute = Microsoft.Azure.Functions.Worker.Http.FromBodyAttribute; namespace PigLatinApp; public class Function1(ILogger [Function(""Function1"")] public IActionResult Run( [HttpTrigger(AuthorizationLevel.Anonymous, ""post"")] HttpRequest req, [FromBody] InputText inputText) { logger.LogInformation(""C# HTTP trigger function processed a request.""); var result = TranslateToPigLatin(inputText.Value); return new OkObjectResult(new PigLatinText(result)); } private static string TranslateToPigLatin(string input) { if (string.IsNullOrEmpty(input)) { return input; } var words = input.Split(\' \'); StringBuilder pigLatin = new(); foreach (string word in words) { if (IsVowel(word[0])) { pigLatin.Append(word + ""yay ""); } else { int vowelIndex = FindFirstVowelIndex(word); if (vowelIndex is -1) { pigLatin.Append(word + ""ay ""); } else { pigLatin.Append( word.Substring(vowelIndex) + word.Substring(0, vowelIndex) + ""ay ""); } } } return pigLatin.ToString().Trim(); } private static int FindFirstVowelIndex(string word) { for (var i = 0; i < word.Length; i++) { if (IsVowel(word[i])) { return i; } } return -1; } private static bool IsVowel(char c) => char.ToLower(c) is \'a\' or \'e\' or \'i\' or \'o\' or \'u\'; } ``` Set a breakpoint on the first logger.LogInformation line of the Run method and press F5 to start the Functions host. Once the .NET Aspire dashboard launches, you observe the following: :::image type=""content"" source=""media/functions-dashboard-screenshot.png"" lightbox=""media/functions-dashboard-screenshot.png"" alt-text=""Screenshot of the .NET Aspire running with an Azure Function app.""::: .NET Aspire has: Configured an emulated Azure Storage resource to be used for bookkeeping by the host. Launched the Functions host locally with the target as the Functions project registered. Wired the port defined in launchSettings.json of the functions project for listening. Use your favorite HTTP client of choice to send a request to the trigger and observe the inputs bound from the request body in the debugger. Unix bash curl --request POST \\ --url http://localhost:7282/api/Function1 \\ --header \'Content-Type: application/json\' \\ --data \'{ ""value"": ""Welcome to Azure Functions"" }\' Windows powershell curl --request POST ` --url http://localhost:7282/api/Function1 ` --header \'Content-Type: application/json\' ` --data \'{ ""value"": ""Welcome to Azure Functions"" }\' :::image type=""content"" source=""media/functions-debug-screenshot.png"" lightbox=""media/functions-debug-screenshot.png"" alt-text=""Screenshot of the .NET Aspire dashboard: Debugging an Azure Function app.""::: Now you\'re ready to deploy our application to Azure Container Apps (ACA). Deployment']","Microsoft Entra ID enhances security in .NET Aspire applications by making Azure Database for PostgreSQL and Azure Cache for Redis resources use Microsoft Entra ID by default. This change requires applications to be updated to connect to these resources securely, promoting better data protection and access control.",multi_hop_specific_query_synthesizer
54,How do you configure Azure Cosmos DB in .NET Aspire and what is the role of the emulator in this process?,"['<1-hop>\n\nLocal emulators Some Azure services can be run locally in emulators. Currently, .NET Aspire supports the following Azure emulators: Hosting integration Description Azure Cosmos DB Call on the IResourceBuilder<AzureCosmosDBResource> to configure the Cosmos DB resource to be emulated with the NoSQL API . Azure Event Hubs Call on the IResourceBuilder<AzureEventHubsResource> to configure the Event Hubs resource to be emulated . Azure Storage Call on the IResourceBuilder<AzureStorageResource> to configure the Storage resource to be emulated with Azurite . To have your Azure resources use the local emulators, chain a call the RunAsEmulator method on the Azure resource builder. This method configures the Azure resource to use the local emulator instead of the actual Azure service. [!IMPORTANT] Calling any of the available RunAsEmulator APIs on an Azure resource builder doesn\'t impact the publishing manifest. When you publish your app, generated Bicep file reflects the actual Azure service, not the local emulator. var endpoint = storage.GetOutput(""endpoint""); var apiService = builder.AddProject For more information, see Bicep outputs. Get secret outputs from Bicep references It\'s important to avoid outputs for secrets when working with Bicep. If an output is considered a secret, meaning it shouldn\'t be exposed in logs or other places, you can treat it as such. This can be achieved by storing the secret in Azure Key Vault and referencing it in the Bicep template. .NET Aspire\'s Azure integration provides a pattern for securely storing outputs from the Bicep template by allows resources to use the keyVaultName parameter to store secrets in Azure Key Vault. Consider the following Bicep template as an example the helps to demonstrate this concept of securing secret outputs: :::code language=""bicep"" source=""snippets/AppHost.Bicep/cosmosdb.bicep"" highlight=""2,41""::: The preceding Bicep template expects a keyVaultName parameter, among several other parameters. It then defines an Azure Cosmos DB resource and stashes a secret into Azure Key Vault, named connectionString which represents the fully qualified connection string to the Cosmos DB instance. To access this secret connection string value, you can use the following code snippet: :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.cs"" id=""secrets""::: In the preceding code snippet, the cosmos Bicep template is added as a reference to the builder. The connectionString secret output is retrieved from the Bicep template and stored in a variable. The secret output is then passed as an environment variable (ConnectionStrings__cosmos) to the api project. This environment variable is used to connect to the Cosmos DB instance. When this resource is deployed, the underlying deployment mechanism will automatically Reference secrets from Azure Key Vault. To guarantee secret isolation, .NET Aspire creates a Key Vault per source. [!NOTE] In local provisioning mode, the secret is extracted from Key Vault and set it in an environment variable. For more information, see Local Azure provisioning. Publishing When you publish your app, the Azure provisioning generated Bicep is used by the Azure Developer CLI to create the Azure resources in your Azure subscription. .NET Aspire outputs a publishing manifest, that\'s also a vital part of the publishing process. The Azure Developer CLI is a command-line tool that provides a set of commands to manage Azure resources. For more information on publishing and deployment, see Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide).', '<2-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","To configure Azure Cosmos DB in .NET Aspire, you call the IResourceBuilder<AzureCosmosDBResource> to set up the Cosmos DB resource. The Azure Cosmos DB emulator allows you to run and test your application locally without needing to connect to the actual Azure service. This is done by chaining a call to the RunAsEmulator method on the Azure resource builder, which configures the resource to use the local emulator instead of the actual Azure service.",multi_hop_specific_query_synthesizer
55,How can the .NET Aspire dashboard be utilized to manage JavaScript client applications and what role does the OpenTelemetry JavaScript SDK play in this process?,"['<1-hop>\n\nDashboard UX enhancements and new interactivity features The .NET Aspire dashboard continues to improve with each release. Manage resource lifecycle The most requested feature for the dashboard is to manage the life-cycles of your orchestrated named resources. Specifically, the ability to stop, start, and restart resources. This feature works for projects, containers, and executables. It enables restarting individual resources without having to restart the entire app host. For project resources, when the debugger is attached, it\'s reattached on restart. For more information, see .NET Aspire dashboard: Stop or Start a resource. Mobile and responsive support The .NET Aspire dashboard is now mobile-friendly, responsively adapting to a wide range of screen sizes and enabling on-the-go management of deployed .NET Aspire applications. Other accessibility improvements were made, including the display of settings and content overflow on mobile. Sensitive properties, volumes, and health checks in resource details The display of resource details contains several improvements: Properties can be marked as sensitive, automatically masking them in the dashboard UI. This security feature helps to avoid accidentally disclosing keys or passwords when screen sharing the dashboard with other people. For example, container arguments could pass sensitive information and so are masked by default. Configured container volumes are listed in resource details. .NET Aspire 9 adds support for health checks. Detailed information about these checks can now be viewed in the resource details pane, showing why a resource might be marked as unhealthy or degraded. Find out more about health checks here. Colorful console log ANSI escape codes format text in terminals by controlling colors (foreground and background) and styles like bold, underline, and italics. Previously, the dashboard\'s console logs page could only render one ANSI escape code at a time, failing when multiple codes were combined. For example, it could display red text, but not text that was both red and bold. A community contribution from @mangeg improved support for ANSI escape codes and removed this limitation. :::image type=""content"" source=""media/console-logs-ansi-text-format.png"" lightbox=""media/console-logs-ansi-text-format.png"" alt-text=""Colorful console logs""::: Another improvement to console logs is hiding unsupported escape codes. Codes that aren\'t related to displaying text, such as positioning the cursor or communicating with the operating system don\'t make sense in this UI, and are hidden. Telemetry user-centric additions Telemetry remains a vital aspect of .NET Aspire. In .NET Aspire 9, many new features were introduced to the Telemetry service. Improved telemetry filtering Traces can be filtered with attribute values. For example, if you only want to view traces for one endpoint in your app, the http.route attribute on HTTP requests can be filtered to a specified value. Telemetry filtering also supports autocomplete of existing values. The Add filter dialog provides a combo box for selecting from values that dashboard has available. This feature makes it much easier to filter to real data and helps avoid typos by entered a value yourself. For more information, see .NET Aspire dashboard: Filter traces. Combine telemetry from multiple resources When a resource has multiple replicas, you can now filter telemetry to view data from all instances at once. Select the parent resource, labeled (application). For more information, see .NET Aspire dashboard: Combine telemetry from multiple resources. Browser telemetry support The dashboard supports OpenTelemetry Protocol (OTLP) over HTTP and cross-origin resource sharing (CORS). These features unlock the ability to send OpenTelemetry from browser apps to the .NET Aspire dashboard. For example, a browser-based single page app (SPA) can configure the JavaScript OpenTelemetry SDK to send structured logs, traces, and metrics created in the browser to the dashboard. Browser telemetry is displayed alongside server telemetry. :::image type=""content"" source=""media/dashboard-browser-telemetry.png"" lightbox=""media/dashboard-browser-telemetry.png"" alt-text=""Trace detail page with browser telemetry""::: For more information on configuring browser telemetry, see Enable browser telemetry documentation.', '<2-hop>\n\nRun the sample app To run the sample app, call the dotnet run command given the orchestrator app host AspireJavaScript.AppHost.csproj as the --project switch: dotnetcli dotnet run --project ./AspireJavaScript.AppHost/AspireJavaScript.AppHost.csproj The .NET Aspire dashboard launches in your default browser, and each client app endpoint displays under the Endpoints column of the Resources page. The following image depicts the dashboard for this sample app: :::image type=""content"" source=""media/aspire-dashboard-with-nodejs.png"" lightbox=""media/aspire-dashboard-with-nodejs.png"" alt-text="".NET Aspire dashboard with multiple JavaScript client apps.""::: The weatherapi service endpoint resolves to a Swagger UI page that documents the HTTP API. Each client app consumes this service to display the weather forecast data. You can view each client app by navigating to the corresponding endpoint in the .NET Aspire dashboard. Their screenshots and the modifications made from the template starting point are detailed in the following sections. In the same terminal session that you used to run the app, press Ctrl + C to stop the app. Explore the app host To help understand how each client app resource is orchestrated, look to the app host project. The app host requires the Aspire.Hosting.NodeJS NuGet package to host Node.js apps: :::code language=""xml"" highlight=""15,22-30"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.AppHost/AspireJavaScript.AppHost.csproj""::: The project file also defines a build target that ensures that the npm dependencies are installed before the app host is built. The app host code (Program.cs) declares the client app resources using the :::code source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.AppHost/Program.cs""::: The preceding code: Creates a Adds the ""weatherapi"" service as a project to the app host. Marks the HTTP endpoints as external. With a reference to the ""weatherapi"" service, adds the ""angular"", ""react"", and ""vue"" client apps as npm apps. Each client app is configured to run on a different container port, and uses the PORT environment variable to determine the port. All client apps also rely on a Dockerfile to build their container image and are configured to express themselves in the publishing manifest as a container from the For more information on inner-loop networking, see .NET Aspire inner-loop networking overview. For more information on deploying apps, see .NET Aspire manifest format for deployment tool builders. When the app host orchestrates the launch of each client app, it uses the npm run start command. This command is defined in the scripts section of the package.json file for each client app. The start script is used to start the client app on the specified port. Each client app relies on a proxy to request the ""weatherapi"" service. The proxy is configured in: The proxy.conf.js file for the Angular client. The webpack.config.js file for the React client. The vite.config.ts file for the Vue client. and passing environment variables to JavaScript-based apps, whether they are client or server apps, use parameters. For more information, see .NET Aspire: External parametersâ€”secrets. Use the OpenTelemetry JavaScript SDK To export OpenTelemetry logs, traces, and metrics from a Node.js server app, you use the OpenTelemetry JavaScript SDK. For a complete example of a Node.js server app using the OpenTelemetry JavaScript SDK, you can refer to the Code Samples: .NET Aspire Node.js sample page. Consider the sample\'s instrumentation.js file, which demonstrates how to configure the OpenTelemetry JavaScript SDK to export logs, traces, and metrics: :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithNode/NodeFrontend/instrumentation.js""::: [!TIP] To configure the .NET Aspire dashboard OTEL CORS settings, see the .NET Aspire dashboard OTEL CORS settings page. Summary While there are several considerations that are beyond the scope of this article, you learned how to build .NET Aspire projects that use Node.js and Node Package Manager (npm). You also learned how to use the See also Code Samples: .NET Aspire with Angular, React, and Vue Code Samples: .NET Aspire Node.js App']","The .NET Aspire dashboard can be utilized to manage JavaScript client applications by launching the dashboard through the orchestrator app host, specifically using the command 'dotnet run --project ./AspireJavaScript.AppHost/AspireJavaScript.AppHost.csproj'. This allows each client app endpoint to be displayed under the Endpoints column of the Resources page. The dashboard supports multiple JavaScript client apps, such as Angular, React, and Vue, which are configured to run on different container ports and rely on a Dockerfile for building their container images. Additionally, the OpenTelemetry JavaScript SDK plays a crucial role in exporting logs, traces, and metrics from Node.js server apps. It allows for structured telemetry data to be sent from browser-based applications to the .NET Aspire dashboard, enabling comprehensive monitoring and analysis of both client and server-side performance.",multi_hop_specific_query_synthesizer
56,What are the health check mechanisms provided by AspNetCore.HealthChecks.CosmosDb and AspNetCore.HealthChecks.Elasticsearch integrations in .NET Aspire?,"['<1-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: .NET Aspire Elasticsearch integration description: Learn how to use the .NET Aspire Elasticsearch integration, which includes both hosting and client integrations. ms.date: 10/11/2024 uid: search/elasticsearch-integration .NET Aspire Elasticsearch integration [!INCLUDE includes-hosting-and-client] Elasticsearch is a distributed, RESTful search and analytics engine, scalable data store, and vector database capable of addressing a growing number of use cases. The .NET Aspire Elasticsearch integration enables you to connect to existing Elasticsearch instances, or create new instances from .NET with the docker.io/library/elasticsearch container image. Hosting integration The Elasticsearch hosting integration models an Elasticsearch instance as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Elasticsearch PackageReference xml <PackageReference Include=""Aspire.Hosting.Elasticsearch"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Elasticsearch resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var elasticsearch = builder.AddElasticsearch(""elasticsearch""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/elasticsearch image, it creates a new Elasticsearch instance on your local machine. A reference to your Elasticsearch resource (the elasticsearch variable) is added to the ExampleProject. The Elasticsearch resource includes default credentials with a username of ""elastic"" and randomly generated password using the The [!TIP] If you\'d rather connect to an existing Elasticsearch instance, call Add Elasticsearch resource with data volume To add a data volume to the Elasticsearch resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var elasticsearch = builder.AddElasticsearch(""elasticsearch"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Elasticsearch data outside the lifecycle of its container. The data volume is mounted at the /usr/share/elasticsearch/data path in the Elasticsearch container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Elasticsearch resource with data bind mount To add a data bind mount to the Elasticsearch resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var elasticsearch = builder.AddElasticsearch(""elasticsearch"") .WithDataBindMount( source: @""C:\\Elasticsearch\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Elasticsearch data across container restarts. The data bind mount is mounted at the C:\\Elasticsearch\\Data on Windows (or /Elasticsearch/Data on Unix) path on the host machine in the Elasticsearch container. For more information on data bind mounts, see Docker docs: Bind mounts. Add Elasticsearch resource with password parameter When you want to explicitly provide the password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var password = builder.AddParameter(""password"", secret: true); var elasticsearch = builder.AddElasticsearch(""elasticsearch"", password); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Hosting integration health checks The Elasticsearch hosting integration automatically adds a health check for the Elasticsearch resource. The health check verifies that the Elasticsearch instance is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Elasticsearch NuGet package.']","The health check mechanisms provided by AspNetCore.HealthChecks.CosmosDb and AspNetCore.HealthChecks.Elasticsearch integrations in .NET Aspire automatically add health checks for their respective resources. For the Azure Cosmos DB integration, the health check verifies that the Cosmos DB is running and that a connection can be established to it. Similarly, the Elasticsearch hosting integration also automatically adds a health check that verifies the Elasticsearch instance is running and that a connection can be established to it.",multi_hop_specific_query_synthesizer
57,"What are the steps to install and configure the .NET Aspire Azure Cosmos DB integration, and how does it ensure health checks for the Cosmos DB resource?","['<1-hop>\n\nlibrary for interacting with Azure App Configuration . - Learn more : ðŸ“„ Azure Application Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ApplicationInsights - Client : N/A A library for interacting with Azure Application Insights . - Learn more : ðŸ“„ Azure Cosmos DB - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos A library for accessing Azure Cosmos DB databases with Entity Framework Core . - Learn more : ðŸ“„ Azure Cosmos DB - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.Azure.Cosmos A library for accessing Azure Cosmos DB databases. - Learn more : ðŸ“„ Azure Event Hubs - Hosting : ðŸ“¦ Aspire.Hosting.Azure.EventHubs - Client : ðŸ“¦ Aspire.Azure.Messaging.EventHubs A library for accessing Azure Event Hubs . - Learn more : ðŸ“„ Azure Functions - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Functions - Client : N/A A library for integrating with Azure Functions . - Learn more : ðŸ“„ Azure Key Vault - Hosting : ðŸ“¦ Aspire.Hosting.Azure.KeyVault - Client : ðŸ“¦ Aspire.Azure.Security.KeyVault A library for accessing Azure Key Vault . - Learn more : ðŸ“„ Azure Operational Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.OperationalInsights - Client : N/A A library for interacting with Azure Operational Insights . - Learn more : ðŸ“„ Azure AI OpenAI - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CognitiveServices - Client : ðŸ“¦ Aspire.Azure.AI.OpenAI A library for accessing Azure AI OpenAI or OpenAI functionality. - Learn more : ðŸ“„ Azure PostgreSQL - Hosting : ðŸ“¦ Aspire.Hosting.Azure.PostgreSQL - Client : N/A A library for interacting with Azure Database for PostgreSQL . - Learn more : ðŸ“„ Azure AI Search - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Search - Client : ðŸ“¦ Aspire.Azure.Search.Documents A library for accessing Azure AI Search functionality. - Learn more : ðŸ“„ Azure Service Bus - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ServiceBus - Client : ðŸ“¦ Aspire.Azure.Messaging.ServiceBus A library for accessing Azure Service Bus . - Learn more : ðŸ“„ Azure SignalR Service - Hosting : ðŸ“¦ Aspire.Hosting.Azure.SignalR - Client : Microsoft.Azure.SignalR A library for accessing Azure SignalR Service . - Learn more : ðŸ“„ Azure Blob Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Blobs A library for accessing Azure Blob Storage . - Learn more : ðŸ“„ Azure Storage Queues - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Queues A library for accessing Azure Storage Queues . - Learn more : ðŸ“„ Azure Table Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Data.Tables A library for accessing the Azure Table service. - Learn more : ðŸ“„ Azure Web PubSub - Hosting : ðŸ“¦ Aspire.Hosting.Azure.WebPubSub - Client : ðŸ“¦ Aspire.Azure.Messaging.WebPubSub A library for accessing the Azure Web PubSub service. Amazon Web Services (AWS) hosting integrations Integration docs and NuGet packages Description - Learn more : ðŸ“„ AWS Hosting - Hosting : ðŸ“¦ Aspire.Hosting.AWS - Client : N/A A library for modeling AWS resources . For more information, see GitHub: Aspire.Hosting.AWS library. Community Toolkit integrations [!NOTE] The Community Toolkit integrations are community-driven and maintained by the .NET Aspire community. These integrations are not officially supported by the .NET Aspire team. Integration docs and NuGet packages Description - Learn More : ðŸ“„ Azure Static Web Apps emulator - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps - Client : N/A A hosting integration for the Azure Static Web Apps emulator (Note: this does not support deployment of a project to Azure Static Web Apps). - Learn More : ðŸ“„ Bun hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Bun - Client : N/A A hosting integration for Bun apps. - Learn More : ðŸ“„ Deno hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Deno - Client : N/A A hosting integration for Deno apps. - Learn More : ðŸ“„ Go hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Golang - Client : N/A A hosting integration for Go apps. - Learn More : ðŸ“„ Java/Spring hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Java - Client : N/A A integration for running Java code in .NET Aspire either using the local JDK or using a container. - Learn More : ðŸ“„ Node.js hosting extensions - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.NodeJs.Extensions - Client : N/A An integration that contains some additional extensions for running Node.js applications - Learn More : ðŸ“„ Ollama - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Ollama - Client : ðŸ“¦ Aspire.CommunitToolkit.OllamaSharp An Aspire component leveraging the Ollama container with support for downloading a model on startup. - Learn More : ðŸ“„ Meilisearch hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Meilisearch - Client : ðŸ“¦ Aspire.CommunitToolkit.Meilisearch An Aspire component leveraging the Meilisearch container. - Learn More : ðŸ“„ Rust hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Rust - Client : N/A A hosting integration for Rust apps. - Learn More : ðŸ“„ SQL Database projects hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects - Client : N/A An Aspire hosting integration for SQL Database Projects. For more information, see .NET Aspire Community Toolkit.', '<2-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","To install and configure the .NET Aspire Azure Cosmos DB integration, you need to install the Aspire.Microsoft.Azure.Cosmos NuGet package in your client-consuming project. After installation, you can connect to existing Cosmos DB instances or create new ones using the Azure Cosmos DB emulator. In your Program.cs file, you should call builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); where the connectionName must match the name used when adding the Cosmos DB resource in the app host project. Additionally, the integration automatically adds a health check for the Cosmos DB resource, which verifies that the Cosmos DB is running and that a connection can be established to it, relying on the AspNetCore.HealthChecks.CosmosDb NuGet package.",multi_hop_specific_query_synthesizer
58,"In the context of using Azure Blob Storage and Azure Storage Blobs within a .NET Aspire Orleans application, how do these storage solutions facilitate the clustering and grain storage functionalities?","['<1-hop>\n\nCreate an Orleans client project In the Orleans client project, add the same NuGet packages: .NET CLI dotnetcli dotnet add package Aspire.Azure.Data.Tables dotnet add package Aspire.Azure.Storage.Blobs dotnet add package Microsoft.Orleans.Client dotnet add package Microsoft.Orleans.Persistence.AzureStorage dotnet add package Microsoft.Orleans.Clustering.AzureStorage PackageReference ```xml ``` Next, in the :::no-loc text=""Program.cs""::: file of your Orleans client project, add the Azure table storage client and then call :::code language=""csharp"" source=""snippets/Orleans/OrleansClient/Program.cs"" range=""6-7"" ::: The following code is a complete example of an Orleans client project. It calls the CounterGrain grain defined in the Orleans server example above: :::code language=""csharp"" source=""snippets/Orleans/OrleansClient/Program.cs"" ::: Enabling OpenTelemetry By convention, .NET Aspire solutions include a project for defining default configuration and behavior for your service. This project is called the service defaults project and templates create it with a name ending in ServiceDefaults. To configure Orleans for OpenTelemetry in .NET Aspire, apply configuration to your service defaults project following the Orleans observability guide. Modify the ConfigureOpenTelemetry method to add the Orleans meters and tracing instruments. The following code snippet shows the modified Extensions.cs file from a service defaults project that includes metrics and traces from Orleans. :::code language=""csharp"" source=""snippets/Orleans/OrleansServiceDefaults/Extensions.cs"" range=""40-68"" highlight=""15,19-20""::: Supported providers The Orleans Aspire integration supports a limited subset of Orleans providers today: Clustering: Redis Azure Storage Tables Persistence: Redis Azure Storage Tables Azure Storage Blobs Reminders: Redis Azure Storage Tables Grain directory: Redis Azure Storage Tables Streaming providers aren\'t supported as of Orleans version 8.1.0. Next steps [!div class=""nextstepaction""] Microsoft Orleans documentation Explore the Orleans voting sample app', '<2-hop>\n\ntitle: .NET Aspire Orleans integration description: Learn how to use the .NET Aspire Orleans hosting integration, which can configure and orchestrate Orleans from a .NET Aspire app host project. ms.date: 11/05/2024 uid: frameworks/orleans .NET Aspire Orleans integration Orleans has built-in support for .NET Aspire. .NET Aspire\'s application model lets you describe the services, databases, and other resources and infrastructure in your app and how they relate to each other. Orleans provides a straightforward way to build distributed applications that are elastically scalable and fault-tolerant. You can use .NET Aspire to configure and orchestrate Orleans and its dependencies, such as by providing Orleans with cluster membership and storage. Orleans is represented as a resource in .NET Aspire. Unlike other integrations, the Orleans integration doesn\'t create a container and doesn\'t require a separate client integration package. Instead you complete the Orleans configuration in the .NET Aspire app host project. [!NOTE] This integration requires Orleans version 8.1.0 or later. Hosting integration The Orleans hosting integration models an Orleans service as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Orleans PackageReference xml <PackageReference Include=""Aspire.Hosting.Orleans"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add an Orleans resource In your app host project, call :::code language=""csharp"" source=""snippets/Orleans/OrleansAppHost/Program.cs"" range=""12""::: Use Azure storage for clustering tables and grain storage In an Orleans app, the fundamental building block is a grain. Grains can have durable states. You must store the durable state for a grain somewhere. In a .NET Aspire application, Azure Blob Storage is one possible location. Orleans hosts register themselves in a database and use that database to find each other and form a cluster. They store which servers are members of which silos in a database table. You can use either relational or NoSQL databases to store this information. In a .NET Aspire application, a popular choice to store this table is Azure Table Storage. To configure Orleans with clustering and grain storage in Azure, install the ðŸ“¦ Aspire.Hosting.Azure.Storage NuGet package in the app host project: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Storage PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Storage"" Version=""*"" /> In your app host project, after you call :::code language=""csharp"" source=""snippets/Orleans/OrleansAppHost/Program.cs"" range=""3-14"" highlight=""4-5,11-12""::: The preceding code tells Orleans that any service referencing it must also reference the clusteringTable resource. Add an Orleans server project in the app host Now you can add a new project, enrolled in .NET Aspire orchestration, to your solution as an Orleans server. It will take part in the Orleans cluster as a silo with constituent grains. Reference the Orleans resource from your server project using WithReference(orleans). When you reference the Orleans resource from your service, those resources are also referenced: :::code language=""csharp"" source=""snippets/Orleans/OrleansAppHost/Program.cs"" range=""16-22""::: Add an Orleans client project in the app host Orleans clients communicate with grains hosted on Orleans servers. In a .NET Aspire app, for example, you might have a front-end Web site that calls grains in an Orleans cluster. Reference the Orleans resource from your Orleans client using WithReference(orleans.AsClient()). :::code language=""csharp"" source=""snippets/Orleans/OrleansAppHost/Program.cs"" range=""24-29""::: Create the Orleans server project Now that the app host project is completed, you can implement the Orleans server project. Let\'s start by adding the necessary NuGet packages: .NET CLI In the folder for the Orleans server project, run these commands: dotnetcli dotnet add package Aspire.Azure.Data.Tables dotnet add package Aspire.Azure.Storage.Blobs dotnet add package Microsoft.Orleans.Server dotnet add package Microsoft.Orleans.Persistence.AzureStorage dotnet add package Microsoft.Orleans.Clustering.AzureStorage PackageReference In the configuration file for the Orleans server project, add these package references: ```xml ``` Next, in the :::no-loc text=""Program.cs""::: file of your Orleans server project, add the Azure Storage blob and tables clients and then call :::code language=""csharp"" source=""snippets/Orleans/OrleansServer/Program.cs"" range=""4-9"" ::: The following code is a complete example of an Orleans server project, including a grain named CounterGrain: :::code language=""csharp"" source=""snippets/Orleans/OrleansServer/Program.cs"" :::']","In a .NET Aspire Orleans application, Azure Blob Storage serves as a potential location for storing the durable state of grains, which are fundamental building blocks in Orleans. This allows grains to maintain their state across different instances. Additionally, Orleans hosts register themselves in a database, which can be stored in Azure Table Storage, to find each other and form a cluster. This database table keeps track of which servers are members of which silos, enabling effective clustering. Therefore, Azure Blob Storage and Azure Storage Blobs play crucial roles in ensuring that both the state of grains and the clustering information are securely stored and easily accessible.",multi_hop_specific_query_synthesizer
59,"How does the integration of Azure Storage Blobs and Azure Storage Account work in the .NET Aspire Azure Functions integration, particularly in the context of testing the app locally?","['<1-hop>\n\ntitle: .NET Aspire Azure Functions integration (Preview) description: Learn how to integrate Azure Functions with .NET Aspire. ms.date: 11/13/2024 zone_pivot_groups: dev-environment .NET Aspire Azure Functions integration (Preview) [!INCLUDE includes-hosting] [!IMPORTANT] The .NET Aspire Azure Functions integration is currently in preview and is subject to change. Azure Functions is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. The .NET Aspire Azure Functions integration enables you to develop, debug, and orchestrate an Azure Functions .NET project as part of the app host. It\'s expected that you\'ve installed the required Azure tooling: :::zone pivot=""visual-studio"" Configure Visual Studio for Azure development with .NET :::zone-end :::zone pivot=""vscode"" Configure Visual Studio Code for Azure development with .NET :::zone-end :::zone pivot=""dotnet-cli"" Install the Azure Functions Core Tools :::zone-end Supported scenarios The .NET Aspire Azure Functions integration has several key supported scenarios. This section outlines the scenarios and provides details related to the implementation of each approach. Supported triggers The following table lists the supported triggers for Azure Functions in the .NET Aspire integration: Trigger Attribute Details Azure Event Hubs trigger EventHubTrigger ðŸ“¦ Aspire.Hosting.Azure.EventHubs Azure Service Bus trigger ServiceBusTrigger ðŸ“¦ Aspire.Hosting.Azure.ServiceBus Azure Storage Blobs trigger BlobTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage Azure Storage Queues trigger QueueTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage HTTP trigger HttpTrigger Supported without any additional resource dependencies. Timer trigger TimerTrigger Supported without any additional resource dependenciesâ€”relies on implicit host storage. [!IMPORTANT] Other Azure Functions triggers and bindings aren\'t currently supported in the .NET Aspire Azure Functions integration. Deployment Currently, deployment is supported only to containers on Azure Container Apps (ACA) using the SDK container publish function in Microsoft.Azure.Functions.Worker.Sdk. This deployment methodology doesn\'t currently support KEDA-based autoscaling. Configure external HTTP endpoints To make HTTP triggers publicly accessible, call the', '<2-hop>\n\nRun and test the app locally The sample app is now ready for testing. Verify that the submitted form data is sent to Azure Blob Storage and Azure Queue Storage by completing the following steps: Visual Studio Press the run button at the top of Visual Studio to launch your .NET Aspire project dashboard in the browser. On the resources page, in the aspirestorage.web row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: .NET CLI In a terminal window at the root of your project, use the dotnet run command to start the app: dotnetcli dotnet run --project AspireStorage.AppHost On the resources page, in the aspirestorage row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: Summary The example app that you built demonstrates persisting blobs from an ASP.NET Core Blazor Web App and processing queues in a .NET Worker Service. Your app connects to Azure Storage using .NET Aspire integrations. The app sends the support tickets to a queue for processing and uploads an attachment to storage. :::zone pivot=""azurite"" Since you choose to use Azurite, there\'s no need to clean up these resources when you\'re done testing them, as you created them locally in the context of an emulator. The emulator enabled you to test your app locally without incurring any costs, as no Azure resources were provisioned or created. :::zone-end :::zone pivot=""azure-portal,azure-cli"" [!INCLUDE clean-up-resources] :::zone-end']","In the .NET Aspire Azure Functions integration, Azure Storage Blobs and Azure Storage Account are utilized to persist data and manage queues. When testing the app locally, users can verify that submitted form data is sent to Azure Blob Storage and Azure Queue Storage. This is done by running the .NET Aspire project in Visual Studio, where users can enter sample data and upload files. After submission, the data is processed, and users can check the Azure portal to navigate to the Storage browser in their Azure Storage Account. They can then view the uploaded files in the Documents container and verify the processing of messages on the queue by checking the Project logs in the .NET Aspire dashboard.",multi_hop_specific_query_synthesizer
60,What are the steps to add an Oracle database resource in your app host project and how do you configure the connection string for the Oracle client integration?,"['<1-hop>\n\nClient integration You need an Oracle database and connection string for accessing the database. To get started with the .NET Aspire Oracle client integration, install the ðŸ“¦ Aspire.Oracle.EntityFrameworkCore NuGet package in the client-consuming project, that is, the project for the application that uses the Oracle client. The Oracle client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Oracle.EntityFrameworkCore PackageReference xml <PackageReference Include=""Aspire.Oracle.EntityFrameworkCore"" Version=""*"" /> Add Oracle client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(connectionName: ""oracledb""); [!TIP] The connectionName parameter must match the name used when adding the Oracle database resource in the app host project. In other words, when you call AddDatabase and provide a name of oracledb that same name should be used when calling AddOracleDatabaseDbContext. For more information, see Add Oracle server and database resources. You can then retrieve the csharp public class ExampleService(ExampleDbContext context) { // Use database context... } For more information on dependency injection, see .NET dependency injection. Add Oracle database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( connectionName: ""oracledb"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the Configuration The .NET Aspire Oracle Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling builder.AddOracleDatabaseDbContext<TContext>(): csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(""oracleConnection""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""oracleConnection"": ""Data Source=TORCL;User Id=OracleUser;Password=Non-default-P@ssw0rd;"" } } The EnrichOracleDatabaseDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it is called. For more information, see the ODP.NET documentation. Use configuration providers The .NET Aspire Oracle Entity Framework Core integration supports The following is an example of an :::no-loc text=""appsettings.json""::: that configures some of the available options: json { ""Aspire"": { ""Oracle"": { ""EntityFrameworkCore"": { ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableRetry"": false, ""CommandTimeout"": 30 } } } } [!TIP] The CommandTimeout property is in seconds. When set as shown in the preceding example, the timeout is 30 seconds. Use inline delegates You can also pass the Action<OracleEntityFrameworkCoreSettings> delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>( ""oracle"", static settings => settings.DisableHealthChecks = true); or csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( static settings => settings.DisableHealthChecks = true); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the Oracle database to connect to. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. DisableRetry A boolean value that indicates whether command retries should be disabled or not. CommandTimeout The time in seconds to wait for the command to execute. [!INCLUDE integration-health-checks] By default, the .NET Aspire Oracle Entity Framework Core integration handles the following: Checks if the If so, adds the DbContextHealthCheck, which calls EF Core\'s [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Oracle Entity Framework Core integration uses the following log categories: Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Database.Connection Microsoft.EntityFrameworkCore.Database.Transaction Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Migrations Microsoft.EntityFrameworkCore.Model Microsoft.EntityFrameworkCore.Model.Validation Microsoft.EntityFrameworkCore.Query Microsoft.EntityFrameworkCore.Update Tracing The .NET Aspire Oracle Entity Framework Core integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Oracle Entity Framework Core integration currently supports the following metrics: Microsoft.EntityFrameworkCore See also Oracle Database Oracle Database Documentation Entity Framework Core docs .NET Aspire integrations .NET Aspire GitHub repo', '<2-hop>\n\nAdd Oracle server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Oracle database container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the container-registry.oracle.com/database/free image, it creates a new Oracle server on your local machine. A reference to your Oracle resource builder (the oracle variable) is used to add a database. The database is named oracledb and then added to the ExampleProject. The Oracle resource includes a random password generated using the The [!TIP] If you\'d rather connect to an existing Oracle server, call Add Oracle resource with password parameter The Oracle resource includes default credentials with a random password. Oracle supports configuration-based default passwords by using the environment variable ORACLE_PWD. When you want to provide a password explicitly, you can provide it as a parameter: ```csharp var password = builder.AddParameter(""password"", secret: true); var oracle = builder.AddOracle(""oracle"", password) .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddOracle API, and internally assigns the parameter to the ORACLE_PWD environment variable of the Oracle container. The password parameter is usually specified as a user secret: json { ""Parameters"": { ""password"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Oracle resource with data volume To add a data volume to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataVolume() .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracle""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Oracle data outside the lifecycle of its container. The data volume is mounted at the /opt/oracle/oradata path in the Oracle container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add Oracle resource with data bind mount To add a data bind mount to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataBindMount(source: @""C:\\Oracle\\Data""); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Oracle data across container restarts. The data bind mount is mounted at the C:\\Oracle\\Data on Windows (or /Oracle/Data on Unix) path on the host machine in the Oracle container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Oracle hosting integration automatically adds a health check for the Oracle resource. The health check verifies that the Oracle server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Oracle NuGet package.']","To add an Oracle database resource in your app host project, you first need to call `var builder = DistributedApplication.CreateBuilder(args);` and then add the Oracle resource using `var oracle = builder.AddOracle(""oracle"").WithLifetime(ContainerLifetime.Persistent);`. After that, you can add the database by calling `var oracledb = oracle.AddDatabase(""oracledb"");`. Once you have added all resources, you can run the app. For configuring the connection string for the Oracle client integration, you need to provide the connection string in the `ConnectionStrings` configuration section of your appsettings.json file, like this: `json { ""ConnectionStrings"": { ""oracleConnection"": ""Data Source=TORCL;User Id=OracleUser;Password=Non-default-P@ssw0rd;"" } }`. When calling `builder.AddOracleDatabaseDbContext<ExampleDbContext>(""oracleConnection"");`, the connection string will be retrieved from this configuration.",multi_hop_specific_query_synthesizer
61,What are the key features of the .NET Aspire Azure Queue Storage integration and how can it be configured in a .NET application?,"['<1-hop>\n\nCommunity Toolkit packages Moving from Aspire.CommunityToolkit to CommunityToolkit.Aspire Moving package links to be Azure Artifacts not GitHub Packages Rewrite the non-Azure messaging integration articles Community Toolkit .NET Aspire orchestration overview - Rewrite the non-Azure messaging integration articles Dashboard configuration Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Enable browser telemetry minor text fixes Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Security considerations for running the .NET Aspire dashboard - Various dashboard and telemetry docs updates Standalone .NET Aspire dashboard - Various dashboard and telemetry docs updates Tutorial: Use the .NET Aspire dashboard with Python apps - Various dashboard and telemetry docs updates Storage Updated articles .NET Aspire Azure Blob Storage integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Data Tables integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Queue Storage integration - Rewrite the non-Azure messaging integration articles Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations - Rewrite the non-Azure messaging integration articles Database Updated articles .NET Aspire Azure Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Microsoft Entity Framework Core Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Milvus database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MongoDB database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MySQL database integration - Rewrite the non-Azure messaging integration articles .NET Aspire Oracle Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire Pomelo MySQL Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL Entity Framework Core integration Rewrite both PostgreSQL integration docs Update postgresql-entity-framework-integration.md Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL integration Rewrite both PostgreSQL integration docs Rewrite the non-Azure messaging integration articles .NET Aspire Qdrant integration - Rewrite the non-Azure messaging integration articles .NET Aspire SQL Server integration - Rewrite the non-Azure messaging integration articles .NET Aspire SqlServer Entity Framework Core integration - Rewrite the non-Azure messaging integration articles Messaging New articles .NET Aspire RabbitMQ integration Updated articles .NET Aspire Apache Kafka integration Fix Kafka integration documentation Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire Azure Event Hubs integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Service Bus integration Rewrite the non-Azure messaging integration articles Use correct method name in ServiceBus .NET Aspire Azure Web PubSub integration - Rewrite the non-Azure messaging integration articles .NET Aspire NATS integration Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire RabbitMQ integration Rewrite both PostgreSQL integration docs Redis rewrite Demote messaging integration headings Rewrite the non-Azure messaging integration articles Caching Updated articles .NET Aspire Redis distributed caching integration Updates to other Redis-protocol docs Rewrite the non-Azure messaging integration articles .NET Aspire Redis integration Updates to other Redis-protocol docs Redis rewrite Rewrite the non-Azure messaging integration articles .NET Aspire Redis output caching integration Updates to other Redis-protocol docs Rewrite the non-Azure messaging integration articles Stack Exchange Redis caching overview - Updates to other Redis-protocol docs Tutorial: Implement caching with .NET Aspire integrations - Rewrite the non-Azure messaging integration articles Security Updated articles .NET Aspire Azure Key Vault integration - Rewrite the non-Azure messaging integration articles Deployment Updated articles Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide) - Fix typo in aca-deployment-azd-in-depth.md Use Application Insights for .NET Aspire telemetry - Rewrite the non-Azure messaging integration articles Use custom Bicep templates - Rewrite the non-Azure messaging integration articles', '<2-hop>\n\ntitle: .NET Aspire Azure Queue Storage integration description: This article describes the .NET Aspire Azure Queue Storage integration features and capabilities. ms.date: 12/09/2024 uid: storage/azure-queue-storage-integration .NET Aspire Azure Queue Storage integration [!INCLUDE includes-hosting-and-client] Azure Queue Storage is a service for storing large numbers of messages that can be accessed from anywhere in the world via authenticated calls. The .NET Aspire Azure Queue Storage integration enables you to connect to existing Azure Queue Storage instances or create new instances from .NET applications. Hosting integration [!INCLUDE storage-app-host] Add Azure Queue Storage resource In your app host project, register the Azure Queue Storage integration by chaining a call to ```csharp var builder = DistributedApplication.CreateBuilder(args); var queues = builder.AddAzureStorage(""storage"") .AddQueues(""queues""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Adds an Azure Storage resource named storage. Adds a queue named queues to the storage resource. Adds the storage resource to the ExampleProject and waits for it to be ready before starting the project. [!INCLUDE storage-hosting-health-checks] Client integration To get started with the .NET Aspire Azure Queue Storage client integration, install the ðŸ“¦ Aspire.Azure.Storage.Queues NuGet package in the client-consuming project, that is, the project for the application that uses the Azure Queue Storage client. The Azure Queue Storage client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Azure.Storage.Queues PackageReference xml <PackageReference Include=""Aspire.Azure.Storage.Queues"" Version=""*"" /> Add Azure Queue Storage client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureQueueClient(""queue""); You can then retrieve the QueueServiceClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(QueueServiceClient client) { // Use client... } Configuration The .NET Aspire Azure Queue Storage integration provides multiple options to configure the QueueServiceClient based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddAzureQueueClient(""queue""); Then the connection string is retrieved from the ConnectionStrings configuration section, and two connection formats are supported: Service URI The recommended approach is to use a ServiceUri, which works with the json { ""ConnectionStrings"": { ""queue"": ""https://{account_name}.queue.core.windows.net/"" } } Connection string Alternatively, an Azure Storage connection string can be used. json { ""ConnectionStrings"": { ""queue"": ""AccountName=myaccount;AccountKey=myaccountkey"" } } For more information, see Configure Azure Storage connection strings. Use configuration providers The .NET Aspire Azure Queue Storage integration supports json { ""Aspire"": { ""Azure"": { ""Storage"": { ""Queues"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Diagnostics"": { ""ApplicationId"": ""myapp"" } } } } } } } For the complete Azure Storage Queues client integration JSON schema, see Aspire.Azure.Data.Queues/ConfigurationSchema.json. Use inline delegates You can also pass the Action<AzureStorageQueuesSettings> configureSettings delegate to set up some or all the options inline, for example to configure health checks: csharp builder.AddAzureQueueClient( ""queue"", settings => settings.DisableHealthChecks = true); You can also set up the csharp builder.AddAzureQueueClient( ""queue"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Diagnostics.ApplicationId = ""myapp"")); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Queue Storage integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","The .NET Aspire Azure Queue Storage integration allows you to connect to existing Azure Queue Storage instances or create new ones from .NET applications. Key features include the ability to store large numbers of messages accessible via authenticated calls. To configure it in a .NET application, you can register the Azure Queue Storage integration by chaining a call in your app host project, such as: `var builder = DistributedApplication.CreateBuilder(args); var queues = builder.AddAzureStorage(""storage"").AddQueues(""queues"");`. Additionally, to get started with the client integration, you need to install the `Aspire.Azure.Storage.Queues` NuGet package and add the Azure Queue Storage client in your `Program.cs` file using `builder.AddAzureQueueClient(""queue"");`. Configuration options include using a connection string or configuration providers to set up the `QueueServiceClient` based on your project requirements.",multi_hop_specific_query_synthesizer
62,How do you add a Postgres database to a .NET Aspire project and what command is used to provision the necessary Azure resources?,"['<1-hop>\n\nDeploy application updates When the azd up command is executed the underlying Azure resources are provisioned and a container image is built and deployed to the container apps hosting the .NET Aspire project. Typically once development is underway and Azure resources are deployed it won\'t be necessary to provision Azure resources every time code is updatedâ€”this is especially true for the developer inner loop. To speed up deployment of code changes, azd supports deploying code updates in the container image. This is done using the azd deploy command: azdeveloper azd deploy [!INCLUDE azd-deploy-output] It\'s not necessary to deploy all services each time. azd understands the .NET Aspire project model, it\'s possible to deploy just one of the services specified using the following command: azdeveloper azd deploy webfrontend For more information, see Azure Developer CLI reference: azd deploy. Deploy infrastructure updates Whenever the dependency structure within a .NET Aspire project changes, azd must re-provision the underlying Azure resources. The azd provision command is used to apply these changes to the infrastructure. To see this in action, update the :::no-loc text=""Program.cs""::: file in the AppHost project to the following: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); // Add the locations database. var locationsdb = builder.AddPostgres(""db"").AddDatabase(""locations""); // Add the locations database reference to the API service. var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` Save the file and issue the following command: azdeveloper azd provision The azd provision command updates the infrastructure by creating a container app to host the Postgres database. The azd provision command didn\'t update the connection strings for the apiservice container. In order to have connection strings updated to point to the newly provisioned Postgres database the azd deploy command needs to be invoked again. When in doubt, use azd up to both provision and deploy. Clean up resources Remember to clean up the Azure resources that you\'ve created during this walkthrough. Because `azd knows the resource group in which it created the resources it can be used to spin down the environment using the following command: azdeveloper azd down The previous command may take some time to execute, but when completed the resource group and all its resources should be deleted. [!INCLUDE azd-down-output]', '<2-hop>\n\ntitle: Create custom .NET Aspire hosting integrations description: Learn how to create a custom .NET Aspire hosting integration for an existing containerized application. ms.date: 11/11/2024 ms.topic: how-to Create custom .NET Aspire hosting integrations .NET Aspire improves the development experience by providing reusable building blocks that can be used to quickly arrange application dependencies and expose them to your own code. One of the key building blocks of an Aspire-based application is the resource. Consider the code below: ```csharp var builder = DistributedApplication.CreateBuilder(args); var redis = builder.AddRedis(""cache""); var db = builder.AddPostgres(""pgserver"") .AddDatabase(""inventorydb""); builder.AddProject In the preceding code there are four resources represented: cache: A Redis container. pgserver: A Postgres container. inventorydb: A database hosted on pgserver. inventoryservice: An ASP.NET Core application. Most .NET Aspire-related code that the average developer writes, centers around adding resources to the app model and creating references between them. Key elements of a .NET Aspire custom resource Building a custom resource in .NET Aspire requires the following: A custom resource type that implements An extension method for When custom resource requires optional configuration, developers may wish to implement With* suffixed extension methods to make these configuration options discoverable using the builder pattern. A practical example: MailDev To help understand how to develop custom resources, this article shows an example of how to build a custom resource for MailDev. MailDev is an open-source tool which provides a local mail server designed to allow developers to test e-mail sending behaviors within their app. For more information, see the MailDev GitHub repository. In this example you create a new .NET Aspire project as a test environment for the MailDev resource that you create. While you can create custom resources in existing .NET Aspire projects it\'s a good idea to consider whether the custom resource might be used across multiple .NET Aspire-based solutions and should be developed as a reusable integration. Set up the starter project Create a new .NET Aspire project that is used to test out the new resource that we\'re developing. dotnetcli dotnet new aspire -o MailDevResource cd MailDevResource dir Once the project is created, you should see a listing containing the following: MailDevResource.AppHost: The app host used to test out the custom resource. MailDevResource.ServiceDefaults: The service defaults project for use in service-related projects. MailDevResource.sln: The solution file referencing both projects. Verify that the project can build and run successfully by executing the following command: dotnetcli dotnet run --project MailDevResource.AppHost/MailDevResource.AppHost.csproj The console output should look similar to the following: dotnetcli Building... info: Aspire.Hosting.DistributedApplication[0] Aspire version: 9.0.0 info: Aspire.Hosting.DistributedApplication[0] Distributed application starting. info: Aspire.Hosting.DistributedApplication[0] Application host directory is: ..\\docs-aspire\\docs\\extensibility\\snippets\\MailDevResource\\MailDevResource.AppHost info: Aspire.Hosting.DistributedApplication[0] Now listening on: https://localhost:17251 info: Aspire.Hosting.DistributedApplication[0] Login to the dashboard at https://localhost:17251/login?t=928db244c720c5022a7a9bf5cf3a3526 info: Aspire.Hosting.DistributedApplication[0] Distributed application started. Press Ctrl+C to shut down. Select the dashboard link in the browser to see the .NET Aspire dashboard: :::image type=""content"" source=""media/maildevresource-empty-dashboard.png"" lightbox=""media/maildevresource-empty-dashboard.png"" alt-text=""A screenshot of the empty .NET Aspire dashboard for test project.""::: Press Ctrl+C to shut down the app (you can close the browser tab).']","To add a Postgres database to a .NET Aspire project, you can use the following code snippet: `var locationsdb = builder.AddPostgres(""db"").AddDatabase(""locations"");`. This code adds a Postgres container and a database named 'locations' to the project. To provision the necessary Azure resources after making changes to the project, you would use the command `azdeveloper azd provision`.",multi_hop_specific_query_synthesizer
63,What are the differences in resource types when using Azure SQL and Azure PostgreSQL with the Azure SDK for .NET?,"['<1-hop>\n\nLocal containers Some Azure services can be run locally in containers. To run an Azure service locally in a container, chain a call to the RunAsContainer method on the Azure resource builder. This method configures the Azure resource to run locally in a container instead of the actual Azure service. Currently, .NET Aspire supports the following Azure services as containers: Hosting integration Details Azure Cache for Redis Call on the IResourceBuilder<AzureRedisCacheResource> to configure it to run locally in a container, based on the docker.io/library/redis image. Azure PostgreSQL Flexible Server Call on the IResourceBuilder<AzurePostgresFlexibleServerResource> to configure it to run locally in a container, based on the docker.io/library/postgres image. Azure SQL Server Call on the IResourceBuilder<AzureSqlServerResource> to configure it to run locally in a container, based on the mcr.microsoft.com/mssql/server image. [!NOTE] Like emulators, calling RunAsContainer on an Azure resource builder doesn\'t impact the publishing manifest. When you publish your app, the generated Bicep file reflects the actual Azure service, not the local container. Understand Azure integration APIs .NET Aspire\'s strength lies in its ability to provide an amazing developer inner-loop. The Azure integrations are no different. They provide a set of common APIs and patterns that are shared across all Azure resources. These APIs and patterns are designed to make it easy to work with Azure resources in a consistent manner. In the preceding containers section, you saw how to run Azure services locally in containers. If you\'re familiar with .NET Aspire, you might wonder how calling AddAzureRedis(""redis"").RunAsContainer() to get a local docker.io/library/redis container differs from AddRedis(""redis"")â€”as they both result in the same local container. The answer is that there\'s no difference when running locally. However, when they\'re published you get different resources: API Run mode Publish mode AddAzureRedis(""redis"").RunAsContainer() Local Redis container Azure Cache for Redis AddRedis(""redis"") Local Redis container Azure Container App with Redis image The same is true for SQL and PostgreSQL services: API Run mode Publish mode AddAzurePostgresFlexibleServer(""postgres"").RunAsContainer() Local PostgreSQL container Azure PostgreSQL Flexible Server AddPostgres(""postgres"") Local PostgreSQL container Azure Container App with PostgreSQL image AddAzureSqlServer(""sql"").RunAsContainer() Local SQL Server container Azure SQL Server AddSqlServer(""sql"") Local SQL Server container Azure Container App with SQL Server image For more information on the difference between run and publish modes, see .NET Aspire app host: Execution context. Infrastructure as code The Azure SDK for .NET provides the ðŸ“¦ Azure.Provisioning NuGet package and a suite of service-specific Azure provisioning packages. These Azure provisioning libraries make it easy to declaratively specify Azure infrastructure natively in .NET. Their APIs enable you to write object-oriented infrastructure in C#, resulting in Bicep. Bicep is a domain-specific language (DSL) for deploying Azure resources declaratively. While it\'s possible to provision Azure resources manually, .NET Aspire simplifies the process by providing a set of APIs to express Azure resources. These APIs are available as extension methods in .NET Aspire Azure hosting libraries, extending the Since .NET Aspire models Azure resources within Azure hosting integrations, the Azure SDK is used to provision these resources. Bicep files are generated that define the Azure resources you need. The generated Bicep files are output alongside the manifest file when you publish your app. There are several ways to influence the generated Bicep files: Azure.Provisioning customization: Configure infrastructure: Customize Azure resource infrastructure. Add Azure infrastructure: Manually add Azure infrastructure to your app host. Use custom Bicep templates: Reference Bicep files: Add a reference to a Bicep file on disk. Reference Bicep inline: Add an inline Bicep template. Local provisioning and Azure.Provisioning To avoid conflating terms and to help disambiguate ""provisioning,"" it\'s important to understand the distinction between local provisioning and Azure provisioning: Local provisioning: By default, when you call any of the Azure hosting integration APIs to add Azure resources, the Azure.Provisioning: Azure.Provisioning refers to the NuGet package, and is a set of libraries that lets you use C# to generate Bicep. The Azure hosting integrations in .NET Aspire use these libraries under the covers to generate Bicep files that define the Azure resources you need. For more information, see Azure.Provisioning customization. Azure.Provisioning customization All .NET Aspire Azure hosting integrations expose various Azure resources, and they\'re all subclasses of the Configure infrastructure Regardless of the Azure resource you\'re working with, to configure its underlying infrastructure, you chain a call to the Consider the following example: :::code language=""csharp"" source=""../snippets/azure/AppHost/Program.ConfigureInfrastructure.cs"" id=""infra""::: The preceding code: Adds a parameter named storage-sku. Adds Azure Storage with the Chains a call to ConfigureInfrastructure to customize the Azure Storage infrastructure: Gets the provisionable resources. Filters to a single Assigns the storage-sku parameter to the This exemplifies flowing an external parameter into the Azure Storage infrastructure, resulting in the generated Bicep file reflecting the desired configuration. Add Azure infrastructure Not all Azure services are exposed as .NET Aspire integrations. While they might be at a later time, you can still provision services that are available in Azure.Provisioning.* libraries. Imagine a scenario where you have worker service that\'s responsible for managing an Azure Container Registry. Now imagine that an app host project takes a dependency on the ðŸ“¦ Azure.Provisioning.ContainerRegistry NuGet package. You can use the AddAzureInfrastructure API to add the Azure Container Registry infrastructure to your app host: :::code language=""csharp"" source=""../snippets/azure/AppHost/Program.AddAzureInfra.cs"" id=""add""::: The preceding code: Calls Provides a configureInfrastructure delegate to customize the Azure Container Registry infrastructure: Instantiates a Adds the Azure Container Registry service to the infra variable. Instantiates a Adds the output to the infra variable. Adds a project named worker to the builder. Chains a call to The functionality demonstrates how to add Azure infrastructure to your app host project, even if the Azure service isn\'t directly exposed as a .NET Aspire integration. It further shows how to flow the output of the Azure Container Registry into the environment of a dependent project. Consider the resulting Bicep file: :::code language=""bicep"" source=""../snippets/azure/AppHost/acr.module.bicep""::: The Bicep file reflects the desired configuration of the Azure Container Registry, as defined by the AddAzureInfrastructure API. Use custom Bicep templates When you\'re targeting Azure as your desired cloud provider, you can use Bicep to define your infrastructure as code.', '<2-hop>\n\nAzure-specific resource types The following resources are available in the ðŸ“¦ Aspire.Hosting.Azure NuGet package. App Model usage Manifest resource type Heading link azure.bicep.v0 Azure App Configuration resource types azure.bicep.v0 Azure Key Vault resource type AddAzureRedis azure.bicep.v0 Azure Redis resource types azure.bicep.v0 Azure Service Bus resource type AddAzureSqlServer(...) azure.bicep.v0 Azure SQL resource types AddAzureSqlServer(...).AddDatabase(...) value.v0 Azure SQL resource types AddAzurePostgresFlexibleServer(...) azure.bicep.v0 Azure Postgres resource types AddAzurePostgresFlexibleServer(...).AddDatabase(...) value.v0 Azure Postgres resource types azure.storage.v0 Azure Storage resource types value.v0 Azure Storage resource types value.v0 Azure Storage resource types value.v0 Azure Storage resource types Azure Key Vault resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureKeyVault(""keyvault1""); ``` Example manifest: json { ""resources"": { ""keyvault1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{keyvault1.outputs.vaultUri}"", ""path"": ""aspire.hosting.azure.bicep.keyvault.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""vaultName"": ""keyvault1"" } } } } Azure Service Bus resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureServiceBus(""sb1"") .AddTopic(""topic1"", []) .AddTopic(""topic2"", []) .AddQueue(""queue1"") .AddQueue(""queue2""); ``` Example manifest: json { ""resources"": { ""sb1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{sb1.outputs.serviceBusEndpoint}"", ""path"": ""aspire.hosting.azure.bicep.servicebus.bicep"", ""params"": { ""serviceBusNamespaceName"": ""sb1"", ""principalId"": """", ""principalType"": """", ""queues"": [ ""queue1"", ""queue2"" ], ""topics"": [ { ""name"": ""topic1"", ""subscriptions"": [] }, { ""name"": ""topic2"", ""subscriptions"": [] } ] } } } } Azure Storage resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""images""); storage.AddBlobs(""blobs""); storage.AddQueues(""queues""); storage.AddTables(""tables""); ``` Example manifest: json { ""resources"": { ""images"": { ""type"": ""azure.bicep.v0"", ""path"": ""aspire.hosting.azure.bicep.storage.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""storageName"": ""images"" } }, ""blobs"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.blobEndpoint}"" }, ""queues"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.queueEndpoint}"" }, ""tables"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.tableEndpoint}"" } } } Azure Redis resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureRedis(""azredis1""); ``` Example manifest: json { ""resources"": { ""azredis"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{azredis.outputs.connectionString}"", ""path"": ""azredis.module.bicep"", ""params"": { ""principalId"": """", ""principalName"": """" } } } } Azure App Configuration resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureAppConfiguration(""appconfig1""); ``` Example manifest: json { ""resources"": { ""appconfig1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{appconfig1.outputs.appConfigEndpoint}"", ""path"": ""aspire.hosting.azure.bicep.appconfig.bicep"", ""params"": { ""configName"": ""appconfig1"", ""principalId"": """", ""principalType"": """" } } } } Azure SQL resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureSqlServer(""sql"") .AddDatabase(""inventory""); ``` Example manifest: json { ""resources"": { ""sql"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""Server=tcp:{sql.outputs.sqlServerFqdn},1433;Encrypt=True;Authentication=\\u0022Active Directory Default\\u0022"", ""path"": ""sql.module.bicep"", ""params"": { ""principalId"": """", ""principalName"": """" } }, ""inventory"": { ""type"": ""value.v0"", ""connectionString"": ""{sql.connectionString};Database=inventory"" } } } Azure Postgres resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzurePostgresFlexibleServer(""postgres"") .AddDatabase(""db""); ``` Example manifest: json { ""resources"": { ""postgres"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{postgres.outputs.connectionString}"", ""path"": ""postgres.module.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""principalName"": """" } }, ""db"": { ""type"": ""value.v0"", ""connectionString"": ""{postgres.connectionString};Database=db"" } } } Resource types supported in the Azure Developer CLI The Azure Developer CLI (azd) is a tool that can be used to deploy .NET Aspire projects to Azure Container Apps. With the azure.bicep.v0 resource type, cloud-agnostic resource container types can be mapped to Azure-specific resources. The following table lists the resource types that are supported in the Azure Developer CLI: Name Cloud-agnostic API Azure API Redis AddAzureRedis Postgres AddAzurePostgresFlexibleServer SQL Server AddAzureSqlServer When resources as configured as Azure resources, the azure.bicep.v0 resource type is generated in the manifest. For more information, see Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide). See also .NET Aspire overview .NET Aspire orchestration overview .NET Aspire integrations overview Service discovery in .NET Aspire']","When using the Azure SDK for .NET, the resource types for Azure SQL and Azure PostgreSQL differ in their configuration methods. For Azure SQL, you would use the method AddAzureSqlServer(""sql"").AddDatabase(""inventory"") to configure the SQL Server and add a database named 'inventory'. In contrast, for Azure PostgreSQL, the method used is AddAzurePostgresFlexibleServer(""postgres"").AddDatabase(""db"") to set up the PostgreSQL server and add a database named 'db'. Both methods generate corresponding Bicep files that define the Azure resources needed for deployment.",multi_hop_specific_query_synthesizer
64,"How can you integrate SQL Server with an existing .NET app using .NET Aspire, and what are the health check features provided by this integration?","['<1-hop>\n\ntitle: Add .NET Aspire to an existing .NET app description: Learn how to add .NET Aspire integrations, orchestration, and tooling to a microservices app that already exists. ms.date: 11/08/2024 ms.topic: how-to zone_pivot_groups: dev-environment Tutorial: Add .NET Aspire to an existing .NET app If you have existing microservices and .NET web app, you can add .NET Aspire to it and get all the included features and benefits. In this article, you add .NET Aspire orchestration to a simple, preexisting .NET 9 project. You learn how to: [!div class=""checklist""] Understand the structure of the existing microservices app. Enroll existing projects in .NET Aspire orchestration. Understand the changes enrollment makes in the projects. Start the .NET Aspire project. [!INCLUDE aspire-prereqs] Get started Let\'s start by obtaining the code for the solution: Open a command prompt and change directories to where you want to store the code. To clone to .NET 9 example solution, use the following git clone command: bash git clone https://github.com/MicrosoftDocs/mslearn-dotnet-cloudnative-devops.git eShopLite', '<2-hop>\n\ntitle: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","To integrate SQL Server with an existing .NET app using .NET Aspire, you can utilize the .NET Aspire SQL Server integration, which allows you to connect to existing SQL Server instances or create new ones from .NET. You need to install the Aspire.Microsoft.Data.SqlClient NuGet package in your client-consuming project. In the Program.cs file, you would call builder.AddSqlServerClient(connectionName: ""database""); to register the SQL Server client. The integration also includes health check features that automatically verify that the SQL Server is running and that a connection can be established. This health check is integrated with the /health HTTP endpoint, ensuring that all registered health checks must pass for the app to be considered ready to accept traffic.",multi_hop_specific_query_synthesizer
65,How do you authenticate to Azure AD when deploying a .NET Aspire project using the Azure SDK?,"['<1-hop>\n\ntitle: Deploy a .NET Aspire project to Azure Container Apps using azd (in-depth guide) description: Learn how to use azd to deploy .NET Aspire projects to Azure Container Apps. ms.date: 06/14/2024 ms.custom: devx-track-extended-azdevcli Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide) The Azure Developer CLI (azd) has been extended to support deploying .NET Aspire projects. Use this guide to walk through the process of creating and deploying a .NET Aspire project to Azure Container Apps using the Azure Developer CLI. In this tutorial, you\'ll learn the following concepts: [!div class=""checklist""] Explore how azd integration works with .NET Aspire projects Provision and deploy resources on Azure for a .NET Aspire project using azd Generate Bicep infrastructure and other template files using azd [!INCLUDE aspire-prereqs] You will also need to have the Azure Developer CLI installed locally. Common install options include the following: Windows powershell winget install microsoft.azd macOS bash brew tap azure/azd && brew install azd Linux bash curl -fsSL https://aka.ms/install-azd.sh | bash How Azure Developer CLI integration works The azd init workflow provides customized support for .NET Aspire projects. The following diagram illustrates how this flow works conceptually and how azd and .NET Aspire are integrated: :::image type=""content"" source=""media/azd-internals.png"" alt-text=""Illustration of internal processing of azd when deploying .NET Aspire project.""::: When azd targets a .NET Aspire project it starts the AppHost with a special command (dotnet run --project AppHost.csproj --output-path manifest.json --publisher manifest), which produces the Aspire manifest file. The manifest file is interrogated by the azd provision sub-command logic to generate Bicep files in-memory only (by default). After generating the Bicep files, a deployment is triggered using Azure\'s ARM APIs targeting the subscription and resource group provided earlier. Once the underlying Azure resources are configured, the azd deploy sub-command logic is executed which uses the same Aspire manifest file. As part of deployment azd makes a call to dotnet publish using .NET\'s built in container publishing support to generate container images. Once azd has built the container images it pushes them to the ACR registry that was created during the provisioning phase. Finally, once the container image is in ACR, azd updates the resource using ARM to start using the new version of the container image. [!NOTE] azd also enables you to output the generated Bicep to an infra folder in your project, which you can read more about in the Generating Bicep from .NET Aspire app model section. Provision and deploy a .NET Aspire starter app The steps in this section demonstrate how to create a .NET Aspire start app and handle provisioning and deploying the app resources to Azure using azd. Create the .NET Aspire starter app Create a new .NET Aspire project using the dotnet new command. You can also create the project using Visual Studio. dotnetcli dotnet new aspire-starter --use-redis-cache -o AspireSample cd AspireSample dotnet run --project AspireSample.AppHost\\AspireSample.AppHost.csproj The previous commands create a new .NET Aspire project based on the aspire-starter template which includes a dependency on Redis cache. It runs the .NET Aspire project which verifies that everything is working correctly. [!INCLUDE init workflow] The azure.yaml file has the following contents: ```yml yaml-language-server: $schema=https://raw.githubusercontent.com/Azure/azure-dev/main/schemas/v1.0/azure.yaml.json name: AspireSample services: app: language: dotnet project: .\\AspireSample.AppHost\\AspireSample.AppHost.csproj host: containerapp ``` Resource naming [!INCLUDE azure-container-app-naming] Initial deployment In order to deploy the .NET Aspire project, authenticate to Azure AD to call the Azure resource management APIs. azdeveloper azd auth login The previous command will launch a browser to authenticate the command-line session. Once authenticated, run the following command from the AppHost project directory to provision and deploy the application. azdeveloper azd up [!IMPORTANT] To push container images to the Azure Container Registry (ACR), you need to have Microsoft.Authorization/roleAssignments/write access. This can be achieved by enabling an Admin user on the registry. Open the Azure Portal, navigate to the ACR resource / Settings / Access keys, and then select the Admin user checkbox. For more information, see Enable admin user. When prompted, select the subscription and location the resources should be deployed to. Once these options are selected the .NET Aspire project will be deployed. [!INCLUDE azd-up-output] The final line of output from the azd command is a link to the Azure Portal that shows all of the Azure resources that were deployed: :::image type=""content"" loc-scope=""azure"" source=""media/azd-azure-portal-deployed-resources.png"" lightbox=""media/azd-azure-portal-deployed-resources.png"" alt-text=""Screenshot of Azure Portal showing deployed resources.""::: Three containers are deployed within this application: webfrontend: Contains code from the web project in the starter template. apiservice: Contains code from the API service project in the starter template. cache: A Redis container image to supply a cache to the front-end. Just like in local development, the configuration of connection strings has been handled automatically. In this case, azd was responsible for interpreting the application model and translating it to the appropriate deployment steps. As an example, consider the connection string and service discovery variables that are injected into the webfrontend container so that it knows how to connect to the Redis cache and apiservice. :::image type=""content"" loc-scope=""azure"" source=""media/azd-aca-variables.png"" lightbox=""media/azd-aca-variables.png"" alt-text=""A screenshot of environment variables in the webfrontend container app.""::: For more information on how .NET Aspire projects handle connection strings and service discovery, see .NET Aspire orchestration overview.', '<2-hop>\n\nLogging The .NET Aspire Azure Service Bus integration uses the following log categories: Azure.Core Azure.Identity Azure-Messaging-ServiceBus Tracing [!NOTE] Service Bus ActivitySource support in the Azure SDK for .NET is experimental, and the shape of activities may change in the future without notice. You can enable tracing in several ways: Setting the Azure.Experimental.EnableActivitySource runtime configuration setting to true. Which can be done with either: Call AppContext.SetSwitch(""Azure.Experimental.EnableActivitySource"", true);. Add the RuntimeHostConfigurationOption setting to your project file: xml <ItemGroup> <RuntimeHostConfigurationOption Include=""Azure.Experimental.EnableActivitySource"" Value=""true"" /> </ItemGroup> Set the AZURE_EXPERIMENTAL_ENABLE_ACTIVITY_SOURCE environment variable to ""true"". Can be achieved by chaining a call to WithEnvironment(""AZURE_EXPERIMENTAL_ENABLE_ACTIVITY_SOURCE"", ""true"") When enabled, the .NET Aspire Azure Service Bus integration will emit the following tracing activities using OpenTelemetry: Message ServiceBusSender.Send ServiceBusSender.Schedule ServiceBusSender.Cancel ServiceBusReceiver.Receive ServiceBusReceiver.ReceiveDeferred ServiceBusReceiver.Peek ServiceBusReceiver.Abandon ServiceBusReceiver.Complete ServiceBusReceiver.DeadLetter ServiceBusReceiver.Defer ServiceBusReceiver.RenewMessageLock ServiceBusSessionReceiver.RenewSessionLock ServiceBusSessionReceiver.GetSessionState ServiceBusSessionReceiver.SetSessionState ServiceBusProcessor.ProcessMessage ServiceBusSessionProcessor.ProcessSessionMessage ServiceBusRuleManager.CreateRule ServiceBusRuleManager.DeleteRule ServiceBusRuleManager.GetRules For more information, see: Azure SDK for .NET: Distributed tracing and the Service Bus client. Azure SDK for .NET: OpenTelemetry configuration. Azure SDK for .NET: Enabling experimental tracing features. Metrics The .NET Aspire Azure Service Bus integration currently doesn\'t support metrics by default due to limitations with the Azure SDK for .NET. If that changes in the future, this section will be updated to reflect those changes. See also Azure Service Bus .NET Aspire integrations .NET Aspire GitHub repo']","To authenticate to Azure AD when deploying a .NET Aspire project using the Azure SDK, you need to run the command 'azd auth login'. This command will launch a browser for you to authenticate the command-line session. Once authenticated, you can proceed to provision and deploy the application using the command 'azd up'.",multi_hop_specific_query_synthesizer
66,"What role do Azure Storage Blobs play in the .NET Aspire Azure Functions integration, and how can they be utilized for data persistence?","['<1-hop>\n\ntitle: .NET Aspire Azure Functions integration (Preview) description: Learn how to integrate Azure Functions with .NET Aspire. ms.date: 11/13/2024 zone_pivot_groups: dev-environment .NET Aspire Azure Functions integration (Preview) [!INCLUDE includes-hosting] [!IMPORTANT] The .NET Aspire Azure Functions integration is currently in preview and is subject to change. Azure Functions is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. The .NET Aspire Azure Functions integration enables you to develop, debug, and orchestrate an Azure Functions .NET project as part of the app host. It\'s expected that you\'ve installed the required Azure tooling: :::zone pivot=""visual-studio"" Configure Visual Studio for Azure development with .NET :::zone-end :::zone pivot=""vscode"" Configure Visual Studio Code for Azure development with .NET :::zone-end :::zone pivot=""dotnet-cli"" Install the Azure Functions Core Tools :::zone-end Supported scenarios The .NET Aspire Azure Functions integration has several key supported scenarios. This section outlines the scenarios and provides details related to the implementation of each approach. Supported triggers The following table lists the supported triggers for Azure Functions in the .NET Aspire integration: Trigger Attribute Details Azure Event Hubs trigger EventHubTrigger ðŸ“¦ Aspire.Hosting.Azure.EventHubs Azure Service Bus trigger ServiceBusTrigger ðŸ“¦ Aspire.Hosting.Azure.ServiceBus Azure Storage Blobs trigger BlobTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage Azure Storage Queues trigger QueueTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage HTTP trigger HttpTrigger Supported without any additional resource dependencies. Timer trigger TimerTrigger Supported without any additional resource dependenciesâ€”relies on implicit host storage. [!IMPORTANT] Other Azure Functions triggers and bindings aren\'t currently supported in the .NET Aspire Azure Functions integration. Deployment Currently, deployment is supported only to containers on Azure Container Apps (ACA) using the SDK container publish function in Microsoft.Azure.Functions.Worker.Sdk. This deployment methodology doesn\'t currently support KEDA-based autoscaling. Configure external HTTP endpoints To make HTTP triggers publicly accessible, call the', '<2-hop>\n\ntitle: Persist data with .NET Aspire using volume mounts description: Learn about .NET Aspire volume configurations. ms.date: 04/26/2024 ms.topic: how-to Persist .NET Aspire project data using volumes In this article, you learn how to configure .NET Aspire projects to persist data across app launches using volumes. A continuous set of data during local development is useful in many scenarios. Various .NET Aspire resource container types are able to leverage volume storage, such as PostgreSQL, Redis and Azure Storage. When to use volumes By default, every time you start and stop a .NET Aspire project, the app also creates and destroys the app resource containers. This setup creates problems when you want to persist data in a database or storage services between app launches for testing or debugging. For example, you may want to handle the following scenarios: Work with a continuous set of data in a database during an extended development session. Test or debug a changing set of files in an Azure Blob Storage emulator. Maintain cached data or messages in a Redis instance across app launches. These goals can all be accomplished using volumes. With volumes, you decide which services retain data between launches of your .NET Aspire project. Understand volumes Volumes are the recommended way to persist data generated by containers and supported on both Windows and Linux. Volumes can store data from multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume, which is the physical location on the host. Target: The target path in the container of the data you want to persist. For the remainder of this article, imagine that your exploring a Program class in a .NET Aspire app host project that\'s already defined the distributed app builder bits: ```csharp var builder = DistributedApplication.CreateBuilder(args); // TODO: // Consider various code snippets for configuring // volumes here and persistent passwords. builder.Build().Run(); ``` The first code snippet to consider uses the WithBindMount API to configure a volume for a SQL Server resource. The following code demonstrates how to configure a volume for a SQL Server resource in a .NET Aspire app host project: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.WithBindMount.cs"" id=""mount""::: In this example: VolumeMount.AppHost-sql-data sets where the volume will be stored on the host. /var/opt/mssql sets the path to the database files in the container. All .NET Aspire container resources can utilize volume mounts, and some provide convenient APIs for adding named volumes derived from resources. Using the WithDataVolume as an example, the following code is functionally equivalent to the previous example but more succinct: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.Implicit.cs"" id=""implicit""::: With the app host project being named VolumeMount.AppHost, the WithDataVolume method automatically creates a named volume as VolumeMount.AppHost-sql-data and is mounted to the /var/opt/mssql path in the SQL Server container. The naming convention is as follows: {appHostProjectName}-{resourceName}-data: The volume name is derived from the app host project name and the resource name. Create a persistent password Named volumes require a consistent password between app launches. .NET Aspire conveniently provides random password generation functionality. Consider the previous example once more, where a password is generated automatically: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.Implicit.cs"" id=""implicit""::: Since the password parameter isn\'t provided when calling AddSqlServer, .NET Aspire automatically generates a password for the SQL Server resource. [!IMPORTANT] This isn\'t a persistent password! Instead, it changes every time the app host runs. To create a persistent password, you must override the generated password. To do this, run the following command in your app host project directory to set a local password in your .NET user secrets: dotnetcli dotnet user-secrets set Parameters:sql-password <password> The naming convention for these secrets is important to understand. The password is stored in configuration with the Parameters:sql-password key. The naming convention follows this pattern: Parameters:{resourceName}-password: In the case of the SQL Server resource (which was named ""sql""), the password is stored in the configuration with the key Parameters:sql-password. The same pattern applies to the other server-based resource types, such as those shown in the following table: | Resource type | Hosting package | Example resource name | Override key | |--|--|--| | MySQL | ðŸ“¦ Aspire.Hosting.MySql | mysql | Parameters:mysql-password | | Oracle | ðŸ“¦ Aspire.Hosting.Oracle | oracle | Parameters:oracle-password | | PostgreSQL | ðŸ“¦ Aspire.Hosting.PostgreSQL | postgresql | Parameters:postgresql-password | | RabbitMQ | ðŸ“¦ Aspire.Hosting.RabbitMq | rabbitmq | Parameters:rabbitmq-password | | SQL Server | ðŸ“¦ Aspire.Hosting.SqlServer | sql | Parameters:sql-password | By overriding the generated password, you can ensure that the password remains consistent between app launches, thus creating a persistent password. An alternative approach is to use the AddParameter method to create a parameter that can be used as a password. The following code demonstrates how to create a persistent password for a SQL Server resource: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.ExplicitStable.cs"" id=""explicit""::: The preceding code snippet demonstrates how to create a persistent password for a SQL Server resource. The AddParameter method is used to create a parameter named sql-password that\'s considered a secret. The AddSqlServer method is then called with the password parameter to set the password for the SQL Server resource. For more information, see External parameters.']","In the .NET Aspire Azure Functions integration, Azure Storage Blobs are utilized as a supported trigger through the BlobTrigger, allowing developers to respond to events related to blob storage. This integration enables the handling of data stored in Azure Blob Storage, which is essential for scenarios where data persistence is required. Additionally, .NET Aspire projects can leverage volume configurations to persist data across app launches, including data stored in Azure Storage, ensuring that a continuous set of data is maintained during local development.",multi_hop_specific_query_synthesizer
67,How do you upgrade the Aspire.Hosting.AppHost package to version 9.0.0 and ensure compliance with the new .NET Aspire 9.0 requirements?,"['<1-hop>\n\nUpdate the NuGet packages in your project files to the latest versions. Adjust your Program.cs file to use the new APIs and remove any obsolete APIs. Edit your app host project file To upgrade your app host project to .NET Aspire 9.0, you need to update your project file to use the new ðŸ“¦ Aspire.AppHost.Sdk: ```diff ``` Optionally upgrade the target framework moniker (TFM) .NET Aspire 9.0 runs on .NET 9.0, but you can also run it on .NET 8.0. In other words, just because you\'re using the .NET Aspire SDK, and pointing to version 9.0 packages, you can still target .NET 8.0. If you want to run your .NET Aspire 9.0 project on .NET 9.0, you need to update the TargetFramework property in your project file: ```diff ``` For more information on TFMs, see Target frameworks in SDK-style projects: Latest versions. Overall app host project differences If you followed all of the preceding steps, your app host project file should look like this: ```diff ``` The changes include the addition of the Aspire.AppHost.Sdk, the update of the TargetFramework property to net9.0, and the update of the Aspire.Hosting.AppHost package to version 9.0.0. Adjust your Program.cs file With the introduction of .NET Aspire 9.0, there are some breaking changes. Some APIs were originally marked as experimental (with the For the complete list of breaking changes in .NET Aspire 9.0, see Breaking changes in .NET Aspire 9.0. Use the Upgrade Assistant The Upgrade Assistant is a tool that helps upgrade targeted projects to the latest version. If you\'re new to the Upgrade Assistant, there\'s two modalities to choose from: The Visual Studio extension version. The .NET CLI global tool version. Regardless of how you install the Upgrade Assistant, you can use it to upgrade your .NET Aspire 8.x projects to .NET Aspire 9.0. :::zone pivot=""visual-studio"" To upgrade the .NET Aspire app host project to .NET Aspire 9.0 with Visual Studio, right-click the project in Solution Explorer and select Upgrade. [!IMPORTANT] If the Upgrade Assistant isn\'t already installed, you\'ll be prompted to install it. The Upgrade Assistant displays a welcome package. Select the Aspire upgrades option: :::image type=""content"" source=""media/upgrade-assistant-welcome-aspire.png"" lightbox=""media/upgrade-assistant-welcome-aspire.png"" alt-text=""Visual Studio: Upgrade Assistant welcome page with .NET Aspire app host project.""::: With the Aspire upgrades option selected, the Upgrade Assistant displays the selectable upgrade target components. Leave all the options checked and select Upgrade selection: :::image type=""content"" source=""media/upgrade-assistant-aspire-app-host-comps.png"" lightbox=""media/upgrade-assistant-aspire-app-host-comps.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire selectable components to upgrade.""::: Finally, after selecting the components to upgrade, the Upgrade Assistant displays the results of the upgrade process. If everything was successful, you see green check marks next to each component: :::image type=""content"" source=""media/upgrade-assistant-aspire-upgraded.png"" lightbox=""media/upgrade-assistant-aspire-upgraded.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire app host project upgraded successfully.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To upgrade the .NET Aspire app host project, ensure that you installed the Upgrade Assistant CLI. Open a terminal session at the root directory of the .NET Aspire app host project file, and run the following command: dotnetcli upgrade-assistant upgrade The output is interactive, expecting you to select the upgrade type. Choose the Aspire upgrades option: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ How do you want to upgrade project AspireSample.AppHost? Aspire upgrades Upgrade to latest .NET Aspire version (aspire.latest) Upgrade project to a newer .NET version In-place project upgrade (framework.inplace) NuGet upgrades NuGet central package management (CPM) (nuget.cpm) Navigation Back Exit ``` Use your keyboard to navigate up â†‘ or down â†“, and select the Aspire upgrades option. The Upgrade Assistant prompts for final confirmation. Enter Y to continue with the upgrade: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Upgrade type aspire.latest Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type / Upgrade â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ We have gathered all required options and are ready to do the upgrade. Do you want to continue? [y/n] (y): ``` Finally, after the upgrade process is complete, the Upgrade Assistant displays the results of the upgrade process: dotnetcli Finalizing operation... Complete: 3 succeeded, 0 failed, 7 skipped. :::zone-end Update the NuGet packages To take advantage of the latest updates in your .NET Aspire solution, update all NuGet packages to version 9.0.0. :::zone pivot=""visual-studio"" :::image type=""content"" source=""media/visual-studio-update-nuget.png"" lightbox=""media/visual-studio-update-nuget.png"" alt-text=""Visual Studio: Update all NuGet packages for the .NET Aspire solution.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To update your app host project, use the following .NET CLI command to update the Aspire.Hosting.AppHost package to version 9.0.0: dotnetcli dotnet add package Aspire.Hosting.AppHost --version 9.0.0 When a package reference already exists, the dotnet add package command updates the reference to the specified version. For more information, see dotnet add package. :::zone-end With the app host project updated, your project file should look like this: ```diff ``` [!TIP] You\'ll want to also update the NuGet packages in your other projects to the latest versions. Verify the upgrade As with any upgrade, ensure that the app runs as expected and that all tests pass. Build the solution and look for suggestions, warnings, or errors in the output windowâ€”address anything that wasn\'t an issue before. If you encounter any issues, let us know by filing a GitHub issue.', '<2-hop>\n\nResource types Each resource has a type field. When a deployment tool reads the manifest, it should read the type to verify whether it can correctly process the manifest. During the .NET Aspire preview period, all resource types have a v0 suffix to indicate that they\'re subject to change. As .NET Aspire approaches release a v1 suffix will be used to signify that the structure of the manifest for that resource type should be considered stable (subsequent updates increment the version number accordingly). Common resource fields The type field is the only field that is common across all resource types, however, the project.v0, container.v0, and executable.v0 resource types also share the env and bindings fields. [!NOTE] The executable.v0 resource type isn\'t fully implemented in the manifest due to its lack of utility in deployment scenarios. For more information on containerizing executables, see Dockerfile resource types. The env field type is a basic key/value mapping where the values might contain placeholder strings. Bindings are specified in the bindings field with each binding contained within its own field under the bindings JSON object. The fields omitted by the .NET Aspire manifest in the bindings node include: scheme: One of the following values tcp, udp, http, or https. protocol: One of the following values tcp or udp transport: Same as scheme, but used to disambiguate between http and http2. containerPort: Optional, if omitted defaults to port 80. The inputs field Some resources generate an inputs field. This field is used to specify input parameters for the resource. The inputs field is a JSON object where each property is an input parameter that\'s used in placeholder structure resolution. Resources that have a connectionString, for example, might use the inputs field to specify a password for the connection string: json ""connectionString"": ""Host={<resourceName>.bindings.tcp.host};Port={<resourceName>.bindings.tcp.port};Username=admin;Password={<resourceName>.inputs.password};"" The connection string placeholder references the password input parameter from the inputs field: json ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } The preceding JSON snippet shows the inputs field for a resource that has a connectionString field. The password input parameter is a string type and is marked as a secret. The default field is used to specify a default value for the input parameter. In this case, the default value is generated using the generate field, with random string of a minimum length. Built-in resources The following table is a list of resource types that are explicitly generated by .NET Aspire and extensions developed by the .NET Aspire team: Cloud-agnostic resource types These resources are available in the ðŸ“¦ Aspire.Hosting NuGet package. App model usage Manifest resource type Heading link container.v0 Container resource type PublishAsDockerFile dockerfile.v0 Dockerfile resource types value.v0 MongoDB Server resource types container.v0 MongoDB resource types value.v0 MySQL Server resource types container.v0 MySQL resource types value.v0 Postgres resource types container.v0 Postgres resource types project.v0 Project resource type container.v0 RabbitMQ resource types container.v0 Redis resource type value.v0 SQL Server resource types container.v0 SQL Server resource types Project resource type Example code: csharp var builder = DistributedApplication.CreateBuilder(args); var apiservice = builder.AddProject<Projects.AspireApp_ApiService>(""apiservice""); Example manifest: json ""apiservice"": { ""type"": ""project.v0"", ""path"": ""../AspireApp.ApiService/AspireApp.ApiService.csproj"", ""env"": { ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES"": ""true"", ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES"": ""true"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"" }, ""https"": { ""scheme"": ""https"", ""protocol"": ""tcp"", ""transport"": ""http"" } } } Container resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddContainer(""mycontainer"", ""myimage"") .WithEnvironment(""LOG_LEVEL"", ""WARN"") .WithHttpEndpoint(3000); ``` Example manifest: json { ""resources"": { ""mycontainer"": { ""type"": ""container.v0"", ""image"": ""myimage:latest"", ""env"": { ""LOG_LEVEL"": ""WARN"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 3000 } } } } } Dockerfile resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddNodeApp(""nodeapp"", ""../nodeapp/app.js"") .WithHttpEndpoint(hostPort: 5031, env: ""PORT"") .PublishAsDockerFile(); ``` [!TIP] The PublishAsDockerFile call is required to generate the Dockerfile resource type in the manifest, and this extension method is only available on the Example manifest: json { ""resources"": { ""nodeapp"": { ""type"": ""dockerfile.v0"", ""path"": ""../nodeapp/Dockerfile"", ""context"": ""../nodeapp"", ""env"": { ""NODE_ENV"": ""development"", ""PORT"": ""{nodeapp.bindings.http.port}"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 5031 } } } } } Postgres resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddPostgres(""postgres1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""postgres1"": { ""type"": ""container.v0"", ""connectionString"": ""Host={postgres1.bindings.tcp.host};Port={postgres1.bindings.tcp.port};Username=postgres;Password={postgres1.inputs.password}"", ""image"": ""postgres:16.2"", ""env"": { ""POSTGRES_HOST_AUTH_METHOD"": ""scram-sha-256"", ""POSTGRES_INITDB_ARGS"": ""--auth-host=scram-sha-256 --auth-local=scram-sha-256"", ""POSTGRES_PASSWORD"": ""{postgres1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5432 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{postgres1.connectionString};Database=shipping"" } } } RabbitMQ resource types RabbitMQ is modeled as a container resource container.v0. The following sample shows how they\'re added to the app model. ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRabbitMQ(""rabbitmq1""); ``` The previous code produces the following manifest: json { ""resources"": { ""rabbitmq1"": { ""type"": ""container.v0"", ""connectionString"": ""amqp://guest:{rabbitmq1.inputs.password}@{rabbitmq1.bindings.tcp.host}:{rabbitmq1.bindings.tcp.port}"", ""image"": ""rabbitmq:3"", ""env"": { ""RABBITMQ_DEFAULT_USER"": ""guest"", ""RABBITMQ_DEFAULT_PASS"": ""{rabbitmq1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5672 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } } } } Redis resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRedis(""redis1""); ``` Example manifest: json { ""resources"": { ""redis1"": { ""type"": ""container.v0"", ""connectionString"": ""{redis1.bindings.tcp.host}:{redis1.bindings.tcp.port}"", ""image"": ""redis:7.2.4"", ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 6379 } } } } } SQL Server resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddSqlServer(""sql1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""sql1"": { ""type"": ""container.v0"", ""connectionString"": ""Server={sql1.bindings.tcp.host},{sql1.bindings.tcp.port};User ID=sa;Password={sql1.inputs.password};TrustServerCertificate=true"", ""image"": ""mcr.microsoft.com/mssql/server:2022-latest"", ""env"": { ""ACCEPT_EULA"": ""Y"", ""MSSQL_SA_PASSWORD"": ""{sql1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 1433 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{sql1.connectionString};Database=shipping"" } } } MongoDB resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddMongoDB(""mongodb1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""mongodb1"": { ""type"": ""container.v0"", ""connectionString"": ""mongodb://{mongodb1.bindings.tcp.host}:{mongodb1.bindings.tcp.port}"", ""image"": ""mongo:7.0.5"", ""bindings"": { ""tcp"": { ""scheme"":']","To upgrade the Aspire.Hosting.AppHost package to version 9.0.0, you can use the .NET CLI command: `dotnet add package Aspire.Hosting.AppHost --version 9.0.0`. This command updates the reference to the specified version in your project file. Additionally, to ensure compliance with the new .NET Aspire 9.0 requirements, you need to update your project file to use the new Aspire.AppHost.Sdk and adjust the TargetFramework property to net9.0. If you want to run your .NET Aspire 9.0 project on .NET 9.0, make sure to follow the steps outlined for updating the NuGet packages and verifying that the app runs as expected after the upgrade.",multi_hop_specific_query_synthesizer
68,What is the significance of the DOTNET_DASHBOARD_OTLP_ENDPOINT_URL in the context of .NET Aspire dashboard configuration and how does it relate to the app host launch settings?,"['<1-hop>\n\ntitle: .NET Aspire dashboard configuration description: .NET Aspire dashboard configuration options ms.date: 10/29/2024 ms.topic: reference Dashboard configuration The dashboard is configured when it starts up. Configuration includes frontend and OpenTelemetry Protocol (OTLP) addresses, the resource service endpoint, authentication, telemetry limits, and more. When the dashboard is launched with the .NET Aspire app host project, it\'s automatically configured to display the app\'s resources and telemetry. Configuration is provided when launching the dashboard in standalone mode. There are many ways to provide configuration: Command line arguments. Environment variables. The : delimiter should be replaced with double underscore (__) in environment variable names. Optional JSON configuration file. The DOTNET_DASHBOARD_CONFIG_FILE_PATH setting can be used to specify a JSON configuration file. Consider the following example, which shows how to configure the dashboard when started from a Docker container: Bash bash docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard \\ -e DASHBOARD__TELEMETRYLIMITS__MAXLOGCOUNT=\'1000\' \\ -e DASHBOARD__TELEMETRYLIMITS__MAXTRACECOUNT=\'1000\' \\ -e DASHBOARD__TELEMETRYLIMITS__MAXMETRICSCOUNT=\'1000\' \\ mcr.microsoft.com/dotnet/aspire-dashboard:9.0 PowerShell powershell docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard ` -e DASHBOARD__TELEMETRYLIMITS__MAXLOGCOUNT=\'1000\' ` -e DASHBOARD__TELEMETRYLIMITS__MAXTRACECOUNT=\'1000\' ` -e DASHBOARD__TELEMETRYLIMITS__MAXMETRICSCOUNT=\'1000\' ` mcr.microsoft.com/dotnet/aspire-dashboard:9.0 Alternatively, these same values could be configured using a JSON configuration file that is specified using DOTNET_DASHBOARD_CONFIG_FILE_PATH: json { ""Dashboard"": { ""TelemetryLimits"": { ""MaxLogCount"": 1000, ""MaxTraceCount"": 1000, ""MaxMetricsCount"": 1000 } } } [!IMPORTANT] The dashboard displays information about resources, including their configuration, console logs and in-depth telemetry. Data displayed in the dashboard can be sensitive. For example, secrets in environment variables, and sensitive runtime data in telemetry. Care should be taken to configure the dashboard to secure access. For more information, see dashboard security. [!NOTE] Configuration described on this page is for the standalone dashboard. To configure an .NET Aspire app host project, see App host configuration. Common configuration Option Default value Description ASPNETCORE_URLS http://localhost:18888 One or more HTTP endpoints through which the dashboard frontend is served. The frontend endpoint is used to view the dashboard in a browser. When the dashboard is launched by the .NET Aspire app host this address is secured with HTTPS. Securing the dashboard with HTTPS is recommended. DOTNET_DASHBOARD_OTLP_ENDPOINT_URL http://localhost:18889 The OTLP/gRPC endpoint. This endpoint hosts an OTLP service and receives telemetry using gRPC. When the dashboard is launched by the .NET Aspire app host this address is secured with HTTPS. Securing the dashboard with HTTPS is recommended. DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL http://localhost:18890 The OTLP/HTTP endpoint. This endpoint hosts an OTLP service and receives telemetry using Protobuf over HTTP. When the dashboard is launched by the .NET Aspire app host the OTLP/HTTP endpoint isn\'t configured by default. To configure an OTLP/HTTP endpoint with the app host, set an DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL env var value in launchSettings.json . Securing the dashboard with HTTPS is recommended. DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS false Configures the dashboard to not use authentication and accepts anonymous access. This setting is a shortcut to configuring Dashboard:Frontend:AuthMode and Dashboard:Otlp:AuthMode to Unsecured . DOTNET_DASHBOARD_CONFIG_FILE_PATH null The path for a JSON configuration file. If the dashboard is being run in a Docker container, then this is the path to the configuration file in a mounted volume. This value is optional. DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null The gRPC endpoint to which the dashboard connects for its data. If this value is unspecified, the dashboard shows telemetry data but no resource list or console logs. This setting is a shortcut to Dashboard:ResourceServiceClient:Url .', '<2-hop>\n\nInternal settings that .NET Aspire uses to run the app host. These are set internally but can be accessed by integrations that extend .NET Aspire. App host configuration is provided by the app host launch profile. The app host has a launch settings file call launchSettings.json which has a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } } } } The preceding launch settings file: Has one launch profile named https. Configures an .NET Aspire app host project: The applicationUrl property configures the dashboard launch address (ASPNETCORE_URLS). Environment variables such as DOTNET_DASHBOARD_OTLP_ENDPOINT_URL and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL are set on the app host. For more information, see .NET Aspire and launch profiles. [!NOTE] Configuration described on this page is for .NET Aspire app host project. To configure the standalone dashboard, see dashboard configuration. Common configuration Option Default value Description ASPIRE_ALLOW_UNSECURED_TRANSPORT false Allows communication with the app host without https. ASPNETCORE_URLS (dashboard address) and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL (app host resource service address) must be secured with HTTPS unless true. DOTNET_ASPIRE_CONTAINER_RUNTIME docker Allows the user of alternative container runtimes for resources backed by containers. Possible values are docker (default) or podman . See Setup and tooling overview for more details . Resource service A resource service is hosted by the app host. The resource service is used by the dashboard to fetch information about resources which are being orchestrated by .NET Aspire. Option Default value Description DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null Configures the address of the resource service hosted by the app host. Automatically generated with launchSettings.json to have a random port on localhost. For example, https://localhost:17037 . DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key is required if the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . Dashboard By default, the dashboard is automatically started by the app host. The dashboard supports its own set of configuration, and some settings can be configured from the app host. Option Default value Description ASPNETCORE_URLS null Dashboard address. Must be https unless ASPIRE_ALLOW_UNSECURED_TRANSPORT or DistributedApplicationOptions.AllowUnsecuredTransport is true. Automatically generated with launchSettings.json to have a random port on localhost. The value in launch settings is set on the applicationUrls property. ASPNETCORE_ENVIRONMENT Production Configures the environment the dashboard runs as. For more information, see Use multiple environments in ASP.NET Core . DOTNET_DASHBOARD_OTLP_ENDPOINT_URL http://localhost:18889 if no gRPC endpoint is configured. Configures the dashboard OTLP gRPC address. Used by the dashboard to receive telemetry over OTLP. Set on resources as the OTEL_EXPORTER_OTLP_ENDPOINT env var. The OTEL_EXPORTER_OTLP_PROTOCOL env var is grpc . Automatically generated with launchSettings.json to have a random port on localhost. DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL null Configures the dashboard OTLP HTTP address. Used by the dashboard to receive telemetry over OTLP. If only DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL is configured then it is set on resources as the OTEL_EXPORTER_OTLP_ENDPOINT env var. The OTEL_EXPORTER_OTLP_PROTOCOL env var is http/protobuf . DOTNET_DASHBOARD_FRONTEND_BROWSERTOKEN Automatically generated 128-bit entropy token. Configures the frontend browser token. This is the value that must be entered to access the dashboard when the auth mode is BrowserToken. If no browser token is specified then a new token is generated each time the app host is launched. Internal Internal settings are used by the app host and integrations. Internal settings aren\'t designed to be configured directly. Option Default value Description AppHost:Directory The content root if there\'s no project. Directory of the project where the app host is located. Accessible from the . AppHost:Path The directory combined with the application name. The path to the app host. It combines the directory with the application name. AppHost:Sha256 It is created from the app host name when the app host is in publish mode. Otherwise it is created from the app host path. Hex encoded hash for the current application. The hash is based on the location of the app on the current machine so it is stable between launches of the app host. AppHost:OtlpApiKey Automatically generated 128-bit entropy token. The API key used to authenticate requests sent to the dashboard OTLP service. The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . AppHost:BrowserToken Automatically generated 128-bit entropy token. The browser token used to authenticate browsing to the dashboard when it is launched by the app host. The browser token can be set by DOTNET_DASHBOARD_FRONTEND_BROWSERTOKEN . The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . AppHost:ResourceService:AuthMode ApiKey . If DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS is true then the value is Unsecured . The authentication mode used to access the resource service. The value is present if needed: the app host is in run mode and the dashboard isn\'t disabled. AppHost:ResourceService:ApiKey Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key can be set by DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY . The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS .']","The DOTNET_DASHBOARD_OTLP_ENDPOINT_URL is crucial for the .NET Aspire dashboard configuration as it specifies the OTLP/gRPC endpoint that the dashboard uses to receive telemetry data. This endpoint is set to http://localhost:18889 by default when no gRPC endpoint is configured. In the context of app host launch settings, this environment variable is defined in the launchSettings.json file, where it can be set to a different value, such as https://localhost:21030, to ensure secure communication. This connection allows the dashboard to fetch telemetry data effectively, which is essential for monitoring and managing resources orchestrated by .NET Aspire.",multi_hop_specific_query_synthesizer
69,"What are the differences in container runtime options for .NET Aspire, specifically regarding the use of Docker and Podman?","['<1-hop>\n\ntitle: .NET Aspire app host configuration description: Learn about the .NET Aspire app host configuration options. ms.date: 11/21/2024 ms.topic: reference App host configuration The app host project configures and starts your distributed application ( Configuration includes: Settings for hosting the resource service, such as the address and authentication options. Settings used to start the .NET Aspire dashboard, such the dashboard\'s frontend and OpenTelemetry Protocol (OTLP) addresses. Internal settings that .NET Aspire uses to run the app host. These are set internally but can be accessed by integrations that extend .NET Aspire. App host configuration is provided by the app host launch profile. The app host has a launch settings file call launchSettings.json which has a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } } } } The preceding launch settings file: Has one launch profile named https. Configures an .NET Aspire app host project: The applicationUrl property configures the dashboard launch address (ASPNETCORE_URLS). Environment variables such as DOTNET_DASHBOARD_OTLP_ENDPOINT_URL and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL are set on the app host. For more information, see .NET Aspire and launch profiles. [!NOTE] Configuration described on this page is for .NET Aspire app host project. To configure the standalone dashboard, see dashboard configuration. Common configuration Option Default value Description ASPIRE_ALLOW_UNSECURED_TRANSPORT false Allows communication with the app host without https. ASPNETCORE_URLS (dashboard address) and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL (app host resource service address) must be secured with HTTPS unless true. DOTNET_ASPIRE_CONTAINER_RUNTIME docker Allows the user of alternative container runtimes for resources backed by containers. Possible values are docker (default) or podman . See Setup and tooling overview for more details . Resource service A resource service is hosted by the app host. The resource service is used by the dashboard to fetch information about resources which are being orchestrated by .NET Aspire. Option Default value Description DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null Configures the address of the resource service hosted by the app host. Automatically generated with launchSettings.json to have a random port on localhost. For example, https://localhost:17037 . DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key is required if the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . ', '<2-hop>\n\ntitle: .NET Aspire tooling description: Learn about essential tooling concepts for .NET Aspire. ms.date: 01/17/2025 zone_pivot_groups: dev-environment uid: dotnet/aspire/setup-tooling .NET Aspire setup and tooling .NET Aspire includes tooling to help you create and configure cloud-native apps. The tooling includes useful starter project templates and other features to streamline getting started with .NET Aspire for Visual Studio, Visual Studio Code, and CLI workflows. In the sections ahead, you learn how to work with .NET Aspire tooling and explore the following tasks: [!div class=""checklist""] Install .NET Aspire and its dependencies Create starter project templates using Visual Studio, Visual Studio Code, or the .NET CLI Install .NET Aspire integrations Work with the .NET Aspire dashboard Install .NET Aspire To work with .NET Aspire, you need the following installed locally: .NET 8.0 or .NET 9.0. An OCI compliant container runtime, such as: Docker Desktop or Podman. For more information, see Container runtime. An Integrated Developer Environment (IDE) or code editor, such as: Visual Studio 2022 version 17.9 or higher (Optional) Visual Studio Code (Optional) C# Dev Kit: Extension (Optional) JetBrains Rider with .NET Aspire plugin (Optional) :::zone pivot=""visual-studio"" Visual Studio 2022 17.9 or higher includes the latest .NET Aspire SDK by default when you install the Web & Cloud workload. If you have an earlier version of Visual Studio 2022, you can either upgrade to Visual Studio 2022 17.9 or you can install the .NET Aspire SDK using the following steps: To install the .NET Aspire workload in Visual Studio 2022, use the Visual Studio installer. Open the Visual Studio Installer. Select Modify next to Visual Studio 2022. Select the ASP.NET and web development workload. On the Installation details panel, select .NET Aspire SDK. Select Modify to install the .NET Aspire integration. :::image type=""content"" loc-scope=""visual-studio"" source=""media/setup-tooling/web-workload-with-aspire.png"" lightbox=""media/setup-tooling/web-workload-with-aspire.png"" alt-text=""A screenshot showing how to install the .NET Aspire workload with the Visual Studio installer.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" :::zone-end Container runtime .NET Aspire projects are designed to run in containers. You can use either Docker Desktop or Podman as your container runtime. Docker Desktop is the most common container runtime. Podman is an open-source daemonless alternative to Docker, that can build and run Open Container Initiative (OCI) containers. If your host environment has both Docker and Podman installed, .NET Aspire defaults to using Docker. You can instruct .NET Aspire to use Podman instead, by setting the DOTNET_ASPIRE_CONTAINER_RUNTIME environment variable to podman: Linux bash export DOTNET_ASPIRE_CONTAINER_RUNTIME=podman For more information, see Install Podman on Linux. Windows ```powershell ``` For more information, see Install Podman on Windows.  see .NET Aspire orchestration overview. Enlist in orchestration Visual Studio provides the option to Enlist in Aspire orchestration during the new project workflow. Select this option to have Visual Studio create .AppHost_ and _.ServiceDefaults projects alongside your selected project template. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/aspire-enlist-orchestration.png"" lightbox=""../media/aspire-enlist-orchestration.png"" alt-text=""A screenshot showing how to enlist in .NET Aspire orchestration.""::: Create test project When you\'re using Visual Studio, and you select the .NET Aspire Start Application template, you have the option to include a test project. This test project is an xUnit project that includes a sample test that you can use as a starting point for your tests. :::image type=""content"" source=""media/setup-tooling/create-test-projects-template.png"" lightbox=""media/setup-tooling/create-test-projects-template.png"" alt-text=""A screenshot of Visual Studio displaying the option to create a test project.""::: For more information, see Write your first .NET Aspire test. :::zone-end :::zone pivot=""vscode"" Visual Studio Code tooling You can use Visual Studio Code, with the C# Dev Kit extension, to create and develop .NET Aspire projects. To create a new .NET Aspire project in Visual Studio Code, select the Create .NET Project button in the Explorer view, then select one of the .NET Aspire templates: :::image type=""content"" source=""media/vscode-create-dotnet-aspire-proj.png"" lightbox=""media/vscode-create-dotnet-aspire-proj.png"" alt-text=""A screenshot showing how to create a new .NET Aspire project in Visual Studio Code.""::: Once you create a new .NET Aspire project, you run and debug the app, stepping through breakpoints, and inspecting variables using the Visual Studio Code debugger: :::image type=""content"" source=""media/setup-tooling/vscode-debugging.png"" lightbox=""media/setup-tooling/vscode-debugging.png"" alt-text=""A screenshot showing how to debug a .NET Aspire project in Visual Studio Code.""::: :::zone-end See also Unable to install .NET Aspire workload Use Dev Proxy with .NET Aspire project']","In .NET Aspire, the default container runtime is Docker, but users have the option to use Podman as an alternative. The DOTNET_ASPIRE_CONTAINER_RUNTIME environment variable can be set to 'podman' to instruct .NET Aspire to utilize Podman instead of Docker. Podman is described as an open-source daemonless alternative to Docker, capable of building and running Open Container Initiative (OCI) containers. If both Docker and Podman are installed on the host environment, .NET Aspire will default to using Docker.",multi_hop_specific_query_synthesizer
70,"What are the limitations of the Azure SDK in the .NET Aspire Azure Queue Storage integration regarding metrics, and how does the Azure SDK facilitate the management of Azure resources in .NET Aspire?","[""<1-hop>\n\nLogging The .NET Aspire Azure Queue Storage integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Queue Storage integration emits the following tracing activities using OpenTelemetry: Azure.Storage.Queues.QueueClient Metrics The .NET Aspire Azure Queue Storage integration currently doesn't support metrics by default due to limitations with the Azure SDK. See also Azure Queue Storage docs .NET Aspire integrations .NET Aspire GitHub repo"", '<2-hop>\n\ntitle: Azure integrations overview description: Overview of the Azure integrations available in the .NET Aspire. ms.date: 12/17/2024 uid: dotnet/aspire/integrations/azure-overview .NET Aspire Azure integrations overview Azure is the most popular cloud platform for building and deploying .NET applications. The Azure SDK for .NET allows for easy management and use of Azure services. .NET Aspire provides a set of integrations with Azure services, where you\'re free to add new resources or connect to existing ones. This article details some common aspects of all Azure integrations in .NET Aspire and aims to help you understand how to use them. Add connection to existing Azure resources .NET Aspire provides the ability to connect to existing resources, including Azure resources. Expressing connection strings is useful when you have existing Azure resources that you want to use in your .NET Aspire app. The [!INCLUDE connection-strings-alert] Consider the following example, where in publish mode you add an Azure Storage resource while in run mode you add a connection string to an existing Azure Storage: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.ExecutionContext.IsPublishMode ? builder.AddAzureStorage(""storage"") : builder.AddConnectionString(""storage""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Creates a new builder instance. Adds a Azure Storage resource named storage in ""publish"" mode. Adds a connection string to an existing Azure Storage named storage in ""run"" mode. Adds a project named api to the builder. The api project references the storage resource regardless of the mode. The consuming API project uses the connection string information with no knowledge of how the app host configured it. In ""publish"" mode, the code adds a new Azure Storage resourceâ€”which would be reflected in the deployment manifest accordingly. When in ""run"" mode, the connection string corresponds to a configuration value visible to the app host. It\'s assumed that any and all role assignments for the target resource have been configured. This means, you\'d likely configure an environment variable or a user secret to store the connection string. The configuration is resolved from the ConnectionStrings__storage (or ConnectionStrings:storage) configuration key. These configuration values can be viewed when the app runs. For more information, see Resource details. Add Azure resources All .NET Aspire Azure hosting integrations expose Azure resources and by convention are added using AddAzure* APIs. When you add these resources to your .NET Aspire app host, they represent an Azure service. The AddAzure* API returns an <xref:Aspire.Hosting.ApplicationModel.IResourceBuilder1> whereTis the type of Azure resource. TheseIResourceBuilder Typical developer experience When your .NET Aspire app host contains Azure resources, and you run it locally (typical developer F5 or dotnet run experience), the Azure resources are provisioned in your Azure subscription. This allows you as the developer to debug against them locally in the context of your app host. .NET Aspire aims to minimize costs by defaulting to Basic or Standard Stock Keeping Unit (SKU) for its Azure integrations. While these sensible defaults are provided, you can customize the Azure resources to suit your needs. Additionally, some integrations support emulators or containers, which are useful for local development, testing, and debugging. By default, when you run your app locally, the Azure resources use the actual Azure service. However, you can configure them to use local emulators or containers, avoiding costs associated with the actual Azure service during local development.']","The limitations of the Azure SDK in the .NET Aspire Azure Queue Storage integration regarding metrics are that it currently doesn't support metrics by default due to these limitations. However, the Azure SDK for .NET facilitates the management of Azure resources by allowing developers to connect to existing Azure resources and add new ones through the use of AddAzure* APIs. This enables easy integration and management of Azure services within .NET Aspire applications.",multi_hop_specific_query_synthesizer
71,How does the management of the app host in .NET Aspire tests relate to the installation of the Aspire.Hosting.Azure package for customizing Bicep templates?,"['<1-hop>\n\ntitle: Manage the app host in .NET Aspire tests description: Learn how to manage the app host in .NET Aspire tests. ms.date: 10/21/2024 zone_pivot_groups: unit-testing-framework Manage the app host in .NET Aspire tests When writing functional or integration tests with .NET Aspire, it\'s important to consider how the app host instance is managed across tests, since the app host represents the full application environment and thus can be expensive to create and tear down. In this article, you\'ll learn how to manage the app host instance in your .NET Aspire tests. For writing tests with .NET Aspire, you use the ðŸ“¦ Aspire.Hosting.Testing NuGet package which contains some helper classes to manage the app host instance in your tests. Use the DistributedApplicationTestingBuilder class In the tutorial on writing your first test, you were introduced to the csharp var appHost = await DistributedApplicationTestingBuilder .CreateAsync<Projects.AspireApp_AppHost>(); The :::zone pivot=""xunit"" With xUnit, you implement the IAsyncLifetime interface on the test class to support asynchronous initialization and disposal of the app host instance. The InitializeAsync method is used to create the app host instance before the tests are run and the DisposeAsync method disposes the app host once the tests are completed. ```csharp public class WebTests : IAsyncLifetime { private DistributedApplication _app; public async Task InitializeAsync() { var appHost = await DistributedApplicationTestingBuilder .CreateAsync<Projects.AspireApp_AppHost>(); _app = await appHost.BuildAsync(); } public async Task DisposeAsync() => await _app.DisposeAsync(); [Fact] public async Task GetWebResourceRootReturnsOkStatusCode() { // test code here } } ``` :::zone-end :::zone pivot=""mstest"" With MSTest, you use the ```csharp [TestClass] public class WebTests { private static DistributedApplication _app; [ClassInitialize] public static async Task ClassInitialize(TestContext context) { var appHost = await DistributedApplicationTestingBuilder .CreateAsync<Projects.AspireApp_AppHost>(); _app = await appHost.BuildAsync(); } [ClassCleanup] public static async Task ClassCleanup() => await _app.DisposeAsync(); [TestMethod] public async Task GetWebResourceRootReturnsOkStatusCode() { // test code here } } ``` :::zone-end :::zone pivot=""nunit"" With NUnit, you use the OneTimeSetUp and OneTimeTearDown attributes on methods of the test class to provide the setup and teardown of the app host instance. The OneTimeSetUp method is used to create the app host instance before the tests are run and the OneTimeTearDown method disposes the app host instance once the tests are completed. ```csharp public class WebTests { private DistributedApplication _app; [OneTimeSetUp] public async Task OneTimeSetup() { var appHost = await DistributedApplicationTestingBuilder .CreateAsync<Projects.AspireApp_AppHost>(); _app = await appHost.BuildAsync(); } [OneTimeTearDown] public async Task OneTimeTearDown() => await _app.DisposeAsync(); [Test] public async Task GetWebResourceRootReturnsOkStatusCode() { // test code here } } ``` :::zone-end By capturing the app host in a field when the test run is started, you can access it in each test without the need to recreate it, decreasing the time it takes to run the tests. Then, when the test run has completed, the app host is disposed, which will clean up any resources that were created during the test run, such as containers. Use the DistributedApplicationFactory class While the DistributedApplicationTestingBuilder class is useful for many scenarios, there might be situations where you want more control over starting the app host, such as executing code before the builder is created or after the app host is built. In these cases, you implement your own version of the csharp public class TestingAspireAppHost : DistributedApplicationFactory(typeof(Projects.AspireApp_AppHost)) { // override methods here } The constructor requires the type of the app host project reference as a parameter. Optionally, you can provide arguments to the underlying host application builder. These arguments control how the app host starts and provide values to the args variable used by the Program.cs file to start the app host instance.', '<2-hop>\n\nIt aims to drastically simplify the authoring experience with a cleaner syntax and better support for modularity and code reuse. While .NET Aspire provides a set of prebuilt Bicep templates, there might be times when you either want to customize the templates or create your own. This section explains the concepts and corresponding APIs that you can use to customize the Bicep templates. [!IMPORTANT] This section isn\'t intended to teach you Bicep, but rather to provide guidance on how to create custom Bicep templates for use with .NET Aspire. As part of the Azure deployment story for .NET Aspire, the Azure Developer CLI (azd) provides an understanding of your .NET Aspire project and the ability to deploy it to Azure. The azd CLI uses the Bicep templates to deploy the application to Azure. Install Aspire.Hosting.Azure package When you want to reference Bicep files, it\'s possible that you\'re not using any of the Azure hosting integrations. In this case, you can still reference Bicep files by installing the Aspire.Hosting.Azure package. This package provides the necessary APIs to reference Bicep files and customize the Azure resources. [!TIP] If you\'re using any of the Azure hosting integrations, you don\'t need to install the Aspire.Hosting.Azure package, as it\'s a transitive dependency. To use any of this functionality, the ðŸ“¦ Aspire.Hosting.Azure NuGet package must be installed: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. What to expect from the examples All the examples in this section assume that you\'re using the ```csharp using Aspire.Hosting.Azure; var builder = DistributedApplication.CreateBuilder(args); // Examples go here... builder.Build().Run(); ``` By default, when you call any of the Bicep-related APIs, a call is also made to Reference Bicep files Imagine that you have a Bicep template in a file named storage.bicep that provisions an Azure Storage Account: :::code language=""bicep"" source=""snippets/AppHost.Bicep/storage.bicep""::: To add a reference to the Bicep file on disk, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.ReferenceBicep.cs"" id=""addfile""::: The preceding code adds a reference to a Bicep file located at ../infra/storage.bicep. The file paths should be relative to the app host project. This reference results in an Reference Bicep inline While having a Bicep file on disk is the most common scenario, you can also add Bicep templates inline. Inline templates can be useful when you want to define a template in code or when you want to generate the template dynamically. To add an inline Bicep template, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.InlineBicep.cs"" id=""addinline""::: In this example, the Bicep template is defined as an inline string and added to the application\'s resources collection with the name ""ai"". This example provisions an Azure AI resource. Pass parameters to Bicep templates Bicep supports accepting parameters, which can be used to customize the behavior of the template. To pass parameters to a Bicep template from .NET Aspire, chain calls to the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.PassParameter.cs"" id=""addparameter""::: The preceding code: Adds a parameter named ""region"" to the builder instance. Adds a reference to a Bicep file located at ../infra/storage.bicep. Passes the ""region"" parameter to the Bicep template, which is resolved using the standard parameter resolution. Passes the ""storageName"" parameter to the Bicep template with a hardcoded value. Passes the ""tags"" parameter to the Bicep template with an array of strings. For more information, see External parameters. Well-known parameters .NET Aspire provides a set of well-known parameters that can be passed to Bicep templates. These parameters are used to provide information about the application and the environment to the Bicep templates. The following well-known parameters are available: Field Description Value The name of the key vault resource used to store secret outputs. ""keyVaultName"" The location of the resource. This is required for all resources. ""location"" The resource ID of the log analytics workspace. ""logAnalyticsWorkspaceId"" The principal ID of the current user or managed identity. ""principalId"" The principal name of the current user or managed identity. ""principalName"" The principal type of the current user or managed identity. Either User or ServicePrincipal . ""principalType"" To use a well-known parameter, pass the parameter name to the Consider an example where you want to set up an Azure Event Grid webhook. You might define the Bicep template as follows: :::code language=""bicep"" source=""snippets/AppHost.Bicep/event-grid-webhook.bicep"" highlight=""3-4,27-35""::: This Bicep template defines several parameters, including the topicName, webHookEndpoint, principalId, principalType, and the optional location. To pass these parameters to the Bicep template, you can use the following code snippet: :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.PassParameter.cs"" id=""addwellknownparams""::: The webHookApi project is added as a reference to the builder. The topicName parameter is passed a hardcoded name value. The webHookEndpoint parameter is passed as an expression that resolves to the URL from the api project references\' ""https"" endpoint with the /hook route. The principalId and principalType parameters are passed as well-known parameters. The well-known parameters are convention-based and shouldn\'t be accompanied with a corresponding value when passed using the WithParameter API. Well-known parameters simplify some common functionality, such as role assignments, when added to the Bicep templates, as shown in the preceding example. Role assignments are required for the Event Grid webhook to send events to the specified endpoint. For more information, see Event Grid Data Sender role assignment. Get outputs from Bicep references In addition to passing parameters to Bicep templates, you can also get outputs from the Bicep templates. Consider the following Bicep template, as it defines an output named endpoint: :::code language=""bicep"" source=""snippets/AppHost.Bicep/storage-out.bicep""::: The Bicep defines an output named endpoint. To get the output from the Bicep template, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.GetOutputReference.cs"" id=""getoutput""::: In this example, the output from the Bicep template is retrieved and stored in an endpoint variable. Typically, you would pass this output as an environment variable to another resource that relies on it. For instance, if you had an ASP.NET Core Minimal API project that depended on this endpoint, you could pass the output as an environment variable to the project using the following code snippet: ```csharp var storage = builder.AddBicepTemplate( name: ""storage"", bicepFile: ""../infra/storage.bicep"" );']","The management of the app host in .NET Aspire tests is crucial because it ensures that the app host instance, which represents the full application environment, is efficiently created and disposed of during testing. This is particularly important as it can be expensive to create and tear down the app host. To facilitate this management, the ðŸ“¦ Aspire.Hosting.Testing NuGet package is used. On the other hand, the installation of the Aspire.Hosting.Azure package is necessary when you want to reference Bicep files and customize Azure resources. This package provides the APIs needed for such customizations, allowing developers to create and manage Bicep templates effectively. Thus, both packages play significant roles in their respective areasâ€”testing and Azure resource managementâ€”within the .NET Aspire framework.",multi_hop_specific_query_synthesizer
72,What is Stack Exchange Redis and how does it relate to observability and telemetry in .NET Aspire?,"['<1-hop>\n\ntitle: Stack Exchange Redis caching overview description: Learn about Stack Exchange Redis caching and how to use it in your applications. ms.date: 11/05/2024 Stack Exchange RedisÂ®* caching overview With .NET Aspire, there are several ways to use caching in your applications. One popular option is to use Stack Exchange Redis, which is a high-performance data store that can be used to store frequently accessed data. This article provides an overview of Stack Exchange Redis caching and links to resources that help you use it in your applications. To use multiple Redis caching integrations in your application, see Tutorial: Implement caching with .NET Aspire integrations. If you\'re interested in using the Redis Cache for Azure, see Tutorial: Deploy a .NET Aspire project with a Redis Cache to Azure. Redis serialization protocol (RESP) The Redis serialization protocol (RESP) is a binary-safe protocol that Redis uses to communicate with clients. RESP is a simple, text-based protocol that is easy to implement and efficient to parse. RESP is used to send commands to Redis and receive responses from Redis. RESP is designed to be fast and efficient, making it well-suited for use in high-performance applications. For more information, see Redis serialization protocol specification. In addition to Redis itself, there are two well-maintained implementations of RESP for .NET: Garnet: Garnet is a remote cache-store from Microsoft Research that offers strong performance (throughput and latency), scalability, storage, recovery, cluster sharding, key migration, and replication features. Garnet can work with existing Redis clients. Valkey: A flexible distributed key-value datastore that supports both caching and beyond caching workloads. .NET Aspire lets you easily model either the Redis, Garnet, or Valkey RESP protocol in your applications and you can choose which one to use based on your requirements. All of the .NET Aspire Redis integrations can be used with either the Redis, Garnet, or Valkey RESP protocol. Caching Caching is a technique used to store frequently accessed data in memory. This helps to reduce the time it takes to retrieve the data from the original source, such as a database or a web service. Caching can significantly improve the performance of an application by reducing the number of requests made to the original source. To access the Redis IConnectionMultiplexer object, you use the Aspire.StackExchange.Redis NuGet package: [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis integration [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis integration (Garnet) [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis integration (Valkey) Distributed caching Distributed caching is a type of caching that stores data across multiple servers. This allows the data to be shared between multiple instances of an application, which can help to improve scalability and performance. Distributed caching can be used to store a wide variety of data, such as session state, user profiles, and frequently accessed data. To use Redis distributed caching in your application (the IDistributedCache interface), use the Aspire.StackExchange.Redis.DistributedCaching NuGet package: [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis distributed caching integration [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis distributed caching integration (Garnet) [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis distributed caching integration (Valkey)', '<2-hop>\n\nObservability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations might only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire Stack Exchange Redis integration uses the following log categories: Aspire.StackExchange.Redis Tracing The .NET Aspire Stack Exchange Redis integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.StackExchangeRedis Metrics The .NET Aspire Stack Exchange Redis integration currently doesn\'t support metrics by default due to limitations with the StackExchange.Redis library. :::zone pivot=""redis"" [!INCLUDE azure-redis-app-host] [!INCLUDE azure-redis-client] :::zone-end See also Stack Exchange Redis docs .NET Aspire integrations .NET Aspire GitHub repo [!INCLUDE redis-trademark]']","Stack Exchange Redis is a high-performance data store used for caching frequently accessed data in applications. It is integrated with .NET Aspire, which automatically sets up logging, tracing, and metrics configurations, known as the pillars of observability. However, the .NET Aspire Stack Exchange Redis integration currently does not support metrics by default due to limitations with the StackExchange.Redis library.",multi_hop_specific_query_synthesizer
73,"What is the role of the Aspire.Hosting.Testing NuGet package in creating a .NET Aspire test project, and how does it relate to the resource types defined in Aspire.Hosting?","['<1-hop>\n\ntitle: Write your first .NET Aspire test description: Learn how to test your .NET Aspire solutions using the xUnit, NUnit, and MSTest testing frameworks. ms.date: 11/11/2024 zone_pivot_groups: unit-testing-framework Write your first .NET Aspire test In this article, you learn how to create a test project, write tests, and run them for your .NET Aspire solutions. The tests in this article aren\'t unit tests, but rather functional or integration tests. .NET Aspire includes several variations of testing project templates that you can use to test your .NET Aspire resource dependenciesâ€”and their communications. The testing project templates are available for MSTest, NUnit, and xUnit testing frameworks and include a sample test that you can use as a starting point for your tests. The .NET Aspire test project templates rely on the ðŸ“¦ Aspire.Hosting.Testing NuGet package. This package exposes the Create a test project The easiest way to create a .NET Aspire test project is to use the testing project template. If you\'re starting a new .NET Aspire project and want to include test projects, the Visual Studio tooling supports that option. If you\'re adding a test project to an existing .NET Aspire project, you can use the dotnet new command to create a test project: :::zone pivot=""xunit"" dotnetcli dotnet new aspire-xunit :::zone-end :::zone pivot=""mstest"" dotnetcli dotnet new aspire-mstest :::zone-end :::zone pivot=""nunit"" dotnetcli dotnet new aspire-nunit :::zone-end For more information, see the .NET CLI dotnet new command documentation. Explore the test project The following example test project was created as part of the .NET Aspire Starter Application template. If you\'re unfamiliar with it, see Quickstart: Build your first .NET Aspire project. The .NET Aspire test project takes a project reference dependency on the target app host. Consider the template project: :::zone pivot=""xunit"" :::code language=""xml"" source=""snippets/testing/xunit/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end :::zone pivot=""mstest"" :::code language=""xml"" source=""snippets/testing/mstest/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end :::zone pivot=""nunit"" :::code language=""xml"" source=""snippets/testing/nunit/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end The preceding project file is fairly standard. There\'s a PackageReference to the ðŸ“¦ Aspire.Hosting.Testing NuGet package, which includes the required types to write tests for .NET Aspire projects. The template test project includes a IntegrationTest1 class with a single test. The test verifies the following scenario: The app host is successfully created and started. The webfrontend resource is available and running. An HTTP request can be made to the webfrontend resource and returns a successful response (HTTP 200 OK). Consider the following test class: :::zone pivot=""xunit"" :::code language=""csharp"" source=""snippets/testing/xunit/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end :::zone pivot=""mstest"" :::code language=""csharp"" source=""snippets/testing/mstest/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end :::zone pivot=""nunit"" :::code language=""csharp"" source=""snippets/testing/nunit/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end The preceding code: Relies on the The appHost is an instance of IDistributedApplicationTestingBuilder that represents the app host. The appHost instance has its service collection configured with the standard HTTP resilience handler. For more information, see Build resilient HTTP apps: Key development patterns. The appHost has its The app has its service provider get the The app is started asynchronously. An The resourceNotificationService is used to wait for the webfrontend resource to be available and running. A simple HTTP GET request is made to the root of the webfrontend resource. The test asserts that the response status code is OK.', '<2-hop>\n\nResource types Each resource has a type field. When a deployment tool reads the manifest, it should read the type to verify whether it can correctly process the manifest. During the .NET Aspire preview period, all resource types have a v0 suffix to indicate that they\'re subject to change. As .NET Aspire approaches release a v1 suffix will be used to signify that the structure of the manifest for that resource type should be considered stable (subsequent updates increment the version number accordingly). Common resource fields The type field is the only field that is common across all resource types, however, the project.v0, container.v0, and executable.v0 resource types also share the env and bindings fields. [!NOTE] The executable.v0 resource type isn\'t fully implemented in the manifest due to its lack of utility in deployment scenarios. For more information on containerizing executables, see Dockerfile resource types. The env field type is a basic key/value mapping where the values might contain placeholder strings. Bindings are specified in the bindings field with each binding contained within its own field under the bindings JSON object. The fields omitted by the .NET Aspire manifest in the bindings node include: scheme: One of the following values tcp, udp, http, or https. protocol: One of the following values tcp or udp transport: Same as scheme, but used to disambiguate between http and http2. containerPort: Optional, if omitted defaults to port 80. The inputs field Some resources generate an inputs field. This field is used to specify input parameters for the resource. The inputs field is a JSON object where each property is an input parameter that\'s used in placeholder structure resolution. Resources that have a connectionString, for example, might use the inputs field to specify a password for the connection string: json ""connectionString"": ""Host={<resourceName>.bindings.tcp.host};Port={<resourceName>.bindings.tcp.port};Username=admin;Password={<resourceName>.inputs.password};"" The connection string placeholder references the password input parameter from the inputs field: json ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } The preceding JSON snippet shows the inputs field for a resource that has a connectionString field. The password input parameter is a string type and is marked as a secret. The default field is used to specify a default value for the input parameter. In this case, the default value is generated using the generate field, with random string of a minimum length. Built-in resources The following table is a list of resource types that are explicitly generated by .NET Aspire and extensions developed by the .NET Aspire team: Cloud-agnostic resource types These resources are available in the ðŸ“¦ Aspire.Hosting NuGet package. App model usage Manifest resource type Heading link container.v0 Container resource type PublishAsDockerFile dockerfile.v0 Dockerfile resource types value.v0 MongoDB Server resource types container.v0 MongoDB resource types value.v0 MySQL Server resource types container.v0 MySQL resource types value.v0 Postgres resource types container.v0 Postgres resource types project.v0 Project resource type container.v0 RabbitMQ resource types container.v0 Redis resource type value.v0 SQL Server resource types container.v0 SQL Server resource types Project resource type Example code: csharp var builder = DistributedApplication.CreateBuilder(args); var apiservice = builder.AddProject<Projects.AspireApp_ApiService>(""apiservice""); Example manifest: json ""apiservice"": { ""type"": ""project.v0"", ""path"": ""../AspireApp.ApiService/AspireApp.ApiService.csproj"", ""env"": { ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES"": ""true"", ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES"": ""true"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"" }, ""https"": { ""scheme"": ""https"", ""protocol"": ""tcp"", ""transport"": ""http"" } } } Container resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddContainer(""mycontainer"", ""myimage"") .WithEnvironment(""LOG_LEVEL"", ""WARN"") .WithHttpEndpoint(3000); ``` Example manifest: json { ""resources"": { ""mycontainer"": { ""type"": ""container.v0"", ""image"": ""myimage:latest"", ""env"": { ""LOG_LEVEL"": ""WARN"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 3000 } } } } } Dockerfile resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddNodeApp(""nodeapp"", ""../nodeapp/app.js"") .WithHttpEndpoint(hostPort: 5031, env: ""PORT"") .PublishAsDockerFile(); ``` [!TIP] The PublishAsDockerFile call is required to generate the Dockerfile resource type in the manifest, and this extension method is only available on the Example manifest: json { ""resources"": { ""nodeapp"": { ""type"": ""dockerfile.v0"", ""path"": ""../nodeapp/Dockerfile"", ""context"": ""../nodeapp"", ""env"": { ""NODE_ENV"": ""development"", ""PORT"": ""{nodeapp.bindings.http.port}"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 5031 } } } } } Postgres resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddPostgres(""postgres1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""postgres1"": { ""type"": ""container.v0"", ""connectionString"": ""Host={postgres1.bindings.tcp.host};Port={postgres1.bindings.tcp.port};Username=postgres;Password={postgres1.inputs.password}"", ""image"": ""postgres:16.2"", ""env"": { ""POSTGRES_HOST_AUTH_METHOD"": ""scram-sha-256"", ""POSTGRES_INITDB_ARGS"": ""--auth-host=scram-sha-256 --auth-local=scram-sha-256"", ""POSTGRES_PASSWORD"": ""{postgres1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5432 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{postgres1.connectionString};Database=shipping"" } } } RabbitMQ resource types RabbitMQ is modeled as a container resource container.v0. The following sample shows how they\'re added to the app model. ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRabbitMQ(""rabbitmq1""); ``` The previous code produces the following manifest: json { ""resources"": { ""rabbitmq1"": { ""type"": ""container.v0"", ""connectionString"": ""amqp://guest:{rabbitmq1.inputs.password}@{rabbitmq1.bindings.tcp.host}:{rabbitmq1.bindings.tcp.port}"", ""image"": ""rabbitmq:3"", ""env"": { ""RABBITMQ_DEFAULT_USER"": ""guest"", ""RABBITMQ_DEFAULT_PASS"": ""{rabbitmq1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5672 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } } } } Redis resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRedis(""redis1""); ``` Example manifest: json { ""resources"": { ""redis1"": { ""type"": ""container.v0"", ""connectionString"": ""{redis1.bindings.tcp.host}:{redis1.bindings.tcp.port}"", ""image"": ""redis:7.2.4"", ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 6379 } } } } } SQL Server resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddSqlServer(""sql1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""sql1"": { ""type"": ""container.v0"", ""connectionString"": ""Server={sql1.bindings.tcp.host},{sql1.bindings.tcp.port};User ID=sa;Password={sql1.inputs.password};TrustServerCertificate=true"", ""image"": ""mcr.microsoft.com/mssql/server:2022-latest"", ""env"": { ""ACCEPT_EULA"": ""Y"", ""MSSQL_SA_PASSWORD"": ""{sql1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 1433 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{sql1.connectionString};Database=shipping"" } } } MongoDB resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddMongoDB(""mongodb1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""mongodb1"": { ""type"": ""container.v0"", ""connectionString"": ""mongodb://{mongodb1.bindings.tcp.host}:{mongodb1.bindings.tcp.port}"", ""image"": ""mongo:7.0.5"", ""bindings"": { ""tcp"": { ""scheme"":']","The Aspire.Hosting.Testing NuGet package plays a crucial role in creating a .NET Aspire test project by providing the necessary types to write tests for .NET Aspire projects. It is utilized in the testing project templates available for MSTest, NUnit, and xUnit frameworks, allowing developers to create functional or integration tests for their .NET Aspire solutions. Additionally, the resource types defined in Aspire.Hosting, such as container.v0 and project.v0, are essential for managing the various components of an application, ensuring that the tests can effectively verify the functionality and integration of these resources.",multi_hop_specific_query_synthesizer
74,"What are the steps to integrate RabbitMQ with Azure using the Aspire.Hosting.Azure package, and how can you add a management plugin to the RabbitMQ server?","['<1-hop>\n\nHosting integration The RabbitMQ hosting integration models a RabbitMQ server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.RabbitMQ PackageReference xml <PackageReference Include=""Aspire.Hosting.RabbitMQ"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add RabbitMQ server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/rabbitmq image, it creates a new RabbitMQ server instance on your local machine. A reference to your RabbitMQ server (the rabbitmq variable) is added to the ExampleProject. The RabbitMQ server resource includes default credentials with a username of ""guest"" and randomly generated password using the The [!TIP] If you\'d rather connect to an existing RabbitMQ server, call Add RabbitMQ server resource with management plugin To add the RabbitMQ management plugin to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithManagementPlugin(); builder.AddProject // After adding all resources, run the app... ``` The RabbitMQ management plugin provides an HTTP-based API for management and monitoring of your RabbitMQ server. .NET Aspire adds another container image docker.io/library/rabbitmq-management to the app host that runs the management plugin. Add RabbitMQ server resource with data volume To add a data volume to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the RabbitMQ server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/rabbitmq path in the RabbitMQ server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add RabbitMQ server resource with data bind mount To add a data bind mount to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataBindMount( source: @""C:\\RabbitMQ\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the RabbitMQ server data across container restarts. The data bind mount is mounted at the C:\\RabbitMQ\\Data on Windows (or /RabbitMQ/Data on Unix) path on the host machine in the RabbitMQ server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add RabbitMQ server resource with parameters When you want to explicitly provide the username and password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username"", secret: true); var password = builder.AddParameter(""password"", secret: true); var rabbitmq = builder.AddRabbitMQ(""messaging"", username, password); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Hosting integration health checks The RabbitMQ hosting integration automatically adds a health check for the RabbitMQ server resource. The health check verifies that the RabbitMQ server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Rabbitmq NuGet package.', '<2-hop>\n\nAzure-specific resource types The following resources are available in the ðŸ“¦ Aspire.Hosting.Azure NuGet package. App Model usage Manifest resource type Heading link azure.bicep.v0 Azure App Configuration resource types azure.bicep.v0 Azure Key Vault resource type AddAzureRedis azure.bicep.v0 Azure Redis resource types azure.bicep.v0 Azure Service Bus resource type AddAzureSqlServer(...) azure.bicep.v0 Azure SQL resource types AddAzureSqlServer(...).AddDatabase(...) value.v0 Azure SQL resource types AddAzurePostgresFlexibleServer(...) azure.bicep.v0 Azure Postgres resource types AddAzurePostgresFlexibleServer(...).AddDatabase(...) value.v0 Azure Postgres resource types azure.storage.v0 Azure Storage resource types value.v0 Azure Storage resource types value.v0 Azure Storage resource types value.v0 Azure Storage resource types Azure Key Vault resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureKeyVault(""keyvault1""); ``` Example manifest: json { ""resources"": { ""keyvault1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{keyvault1.outputs.vaultUri}"", ""path"": ""aspire.hosting.azure.bicep.keyvault.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""vaultName"": ""keyvault1"" } } } } Azure Service Bus resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureServiceBus(""sb1"") .AddTopic(""topic1"", []) .AddTopic(""topic2"", []) .AddQueue(""queue1"") .AddQueue(""queue2""); ``` Example manifest: json { ""resources"": { ""sb1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{sb1.outputs.serviceBusEndpoint}"", ""path"": ""aspire.hosting.azure.bicep.servicebus.bicep"", ""params"": { ""serviceBusNamespaceName"": ""sb1"", ""principalId"": """", ""principalType"": """", ""queues"": [ ""queue1"", ""queue2"" ], ""topics"": [ { ""name"": ""topic1"", ""subscriptions"": [] }, { ""name"": ""topic2"", ""subscriptions"": [] } ] } } } } Azure Storage resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""images""); storage.AddBlobs(""blobs""); storage.AddQueues(""queues""); storage.AddTables(""tables""); ``` Example manifest: json { ""resources"": { ""images"": { ""type"": ""azure.bicep.v0"", ""path"": ""aspire.hosting.azure.bicep.storage.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""storageName"": ""images"" } }, ""blobs"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.blobEndpoint}"" }, ""queues"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.queueEndpoint}"" }, ""tables"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.tableEndpoint}"" } } } Azure Redis resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureRedis(""azredis1""); ``` Example manifest: json { ""resources"": { ""azredis"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{azredis.outputs.connectionString}"", ""path"": ""azredis.module.bicep"", ""params"": { ""principalId"": """", ""principalName"": """" } } } } Azure App Configuration resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureAppConfiguration(""appconfig1""); ``` Example manifest: json { ""resources"": { ""appconfig1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{appconfig1.outputs.appConfigEndpoint}"", ""path"": ""aspire.hosting.azure.bicep.appconfig.bicep"", ""params"": { ""configName"": ""appconfig1"", ""principalId"": """", ""principalType"": """" } } } } Azure SQL resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureSqlServer(""sql"") .AddDatabase(""inventory""); ``` Example manifest: json { ""resources"": { ""sql"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""Server=tcp:{sql.outputs.sqlServerFqdn},1433;Encrypt=True;Authentication=\\u0022Active Directory Default\\u0022"", ""path"": ""sql.module.bicep"", ""params"": { ""principalId"": """", ""principalName"": """" } }, ""inventory"": { ""type"": ""value.v0"", ""connectionString"": ""{sql.connectionString};Database=inventory"" } } } Azure Postgres resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzurePostgresFlexibleServer(""postgres"") .AddDatabase(""db""); ``` Example manifest: json { ""resources"": { ""postgres"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{postgres.outputs.connectionString}"", ""path"": ""postgres.module.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""principalName"": """" } }, ""db"": { ""type"": ""value.v0"", ""connectionString"": ""{postgres.connectionString};Database=db"" } } } Resource types supported in the Azure Developer CLI The Azure Developer CLI (azd) is a tool that can be used to deploy .NET Aspire projects to Azure Container Apps. With the azure.bicep.v0 resource type, cloud-agnostic resource container types can be mapped to Azure-specific resources. The following table lists the resource types that are supported in the Azure Developer CLI: Name Cloud-agnostic API Azure API Redis AddAzureRedis Postgres AddAzurePostgresFlexibleServer SQL Server AddAzureSqlServer When resources as configured as Azure resources, the azure.bicep.v0 resource type is generated in the manifest. For more information, see Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide). See also .NET Aspire overview .NET Aspire orchestration overview .NET Aspire integrations overview Service discovery in .NET Aspire']","To integrate RabbitMQ with Azure using the Aspire.Hosting.Azure package, you first need to add the RabbitMQ server resource in your app host project. This can be done by calling `var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging""); builder.AddProject`. To add the RabbitMQ management plugin, you can modify the RabbitMQ server resource by calling `var rabbitmq = builder.AddRabbitMQ(""messaging"").WithManagementPlugin();`. This will provide an HTTP-based API for management and monitoring of your RabbitMQ server.",multi_hop_specific_query_synthesizer
75,"What are the essential requirements for using the C# Dev Kit with .NET Aspire, and how does it integrate with the dashboard authentication process?","['<1-hop>\n\ntitle: Explore .NET Aspire dashboard description: Explore the .NET Aspire dashboard features through the .NET Aspire Starter app. ms.date: 11/07/2024 ms.topic: reference Explore the .NET Aspire dashboard In the upcoming sections, you discover how to create a .NET Aspire project and embark on the following tasks: [!div class=""checklist""] Investigate the dashboard\'s capabilities by using the app generated from the project template as explained in the Quickstart: Build your first .NET Aspire project. Delve into the features of the .NET Aspire dashboard app. The screenshots featured in this article showcase the dark theme. For more information on theme selection, see Theme selection. Dashboard authentication When you run a .NET Aspire app host, the orchestrator starts up all the app\'s dependent resources and then opens a browser window to the dashboard. The .NET Aspire dashboard requires token-based authentication for its users because it displays environment variables and other sensitive information. When the dashboard is launched from Visual Studio or Visual Studio Code (with the C# Dev Kit extension), the browser is automatically logged in, and the dashboard opens directly. This is the typical developer F5 experience, and the authentication login flow is automated by the .NET Aspire tooling. However, if you start the app host from the command line, you\'re presented with the login page. The console window displays a URL that you can select on to open the dashboard in your browser. :::image type=""content"" source=""media/explore/dotnet-run-login-url.png"" lightbox=""media/explore/dotnet-run-login-url.png"" alt-text="".NET CLI run command output, showing the login URL with token query string.""::: The URL contains a token query string (with the token value mapped to the t name part) that\'s used to log in to the dashboard. If your console supports it, you can hold the Ctrl key and then select the link to open the dashboard in your browser. This method is easier than copying the token from the console and pasting it into the login page. If you end up on the dashboard login page without either of the previously described methods, you can always return to the console to copy the token. :::image type=""content"" source=""media/explore/aspire-login.png"" lightbox=""media/explore/aspire-login.png"" alt-text="".NET Aspire dashboard login page.""::: The login page accepts a token and provides helpful instructions on how to obtain the token, as shown in the following screenshot: :::image type=""content"" source=""media/explore/aspire-login-help.png"" lightbox=""media/explore/aspire-login-help.png"" alt-text="".NET Aspire dashboard login page with instructions on how to obtain the token.""::: After copying the token from the console and pasting it into the login page, select the Log in button. :::image type=""content"" source=""media/explore/aspire-login-filled.png"" lightbox=""media/explore/aspire-login-filled.png"" alt-text="".NET Aspire dashboard login page with the token pasted into the textbox.""::: The dashboard persists the token as a browser persistent cookie, which remains valid for three days. Persistent cookies have an expiration date and remain valid even after closing the browser. This means that users don\'t need to log in again if they close and reopen the browser. For more information, see the Security considerations for running the .NET Aspire dashboard documentation. the .NET Aspire dashboard Resources page filtered to show only containers.""::: Executables are stand-alone processes. You can configure a .NET Aspire project to run a stand-alone executable during startup, though the default starter templates don\'t include any executables by default. The following screenshot shows an example of a project that has errors: :::image type=""content"" source=""media/explore/projects-errors.png"" lightbox=""media/explore/projects-errors.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing a project with errors.""::: Selecting the error count badge navigates to the Structured logs page with a filter applied to show only the logs relevant to the resource: :::image type=""content"" source=""media/explore/structured-logs-errors.png"" lightbox=""media/explore/structured-logs-errors.png"" alt-text=""A screenshot of the .NET Aspire dashboard Structured logs page, showing a filter applied to show only the logs relevant to the resource.""::: To see the log entry in detail for the error, select the View button to open a window below the list with the structured log entry details: :::image type=""content"" source=""media/explore/structured-logs-errors-view.png"" lightbox=""media/explore/structured-logs-errors-view.png"" alt-text=""A screenshot of the .NET Aspire dashboard Structured logs page, showing a lower window with the structured log entry details.""::: For more information and examples of Structured logs, see the Structured logs page section. [!NOTE] The resources page isn\'t available if the dashboard is started without a configured resource service. The dashboard starts on the Structured logs page instead. This is the default experience when the dashboard is run in standalone mode without additional configuration. For more information about configuring a resource service, see Dashboard configuration.', '<2-hop>\n\ntitle: .NET Aspire tooling description: Learn about essential tooling concepts for .NET Aspire. ms.date: 01/17/2025 zone_pivot_groups: dev-environment uid: dotnet/aspire/setup-tooling .NET Aspire setup and tooling .NET Aspire includes tooling to help you create and configure cloud-native apps. The tooling includes useful starter project templates and other features to streamline getting started with .NET Aspire for Visual Studio, Visual Studio Code, and CLI workflows. In the sections ahead, you learn how to work with .NET Aspire tooling and explore the following tasks: [!div class=""checklist""] Install .NET Aspire and its dependencies Create starter project templates using Visual Studio, Visual Studio Code, or the .NET CLI Install .NET Aspire integrations Work with the .NET Aspire dashboard Install .NET Aspire To work with .NET Aspire, you need the following installed locally: .NET 8.0 or .NET 9.0. An OCI compliant container runtime, such as: Docker Desktop or Podman. For more information, see Container runtime. An Integrated Developer Environment (IDE) or code editor, such as: Visual Studio 2022 version 17.9 or higher (Optional) Visual Studio Code (Optional) C# Dev Kit: Extension (Optional) JetBrains Rider with .NET Aspire plugin (Optional) :::zone pivot=""visual-studio"" Visual Studio 2022 17.9 or higher includes the latest .NET Aspire SDK by default when you install the Web & Cloud workload. If you have an earlier version of Visual Studio 2022, you can either upgrade to Visual Studio 2022 17.9 or you can install the .NET Aspire SDK using the following steps: To install the .NET Aspire workload in Visual Studio 2022, use the Visual Studio installer. Open the Visual Studio Installer. Select Modify next to Visual Studio 2022. Select the ASP.NET and web development workload. On the Installation details panel, select .NET Aspire SDK. Select Modify to install the .NET Aspire integration. :::image type=""content"" loc-scope=""visual-studio"" source=""media/setup-tooling/web-workload-with-aspire.png"" lightbox=""media/setup-tooling/web-workload-with-aspire.png"" alt-text=""A screenshot showing how to install the .NET Aspire workload with the Visual Studio installer.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" :::zone-end Container runtime .NET Aspire projects are designed to run in containers. You can use either Docker Desktop or Podman as your container runtime. Docker Desktop is the most common container runtime. Podman is an open-source daemonless alternative to Docker, that can build and run Open Container Initiative (OCI) containers. If your host environment has both Docker and Podman installed, .NET Aspire defaults to using Docker. You can instruct .NET Aspire to use Podman instead, by setting the DOTNET_ASPIRE_CONTAINER_RUNTIME environment variable to podman: Linux bash export DOTNET_ASPIRE_CONTAINER_RUNTIME=podman For more information, see Install Podman on Linux. Windows ```powershell ``` For more information, see Install Podman on Windows.  see .NET Aspire orchestration overview. Enlist in orchestration Visual Studio provides the option to Enlist in Aspire orchestration during the new project workflow. Select this option to have Visual Studio create .AppHost_ and _.ServiceDefaults projects alongside your selected project template. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/aspire-enlist-orchestration.png"" lightbox=""../media/aspire-enlist-orchestration.png"" alt-text=""A screenshot showing how to enlist in .NET Aspire orchestration.""::: Create test project When you\'re using Visual Studio, and you select the .NET Aspire Start Application template, you have the option to include a test project. This test project is an xUnit project that includes a sample test that you can use as a starting point for your tests. :::image type=""content"" source=""media/setup-tooling/create-test-projects-template.png"" lightbox=""media/setup-tooling/create-test-projects-template.png"" alt-text=""A screenshot of Visual Studio displaying the option to create a test project.""::: For more information, see Write your first .NET Aspire test. :::zone-end :::zone pivot=""vscode"" Visual Studio Code tooling You can use Visual Studio Code, with the C# Dev Kit extension, to create and develop .NET Aspire projects. To create a new .NET Aspire project in Visual Studio Code, select the Create .NET Project button in the Explorer view, then select one of the .NET Aspire templates: :::image type=""content"" source=""media/vscode-create-dotnet-aspire-proj.png"" lightbox=""media/vscode-create-dotnet-aspire-proj.png"" alt-text=""A screenshot showing how to create a new .NET Aspire project in Visual Studio Code.""::: Once you create a new .NET Aspire project, you run and debug the app, stepping through breakpoints, and inspecting variables using the Visual Studio Code debugger: :::image type=""content"" source=""media/setup-tooling/vscode-debugging.png"" lightbox=""media/setup-tooling/vscode-debugging.png"" alt-text=""A screenshot showing how to debug a .NET Aspire project in Visual Studio Code.""::: :::zone-end See also Unable to install .NET Aspire workload Use Dev Proxy with .NET Aspire project']","To use the C# Dev Kit with .NET Aspire, you need to have .NET 8.0 or .NET 9.0 installed locally, along with an OCI compliant container runtime like Docker Desktop or Podman. The C# Dev Kit is an optional extension that enhances the development experience in Visual Studio and Visual Studio Code. When you run a .NET Aspire app host, the dashboard requires token-based authentication for its users. If the app is launched from Visual Studio or Visual Studio Code with the C# Dev Kit extension, the browser is automatically logged in, allowing direct access to the dashboard. This integration streamlines the authentication process, making it easier for developers to access the dashboard without manual login steps.",multi_hop_specific_query_synthesizer
76,What is the role of Azure Storage Blobs in the integration with Azure Storage Account as described in the .NET Aspire Azure Functions integration?,"['<1-hop>\n\ntitle: .NET Aspire Azure Functions integration (Preview) description: Learn how to integrate Azure Functions with .NET Aspire. ms.date: 11/13/2024 zone_pivot_groups: dev-environment .NET Aspire Azure Functions integration (Preview) [!INCLUDE includes-hosting] [!IMPORTANT] The .NET Aspire Azure Functions integration is currently in preview and is subject to change. Azure Functions is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. The .NET Aspire Azure Functions integration enables you to develop, debug, and orchestrate an Azure Functions .NET project as part of the app host. It\'s expected that you\'ve installed the required Azure tooling: :::zone pivot=""visual-studio"" Configure Visual Studio for Azure development with .NET :::zone-end :::zone pivot=""vscode"" Configure Visual Studio Code for Azure development with .NET :::zone-end :::zone pivot=""dotnet-cli"" Install the Azure Functions Core Tools :::zone-end Supported scenarios The .NET Aspire Azure Functions integration has several key supported scenarios. This section outlines the scenarios and provides details related to the implementation of each approach. Supported triggers The following table lists the supported triggers for Azure Functions in the .NET Aspire integration: Trigger Attribute Details Azure Event Hubs trigger EventHubTrigger ðŸ“¦ Aspire.Hosting.Azure.EventHubs Azure Service Bus trigger ServiceBusTrigger ðŸ“¦ Aspire.Hosting.Azure.ServiceBus Azure Storage Blobs trigger BlobTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage Azure Storage Queues trigger QueueTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage HTTP trigger HttpTrigger Supported without any additional resource dependencies. Timer trigger TimerTrigger Supported without any additional resource dependenciesâ€”relies on implicit host storage. [!IMPORTANT] Other Azure Functions triggers and bindings aren\'t currently supported in the .NET Aspire Azure Functions integration. Deployment Currently, deployment is supported only to containers on Azure Container Apps (ACA) using the SDK container publish function in Microsoft.Azure.Functions.Worker.Sdk. This deployment methodology doesn\'t currently support KEDA-based autoscaling. Configure external HTTP endpoints To make HTTP triggers publicly accessible, call the', '<2-hop>\n\nAdd the Worker Service project Next, add a Worker Service project to the solution to retrieve and process messages as they are added to the Azure Storage queue. Visual Studio In the solution explorer, right click on the top level AspireStorage solution node and select Add > New project. Search for and select the Worker Service template and choose Next. For the Project name, enter AspireStorage.WorkerService and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Make sure Enlist in .NET Aspire orchestration is checked and select Create. Visual Studio adds the project to your solution and updates the :::no-loc text=""Program.cs""::: file of the AspireStorage.AppHost project with a new line of code: csharp builder.AddProject<Projects.AspireStorage_WorkerService>( ""aspirestorage-workerservice""); Visual Studio tooling added this line of code to register your new project with the .NET CLI In the root directory of the app, use the dotnet new command to create a new Worker Service app: dotnetcli dotnet new worker --name AspireStorage.WorkerService Use the dotnet sln command to add the project to the solution: dotnet sln AspireStorage.sln add AspireStorage.WorkerService/AspireStorage.WorkerService.csproj Use the dotnet add reference command to add project reference between the .AppHost and .WorkerService project: dotnetcli dotnet add AspireStorage.AppHost/AspireStorage.AppHost.csproj reference AspireStorage.WorkerService/AspireStorage.WorkerService.csproj Add the following line of code to the :::no-loc text=""Program.cs""::: file in the AspireStorage.AppHost project: csharp builder.AddProject<Projects.AspireStorage_WorkerService>( ""aspirestorage-workerservice""); The completed solution structure should resemble the following: :::image type=""content"" loc-scope=""visual-studio"" source=""media/storage-project.png"" alt-text=""A screenshot showing the structure of the .NET Aspire storage sample solution.""::: Add the .NET Aspire integrations to the Blazor app Add the .NET Aspire Azure Blob Storage integration and .NET Aspire Azure Queue Storage integration packages to your AspireStorage.Web project: dotnetcli dotnet add package Aspire.Azure.Storage.Blobs dotnet add package Aspire.Azure.Storage.Queues Your AspireStorage.Web project is now set up to use .NET Aspire integrations. Here\'s the updated AspireStorage.Web.csproj file: :::code language=""xml"" source=""snippets/tutorial/AspireStorage/AspireStorage.Web/AspireStorage.Web.csproj"" highlight=""14-15""::: The next step is to add the integrations to the app. In the :::no-loc text=""Program.cs""::: file of the AspireStorage.Web project, add calls to the :::zone pivot=""azurite"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.Web/Program.cs"" highlight=""4-5,9-10,36-48""::: :::zone-end :::zone pivot=""azure-portal,azure-cli"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.Web/Program.cs"" range=""1-35,49-63"" highlight=""2-3,7-8""::: :::zone-end With the additional using statements, these methods accomplish the following tasks: Register a Automatically enable corresponding health checks, logging, and telemetry for the respective services. :::zone pivot=""azurite"" When the AspireStorage.Web project starts, it will create a fileuploads container in Azurite Blob Storage and a tickets queue in Azurite Queue Storage. This is conditional when the app is running in a development environment. When the app is running in a production environment, the container and queue are assumed to have already been created. :::zone-end Add the .NET Aspire integration to the Worker Service The worker service handles pulling messages off of the Azure Storage queue for processing. Add the .NET Aspire Azure Queue Storage integration integration package to your AspireStorage.WorkerService app: dotnetcli dotnet add package Aspire.Azure.Storage.Queues In the :::no-loc text=""Program.cs""::: file of the AspireStorage.WorkerService project, add a call to the :::code source=""snippets/tutorial/AspireStorage/AspireStorage.WorkerService/Program.cs"" highlight=""5""::: This method handles the following tasks: Register a Automatically enable corresponding health checks, logging, and telemetry for the respective services. Create the form The app requires a form for the user to be able to submit support ticket information and upload an attachment. The app uploads the attached file on the Document ( Use the following Razor markup to create a basic form, replacing the contents of the Home.razor file in the AspireStorage.Web/Components/Pages directory: :::code language=""razor"" source=""snippets/tutorial/AspireStorage/AspireStorage.Web/Components/Pages/Home.razor""::: For more information about creating forms in Blazor, see ASP.NET Core Blazor forms overview. Update the AppHost The AspireStorage.AppHost project is the orchestrator for your app. It\'s responsible for connecting and configuring the different projects and services of your app. The orchestrator should be set as the startup project. To add Azure Storage hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Storage PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Storage"" Version=""*"" /> Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireStorage.AppHost project with the following code: :::zone pivot=""azurite"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.AppHost/Program.cs""::: The preceding code adds Azure storage, blobs, and queues, and when in development mode, it uses the emulator. Each project defines references for these resources that they depend on. :::zone-end :::zone pivot=""azure-portal,azure-cli"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.AppHost/Program.cs"" range=""1-6,12-27""::: The preceding code adds Azure storage, blobs, and queues, and defines references for these resources within each project that depend on them. :::zone-end Process the items in the queue When a new message is placed on the tickets queue, the worker service should retrieve, process, and delete the message. Update the Worker.cs class, replacing the contents with the following code: :::zone pivot=""azurite"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.WorkerService/Worker.cs""::: Before the worker service can process messages, it needs to be able to connect to the Azure Storage queue. With Azurite, you need to ensure that the queue is available before the worker service starts executing message queue processing. :::zone-end :::zone pivot=""azure-portal,azure-cli"" :::code source=""snippets/tutorial/AspireStorage/AspireStorage.WorkerService/Worker.cs"" range=""1-12,15-37""::: The worker service processes messages by connecting to the Azure Storage queue, and pulling messages off the queue. :::zone-end The worker service processes message in the queue and deletes them when they\'ve been processed. :::zone pivot=""azure-portal,azure-cli,azure-developer-cli"" Configure the connection strings The AspireStorage and AspireStorage.Worker projects must be configured to connect to the correct Azure Storage Account you created earlier. You can specify the endpoints for the blob and queue services in the storage account using the :::no-loc text=""appsettings.json""::: file in each project. In the AspireStorage project, add the following configuration to the appsettings.Development.json file: json ""ConnectionStrings"": { ""BlobConnection"": ""https://<your-storage-account-name>.blob.core.windows.net/"", ""QueueConnection"": ""https://<your-storage-account-name>.queue.core.windows.net/"" } In the AspireStorage.Worker project, add the following configuration to the appsettings.Development.json file: json ""ConnectionStrings"": { ""QueueConnection"": ""https://<your-storage-account-name>.queue.core.windows.net/"" } :::zone-end']","In the .NET Aspire Azure Functions integration, Azure Storage Blobs play a crucial role as one of the supported triggers. Specifically, the Azure Storage Blobs trigger, identified as BlobTrigger, allows Azure Functions to respond to events related to blob storage, enabling the processing of data as it is added or modified in the Azure Storage Account. This integration facilitates the development of serverless applications that can efficiently handle data stored in Azure Storage Blobs.",multi_hop_specific_query_synthesizer
77,How do the .NET Aspire templates utilize Microsoft.AspNetCore.App and Microsoft.AspNetCore.Mvc in creating a new app host for testing MailDev integration?,"['<1-hop>\n\ntitle: .NET Aspire templates description: Learn how to install the .NET Aspire templates, and how to use them to create new apps. ms.date: 11/09/2024 zone_pivot_groups: dev-environment uid: dotnet/aspire/templates .NET Aspire templates There are a number of .NET Aspire project templates available to you. You can use these templates to create full .NET Aspire solutions, or add individual projects to existing .NET Aspire solutions. The .NET Aspire templates are available in the ðŸ“¦ Aspire.ProjectTemplates NuGet package. Install the .NET Aspire templates :::zone pivot=""visual-studio"" To install the .NET Aspire templates in Visual Studio, you need to manually install them unless you\'re using Visual Studio 17.12 or later. For Visual Studio 17.9 to 17.11, follow these steps: Open Visual Studio. Go to Tools > NuGet Package Manager > Package Manager Console. Run the following command to install the templates: dotnetcli dotnet new install Aspire.ProjectTemplates For Visual Studio 17.12 or later, the .NET Aspire templates are installed automatically. :::zone-end :::zone pivot=""vscode,dotnet-cli"" To install these templates, use the dotnet new install command, passing in the Aspire.ProjectTemplates NuGet identifier. dotnetcli dotnet new install Aspire.ProjectTemplates To install a specific version, append the version number to the package name: dotnetcli dotnet new install Aspire.ProjectTemplates::9.0.0 [!TIP] If you already have the .NET Aspire workload installed, you need to pass the --force flag to overwrite the existing templates. Feel free to uninstall the .NET Aspire workload. :::zone-end List the .NET Aspire templates :::zone pivot=""visual-studio"" The .NET Aspire templates are installed automatically when you install Visual Studio 17.9 or later. To see what .NET Aspire templates are available, select File > New > Project in Visual Studio, and search for ""Aspire"" in the search bar (Alt+S). You\'ll see a list of available .NET Aspire project templates: :::image type=""content"" source=""media/vs-create-dotnet-aspire-proj.png"" alt-text=""Visual Studio: Create new project and search for \'Aspire\'."" lightbox=""media/vs-create-dotnet-aspire-proj.png""::: :::zone-end :::zone pivot=""vscode"" To view the available templates in Visual Studio Code with the C# DevKit installed, select the Create .NET Project button when no folder is opened in the Explorer view: :::image type=""content"" source=""media/vscode-create-dotnet-proj.png"" alt-text=""Visual Studio Code: Create .NET Project button."" lightbox=""media/vscode-create-dotnet-proj.png""::: Then, search for ""Aspire"" in the search bar to see the available .NET Aspire project templates: :::image type=""content"" source=""media/vscode-create-dotnet-aspire-proj.png"" alt-text=""Visual Studio Code: Create new project and search for \'Aspire\'."" lightbox=""media/vscode-create-dotnet-aspire-proj.png""::: :::zone-end :::zone pivot=""dotnet-cli"" To verify that the .NET Aspire templates are installed, use the dotnet new list command, passing in the aspire template name: dotnetcli dotnet new list aspire Your console output should look like the following: [!INCLUDE dotnet-new-list-aspire-output] :::zone-end Available templates The .NET Aspire templates allow you to create new apps pre-configured with the .NET Aspire solutions structure and default settings. These projects also provide a unified debugging experience across the different resources of your app. .NET Aspire templates are available in two categories: solution templates and project templates. Solution templates create a new .NET Aspire solution with multiple projects, while project templates create individual projects that can be added to an existing .NET Aspire solution. Solution templates The following .NET Aspire solution templates are available, assume the solution is named AspireSample: .NET Aspire Empty App: A minimal .NET Aspire project that includes the following: AspireSample.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. AspireSample.ServiceDefaults: A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. .NET Aspire Starter App: In addition to the .AppHost and .ServiceDefaults projects, the .NET Aspire Starter App also includes the following: AspireSample.ApiService: An ASP.NET Core Minimal API project is used to provide data to the frontend. This project depends on the shared AspireSample.ServiceDefaults project. AspireSample.Web: An ASP.NET Core Blazor App project with default .NET Aspire service configurations, this project depends on the AspireSample.ServiceDefaults project. AspireSample.Test: Either an MSTest, NUnit, or xUnit test project with project references to the AspireSample.AppHost and an example WebTests.cs file demonstrating an integration test. Project templates The following .NET Aspire project templates are available: .NET Aspire App Host: A standalone .AppHost project that can be used to orchestrate and manage the different projects and services of your app. .NET Aspire Test projects: These project templates are used to create test projects for your .NET Aspire app, and they\'re intended to represent functional and integration tests. The test projects include the following templates: MSTest: A project that contains MSTest integration of a .NET Aspire AppHost project. NUnit: A project that contains NUnit integration of a .NET Aspire AppHost project. xUnit: A project that contains xUnit.net integration of a .NET Aspire AppHost project. For more information on the test templates, see Testing in .NET Aspire. .NET Aspire Service Defaults: A standalone .ServiceDefaults project that can be used to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. [!IMPORTANT] The service defaults project template takes a FrameworkReference dependency on Microsoft.AspNetCore.App. This may not be ideal for some project types. For more information, see .NET Aspire service defaults.', '<2-hop>\n\nAdd a .NET service project to the app host for testing Once .NET Aspire can successfully launch the MailDev integration, it\'s time to consume the connection information for MailDev within a .NET project. In .NET Aspire it\'s common for there to be a hosting package and one or more component packages. For example consider: Hosting package: Used to represent resources within the app model. Aspire.Hosting.Redis Component packages: Used to configure and consume client libraries. Aspire.StackExchange.Redis Aspire.StackExchange.Redis.DistributedCaching Aspire.StackExchange.Redis.OutputCaching In the case of the MailDev resource, the .NET platform already has a simple mail transfer protocol (SMTP) client in the form of In order to test the end-to-end scenario, you need a .NET project which we can inject the connection information into for the MailDev resource. Add a Web API project: Create a new .NET project named :::no-loc text=""MailDevResource.NewsletterService"":::. dotnetcli dotnet new webapi --use-minimal-apis -o MailDevResource.NewsletterService Add a reference to the :::no-loc text=""MailDev.Hosting""::: project. dotnetcli dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference ./MailDev.Hosting/MailDev.Hosting.csproj Add a reference to the :::no-loc text=""MailDevResource.AppHost""::: project. dotnetcli dotnet add ./MailDevResource.AppHost/MailDevResource.AppHost.csproj reference ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj Add the new project to the solution file. dotnetcli dotnet sln ./MailDevResource.sln add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj After the project has been added and references have been updated, open the :::no-loc text=""Program.cs""::: of the :::no-loc text=""MailDevResource.AppHost.csproj""::: project, and update the source file to look like the following: :::code source=""snippets/MailDevResource/MailDevResource.AppHost/Program.cs""::: After updating the :::no-loc text=""Program.cs""::: file, launch the app host again. Then verify that the Newsletter Service started and that the environment variable ConnectionStrings__maildev was added to the process. From the Resources page, find the newsletterservice row, and select the View link on the Details column: :::image type=""content"" source=""media/maildev-envvar.png"" lightbox=""media/maildev-envvar.png"" alt-text=""Environment variables for Newsletter Service in .NET Aspire Dashboard.""::: The preceding screenshot shows the environment variables for the newsletterservice project. The ConnectionStrings__maildev environment variable is the connection string that was injected into the project by the maildev resource. Use connection string to send messages To use the SMTP connection details that were injected into the newsletter service project, you inject an instance of :::code source=""snippets/MailDevResource/MailDevResource.NewsletterService/Program.cs"" id=""smtp""::: [!TIP] This code snippet relies on the official SmtpClient, however; this type is obsolete on some platforms and not recommended on others. For a more modern approach using MailKit, see Create custom .NET Aspire client integrations. To test the client, add two simple subscribe and unsubscribe POST methods to the newsletter service. Add the following code replacing the ""weatherforecast"" MapGet call in the :::no-loc text=""Program.cs""::: file of the MailDevResource.NewsletterService project to set up the ASP.NET Core routes: :::code source=""snippets/MailDevResource/MailDevResource.NewsletterService/Program.cs"" id=""subs""::: [!TIP] Remember to reference the System.Net.Mail and Microsoft.AspNetCore.Mvc namespaces in :::no-loc text=""Program.cs""::: if your code editor doesn\'t automatically add them. Once the :::no-loc text=""Program.cs""::: file is updated, launch the app host and use your browser, or curl to hit the following URLs (alternatively if you\'re using Visual Studio you can use .http files): http POST /subscribe?email=test@test.com HTTP/1.1 Host: localhost:7251 Content-Type: application/json To use this API, you can use curl to send the request. The following curl command sends an HTTP POST request to the subscribe endpoint, and it expects an email query string value to subscribe to the newsletter. The Content-Type header is set to application/json to indicate that the request body is in JSON format.: Unix bash curl -H ""Content-Type: application/json"" --request POST https://localhost:7251/subscribe?email=test@test.com Windows powershell curl -H @{ ContentType = ""application/json"" } -Method POST https://localhost:7251/subscribe?email=test@test.com The next API is the unsubscribe endpoint. This endpoint is used to unsubscribe from the newsletter. http POST /unsubscribe?email=test@test.com HTTP/1.1 Host: localhost:7251 Content-Type: application/json To unsubscribe from the newsletter, you can use the following curl command, passing an email parameter to the unsubscribe endpoint as a query string: Unix bash curl -H ""Content-Type: application/json"" --request POST https://localhost:7251/unsubscribe?email=test@test.com Windows powershell curl -H @{ ContentType = ""application/json"" } -Method POST https://localhost:7251/unsubscribe?email=test@test.com [!TIP] Make sure that you replace the https://localhost:7251 with the correct localhost port (the URL of the app host that you are running). If those API calls return a successful response (HTTP 200, Ok) then you should be able to select on the maildev resource the dashboard and the :::no-loc text=""MailDev UI""::: will show the emails that have been sent to the SMTP endpoint. :::image type=""content"" source=""media/maildev-emails.png"" lightbox=""media/maildev-emails.png"" alt-text=""E-mails visible in the MailDev UI""::: Technical details In the following sections, various technical details are discussed which are important to understand when developing custom resources for .NET Aspire. Secure networking In this example, the MailDev resource is a container resource which is exposed to the host machine over HTTP and SMTP. The MailDev resource is a development tool and isn\'t intended for production use. To instead use HTTPS, see MailDev: Configure HTTPS. When developing custom resources that expose network endpoints, it\'s important to consider the security implications of the resource. For example, if the resource is a database, it\'s important to ensure that the database is secure and that the connection string isn\'t exposed to the public internet. The ReferenceExpression and EndpointReference type In the preceding code, the MailDevResource had two properties: SmtpEndpoint: ConnectionStringExpression: These types are among several which are used throughout .NET Aspire to represent configuration data, which isn\'t finalized until the .NET Aspire project is either run or published to the cloud via a tool such as Azure Developer CLI (azd). The fundamental problem that these types help to solve, is deferring resolution of concrete configuration information until all the information is available. For example, the MailDevResource exposes a property called ConnectionStringExpression as required by the csharp public ReferenceExpression ConnectionStringExpression => ReferenceExpression.Create( $""smtp://{SmtpEndpoint.Property(EndpointProperty.Host)}:{SmtpEndpoint.Property(EndpointProperty.Port)}"" ); The signature for the csharp public static ReferenceExpression Create( in ExpressionInterpolatedStringHandler handler) This isn\'t a regular Here\'s how the flow of execution works: A resource which implements The IResourceBuilder<MailDevResource> is passed to the The WithReference wraps the resource in a As the process that references the connection string starts .NET Aspire starts evaluating the expression. It first gets the The GetValueAsync method gets the value of the The Because the interpolated string contains references to other reference types such as Manifest publishing The To solve this problem .NET Aspire produces a manifest file which']","The .NET Aspire templates utilize Microsoft.AspNetCore.App by requiring it as a FrameworkReference dependency in the .NET Aspire Service Defaults project template. This is important for managing configurations related to resilience, service discovery, and telemetry across the projects in your solution. Additionally, when creating a new .NET project for testing MailDev integration, you can add a Web API project using the command 'dotnet new webapi --use-minimal-apis -o MailDevResource.NewsletterService'. This project will depend on Microsoft.AspNetCore.Mvc to handle HTTP requests and responses, allowing you to implement the necessary API endpoints for subscribing and unsubscribing from the newsletter service.",multi_hop_specific_query_synthesizer
78,How does the MailKitClientFactory utilize the Credentials property from MailKitClientSettings to authenticate with the SMTP server?,"['<1-hop>\n\nExpose client functionality The goal of .NET Aspire integrations is to expose the underlying client library to consumers through dependency injection. With MailKit and for this example, the SmtpClient class is what you want to expose. You\'re not wrapping any functionality, but rather mapping configuration settings to an SmtpClient class. It\'s common to expose both standard and keyed-service registrations for integrations. Standard registrations are used when there\'s only one instance of a service, and keyed-service registrations are used when there are multiple instances of a service. Sometimes, to achieve multiple registrations of the same type you use a factory pattern. Add the following code to the MailKit.Client project in a file named MailKitClientFactory.cs: :::code source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKitClientFactory.cs""::: The MailKitClientFactory class is a factory that creates an ISmtpClient instance based on the configuration settings. It\'s responsible for returning an ISmtpClient implementation that has an active connection to a configured SMTP server. Next, you need to expose the functionality for the consumers to register this factory with the dependency injection container. Add the following code to the MailKit.Client project in a file named MailKitExtensions.cs: :::code source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKitExtensions.cs""::: The preceding code adds two extension methods on the IHostApplicationBuilder type, one for the standard registration of MailKit and another for keyed-registration of MailKit. [!TIP] Extension methods for .NET Aspire integrations should extend the IHostApplicationBuilder type and follow the Add<MeaningfulName> naming convention where the <MeaningfulName> is the type or functionality you\'re adding. For this article, the AddMailKitClient extension method is used to add the MailKit client. It\'s likely more in-line with the official guidance to use AddMailKitSmtpClient instead of AddMailKitClient, since this only registers the SmtpClient and not the entire MailKit library. Both extensions ultimately rely on the private AddMailKitClient method to register the MailKitClientFactory with the dependency injection container as a scoped service. The reason for registering the MailKitClientFactory as a scoped service is because the connection operations are considered expensive and should be reused within the same scope where possible. In other words, for a single request, the same ISmtpClient instance should be used. The factory holds on to the instance of the SmtpClient that it creates and disposes of it. Configuration binding One of the first things that the private implementation of the AddMailKitClient methods does, is to bind the configuration settings to the MailKitClientSettings class. The settings class is instantiated and then Bind is called with the specific section of configuration. Then the optional configureSettings delegate is invoked with the current settings. This allows the consumer to further configure the settings, ensuring that manual code settings are honored over configuration settings. After that, depending on whether the serviceKey value was provided, the MailKitClientFactory should be registered with the dependency injection container as either a standard or keyed service. [!IMPORTANT] It\'s intentional that the implementationFactory overload is called when registering services. The CreateMailKitClientFactory method throws when the configuration is invalid. This ensures that creation of the MailKitClientFactory is deferred until it\'s needed and it prevents the app from erroring out before logging is available. The registration of health checks, and telemetry are described in a bit more detail in the following sections. Add health checks Health checks are a way to monitor the health of an integration. With MailKit, you can check if the connection to the SMTP server is healthy. Add the following code to the MailKit.Client project in a file named MailKitHealthCheck.cs: :::code source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKitHealthCheck.cs""::: The preceding health check implementation: Implements the IHealthCheck interface. Accepts the MailKitClientFactory as a primary constructor parameter. Satisfies the CheckHealthAsync method by: Attempting to get an ISmtpClient instance from the factory. If successful, it returns HealthCheckResult.Healthy. If an exception is thrown, it returns HealthCheckResult.Unhealthy. As previously shared in the registration of the MailKitClientFactory, the MailKitHealthCheck is conditionally registered with the IHeathChecksBuilder: csharp if (settings.DisableHealthChecks is false) { builder.Services.AddHealthChecks() .AddCheck<MailKitHealthCheck>( name: serviceKey is null ? ""MailKit"" : $""MailKit_{connectionName}"", failureStatus: default, tags: []); } The consumer could choose to omit health checks by setting the DisableHealthChecks property to true in the configuration. A common pattern for integrations is to have optional features and .NET Aspire integrations strongly encourages these types of configurations. For more information on health checks and a working sample that includes a user interface, see .NET Aspire ASP.NET Core HealthChecksUI sample. Wire up telemetry As a best practice, the MailKit client library exposes telemetry. .NET Aspire can take advantage of this telemetry and display it in the .NET Aspire dashboard. Depending on whether or not tracing and metrics are enabled, telemetry is wired up as shown in the following code snippet: ```csharp if (settings.DisableTracing is false) { builder.Services.AddOpenTelemetry() .WithTracing( traceBuilder => traceBuilder.AddSource( Telemetry.SmtpClient.ActivitySourceName)); } if (settings.DisableMetrics is false) { // Required by MailKit to enable metrics Telemetry.SmtpClient.Configure(); builder.Services.AddOpenTelemetry() .WithMetrics( metricsBuilder => metricsBuilder.AddMeter( Telemetry.SmtpClient.MeterName)); } ``` Update the Newsletter service With the integration library created, you can now update the Newsletter service to use the MailKit client. The first step is to add a reference to the MailKit.Client project. Add the MailKit.Client.csproj project reference to the MailDevResource.NewsletterService project: dotnetcli dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference MailKit.Client/MailKit.Client.csproj Next, add a reference to the ServiceDefaults project: dotnetcli dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference MailDevResource.ServiceDefaults/MailDevResource.ServiceDefaults.csproj The final step is to replace the existing :::no-loc text=""Program.cs""::: file in the MailDevResource.NewsletterService project with the following C# code: :::code source=""snippets/MailDevResourceAndComponent/MailDevResource.NewsletterService/Program.cs""::: The most notable changes in the preceding code are: The updated using statements that include the MailKit.Client, MailKit.Net.Smtp, and MimeKit namespaces. The replacement of the registration for the official .NET SmtpClient with the call to the AddMailKitClient extension method. The replacement of both /subscribe and /unsubscribe map post calls to instead inject the MailKitClientFactory and use the ISmtpClient instance to send the email. Run the sample Now that you\'ve created the MailKit client integration and updated the Newsletter service to use it, you can run the sample. From your IDE, select F5 or run dotnet run from the root directory of the solution to start the applicationâ€”you should see the .NET Aspire dashboard: :::image type=""content"" source=""./media/maildev-with-newsletterservice-dashboard.png"" lightbox=""./media/maildev-with-newsletterservice-dashboard.png"" alt-text="".NET Aspire dashboard: MailDev and Newsletter resources running.""::: Once the application is', '<2-hop>\n\nUpdate the MailKit integration It\'s good practice for client integrations to expect connection strings to contain various key/value pairs, and to parse these pairs into the appropriate properties. Update the MailKitClientSettings.cs file in the MailKit.Client project with the following C# code: :::code source=""snippets/MailDevResourceWithCredentials/MailKit.Client/MailKitClientSettings.cs"" highlight=""21-28,95-100""::: The preceding settings class, now includes a Credentials property of type NetworkCredential. The ParseConnectionString method is updated to parse the Username and Password keys from the connection string. If the Username and Password keys are present, a NetworkCredential is created and assigned to the Credentials property. With the settings class updated to understand and populate the credentials, update the factory to conditionally use the credentials if they\'re configured. Update the MailKitClientFactory.cs file in the MailKit.Client project with the following C# code: :::code source=""snippets/MailDevResourceWithCredentials/MailKit.Client/MailKitClientFactory.cs"" highlight=""44-48""::: When the factory determines that credentials have been configured, it authenticates with the SMTP server after connecting before returning the SmtpClient. Run the sample Now that you\'ve updated the resource, corresponding integration projects, and the app host, you\'re ready to run the sample app. To run the sample from your IDE, select F5 or use dotnet run from the root directory of the solution to start the applicationâ€”you should see the .NET Aspire dashboard. Navigate to the maildev container resource and view the details. You should see the username and password parameters in the resource details, under the Environment Variables section: :::image type=""content"" source=""media/maildev-details.png"" lightbox=""media/maildev-details.png"" alt-text="".NET Aspire Dashboard: MailDev container resource details.""::: Likewise, you should see the connection string in the newsletterservice resource details, under the Environment Variables section: :::image type=""content"" source=""media/newsletter-details.png"" lightbox=""media/newsletter-details.png"" alt-text="".NET Aspire Dashboard: Newsletter service resource details.""::: Validate that everything is working as expected. Summary This article demonstrated how to flow authentication credentials from a custom resource to a custom client integration. The custom resource is a MailDev container that allows for either incoming or outgoing credentials. The custom client integration is a MailKit client that sends emails. By updating the resource to include the username and password parameters, and updating the integration to parse and use these parameters, authentication flows credentials from the hosting integration to the client integration.']","The MailKitClientFactory utilizes the Credentials property from MailKitClientSettings by first checking if the credentials have been configured. If the Username and Password keys are present in the connection string, a NetworkCredential is created and assigned to the Credentials property. When the factory connects to the SMTP server, it authenticates using these credentials before returning the SmtpClient instance.",multi_hop_specific_query_synthesizer
79,How does .NET Aspire enhance the local development experience for cloud-native applications compared to Kubernetes?,"['<1-hop>\n\ntitle: .NET Aspire overview description: Learn about .NET Aspire, an application stack designed to improve the experience of building distributed applications. ms.date: 11/12/2024 .NET Aspire overview :::row::: :::column::: :::image type=""icon"" border=""false"" source=""../../assets/dotnet-aspire-logo-128.svg""::: :::column-end::: :::column span=""3""::: .NET Aspire is a set of tools, templates, and packages for building observable, production ready apps.\u200b\u200b .NET Aspire is delivered through a collection of NuGet packages that bootstrap or improve specific challenges with modern app development. Today\'s apps generally consume a large number of services, such as databases, messaging, and caching, many of which are supported via .NET Aspire Integrations. For information on support, see the .NET Aspire Support Policy. :::column-end::: :::row-end::: Why .NET Aspire? .NET Aspire improves the experience of building apps that have a variety of projects and resources. With dev-time productivity enhancements that emulate deployed scenarios, you can quickly develop interconnected apps. Designed for flexibility, .NET Aspire allows you to replace or extend parts with your preferred tools and workflows. Key features include: Dev-Time Orchestration: .NET Aspire provides features for running and connecting multi-project applications, container resources, and other dependencies for local development environments. Integrations: .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects.  .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects. Dev-time orchestration In .NET Aspire, ""orchestration"" primarily focuses on enhancing the local development experience by simplifying the management of your app\'s configuration and interconnections. It\'s important to note that .NET Aspire\'s orchestration isn\'t intended to replace the robust systems used in production environments, such as Kubernetes. Instead, it\'s a set of abstractions that streamline the setup of service discovery, environment variables, and container configurations, eliminating the need to deal with low-level implementation details. With .NET Aspire, your code has a consistent bootstrapping experience on any dev machine without the need for complex manual steps, making it easier to manage during the development phase. .NET Aspire orchestration assists with the following concerns: App composition: Specify the .NET projects, containers, executables, and cloud resources that make up the application. Service discovery and connection string management: The app host injects the right connection strings, network configurations, and service discovery information to simplify the developer experience. For example, using .NET Aspire, the following code creates a local Redis container resource, waits for it to become available, and then configures the appropriate connection string in the ""frontend"" project with a few helper method calls: ```csharp // Create a distributed application builder given the command line arguments. var builder = DistributedApplication.CreateBuilder(args); // Add a Redis server to the application. var cache = builder.AddRedis(""cache""); // Add the frontend project to the application and configure it to use the // Redis server, defined as a referenced dependency. builder.AddProject For more information, see .NET Aspire orchestration overview. [!IMPORTANT] The call to .NET Aspire integrations .NET Aspire integrations are NuGet packages designed to simplify connections to popular services and platforms, such as Redis or PostgreSQL. .NET Aspire integrations handle cloud resource setup and interaction for you through standardized patterns, such as adding health checks and telemetry. Integrations are two-fold - ""hosting"" integrations represents the service you\'re connecting to, and ""client"" integrations represents the client or consumer of that service. In other words, for many hosting packages there\'s a corresponding client package that handles the service connection within your code. Each integration is designed to work with the .NET Aspire app host, and their configurations are injected automatically by referencing named resources. In other words, if Example.ServiceFoo references Example.ServiceBar, Example.ServiceFoo inherits the integration\'s required configurations to allow them to communicate with each other automatically. For example, consider the following code using the .NET Aspire Service Bus integration: csharp builder.AddAzureServiceBusClient(""servicebus""); The Registers a Applies Enables corresponding health checks, logging, and telemetry specific to the Azure Service Bus usage. A full list of available integrations is detailed on the .NET Aspire integrations overview page.', '<2-hop>\n\ntitle: NET Aspire Dapr integration description: Learn how to use the .NET Aspire Dapr integration, which can configure and orchestrate Dapr from a .NET Aspire app host project. ms.date: 01/16/2025 uid: frameworks/dapr .NET Aspire Dapr integration Distributed Application Runtime (Dapr) offers developer APIs that serve as a conduit for interacting with other services and dependencies and abstract the application from the specifics of those services and dependencies. Dapr and .NET Aspire can work together to improve your local development experience. By using Dapr with .NET Aspire, you can focus on writing and implementing .NET-based distributed applications instead of local on-boarding. In this guide, you\'ll learn how to take advantage of Dapr\'s abstraction and .NET Aspire\'s opinionated configuration of cloud technologies to build simple, portable, resilient, and secured microservices at scale. Comparing .NET Aspire and Dapr At first sight Dapr and .NET Aspire may look like they have overlapping functionality, and they do. However, they take different approaches. .NET Aspire is opinionated on how to build distributed applications on a cloud platform and focuses on improving the local development experience. Dapr is a runtime that abstracts away the common complexities of the underlying cloud platform both during development and in production. It relies on sidecars to provide abstractions for things like configuration, secret management, and messaging. The underlying technology can be easily switched out through configuration files, while your code does not need to change. Aspect .NET Aspire Dapr Purpose Designed to make it easier to develop cloud-native solutions on local development computers. Designed to make it easier to develop and run distributed apps with common APIs that can be easily swapped. APIs Developers must call resource APIs using their specific SDKs Developers call APIs in the Dapr sidecar, which forwards the call to the correct API. It\'s easy to swap resource APIs without changing code in your microservices. Languages You write microservices in .NET languages, Go, Python, Javascript, and others. You can call Dapr sidecar functions in any language that supports HTTP/gRPC interfaces. Security policies Doesn\'t include security policies but can securely configure connections between inter-dependent resources. Includes customizable security policies that control which microservices have access to other services or resources. Deployment There are deployment tools for Azure and Kubernetes. Doesn\'t include deployment tools. Apps are usually deployed with Continuous Integration/Continuous Development (CI/CD) systems. Dashboard Provides a comprehensive view of the resources and their telemetry and supports listening on any OTEL supported resource. Limited to Dapr resources only. .NET Aspire makes setting up and debugging Dapr applications easier by providing a straightforward API to configure Dapr sidecars, and by exposing the sidecars as resources in the dashboard. Explore Dapr components with .NET Aspire Dapr provides many built-in components, and when you use Dapr with .NET Aspire you can easily explore and configure these components. Don\'t confuse these components with .NET Aspire integrations. For example, consider the following: Daprâ€”State stores: Call Daprâ€”Pub Sub: Call Daprâ€”Components: Call Install Dapr This integration requires Dapr version 1.13 or later. To install Dapr, see Install the Dapr CLI. After installing the Dapr CLI, run the dapr init, as described in Initialize Dapr in your local environment. [!IMPORTANT] If you attempt to run the .NET Aspire solution without the Dapr CLI, you\'ll receive the following error: plaintext Unable to locate the Dapr CLI. Hosting integration In your .NET Aspire solution, to integrate Dapr and access its types and APIs, add the ðŸ“¦ Aspire.Hosting.Dapr NuGet package in the app host project. .NET CLI dotnetcli dotnet add package Aspire.Hosting.Dapr PackageReference xml <PackageReference Include=""Aspire.Hosting.Dapr"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications.']",".NET Aspire enhances the local development experience for cloud-native applications by providing features for running and connecting multi-project applications, container resources, and other dependencies in local development environments. It simplifies the management of app configurations and interconnections, allowing developers to focus on building applications without dealing with low-level implementation details. In contrast, Kubernetes is a robust system used in production environments, which is not intended to replace the orchestration provided by .NET Aspire but rather complements it by managing containerized applications at scale.",multi_hop_specific_query_synthesizer
80,"What updates were made to the .NET Aspire documentation in October 2024, and who were the community contributors involved in these changes?","['<1-hop>\n\ntitle: "" .NET Aspire docs: What\'s new for October 2024"" description: ""What\'s new in the .NET Aspire docs for October 2024."" ms.custom: October-2024 ms.date: 11/01/2024 .NET Aspire docs: What\'s new for October 2024 Welcome to what\'s new in the .NET Aspire docs for October 2024. This article lists some of the major changes to docs during this period. Get started Updated articles Orchestrate Node.js apps in .NET Aspire - Fix broken links Quickstart: Build your first .NET Aspire solution - Make it easier to onboard with VS Code. Fundamentals New articles Enable browser telemetry Updated articles .NET Aspire dashboard overview Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. .NET Aspire integrations overview Add Meilisearch integeration docs Using nuget.org links for', '<2-hop>\n\nCommunity Toolkit packages Moving from Aspire.CommunityToolkit to CommunityToolkit.Aspire Moving package links to be Azure Artifacts not GitHub Packages Rewrite the non-Azure messaging integration articles Community Toolkit .NET Aspire orchestration overview - Rewrite the non-Azure messaging integration articles Dashboard configuration Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Enable browser telemetry minor text fixes Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Security considerations for running the .NET Aspire dashboard - Various dashboard and telemetry docs updates Standalone .NET Aspire dashboard - Various dashboard and telemetry docs updates Tutorial: Use the .NET Aspire dashboard with Python apps - Various dashboard and telemetry docs updates Storage Updated articles .NET Aspire Azure Blob Storage integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Data Tables integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Queue Storage integration - Rewrite the non-Azure messaging integration articles Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations - Rewrite the non-Azure messaging integration articles Database Updated articles .NET Aspire Azure Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Microsoft Entity Framework Core Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Milvus database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MongoDB database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MySQL database integration - Rewrite the non-Azure messaging integration articles .NET Aspire Oracle Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire Pomelo MySQL Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL Entity Framework Core integration Rewrite both PostgreSQL integration docs Update postgresql-entity-framework-integration.md Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL integration Rewrite both PostgreSQL integration docs Rewrite the non-Azure messaging integration articles .NET Aspire Qdrant integration - Rewrite the non-Azure messaging integration articles .NET Aspire SQL Server integration - Rewrite the non-Azure messaging integration articles .NET Aspire SqlServer Entity Framework Core integration - Rewrite the non-Azure messaging integration articles Messaging New articles .NET Aspire RabbitMQ integration Updated articles .NET Aspire Apache Kafka integration Fix Kafka integration documentation Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire Azure Event Hubs integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Service Bus integration Rewrite the non-Azure messaging integration articles Use correct method name in ServiceBus .NET Aspire Azure Web PubSub integration - Rewrite the non-Azure messaging integration articles .NET Aspire NATS integration Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire RabbitMQ integration Rewrite both PostgreSQL integration docs Redis rewrite Demote messaging integration headings Rewrite the non-Azure messaging integration articles Caching Updated articles .NET Aspire Redis distributed caching integration Updates to other Redis-protocol docs Rewrite the non-Azure messaging integration articles .NET Aspire Redis integration Updates to other Redis-protocol docs Redis rewrite Rewrite the non-Azure messaging integration articles .NET Aspire Redis output caching integration Updates to other Redis-protocol docs Rewrite the non-Azure messaging integration articles Stack Exchange Redis caching overview - Updates to other Redis-protocol docs Tutorial: Implement caching with .NET Aspire integrations - Rewrite the non-Azure messaging integration articles Security Updated articles .NET Aspire Azure Key Vault integration - Rewrite the non-Azure messaging integration articles Deployment Updated articles Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide) - Fix typo in aca-deployment-azd-in-depth.md Use Application Insights for .NET Aspire telemetry - Rewrite the non-Azure messaging integration articles Use custom Bicep templates - Rewrite the non-Azure messaging integration articles', '<3-hop>\n\nCommunity contributors The following people contributed to the .NET Aspire docs during this period. Thank you! Learn how to contribute by following the links under ""Get involved"" in the what\'s new landing page. alexravenna - Alex Ravenna Alirexaa - Alireza Baloochi fabiocozzolino - Fabio Cozzolino g7ed6e - Guillaume Delahaye willibrandon - Brandon Williams']","In October 2024, the .NET Aspire documentation saw several updates, including the orchestration of Node.js apps, improvements to the dashboard and telemetry documentation, and various integration articles being rewritten for Azure services. Notable updates included enabling browser telemetry and integrating with Azure Blob Storage, Azure Cosmos DB, and RabbitMQ. The community contributors who played a role in these updates included Alex Ravenna, Alireza Baloochi, Fabio Cozzolino, Guillaume Delahaye, and Brandon Williams.",multi_hop_abstract_query_synthesizer
81,"What are the steps to integrate both the .NET Aspire Community Toolkit for Meilisearch and Azure Event Hubs in a .NET application, and how do they ensure data protection and access control?","['<1-hop>\n\ntitle: .NET Aspire Community Toolkit Meilisearch integration description: Learn how to use the .NET Aspire Meilisearch hosting and client integration to run the Meilisearch container and accessing it via the Meilisearch client. ms.date: 10/24/2024 .NET Aspire Community Toolkit Meilisearch integration [!INCLUDE includes-hosting-and-client] [!INCLUDE banner] In this article, you learn how to use the .NET Aspire Meilisearch hosting integration to run Meilisearch container and accessing it via the Meilisearch client. Hosting integration To run the Meilisearch container, install the ðŸ“¦ CommunityToolkit.Aspire.Hosting.Meilisearch NuGet package in the app host project. .NET CLI dotnetcli dotnet add package CommunityToolkit.Aspire.Hosting.Meilisearch PackageReference xml <PackageReference Include=""CommunityToolkit.Aspire.Hosting.Meilisearch"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Meilisearch resource In the app host project, register and consume the Meilisearch integration using the AddMeilisearch extension method to add the Meilisearch container to the application builder. ```csharp var builder = DistributedApplication.CreateBuilder(args); var meilisearch = builder.AddMeilisearch(""meilisearch""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/getmeili/meilisearch image, it creates a new Meilisearch instance on your local machine. A reference to your Meilisearch resource (the meilisearch variable) is added to the ExampleProject. The Meilisearch resource includes a randomly generated master key using the For more information, see Container resource lifecycle. Add Meilisearch resource with data volume To add a data volume to the Meilisearch resource, call the Aspire.Hosting.MeilisearchBuilderExtensions.WithDataVolume method on the Meilisearch resource: ```csharp var builder = DistributedApplication.CreateBuilder(args); var meilisearch = builder.AddMeilisearch(""meilisearch"") .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Meilisearch data outside the lifecycle of its container. The data volume is mounted at the /meili_data path in the Meilisearch container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Meilisearch resource with data bind mount To add a data bind mount to the Meilisearch resource, call the Aspire.Hosting.MeilisearchBuilderExtensions.WithDataBindMount method: ```csharp var builder = DistributedApplication.CreateBuilder(args); var meilisearch = builder.AddMeilisearch(""meilisearch"") .WithDataBindMount( source: @""C:\\Meilisearch\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Meilisearch data across container restarts. The data bind mount is mounted at the C:\\Meilisearch\\Data on Windows (or /Meilisearch/Data on Unix) path on the host machine in the Meilisearch container. For more information on data bind mounts, see Docker docs: Bind mounts. Add Meilisearch resource with master key parameter When you want to explicitly provide the master key used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var masterkey = builder.AddParameter(""masterkey"", secret: true); var meilisearch = builder.AddMeilisearch(""meilisearch"", masterkey); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Client integration To get started with the .NET Aspire Meilisearch client integration, install the ðŸ“¦ CommunityToolkit.Aspire.Meilisearch NuGet package in the client-consuming project, that is, the project for the application that uses the Meilisearch client. .NET CLI dotnetcli dotnet add package CommunityToolkit.Aspire.Meilisearch PackageReference xml <PackageReference Include=""CommunityToolkit.Aspire.Meilisearch"" Version=""*"" /> Add Meilisearch client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the Microsoft.Extensions.Hosting.AspireMeilisearchExtensions.AddMeilisearchClient extension method on any csharp builder.AddMeilisearchClient(connectionName: ""meilisearch""); [!TIP] The connectionName parameter must match the name used when adding the Meilisearch resource in the app host project. For more information, see Add Meilisearch resource. You can then retrieve the MeilisearchClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(MeilisearchClient client) { // Use client... } Add keyed Meilisearch client There might be situations where you want to register multiple MeilisearchClient instances with different connection names. To register keyed Meilisearch clients, call the Microsoft.Extensions.Hosting.AspireMeilisearchExtensions.AddKeyedMeilisearchClient csharp builder.AddKeyedMeilisearchClient(name: ""products""); builder.AddKeyedMeilisearchClient(name: ""orders""); Then you can retrieve the MeilisearchClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""products"")] MeilisearchClient productsClient, [FromKeyedServices(""orders"")] MeilisearchClient ordersClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services.', '<2-hop>\n\ntitle: .NET Aspire Azure Event Hubs integration description: This article describes the .NET Aspire Azure Event Hubs integration features and capabilities. ms.topic: how-to ms.date: 08/26/2024 .NET Aspire Azure Event Hubs integration In this article, you learn how to use the .NET Aspire Azure Event Hubs integration. The Aspire.Azure.Messaging.EventHubs library offers options for registering the following types: These type are registered in the DI container for connecting to Azure Event Hubs. Prerequisites Azure subscription: create one for free. Azure Event Hubs namespace: for more information, see add an Event Hubs namespace. Alternatively, you can use a connection string, which isn\'t recommended in production environments. Get started To get started with the .NET Aspire Azure Event Hubs integration, install the ðŸ“¦ Aspire.Azure.Messaging.EventHubs NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Event Hubs client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.EventHubs PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.EventHubs"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Supported clients with options classes The following clients are supported by the library, along with their corresponding options and settings classes: Azure Client type Azure Options class .NET Aspire Settings class EventHubProducerClient EventHubProducerClientOptions AzureMessagingEventHubsProducerSettings EventHubBufferedProducerClient EventHubBufferedProducerClientOptions AzureMessagingEventHubsBufferedProducerSettings EventHubConsumerClient EventHubConsumerClientOptions AzureMessagingEventHubsConsumerSettings EventProcessorClient EventProcessorClientOptions AzureMessagingEventHubsProcessorSettings PartitionReceiver PartitionReceiverOptions AzureMessagingEventHubsPartitionReceiverSettings The client type are from the Azure SDK for .NET, as are the corresponding options classes. The settings classes are provided by the .NET Aspire Azure Event Hubs integration library.', '<3-hop>\n\nExample usage The following example assumes that you have an Azure Event Hubs namespace and an Event Hub created and wish to configure an EventHubProducerClient to send events to the Event Hub. The EventHubBufferedProducerClient, EventHubConsumerClient, EventProcessorClient, and PartitionReceiverare configured in a similar manner. In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the AddAzureEventHubProducerClient extension to register a EventHubProducerClient for use via the dependency injection container. csharp builder.AddAzureEventHubProducerClient(""eventHubsConnectionName""); You can then retrieve the EventHubProducerClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(EventHubProducerClient client) { // Use client... } For more information, see the Azure.Messaging.EventHubs documentation for examples on using the EventHubProducerClient. App host usage To add Azure Event Hub hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.EventHubs PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.EventHubs"" Version=""*"" /> In your app host project, add an Event Hubs connection and an Event Hub resource and consume the connection using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .AddEventHub(""MyHub""); var exampleService = builder.AddProject The AddAzureEventHubs method will read connection information from the AppHost\'s configuration (for example, from ""user secrets"") under the ConnectionStrings:eventHubsConnectionName config key. The WithReference method passes that connection information into a connection string named eventHubsConnectionName in the ExampleService project. As of .NET Aspire 8.1, the Azure EventHubs extension for .NET Aspire supports launching a local emulator for EventHubs. You can use the emulator by applying the RunAsEmulator() extension method as follows: csharp var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .RunAsEmulator() .AddEventHub(""MyHub""); The emulator for Azure EventHubs results in two container resources being launched inside .NET Aspire derived from the name of the Event Hubs resource name. [!IMPORTANT] Even though we are creating an Event Hub using the AddEventHub at the same time as the namespace, as of .NET Aspire version preview-5, the connection string will not include the EntityPath property, so the EventHubName property must be set in the settings callback for the preferred client. Future versions of Aspire will include the EntityPath property in the connection string and will not require the EventHubName property to be set in this scenario. In the :::no-loc text=""Program.cs""::: file of ExampleService, the connection can be consumed using by calling of the supported Event Hubs client extension methods: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; }); Configuration The .NET Aspire Azure Event Hubs library provides multiple options to configure the Azure Event Hubs connection based on the requirements and conventions of your project. Either a FullyQualifiedNamespace or a ConnectionString is a required to be supplied. Use a connection string When using a connection string from the ConnectionStrings configuration section, provide the name of the connection string when calling builder.AddAzureEventHubProducerClient() and other supported Event Hubs clients. In this example, the connection string does not include the EntityPath property, so the EventHubName property must be set in the settings callback: csharp builder.AddAzureEventHubProducerClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; }); And then the connection information will be retrieved from the ConnectionStrings configuration section. Two connection formats are supported: Fully Qualified Namespace (FQN) The recommended approach is to use a fully qualified namespace, which works with the AzureMessagingEventHubsSettings.Credential property to establish a connection. If no credential is configured, the json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""{your_namespace}.servicebus.windows.net"" } } Connection string Alternatively, use a connection string: json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""Endpoint=sb://mynamespace.servicebus.windows.net/;SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey;EntityPath=MyHub"" } } Use configuration providers The .NET Aspire Azure Event Hubs library supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""EventHubs"": { ""EventProcessorClient"": { ""EventHubName"": ""MyHub"", ""ClientOptions"": { ""Identifier"": ""PROCESSOR_ID"" } } } } } } } You can also setup the Options type using the optional Action<IAzureClientBuilder<EventProcessorClient, EventProcessorClientOptions>> configureClientBuilder parameter of the AddAzureEventProcessorClient method. For example, to set the processor\'s client ID for this client: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Identifier = ""PROCESSOR_ID"")); [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Azure Event Hubs integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Event Hubs integration will emit the following tracing activities using OpenTelemetry: ""Azure.Messaging.EventHubs.*"" Metrics The .NET Aspire Azure Event Hubs integration currently doesn\'t support metrics by default due to limitations with the Azure SDK for .NET. If that changes in the future, this section will be updated to reflect those changes. See also Azure Event Hubs .NET Aspire integrations .NET Aspire GitHub repo']","To integrate the .NET Aspire Community Toolkit for Meilisearch, you first need to install the CommunityToolkit.Aspire.Hosting.Meilisearch NuGet package in your app host project. You can then run the Meilisearch container by using the AddMeilisearch extension method to add the Meilisearch resource to the application builder. For data protection, you can add a data volume to persist Meilisearch data outside the container's lifecycle. Additionally, you can provide a master key for the container image to enhance security. 

For Azure Event Hubs integration, you need to install the Aspire.Azure.Messaging.EventHubs NuGet package in your client-consuming project. You can register the EventHubProducerClient using the AddAzureEventHubProducerClient extension method. This integration allows you to manage connections securely, as it supports using a fully qualified namespace or a connection string, with the latter being less recommended for production environments. 

Both integrations emphasize data protection through the use of secure connection strings and the ability to manage sensitive information like master keys, ensuring that access control measures are in place.",multi_hop_abstract_query_synthesizer
82,How can you integrate Identity and Access Management using .NET Aspire Keycloak with an ASP.NET Core application that connects to SQL Server?,"['<1-hop>\n\ntitle: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core description: Learn how to connect an ASP.NET Core app to to SQL Server using .NET Aspire and Entity Framework Core. ms.date: 12/02/2024 ms.topic: tutorial Tutorial: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core In this tutorial, you create an ASP.NET Core app that uses a .NET Aspire Entity Framework Core SQL Server integration to connect to SQL Server to read and write support ticket data. Entity Framework Core is a lightweight, extensible, open source object-relational mapper that enables .NET developers to work with databases using .NET objects. You\'ll learn how to: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire integrations Add a .NET Aspire integration to connect to SQL Server Configure and use .NET Aspire Component features to read and write from the database [!INCLUDE aspire-prereqs] Create the sample solution At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Blazor and select Blazor Web App. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQLEFCore. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Ensure the Interactive render mode is set to None. Check the Enlist in .NET Aspire orchestration option and select Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQLEFCore: A Blazor project that depends on service defaults. AspireSQLEFCore.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQLEFCore.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Create the database model and context classes To represent a user submitted support request, add the following SupportTicket model class at the root of the AspireSQLEFCore project. :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/SupportTicket.cs""::: Add the following TicketDbContext data context class at the root of the AspireSQLEFCore project. The class inherits :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/TicketContext.cs""::: Add the .NET Aspire integration to the Blazor app Add the .NET Aspire Entity Framework Core Sql Server library package to your AspireSQLEFCore project: dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer Your AspireSQLEFCore project is now set up to use .NET Aspire integrations. Here\'s the updated AspireSQLEFCore.csproj file: :::code language=""xml"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/AspireSQLEFCore.csproj"" highlight=""10""::: Configure the .NET Aspire integration In the :::no-loc text=""Program.cs""::: file of the AspireSQLEFCore project, add a call to the :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-14"" highlight=""5""::: This method accomplishes the following tasks: Registers a TicketContext with the DI container for connecting to the containerized Azure SQL Database. Automatically enable corresponding health checks, logging, and telemetry. Create the database While developing locally, you need to create a database inside the SQL Server container. Update the :::no-loc text=""Program.cs""::: file with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-30"" highlight=""16-30""::: The preceding code: Checks if the app is running in a development environment. If it is, it retrieves the TicketContext service from the DI container and calls Database.EnsureCreated() to create the database if it doesn\'t already exist. [!NOTE] Note that EnsureCreated() is not suitable for production environments, and it only creates the database as defined in the context. It doesn\'t apply any migrations. For more information on Entity Framework Core migrations in .NET Aspire, see Apply Entity Framework Core migrations in .NET Aspire. Create the form The app requires a form for the user to be able to submit support ticket information and save the entry to the database. Use the following Razor markup to create a basic form, replacing the contents of the Home.razor file in the AspireSQLEFCore/Components/Pages directory: :::code language=""razor"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Components/Pages/Home.razor""::: For more information about creating forms in Blazor, see ASP.NET Core Blazor forms overview. Configure the AppHost The AspireSQLEFCore.AppHost project is the orchestrator for your app. It\'s responsible for connecting and configuring the different projects and services of your app. The orchestrator should be set as the startup project. Add the .NET Aspire Hosting Sql Server NuGet package to your AspireStorage.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQLEFCore.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The Entity Framework classes you configured earlier will automatically use this connection when migrating and connecting to the database.', '<2-hop>\n\ntitle: .NET Aspire Keycloak integration (Preview) description: Learn how to use the .NET Aspire Keycloak integration, which includes both hosting and client integrations. ms.date: 12/06/2024 uid: authentication/keycloak-integration .NET Aspire Keycloak integration (Preview) [!INCLUDE includes-hosting-and-client] Keycloak is an open-source Identity and Access Management solution aimed at modern applications and services. The .NET Aspire Keycloak integration enables you to connect to existing Keycloak instances or create new instances from .NET with the quay.io/keycloak/keycloak container image. Hosting integration The .NET Aspire Keycloak hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Keycloak --prerelease PackageReference xml <PackageReference Include=""Aspire.Hosting.Keycloak"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications.']","To integrate Identity and Access Management using .NET Aspire Keycloak with an ASP.NET Core application that connects to SQL Server, you first need to set up your ASP.NET Core app to connect to SQL Server using .NET Aspire and Entity Framework Core. This involves creating a Blazor project, configuring the database model and context classes, and ensuring the app can read and write support ticket data. After establishing the SQL Server connection, you can then add the .NET Aspire Keycloak integration by using the command 'dotnet add package Aspire.Hosting.Keycloak'. This integration allows you to connect to existing Keycloak instances or create new ones, enabling robust identity management for your application.",multi_hop_abstract_query_synthesizer
83,How do you test the custom command in the .NET Aspire dashboard UI after adding it to the Redis resource?,"['<1-hop>\n\ntitle: Custom resource commands in .NET Aspire description: Learn how to create custom resource commands in .NET Aspire. ms.date: 11/07/2024 ms.topic: how-to Custom resource commands in .NET Aspire Each resource in the .NET Aspire app model is represented as an [!IMPORTANT] These .NET Aspire dashboard commands are only available when running the dashboard locally. They\'re not available when running the dashboard in Azure Container Apps. Add custom commands to a resource Start by creating a new .NET Aspire Starter App from the available templates. To create the solution from this template, follow the Quickstart: Build your first .NET Aspire solution. After creating this solution, add a new class named RedisResourceBuilderExtensions.cs to the app host project. Replace the contents of the file with the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/RedisResourceBuilderExtensions.cs""::: The preceding code: Shares the Is a static class so that it can contain extension methods. It defines a single extension method named WithClearCommand, extending the IResourceBuilder<RedisResource> interface. The WithClearCommand method registers a command named clear-cache that clears the cache of the Redis resource. The WithClearCommand method returns the IResourceBuilder<RedisResource> instance to allow chaining. The WithCommand API adds the appropriate annotations to the resource, which are consumed in the .NET Aspire dashboard. The dashboard uses these annotations to render the command in the UI. Before getting too far into those details, let\'s ensure that you first understand the parameters of the WithCommand method: name: The name of the command to invoke. displayName: The name of the command to display in the dashboard. executeCommand: The Func<ExecuteCommandContext, Task<ExecuteCommandResult>> to run when the command is invoked, which is where the command logic is implemented. updateState: The Func<UpdateCommandStateContext, ResourceCommandState> callback is invoked to determine the ""enabled"" state of the command, which is used to enable or disable the command in the dashboard. iconName: The name of the icon to display in the dashboard. The icon is optional, but when you do provide it, it should be a valid Fluent UI Blazor icon name. iconVariant: The variant of the icon to display in the dashboard, valid options are Regular (default) or Filled. Execute command logic The executeCommand delegate is where the command logic is implemented. This parameter is defined as a Func<ExecuteCommandContext, Task<ExecuteCommandResult>>. The ExecuteCommandContext provides the following properties: ExecuteCommandContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. ExecuteCommandContext.ResourceName: The name of the resource instance that the command is being executed on. ExecuteCommandContext.CancellationToken: The In the preceding example, the executeCommand delegate is implemented as an async method that clears the cache of the Redis resource. It delegates out to a private class-scoped function named OnRunClearCacheCommandAsync to perform the actual cache clearing. Consider the following code: ```csharp private static async Task await using var connection = ConnectionMultiplexer.Connect(connectionString); var database = connection.GetDatabase(); await database.ExecuteAsync(""FLUSHALL""); return CommandResults.Success(); } ``` The preceding code: Retrieves the connection string from the Redis resource. Connects to the Redis instance. Gets the database instance. Executes the FLUSHALL command to clear the cache. Returns a CommandResults.Success() instance to indicate that the command was successful. Update command state logic The updateState delegate is where the command state is determined. This parameter is defined as a Func<UpdateCommandStateContext, ResourceCommandState>. The UpdateCommandStateContext provides the following properties: UpdateCommandStateContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. UpdateCommandStateContext.ResourceSnapshot: The snapshot of the resource instance that the command is being executed on. The immutable snapshot is an instance of CustomResourceSnapshot, which exposes all sorts of valuable details about the resource instance. Consider the following code: ```csharp private static ResourceCommandState OnUpdateResourceState( UpdateCommandStateContext context) { var logger = context.ServiceProvider.GetRequiredService if (logger.IsEnabled(LogLevel.Information)) { logger.LogInformation( ""Updating resource state: {ResourceSnapshot}"", context.ResourceSnapshot); } return context.ResourceSnapshot.HealthStatus is HealthStatus.Healthy ? ResourceCommandState.Enabled : ResourceCommandState.Disabled; } ``` The preceding code: Retrieves the logger instance from the service provider. Logs the resource snapshot details. Returns ResourceCommandState.Enabled if the resource is healthy; otherwise, it returns ResourceCommandState.Disabled.', '<2-hop>\n\nTest the custom command To test the custom command, update your app host project\'s Program.cs file to include the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/Program.cs"" highlight=""4""::: The preceding code calls the WithClearCommand extension method to add the custom command to the Redis resource. Run the app and navigate to the .NET Aspire dashboard. You should see the custom command listed under the Redis resource. On the Resources page of the dashboard, select the ellipsis button under the Actions column: :::image source=""media/custom-clear-cache-command.png"" lightbox=""media/custom-clear-cache-command.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command displayed.""::: The preceding image shows the Clear cache command that was added to the Redis resource. The icon displays as a rabbit crosses out to indicate that the speed of the dependant resource is being cleared. Select the Clear cache command to clear the cache of the Redis resource. The command should execute successfully, and the cache should be cleared: :::image source=""media/custom-clear-cache-command-succeeded.png"" lightbox=""media/custom-clear-cache-command-succeeded.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command executed.""::: See also .NET Aspire orchestration overview .NET Aspire dashboard: Resource submenu actions']","To test the custom command in the .NET Aspire dashboard UI, you need to update your app host project's Program.cs file to include the code that calls the WithClearCommand extension method, which adds the custom command to the Redis resource. After running the app, navigate to the .NET Aspire dashboard where you should see the custom command listed under the Redis resource. On the Resources page of the dashboard, select the ellipsis button under the Actions column to execute the Clear cache command, which will clear the cache of the Redis resource.",multi_hop_abstract_query_synthesizer
84,How does the .NET Aspire service defaults project support cloud-native applications and what options are available for using the Azure Monitor exporter?,"['<1-hop>\n\ntitle: .NET Aspire service defaults description: Learn about the .NET Aspire service defaults project. ms.date: 11/04/2024 ms.topic: reference uid: dotnet/aspire/service-defaults .NET Aspire service defaults In this article, you learn about the .NET Aspire service defaults project, a set of extension methods that: Connect telemetry, health checks, service discovery to your app. Are customizable and extensible. Cloud-native applications often require extensive configurations to ensure they work across different environments reliably and securely. .NET Aspire provides many helper methods and tools to streamline the management of configurations for OpenTelemetry, health checks, environment variables, and more. Explore the service defaults project When you either Enlist in .NET Aspire orchestration or create a new .NET Aspire project, the YourAppName.ServiceDefaults.csproj project is added to your solution. For example, when building an API, you call the AddServiceDefaults method in the :::no-loc text=""Program.cs""::: file of your apps: csharp builder.AddServiceDefaults(); The AddServiceDefaults method handles the following tasks: Configures OpenTelemetry metrics and tracing. Adds default health check endpoints. Adds service discovery functionality. Configures For more information, see Provided extension methods for details on the AddServiceDefaults method. [!IMPORTANT] The .NET Aspire service defaults project is specifically designed for sharing the Extensions.cs file and its functionality. Don\'t include other shared functionality or models in this project. Use a conventional shared class library project for those purposes.  Provided extension methods for details on the AddServiceDefaults method. [!IMPORTANT] The .NET Aspire service defaults project is specifically designed for sharing the Extensions.cs file and its functionality. Don\'t include other shared functionality or models in this project. Use a conventional shared class library project for those purposes. Project characteristics The YourAppName.ServiceDefaults project is a .NET 9.0 library that contains the following XML: :::code language=""xml"" source=""snippets/template/YourAppName/YourAppName.ServiceDefaults.csproj"" highlight=""11""::: The service defaults project template imposes a FrameworkReference dependency on Microsoft.AspNetCore.App. [!TIP] If you don\'t want to take a dependency on Microsoft.AspNetCore.App, you can create a custom service defaults project. For more information, see', '<2-hop>\n\nCustom service defaults. The IsAspireSharedProject property is set to true, which indicates that this project is a shared project. The .NET Aspire tooling uses this project as a reference for other projects added to a .NET Aspire solution. When you enlist the new project for orchestration, it automatically references the YourAppName.ServiceDefaults project and updates the :::no-loc text=""Program.cs""::: file to call the AddServiceDefaults method. Provided extension methods The YourAppName.ServiceDefaults project exposes a single Extensions.cs file that contains several opinionated extension methods: AddServiceDefaults: Adds service defaults functionality. ConfigureOpenTelemetry: Configures OpenTelemetry metrics and tracing. AddDefaultHealthChecks: Adds default health check endpoints. MapDefaultEndpoints: Maps the health checks endpoint to /health and the liveness endpoint to /alive. Add service defaults functionality The AddServiceDefaults method defines default configurations with the following opinionated functionality: :::code source=""snippets/template/YourAppName/Extensions.cs"" id=""addservicedefaults""::: The preceding code: Configures OpenTelemetry metrics and tracing, by calling the ConfigureOpenTelemetry method. Adds default health check endpoints, by calling the AddDefaultHealthChecks method. Adds service discovery functionality, by calling the AddServiceDiscovery method. Configures Adds the standard HTTP resilience handler, by calling the AddStandardResilienceHandler method. Specifies that the Returns the IHostApplicationBuilder instance to allow for method chaining. OpenTelemetry configuration Telemetry is a critical part of any cloud-native application. .NET Aspire provides a set of opinionated defaults for OpenTelemetry, which are configured with the ConfigureOpenTelemetry method: :::code source=""snippets/template/YourAppName/Extensions.cs"" id=""configureotel""::: The ConfigureOpenTelemetry method: Adds .NET Aspire telemetry logging to include formatted messages and scopes. Adds OpenTelemetry metrics and tracing that include: Runtime instrumentation metrics. ASP.NET Core instrumentation metrics. HttpClient instrumentation metrics. In a development environment, the AlwaysOnSampler is used to view all traces. Tracing details for ASP.NET Core, gRPC and HTTP instrumentation. Adds OpenTelemetry exporters, by calling AddOpenTelemetryExporters. The AddOpenTelemetryExporters method is defined privately as follows: :::code source=""snippets/template/YourAppName/Extensions.cs"" id=""addotelexporters""::: The AddOpenTelemetryExporters method adds OpenTelemetry exporters based on the following conditions: If the OTEL_EXPORTER_OTLP_ENDPOINT environment variable is set, the OpenTelemetry exporter is added. Optionally consumers of .NET Aspire service defaults can uncomment some code to enable the Prometheus exporter, or the Azure Monitor exporter. For more information, see .NET Aspire telemetry. Health checks configuration Health checks are used by various tools and systems to assess the readiness of your app. .NET Aspire provides a set of opinionated defaults for health checks, which are configured with the AddDefaultHealthChecks method: :::code source=""snippets/template/YourAppName/Extensions.cs"" id=""addhealthchecks""::: The AddDefaultHealthChecks method adds a default liveness check to ensure the app is responsive. The call to Web app health checks configuration To expose health checks in a web app, .NET Aspire automatically determines the type of project being referenced within the solution, and adds the appropriate call to MapDefaultEndpoints: :::code source=""snippets/template/YourAppName/Extensions.cs"" id=""mapdefaultendpoints""::: The MapDefaultEndpoints method: Allows consumers to optionally uncomment some code to enable the Prometheus endpoint. Maps the health checks endpoint to /health. Maps the liveness endpoint to /alive route where the health check tag contains live. For more information, see .NET Aspire health checks. Custom service defaults If the default service configuration provided by the project template is not sufficient for your needs, you have the option to create your own service defaults project. This is especially useful when your consuming project, such as a Worker project or WinForms project, cannot or does not want to have a FrameworkReference dependency on Microsoft.AspNetCore.App. To do this, create a new .NET 9.0 class library project and add the necessary dependencies to the project file, consider the following example: ```xml ``` Then create an extensions class that contains the necessary methods to configure the app defaults: ```csharp using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; using OpenTelemetry.Logs; using OpenTelemetry.Metrics; using OpenTelemetry.Trace; namespace Microsoft.Extensions.Hosting; public static class AppDefaultsExtensions { public static IHostApplicationBuilder AddAppDefaults( this IHostApplicationBuilder builder) { builder.ConfigureAppOpenTelemetry(); builder.Services.AddServiceDiscovery(); builder.Services.ConfigureHttpClientDefaults(http => { // Turn on resilience by default http.AddStandardResilienceHandler(); // Turn on service discovery by default http.AddServiceDiscovery(); }); return builder; } public static IHostApplicationBuilder ConfigureAppOpenTelemetry( this IHostApplicationBuilder builder) { builder.Logging.AddOpenTelemetry(logging => { logging.IncludeFormattedMessage = true; logging.IncludeScopes = true; }); builder.Services.AddOpenTelemetry() .WithMetrics(static metrics => { metrics.AddRuntimeInstrumentation(); }) .WithTracing(tracing => { if (builder.Environment.IsDevelopment()) { // We want to view all traces in development tracing.SetSampler(new AlwaysOnSampler()); } tracing.AddGrpcClientInstrumentation() .AddHttpClientInstrumentation(); }); builder.AddOpenTelemetryExporters(); return builder; } private static IHostApplicationBuilder AddOpenTelemetryExporters( this IHostApplicationBuilder builder) { var useOtlpExporter = !string.IsNullOrWhiteSpace( builder.Configuration[""OTEL_EXPORTER_OTLP_ENDPOINT""]); if (useOtlpExporter) { builder.Services.Configure<OpenTelemetryLoggerOptions>( logging => logging.AddOtlpExporter()); builder.Services.ConfigureOpenTelemetryMeterProvider( metrics => metrics.AddOtlpExporter()); builder.Services.ConfigureOpenTelemetryTracerProvider( tracing => tracing.AddOtlpExporter()); } return builder; } } ``` This is only an example, and you can customize the AppDefaultsExtensions class to meet your specific needs. Next steps This code is derived from the .NET Aspire Starter Application template and is intended as a starting point. You\'re free to modify this code however you deem necessary to meet your needs. It\'s important to know that service defaults project and its functionality are automatically applied to all project resources in a .NET Aspire solution. Service discovery in .NET Aspire .NET Aspire SDK .NET Aspire templates Health checks in .NET Aspire .NET Aspire telemetry Build resilient HTTP apps: Key development patterns']","The .NET Aspire service defaults project supports cloud-native applications by providing a set of extension methods that streamline the management of configurations, including telemetry, health checks, and service discovery. It allows for extensive customization and extensibility, which is crucial for ensuring applications work reliably across different environments. Regarding the Azure Monitor exporter, users can uncomment specific code in the AddOpenTelemetryExporters method to enable it, alongside other options like the Prometheus exporter, depending on their needs.",multi_hop_abstract_query_synthesizer
85,How can you seed data in a .NET Aspire project using Entity Framework Core and ensure it integrates with a Seq Server for logging?,"['<1-hop>\n\ntitle: Seed data in a database using .NET Aspire description: Learn about how to seed database data in .NET Aspire ms.date: 08/12/2024 ms.topic: how-to Seed data in a database using .NET Aspire In this article, you learn how to configure .NET Aspire projects to seed data in a database during app startup. .NET Aspire enables you to seed data using database scripts or Entity Framework Core for common platforms such as SQL Server, PostgreSQL and MySQL. When to seed data Seeding data pre-populates database tables with rows of data so they\'re ready for testing via your app. You may want to seed data for the following scenarios: Manually develop and test different features of your app against a meaningful set of data, such as a product catalog or list of customers. Run test suites to verify that features behave a specific way with a given set of data. Manually seeding data is tedious and time consuming, so you should automate the process when possible. Use volumes to run database scripts for .NET Aspire projects during startup. You can also seed your database using tools like Entity Framework Core, which handles many underlying concerns for you. Understand containerized databases By default, .NET Aspire database integrations rely on containerized databases, which create the following challenges when trying to seed data: .NET Aspire destroys and recreates containers every time the app restarts, which means by default you have to re-seed your database every time the app restarts. Depending on your selected database technology, the new container instance may or may not create a default database, which means you might also have to create the database itself. Even if a default database exists, it most likely will not have the desired name or schema for your specific app. .NET Aspire enables you to resolve these challenges using volumes and a few configurations to seed data effectively. Seed data using volumes and SQL scripts Volumes are the recommended way to automatically seed containerized databases when using SQL scripts. Volumes can store data for multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume mount, which is the physical location on your host. Target: The target path in the container of the data you want to persist. Consider the following volume configuration code from a :::no-loc text=""Program.cs""::: file in a sample AppHost project: csharp var todosDbName = ""Todos""; var todosDb = builder.AddPostgres(""postgres"") .WithEnvironment(""POSTGRES_DB"", todosDbName) .WithBindMount( ""../DatabaseContainers.ApiService/data/postgres"", ""/docker-entrypoint-initdb.d"") .AddDatabase(todosDbName); In this example, the .WithBindMount method parameters configure the following: ../DatabaseContainers.ApiService/data/postgres sets a path to the SQL script in your local project that you want to run in the container to seed data. /docker-entrypoint-initdb.d sets the path to an entry point in the container so your script will be run during container startup. The referenced SQL script located at ../DatabaseContainers.ApiService/data/postgres creates and seeds a Todos table: ```sql -- Postgres init script -- Create the Todos table CREATE TABLE IF NOT EXISTS Todos ( Id SERIAL PRIMARY KEY, Title text UNIQUE NOT NULL, IsComplete boolean NOT NULL DEFAULT false ); -- Insert some sample data into the Todos table INSERT INTO Todos (Title, IsComplete) VALUES (\'Give the dog a bath\', false), (\'Wash the dishes\', false), (\'Do the groceries\', false) ON CONFLICT DO NOTHING; ``` The script runs during startup every time a new container instance is created. Database seeding examples The following examples demonstrate how to seed data using SQL scripts and configurations applied using the .WithBindMount method for different database technologies: [!NOTE] Visit the Database Container Sample App to view the full project and file structure for each database option. SQL Server The configuration code in the .AppHost :::no-loc text=""Program.cs""::: file mounts the required database files and folders and configures an entrypoint so that they run during startup. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""37-49"" ::: The entrypoint.sh script lives in the mounted ./sqlserverconfig project folder and runs when the container starts. The script launches SQL Server and checks that it\'s running. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/sqlserverconfig/entrypoint.sh"" ::: The init.sql SQL script that lives in the mounted ../DatabaseContainers.ApiService/data/sqlserver project folder creates the database and tables. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/sqlserver/init.sql"" ::: PostgreSQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""3-15"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/postgres/init.sql"" ::: MySQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""20-32"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/mysql/init.sql"" :::', '<2-hop>\n\nSeed data using Entity Framework Core You can also seed data in .NET Aspire projects using Entity Framework Core by explicitly running migrations during startup. Entity Framework Core handles underlying database connections and schema creation for you, which eliminates the need to use volumes or run SQL scripts during container startup. [!IMPORTANT] These types of configurations should only be done during development, so make sure to add a conditional that checks your current environment context. Add the following code to the :::no-loc text=""Program.cs""::: file of your API Service project. SQL Server ```csharp // Register DbContext class builder.AddSqlServerDbContext var app = builder.Build(); app.MapDefaultEndpoints(); if (app.Environment.IsDevelopment()) { // Retrieve an instance of the DbContext class and manually run migrations during startup using (var scope = app.Services.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService PostgreSQL ```csharp // Register DbContext class builder.AddNpgsqlDbContext var app = builder.Build(); app.MapDefaultEndpoints(); if (app.Environment.IsDevelopment()) { // Retrieve an instance of the DbContext class and manually run migrations during startup using (var scope = app.Services.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService MySQL ```csharp // Register DbContext class builder.AddMySqlDataSource var app = builder.Build(); app.MapDefaultEndpoints(); if (app.Environment.IsDevelopment()) { // Retrieve an instance of the DbContext class and manually run migrations during startup using (var scope = app.Services.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService Next steps Database seeding is useful in a variety of app development scenarios. Try combining these techniques with the resource implementations demonstrated in the following tutorials: Tutorial: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations .NET Aspire orchestration overview', '<3-hop>\n\ntitle: .NET Aspire Seq integration description: Learn how to use the .NET Aspire Seq integration to add OpenTelemetry Protocol (OTLP) exporters that send logs and traces to a Seq Server. ms.date: 08/12/2024 uid: logging/seq-integration .NET Aspire Seq integration [!INCLUDE includes-hosting-and-client] Seq is a self-hosted search and analysis server that handles structured application logs and trace files. It includes a JSON event store and a simple query language that make it easy to use. You can use the .NET Aspire Seq integration to send OpenTelemetry Protocol (OTLP) data to Seq. The integration supports persistent logs and traces across application restarts. During development, .NET Aspire runs and connects to the datalust/seq container image. Hosting integration The Seq hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Seq PackageReference xml <PackageReference Include=""Aspire.Hosting.Seq"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add a Seq resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var seq = builder.AddSeq(""seq"") .ExcludeFromManifest() .WithLifetime(ContainerLifetime.Persistent) .WithEnvironment(""ACCEPT_EULA"", ""Y""); var myService = builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Seq container may be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. Accept the Seq End User License Agreement (EULA) You must accept the Seq EULA for Seq to start. To accept the agreement in code, pass the environment variable ACCEPT_EULA to the Seq container, and set its value to Y. The above code passes this variable in the chained call to Seq in the .NET Aspire manifest Seq shouldn\'t be part of the .NET Aspire deployment manifest, hence the chained call to Persistent logs and traces Register Seq with a data directory in your app host project to retain Seq\'s data and configuration across application restarts: csharp var seq = builder.AddSeq(""seq"", seqDataDirectory: ""./seqdata"") .ExcludeFromManifest() .WithLifetime(ContainerLifetime.Persistent); The directory specified must already exist. Add a Seq resource with a data volume To add a data volume to the Seq resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var seq = builder.AddSeq(""seq"") .WithDataVolume() .ExcludeFromManifest() .WithLifetime(ContainerLifetime.Persistent); var myService = builder.AddProject The data volume is used to persist the Seq data outside the lifecycle of its container. The data volume is mounted at the /data path in the Seq container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Seq resource with data bind mount To add a data bind mount to the Seq resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var seq = builder.AddSeq(""seq"") .WithDataBindMount(source: @""C:\\Data"") .ExcludeFromManifest() .WithLifetime(ContainerLifetime.Persistent); var myService = builder.AddProject ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Seq data across container restarts. The data bind mount is mounted at the C:\\Data on Windows (or /Data on Unix) path on the host machine in the Seq container. For more information on data bind mounts, see Docker docs: Bind mounts.']","In a .NET Aspire project, you can seed data using Entity Framework Core by explicitly running migrations during startup. This process eliminates the need for volumes or SQL scripts during container startup, as Entity Framework Core manages database connections and schema creation. To implement this, you would add the necessary DbContext registration in the Program.cs file of your API Service project. Additionally, to integrate with a Seq Server for logging, you can use the .NET Aspire Seq integration, which allows you to send OpenTelemetry Protocol (OTLP) data to Seq. This integration supports persistent logs and traces across application restarts, ensuring that your application's logging is robust and reliable.",multi_hop_abstract_query_synthesizer
86,"What is the relationship between .NET Aspire's app host launch profiles and service projects, and how do they simplify the debugging experience?","['<1-hop>\n\ntitle: .NET Aspire and launch profiles description: Learn how .NET Aspire integrates with .NET launch profiles. ms.date: 04/23/2024 .NET Aspire and launch profiles .NET Aspire makes use of launch profiles defined in both the app host and service projects to simplify the process of configuring multiple aspects of the debugging and publishing experience for .NET Aspire-based distributed applications. Launch profile basics When creating a new .NET application from a template developers will often see a Properties directory which contains a file named launchSettings.json. The launch settings file contains a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. The code below is an example of launch profiles in a launchSettings.json file for an ASP.NET Core application. json { ""$schema"": ""http://json.schemastore.org/launchsettings.json"", ""profiles"": { ""http"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": false, ""applicationUrl"": ""http://localhost:5130"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"" } }, ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": false, ""applicationUrl"": ""https://localhost:7106;http://localhost:5130"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"" } } } } The launchSettings.json file above defines two launch profiles, http and https. Each has its own set of environment variables, launch URLs and other options. When launching a .NET Core application developers can choose which launch profile to use. dotnetcli dotnet run --launch-profile https If no launch profile is specified, then the first launch profile is selected by default. It is possible to launch a .NET Core application without a launch profile using the --no-launch-profile option. Some fields from the launchSettings.json file are translated to environment variables. For example, the applicationUrl field is converted to the ASPNETCORE_URLS environment variable which controls which address and port ASP.NET Core binds to. In Visual Studio it\'s possible to select the launch profile when launching the application making it easy to switch between configuration scenarios when manually debugging issues: :::image type=""content"" loc-scope=""visual-studio"" source=""./media/launch-profiles/vs-launch-profile-toolbar.png"" lightbox=""./media/launch-profiles/vs-launch-profile-toolbar.png"" alt-text=""Screenshot of the standard toolbar in Visual Studio with the launch profile selector highlighted.""::: When a .NET application is launched with a launch profile a special environment variable called DOTNET_LAUNCH_PROFILE is populated with the name of the launch profile that was used when launching the process. Launch profiles for .NET Aspire app host In .NET Aspire, the AppHost is just a .NET application. As a result it has a launchSettings.json file just like any other application. Here is an example of the launchSettings.json file generated when creating a new .NET Aspire project from the starter template (dotnet new aspire-starter). json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } }, ""http"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""http://localhost:19240"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""http://localhost:20154"" } } } } The .NET Aspire templates have a very similar set of launch profiles to a regular ASP.NET Core application. When the .NET Aspire app project launches, it starts a For information about app host configuration options, see .NET Aspire app host configuration.', '<2-hop>\n\nRelationship between app host launch profiles and service projects In .NET Aspire the app host is responsible for coordinating the launch of multiple service projects. When you run the app host either via the command line or from Visual Studio (or other development environment) a launch profile is selected for the app host. In turn, the app host will attempt to find a matching launch profile in the service projects it is launching and use those options to control the environment and default networking configuration for the service project. When the app host launches a service project it doesn\'t simply launch the service project using the --launch-profile option. Therefore, there will be no DOTNET_LAUNCH_PROFILE environment variable set for service projects. This is because .NET Aspire modifies the ASPNETCORE_URLS environment variable (derived from the applicationUrl field in the launch profile) to use a different port. By default, .NET Aspire inserts a reverse proxy in front of the ASP.NET Core application to allow for multiple instances of the application using the Other settings such as options from the environmentVariables field are passed through to the application without modification. Control launch profile selection Ideally, it\'s possible to align the launch profile names between the app host and the service projects to make it easy to switch between configuration options on all projects coordinated by the app host at once. However, it may be desirable to control launch profile that a specific project uses. The csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject<Projects.InventoryService>( ""inventoryservice"", launchProfileName: ""mylaunchprofile""); The preceding code shows that the inventoryservice resource (a .NET project) is launched using the options from the mylaunchprofile launch profile. The launch profile precedence logic is as follows: Use the launch profile specified by launchProfileName argument if specified. Use the launch profile with the same name as the AppHost (determined by reading the DOTNET_LAUNCH_PROFILE environment variable). Use the default (first) launch profile in launchSettings.json. Don\'t use a launch profile. To force a service project to launch without a launch profile the launchProfileName argument on the Launch profiles and endpoints When adding an ASP.NET Core project to the app host, .NET Aspire will parse the launchSettings.json file selecting the appropriate launch profile and automatically generate endpoints in the application model based on the URL(s) present in the applicationUrl field. To modify the endpoints that are automatically injected the csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject<Projects.InventoryService>(""inventoryservice"") .WithEndpoint(""https"", endpoint => endpoint.IsProxied = false); The preceding code shows how to disable the reverse proxy that .NET Aspire deploys in front for the .NET Core application and instead allows the .NET Core application to respond directly on requests over HTTP(S). For more information on networking options within .NET Aspire see .NET Aspire inner loop networking overview. See also Kestrel configured endpoints']",".NET Aspire's app host launch profiles are crucial for coordinating the launch of multiple service projects. When the app host is run, it selects a launch profile that controls the environment and networking configuration for the service projects it launches. This integration simplifies the debugging experience by allowing developers to easily switch between different configuration scenarios using the launch profiles defined in the launchSettings.json file. Additionally, the app host modifies the ASPNETCORE_URLS environment variable to ensure proper port usage, enhancing the overall management of distributed applications.",multi_hop_abstract_query_synthesizer
87,How does the DistributedApplicationBuilder facilitate the orchestration of the Store and Products projects in the .NET Aspire framework?,"['<1-hop>\n\nAdd .NET Aspire to the Store web app Now, let\'s enroll the Store project, which implements the web user interface, in .NET Aspire orchestration: :::zone pivot=""visual-studio"" In Visual Studio, in the Solution Explorer, right-click the Store project, select Add, and then select .NET Aspire Orchestrator Support. In the Add .NET Aspire Orchestrator Support dialog, select OK. :::image type=""content"" loc-scope=""visual-studio"" source=""media/add-aspire-orchestrator-support.png"" alt-text=""Screenshot of the Add .NET Aspire Orchestrator Support dialog.""::: You should now have two new projects, both added to the solution: eShopLite.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator is set as the Startup project, and it depends on the eShopLite.Store project. eShopLite.ServiceDefaults: A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. In the eShopLite.AppHost project, open the :::no-loc text=""Program.cs""::: file. Notice this line of code, which registers the Store project in the .NET Aspire orchestration: csharp builder.AddProject<Projects.Store>(""store""); For more information, see To add the Products project to .NET Aspire: In Visual Studio, in the Solution Explorer, right-click the Products project, select Add, and then select .NET Aspire Orchestrator Support. A dialog indicating that .NET Aspire Orchestrator project already exists, select OK. :::image type=""content"" loc-scope=""visual-studio"" source=""media/orchestrator-already-added.png"" alt-text=""Screenshot indicating that the.NET Aspire Orchestrator was already added.""::: In the eShopLite.AppHost project, open the :::no-loc text=""Program.cs""::: file. Notice this line of code, which registers the Products project in the .NET Aspire orchestration: csharp builder.AddProject<Projects.Products>(""products""); Also notice that the eShopLite.AppHost project, now depends on both the Store and Products projects. :::zone-end :::zone pivot=""vscode,dotnet-cli"" Create an app host project In order to orchestrate the existing projects, you need to create a new app host project. To create a new app host project from the available .NET Aspire templates, use the following .NET CLI command: dotnetcli dotnet new aspire-apphost -o eShopLite.AppHost Add the app host project to existing solution: Unix dotnetcli dotnet sln ./eShopLite.sln add ./eShopLite.AppHost/eShopLite.AppHost.csproj Windows dotnetcli dotnet sln .\\eShopLite.sln add .\\eShopLite.AppHost\\eShopLite.AppHost.csproj Add the Store project as a project reference to the app host project using the following .NET CLI command: Unix dotnetcli dotnet add ./eShopLite.AppHost/eShopLite.AppHost.csproj reference ./Store/Store.csproj Windows dotnetcli dotnet add .\\eShopLite.AppHost\\eShopLite.AppHost.csproj reference .\\Store\\Store.csproj Create a service defaults project After the app host project is created, you need to create a new service defaults project. To create a new service defaults project from the available .NET Aspire templates, use the following .NET CLI command: dotnetcli dotnet new aspire-servicedefaults -o eShopLite.ServiceDefaults To add the project to the solution, use the following .NET CLI command: Unix dotnetcli dotnet sln ./eShopLite.sln add ./eShopLite.ServiceDefaults/eShopLite.ServiceDefaults.csproj Windows dotnetcli dotnet sln .\\eShopLite.sln add .\\eShopLite.ServiceDefaults\\eShopLite.ServiceDefaults.csproj Update the app host project to add a project reference to the Products project: Unix dotnetcli dotnet add ./eShopLite.AppHost/eShopLite.AppHost.csproj reference ./Products/Products.csproj Windows dotnetcli dotnet add .\\eShopLite.AppHost\\eShopLite.AppHost.csproj reference .\\Products\\Products.csproj Both the Store and Products projects need to reference the service defaults project so that they can easily include service discovery. To add a reference to the service defaults project in the Store project, use the following .NET CLI command: Unix dotnetcli dotnet add ./Store/Store.csproj reference ./eShopLite.ServiceDefaults/eShopLite.ServiceDefaults.csproj Windows dotnetcli dotnet add .\\Store\\Store.csproj reference .\\eShopLite.ServiceDefaults\\eShopLite.ServiceDefaults.csproj The same command with slightly different paths should be used to add a reference to the service defaults project in the Products project: Unix dotnetcli dotnet add ./Products/Products.csproj reference ./eShopLite.ServiceDefaults/eShopLite.ServiceDefaults.csproj Windows dotnetcli dotnet add .\\Products\\Products.csproj reference .\\eShopLite.ServiceDefaults\\eShopLite.ServiceDefaults.csproj In both the Store and Products projects, update their :::no-loc text=""Program.cs""::: files, adding the following line immediately after their var builder = WebApplication.CreateBuilder(args); line: csharp builder.AddServiceDefaults(); Update the app host project Open the :::no-loc text=""Program.cs""::: file of the app host project, and replace its contents with the following C# code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code: Creates a new DistributedApplicationBuilder instance. Adds the Store project to the orchestrator. Adds the Products project to the orchestrator. Builds and runs the orchestrator. :::zone-end Service Discovery At this point, both projects are part of .NET Aspire orchestration, but the Store needs to be able to discover the Products backend address through .NET Aspire\'s service discovery. To enable service discovery, open the :::no-loc text=""Program.cs""::: file in eShopLite.AppHost and update the code that the Store adds a reference to the Products project: ```csharp var builder = DistributedApplication.CreateBuilder(args); var products = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code expresses that the Store project depends on the Products project. For more information, see .NET Aspire app host: Reference resources. This reference is used to discover the address of the Products project. Additionally, the Store project is configured to use external HTTP endpoints. If you later choose to deploy this app, you\'d need the call to Next, update the :::no-loc text=""appsettings.json""::: in the Store project with the following JSON: json { ""DetailedErrors"": true, ""Logging"": { ""LogLevel"": { ""Default"": ""Information"", ""Microsoft.AspNetCore"": ""Warning"" } }, ""AllowedHosts"": ""*"", ""ProductEndpoint"": ""http://products"", ""ProductEndpointHttps"": ""https://products"" } The addresses for both the endpoints now uses the ""products"" name that was added to the orchestrator in the app host. These names are used to discover the address of the Products project.', '<2-hop>\n\nExplore the enrolled app Let\'s start the solution and examine the new behavior that .NET Aspire provides. :::zone pivot=""visual-studio"" [!NOTE] Notice that the eShopLite.AppHost project is the new startup project. In Visual Studio, to start debugging, press F5 Visual Studio builds the projects. If the Start Docker Desktop dialog appears, select Yes. Visual Studio starts the Docker engine and creates the necessary containers. When the deployment is complete, the .NET Aspire dashboard is displayed. In the dashboard, select the endpoint for the products project. A new browser tab appears and displays the product catalog in JSON format. In the dashboard, select the endpoint for the store project. A new browser tab appears and displays the home page for the web app. In the menu on the left, select Products. The product catalog is displayed. To stop debugging, close the browser. :::zone-end :::zone pivot=""vscode"" Delete the launch.json file that you created earlier, it no longer serves a purpose. Instead, start the app host project, which orchestrates the other projects: Start the app host project by right-clicking the eShopLite.AppHost project in the Solution Explorer and selecting Debug > Start New Instance: :::image type=""content"" source=""media/vscode-run-app-host.png"" lightbox=""media/vscode-run-app-host.png"" alt-text=""Visual Studio Code: Solution Explorer selecting Debug > Start New Instance."" ::: [!NOTE] If Docker Desktop (or Podman) isn\'t running, you\'ll experience an error. Start the OCI compliant container engine and try again. :::zone-end :::zone pivot=""dotnet-cli"" Start the app host project by running the following command: dotnetcli dotnet run --project ./eShopLite.AppHost/eShopLite.AppHost.csproj [!NOTE] If Docker Desktop (or Podman) isn\'t running, you\'ll experience an error. Start the OCI compliant container engine and try again. :::zone-end :::zone pivot=""vscode,dotnet-cli"" In the dashboard, select the endpoint for the products project. A new browser tab appears and displays the product catalog in JSON format. In the dashboard, select the endpoint for the store project. A new browser tab appears and displays the home page for the web app. In the menu on the left, select Products. The product catalog is displayed. To stop debugging, close the browser. :::zone-end Congratulations, you added .NET Aspire orchestration to your pre-existing web app. You can now add .NET Aspire integrations and use the .NET Aspire tooling to streamline your cloud-native web app development.']","The DistributedApplicationBuilder facilitates the orchestration of the Store and Products projects in the .NET Aspire framework by creating a new instance that allows for the registration of both projects. In the app host project, the code initializes the builder with 'var builder = DistributedApplication.CreateBuilder(args);', and then adds the Store and Products projects using 'builder.AddProject<Projects.Store>(""store"");' and 'builder.AddProject<Projects.Products>(""products"");'. This setup enables the Store project to discover the Products backend address through service discovery, ensuring that both projects can communicate effectively within the orchestration.",multi_hop_abstract_query_synthesizer
88,How can you test a custom command in .NET Aspire after deploying a project using the Azure Developer CLI (azd)?,"['<1-hop>\n\ntitle: Custom resource commands in .NET Aspire description: Learn how to create custom resource commands in .NET Aspire. ms.date: 11/07/2024 ms.topic: how-to Custom resource commands in .NET Aspire Each resource in the .NET Aspire app model is represented as an [!IMPORTANT] These .NET Aspire dashboard commands are only available when running the dashboard locally. They\'re not available when running the dashboard in Azure Container Apps. Add custom commands to a resource Start by creating a new .NET Aspire Starter App from the available templates. To create the solution from this template, follow the Quickstart: Build your first .NET Aspire solution. After creating this solution, add a new class named RedisResourceBuilderExtensions.cs to the app host project. Replace the contents of the file with the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/RedisResourceBuilderExtensions.cs""::: The preceding code: Shares the Is a static class so that it can contain extension methods. It defines a single extension method named WithClearCommand, extending the IResourceBuilder<RedisResource> interface. The WithClearCommand method registers a command named clear-cache that clears the cache of the Redis resource. The WithClearCommand method returns the IResourceBuilder<RedisResource> instance to allow chaining. The WithCommand API adds the appropriate annotations to the resource, which are consumed in the .NET Aspire dashboard. The dashboard uses these annotations to render the command in the UI. Before getting too far into those details, let\'s ensure that you first understand the parameters of the WithCommand method: name: The name of the command to invoke. displayName: The name of the command to display in the dashboard. executeCommand: The Func<ExecuteCommandContext, Task<ExecuteCommandResult>> to run when the command is invoked, which is where the command logic is implemented. updateState: The Func<UpdateCommandStateContext, ResourceCommandState> callback is invoked to determine the ""enabled"" state of the command, which is used to enable or disable the command in the dashboard. iconName: The name of the icon to display in the dashboard. The icon is optional, but when you do provide it, it should be a valid Fluent UI Blazor icon name. iconVariant: The variant of the icon to display in the dashboard, valid options are Regular (default) or Filled. Execute command logic The executeCommand delegate is where the command logic is implemented. This parameter is defined as a Func<ExecuteCommandContext, Task<ExecuteCommandResult>>. The ExecuteCommandContext provides the following properties: ExecuteCommandContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. ExecuteCommandContext.ResourceName: The name of the resource instance that the command is being executed on. ExecuteCommandContext.CancellationToken: The In the preceding example, the executeCommand delegate is implemented as an async method that clears the cache of the Redis resource. It delegates out to a private class-scoped function named OnRunClearCacheCommandAsync to perform the actual cache clearing. Consider the following code: ```csharp private static async Task await using var connection = ConnectionMultiplexer.Connect(connectionString); var database = connection.GetDatabase(); await database.ExecuteAsync(""FLUSHALL""); return CommandResults.Success(); } ``` The preceding code: Retrieves the connection string from the Redis resource. Connects to the Redis instance. Gets the database instance. Executes the FLUSHALL command to clear the cache. Returns a CommandResults.Success() instance to indicate that the command was successful. Update command state logic The updateState delegate is where the command state is determined. This parameter is defined as a Func<UpdateCommandStateContext, ResourceCommandState>. The UpdateCommandStateContext provides the following properties: UpdateCommandStateContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. UpdateCommandStateContext.ResourceSnapshot: The snapshot of the resource instance that the command is being executed on. The immutable snapshot is an instance of CustomResourceSnapshot, which exposes all sorts of valuable details about the resource instance. Consider the following code: ```csharp private static ResourceCommandState OnUpdateResourceState( UpdateCommandStateContext context) { var logger = context.ServiceProvider.GetRequiredService if (logger.IsEnabled(LogLevel.Information)) { logger.LogInformation( ""Updating resource state: {ResourceSnapshot}"", context.ResourceSnapshot); } return context.ResourceSnapshot.HealthStatus is HealthStatus.Healthy ? ResourceCommandState.Enabled : ResourceCommandState.Disabled; } ``` The preceding code: Retrieves the logger instance from the service provider. Logs the resource snapshot details. Returns ResourceCommandState.Enabled if the resource is healthy; otherwise, it returns ResourceCommandState.Disabled.', '<2-hop>\n\nTest the custom command To test the custom command, update your app host project\'s Program.cs file to include the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/Program.cs"" highlight=""4""::: The preceding code calls the WithClearCommand extension method to add the custom command to the Redis resource. Run the app and navigate to the .NET Aspire dashboard. You should see the custom command listed under the Redis resource. On the Resources page of the dashboard, select the ellipsis button under the Actions column: :::image source=""media/custom-clear-cache-command.png"" lightbox=""media/custom-clear-cache-command.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command displayed.""::: The preceding image shows the Clear cache command that was added to the Redis resource. The icon displays as a rabbit crosses out to indicate that the speed of the dependant resource is being cleared. Select the Clear cache command to clear the cache of the Redis resource. The command should execute successfully, and the cache should be cleared: :::image source=""media/custom-clear-cache-command-succeeded.png"" lightbox=""media/custom-clear-cache-command-succeeded.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command executed.""::: See also .NET Aspire orchestration overview .NET Aspire dashboard: Resource submenu actions', '<3-hop>\n\ntitle: Deploy a .NET Aspire project using the Azure Developer CLI description: Learn how to use azd to deploy .NET Aspire projects. ms.date: 01/08/2025 zone_pivot_groups: deployment-platform ms.custom: devx-track-extended-azdevcli Tutorial: Deploy a .NET Aspire project using the Azure Developer CLI The Azure Developer CLI (azd) enables you to deploy .NET Aspire projects using GitHub Actions or Azure Devops pipelines by automatically configuring the required authentication and environment settings. This article walks you through the process of creating and deploying a .NET Aspire project on Azure Container Apps using azd. You learn the following concepts: [!div class=""checklist""] Explore how azd integration works with .NET Aspire projects Create and configure a GitHub or Azure DevOps repository for a .NET Aspire project using azd Monitor and explore GitHub Actions workflow or Azure DevOps pipeline executions and Azure deployments [!INCLUDE aspire-prereqs] :::zone pivot=""azure-pipelines"" Create an Azure DevOps organization or choose an existing organization Create an Azure DevOps Personal Access Token (PAT) and save it for later use. Configure the token with the following permissions: Agent Pools (read, manage) Build (read and execute) Code (full) Project and team (read, write and manage) Release (read, write, execute and manage) Service Connections (read, query and manage) :::zone-end You also need to have the Azure Developer CLI installed locally (version 1.5.1 or higher). Common install options include the following: Windows powershell winget install microsoft.azd macOS bash brew tap azure/azd && brew install azd Linux bash curl -fsSL https://aka.ms/install-azd.sh | bash Create a .NET Aspire solution As a starting point, this article assumes that you\'ve created a .NET Aspire solution from the .NET Aspire Starter Application template. For more information, see Quickstart: Build your first .NET Aspire app. [!INCLUDE init workflow] :::zone pivot=""github-actions"" Create the GitHub repository and pipeline The Azure Developer CLI enables you to automatically create CI/CD pipelines with the correct configurations and permissions to provision and deploy resources to Azure. azd can also create a GitHub repository for your app if it doesn\'t exist already. Run the azd pipeline config command to configure your deployment pipeline and securely connect it to Azure: azdeveloper azd pipeline config Select the subscription to provision and deploy the app resources to. Select the Azure location to use for the resources. When prompted whether to create a new Git repository in the directory, enter y and press Enter. [!NOTE] Creating a GitHub repository required you being logged into GitHub. There are a few selections that vary based on your preferences. After logging in, you will be prompted to create a new repository in the current directory. Select Create a new private GitHub repository to configure the git remote. Enter a name of your choice for the new GitHub repository or press enter to use the default name. azd creates a new repository in GitHub and configures it with the necessary secrets required to authenticate to Azure. :::image type=""content"" loc-scope=""other"" source=""media/pipeline-configuration.png"" alt-text=""A screenshot showing the pipeline configuration steps.""::: Enter y to proceed when azd prompts you to commit and push your local changes to start the configured pipeline.']","To test a custom command in .NET Aspire after deploying a project using the Azure Developer CLI (azd), you need to update your app host project's Program.cs file to include the code that calls the WithClearCommand extension method, which adds the custom command to the Redis resource. After running the app, navigate to the .NET Aspire dashboard where you should see the custom command listed under the Redis resource. On the Resources page of the dashboard, select the ellipsis button under the Actions column",multi_hop_abstract_query_synthesizer
89,How do you start the .NET Aspire Milvus client integration and what NuGet package do you need to install?,"['<1-hop>\n\nClient integration To get started with the .NET Aspire Milvus client integration, install the ðŸ“¦ Aspire.Milvus.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Milvus database client. The Milvus client integration registers a Milvus.Client.MilvusClient instance that you can use to interact with Milvus databases. .NET CLI dotnetcli dotnet add package Aspire.Milvus.Client PackageReference xml <PackageReference Include=""Aspire.Milvus.Client"" Version=""*"" /> Add a Milvus client In the Program.cs file of your client-consuming project, call the csharp builder.AddMilvusClient(""milvusdb""); [!TIP] The connectionName parameter must match the name used when adding the Milvus database resource in the app host project. In other words, when you call AddDatabase and provide a name of milvusdb that same name should be used when calling AddMilvusClient. For more information, see Add a Milvus server resource and database resource. You can then retrieve the MilvusClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(MilvusClient client) { // Use the Milvus Client... } For more information on dependency injection, see .NET dependency injection. Add a keyed Milvus client There might be situations where you want to register multiple MilvusClient instances with different connection names. To register keyed Milvus clients, call the csharp builder.AddKeyedMilvusClient(name: ""mainDb""); builder.AddKeyedMilvusClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Milvus resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the MilvusClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] MilvusClient mainDbClient, [FromKeyedServices(""loggingDb"")] MilvusClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Milvus client integration provides multiple options to configure the connection to Milvus based on the requirements and conventions of your project. [!TIP] The default use is root and the default password is Milvus. To configure a different password in the Milvus container, see Handling credentials and passing other parameters for the Milvus resource. Use the following techniques to configure consuming client apps in your .NET Aspire solution with the same password or other settings. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddMilvusClient(): csharp builder.AddMilvusClient(""milvus""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""milvus"": ""Endpoint=http://localhost:19530/;Key=root:Non-default-P@ssw0rd"" } } By default the MilvusClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Milvus client integration supports json { ""Aspire"": { ""Milvus"": { ""Client"": { ""Endpoint"": ""http://localhost:19530/"", ""Database"": ""milvusdb"", ""Key"": ""root:Non-default-P@ssw0rd"", ""DisableHealthChecks"": false } } } } For the complete Milvus client integration JSON schema, see Aspire.Milvus.Client/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MilvusSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddMilvusClient( ""milvus"", static settings => settings.Key = ""root:Non-default-P@ssw0rd""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Milvus database integration: Adds the health check when Uses the configured client to perform a HealthAsync. If the result is healthy, the health check is considered healthy, otherwise it\'s unhealthy. Likewise, if there\'s an exception, the health check is considered unhealthy with the error propagating through the health check failure. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nClient integration To get started with the .NET Aspire Seq client integration, install the ðŸ“¦ Aspire.Seq NuGet package in the client-consuming project, that is, the project for the application that uses the Seq client. .NET CLI dotnetcli dotnet add package Aspire.Seq PackageReference xml <PackageReference Include=""Aspire.Seq"" Version=""*"" /> Add a Seq client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSeqEndpoint(connectionName: ""seq""); [!TIP] The connectionName parameter must match the name used when adding the Seq resource in the app host project. In other words, when you call AddSeq and provide a name of seq that same name should be used when calling AddSeqEndpoint. For more information, see Add a Seq resource. Configuration The .NET Aspire Seq integration provides multiple options to configure the connection to Seq based on the requirements and conventions of your project. Use configuration providers The .NET Aspire Seq integration supports json { ""Aspire"": { ""Seq"": { ""DisableHealthChecks"": true, ""ServerUrl"": ""http://localhost:5341"" } } } For the complete Seq client integration JSON schema, see Aspire.Seq/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<SeqSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSeqEndpoint(""seq"", static settings => { settings.DisableHealthChecks = true; settings.ServerUrl = ""http://localhost:5341"" }); [!INCLUDE integration-health-checks] The .NET Aspire Seq integration handles the following: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Seq integration uses the following log categories: Seq Tracing and Metrics The .NET Aspire Seq integration doesn\'t emit tracing activities and or metrics because it\'s a telemetry sink, not a telemetry source. See also Seq Seq Query Language .NET Aspire integrations .NET Aspire GitHub repo', '<3-hop>\n\ntitle: .NET Aspire Azure Key Vault integration description: Lean about the .NET Aspire Azure Key Vault integration. ms.topic: how-to ms.date: 08/12/2024 .NET Aspire Azure Key Vault integration In this article, you learn how to use the .NET Aspire Azure Key Vault integration. The Aspire.Azure.Key.Vault integration library is used to register a Get started To get started with the .NET Aspire Azure Key Vault integration, install the ðŸ“¦ Aspire.Azure.Security.KeyVault NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Key Vault client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Security.KeyVault PackageReference xml <PackageReference Include=""Aspire.Azure.Security.KeyVault"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Example usage THe following sections describe various example usages. Add secrets to configuration In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.Configuration.AddAzureKeyVaultSecrets(""secrets""); You can then retrieve a secret through normal csharp public class ExampleService(IConfiguration configuration) { string secretValue = configuration[""secretKey""]; // Use secretValue ... } Use SecretClient Alternatively, you can use a SecretClient to retrieve the secrets on demand. In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureKeyVaultClient(""secrets""); You can then retrieve the csharp public class ExampleService(SecretClient client) { // Use client... } ']","To start the .NET Aspire Milvus client integration, you need to install the Aspire.Milvus.Client NuGet package in the client-consuming project. This package allows you to register a Milvus.Client.MilvusClient instance for interacting with Milvus databases.",multi_hop_abstract_query_synthesizer
90,How does the .NET Aspire client integration utilize dependency injection to expose the MailKit SmtpClient functionality?,"['<1-hop>\n\ntitle: Create custom .NET Aspire client integrations description: Learn how to create a custom .NET Aspire client integration for an existing containerized application. ms.date: 09/12/2024 ms.topic: how-to Create custom .NET Aspire client integrations This article is a continuation of the Create custom .NET Aspire hosting integrations article. It guides you through creating a .NET Aspire client integration that uses MailKit to send emails. This integration is then added into the Newsletter app you previously built. The previous example omitted the creation of a client integration and instead relied on the existing .NET SmtpClient. It\'s best to use MailKit\'s SmtpClient over the official .NET SmtpClient for sending emails, as it\'s more modern and supports more features/protocols. For more information, see .NET SmtpClient: Remarks. Prerequisites If you\'re following along, you should have a Newsletter app from the steps in the Create custom .NET Aspire hosting integration article. [!TIP] This article is inspired by existing .NET Aspire integrations, and based on the team\'s official guidance. There are places where said guidance varies, and it\'s important to understand the reasoning behind the differences. For more information, see .NET Aspire integration requirements. Create library for integration .NET Aspire integrations are delivered as NuGet packages, but in this example, it\'s beyond the scope of this article to publish a NuGet package. Instead, you create a class library project that contains the integration and reference it as a project. .NET Aspire integration packages are intended to wrap a client library, such as MailKit, and provide production-ready telemetry, health checks, configurability, and testability. Let\'s start by creating a new class library project. Create a new class library project named MailKit.Client in the same directory as the MailDevResource.sln from the previous article. dotnetcli dotnet new classlib -o MailKit.Client Add the project to the solution. dotnetcli dotnet sln ./MailDevResource.sln add MailKit.Client/MailKit.Client.csproj The next step is to add all the NuGet packages that the integration relies on. Rather than having you add each package one-by-one from the .NET CLI, it\'s likely easier to copy and paste the following XML into the MailKit.Client.csproj file. :::code language=""xml"" source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKit.Client.csproj"" range=""9-16""::: Define integration settings Whenever you\'re creating a .NET Aspire integration, it\'s best to understand the client library that you\'re mapping to. With MailKit, you need to understand the configuration settings that are required to connect to a Simple Mail Transfer Protocol (SMTP) server. But it\'s also important to understand if the library has support for health checks, tracing and metrics. MailKit supports tracing and metrics, through its Telemetry.SmtpClient class. When adding health checks, you should use any established or existing health checks where possible. Otherwise, you might consider implementing your own in the integration. Add the following code to the MailKit.Client project in a file named MailKitClientSettings.cs: :::code source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKitClientSettings.cs""::: The preceding code defines the MailKitClientSettings class with: Endpoint property that represents the connection string to the SMTP server. DisableHealthChecks property that determines whether health checks are enabled. DisableTracing property that determines whether tracing is enabled. DisableMetrics property that determines whether metrics are enabled. Parse connection string logic The settings class also contains a ParseConnectionString method that parses the connection string into a valid Uri. The configuration is expected to be provided in the following format: ConnectionStrings:<connectionName>: The connection string to the SMTP server. MailKit:Client:ConnectionString: The connection string to the SMTP server. If neither of these values are provided, an exception is thrown.', '<2-hop>\n\nExpose client functionality The goal of .NET Aspire integrations is to expose the underlying client library to consumers through dependency injection. With MailKit and for this example, the SmtpClient class is what you want to expose. You\'re not wrapping any functionality, but rather mapping configuration settings to an SmtpClient class. It\'s common to expose both standard and keyed-service registrations for integrations. Standard registrations are used when there\'s only one instance of a service, and keyed-service registrations are used when there are multiple instances of a service. Sometimes, to achieve multiple registrations of the same type you use a factory pattern. Add the following code to the MailKit.Client project in a file named MailKitClientFactory.cs: :::code source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKitClientFactory.cs""::: The MailKitClientFactory class is a factory that creates an ISmtpClient instance based on the configuration settings. It\'s responsible for returning an ISmtpClient implementation that has an active connection to a configured SMTP server. Next, you need to expose the functionality for the consumers to register this factory with the dependency injection container. Add the following code to the MailKit.Client project in a file named MailKitExtensions.cs: :::code source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKitExtensions.cs""::: The preceding code adds two extension methods on the IHostApplicationBuilder type, one for the standard registration of MailKit and another for keyed-registration of MailKit. [!TIP] Extension methods for .NET Aspire integrations should extend the IHostApplicationBuilder type and follow the Add<MeaningfulName> naming convention where the <MeaningfulName> is the type or functionality you\'re adding. For this article, the AddMailKitClient extension method is used to add the MailKit client. It\'s likely more in-line with the official guidance to use AddMailKitSmtpClient instead of AddMailKitClient, since this only registers the SmtpClient and not the entire MailKit library. Both extensions ultimately rely on the private AddMailKitClient method to register the MailKitClientFactory with the dependency injection container as a scoped service. The reason for registering the MailKitClientFactory as a scoped service is because the connection operations are considered expensive and should be reused within the same scope where possible. In other words, for a single request, the same ISmtpClient instance should be used. The factory holds on to the instance of the SmtpClient that it creates and disposes of it. Configuration binding One of the first things that the private implementation of the AddMailKitClient methods does, is to bind the configuration settings to the MailKitClientSettings class. The settings class is instantiated and then Bind is called with the specific section of configuration. Then the optional configureSettings delegate is invoked with the current settings. This allows the consumer to further configure the settings, ensuring that manual code settings are honored over configuration settings. After that, depending on whether the serviceKey value was provided, the MailKitClientFactory should be registered with the dependency injection container as either a standard or keyed service. [!IMPORTANT] It\'s intentional that the implementationFactory overload is called when registering services. The CreateMailKitClientFactory method throws when the configuration is invalid. This ensures that creation of the MailKitClientFactory is deferred until it\'s needed and it prevents the app from erroring out before logging is available. The registration of health checks, and telemetry are described in a bit more detail in the following sections. Add health checks Health checks are a way to monitor the health of an integration. With MailKit, you can check if the connection to the SMTP server is healthy. Add the following code to the MailKit.Client project in a file named MailKitHealthCheck.cs: :::code source=""snippets/MailDevResourceAndComponent/MailKit.Client/MailKitHealthCheck.cs""::: The preceding health check implementation: Implements the IHealthCheck interface. Accepts the MailKitClientFactory as a primary constructor parameter. Satisfies the CheckHealthAsync method by: Attempting to get an ISmtpClient instance from the factory. If successful, it returns HealthCheckResult.Healthy. If an exception is thrown, it returns HealthCheckResult.Unhealthy. As previously shared in the registration of the MailKitClientFactory, the MailKitHealthCheck is conditionally registered with the IHeathChecksBuilder: csharp if (settings.DisableHealthChecks is false) { builder.Services.AddHealthChecks() .AddCheck<MailKitHealthCheck>( name: serviceKey is null ? ""MailKit"" : $""MailKit_{connectionName}"", failureStatus: default, tags: []); } The consumer could choose to omit health checks by setting the DisableHealthChecks property to true in the configuration. A common pattern for integrations is to have optional features and .NET Aspire integrations strongly encourages these types of configurations. For more information on health checks and a working sample that includes a user interface, see .NET Aspire ASP.NET Core HealthChecksUI sample. Wire up telemetry As a best practice, the MailKit client library exposes telemetry. .NET Aspire can take advantage of this telemetry and display it in the .NET Aspire dashboard. Depending on whether or not tracing and metrics are enabled, telemetry is wired up as shown in the following code snippet: ```csharp if (settings.DisableTracing is false) { builder.Services.AddOpenTelemetry() .WithTracing( traceBuilder => traceBuilder.AddSource( Telemetry.SmtpClient.ActivitySourceName)); } if (settings.DisableMetrics is false) { // Required by MailKit to enable metrics Telemetry.SmtpClient.Configure(); builder.Services.AddOpenTelemetry() .WithMetrics( metricsBuilder => metricsBuilder.AddMeter( Telemetry.SmtpClient.MeterName)); } ``` Update the Newsletter service With the integration library created, you can now update the Newsletter service to use the MailKit client. The first step is to add a reference to the MailKit.Client project. Add the MailKit.Client.csproj project reference to the MailDevResource.NewsletterService project: dotnetcli dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference MailKit.Client/MailKit.Client.csproj Next, add a reference to the ServiceDefaults project: dotnetcli dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference MailDevResource.ServiceDefaults/MailDevResource.ServiceDefaults.csproj The final step is to replace the existing :::no-loc text=""Program.cs""::: file in the MailDevResource.NewsletterService project with the following C# code: :::code source=""snippets/MailDevResourceAndComponent/MailDevResource.NewsletterService/Program.cs""::: The most notable changes in the preceding code are: The updated using statements that include the MailKit.Client, MailKit.Net.Smtp, and MimeKit namespaces. The replacement of the registration for the official .NET SmtpClient with the call to the AddMailKitClient extension method. The replacement of both /subscribe and /unsubscribe map post calls to instead inject the MailKitClientFactory and use the ISmtpClient instance to send the email. Run the sample Now that you\'ve created the MailKit client integration and updated the Newsletter service to use it, you can run the sample. From your IDE, select F5 or run dotnet run from the root directory of the solution to start the applicationâ€”you should see the .NET Aspire dashboard: :::image type=""content"" source=""./media/maildev-with-newsletterservice-dashboard.png"" lightbox=""./media/maildev-with-newsletterservice-dashboard.png"" alt-text="".NET Aspire dashboard: MailDev and Newsletter resources running.""::: Once the application is', '<3-hop>\n\nrunning, navigate to the Swagger UI at https://localhost:7251/swagger and test the /subscribe and /unsubscribe endpoints. Select the down arrow to expand the endpoint: :::image type=""content"" source=""./media/swagger-ui.png"" lightbox=""./media/swagger-ui.png"" alt-text=""Swagger UI: Subscribe endpoint.""::: Then select the Try it out button. Enter an email address, and then select the Execute button. :::image type=""content"" source=""./media/swagger-ui-try.png"" lightbox=""./media/swagger-ui-try.png"" alt-text=""Swagger UI: Subscribe endpoint with email address.""::: Repeat this several times, to add multiple email addresses. You should see the email sent to the MailDev inbox: :::image type=""content"" source=""./media/maildev-inbox.png"" alt-text=""MailDev inbox with multiple emails.""::: Stop the application by selecting Ctrl+C in the terminal window where the application is running, or by selecting the stop button in your IDE. View MailKit telemetry The MailKit client library exposes telemetry that can be viewed in the .NET Aspire dashboard. To view the telemetry, navigate to the .NET Aspire dashboard at https://localhost:7251. Select the newsletter resource to view the telemetry on the Metrics page: :::image type=""content"" source=""./media/mailkit-metrics-dashboard.png"" lightbox=""./media/mailkit-metrics-dashboard.png"" alt-text="".NET Aspire dashboard: MailKit telemetry.""::: Open up the Swagger UI again, and make some requests to the /subscribe and /unsubscribe endpoints. Then, navigate back to the .NET Aspire dashboard and select the newsletter resource. Select a metric under the mailkit.net.smtp node, such as mailkit.net.smtp.client.operation.count. You should see the telemetry for the MailKit client: :::image type=""content"" source=""./media/mailkit-metrics-graph-dashboard.png"" lightbox=""./media/mailkit-metrics-graph-dashboard.png"" alt-text="".NET Aspire dashboard: MailKit telemetry for operation count.""::: Summary In this article, you learned how to create a .NET Aspire integration that uses MailKit to send emails. You also learned how to integrate this integration into the Newsletter app you previously built. You learned about the core principles of .NET Aspire integrations, such as exposing the underlying client library to consumers through dependency injection, and how to add health checks and telemetry to the integration. You also learned how to update the Newsletter service to use the MailKit client. Go forth and build your own .NET Aspire integrations. If you believe that there\'s enough community value in the integration you\'re building, consider publishing it as a NuGet package for others to use. Furthermore, consider submitting a pull request to the .NET Aspire GitHub repository for consideration to be included in the official .NET Aspire integrations. Next steps [!div class=""nextstepaction""] Secure communication between hosting and client integrations']","The .NET Aspire client integration utilizes dependency injection to expose the MailKit SmtpClient functionality by mapping configuration settings to the SmtpClient class. The MailKitClientFactory class is created to generate an ISmtpClient instance based on the configuration settings. This factory is registered with the dependency injection container as a scoped service, ensuring that the same ISmtpClient instance is reused within the same request scope. Additionally, extension methods are provided to facilitate the registration of the MailKit client, allowing consumers to easily integrate the MailKit functionality into their applications.",multi_hop_abstract_query_synthesizer
91,What are the client integration features related to Azure Application Insights in the .NET Aspire solution?,"['<1-hop>\n\nIntegration features When you add a client integration to a project within your .NET Aspire solution, service defaults are automatically applied to that project; meaning the Service Defaults project is referenced and the AddServiceDefaults extension method is called. These defaults are designed to work well in most scenarios and can be customized as needed. The following service defaults are applied: Observability and telemetry: Automatically sets up logging, tracing, and metrics configurations: Logging: A technique where code is instrumented to produce logs of interesting events that occurred while the program was running. Tracing: A specialized form of logging that helps you localize failures and performance issues within applications distributed across multiple machines or processes. Metrics: Numerical measurements recorded over time to monitor application performance and health. Metrics are often used to generate alerts when potential problems are detected. Health checks: Exposes HTTP endpoints to provide basic availability and state information about an app. Health checks are used to influence decisions made by container orchestrators, load balancers, API gateways, and other management services. Resiliency: The ability of your system to react to failure and still remain functional. Resiliency extends beyond preventing failures to include recovering and reconstructing your cloud-native environment back to a healthy state. Versioning considerations Hosting and client integrations are updated each release to target the latest stable versions of dependent resources. When container images are updated with new image versions, the hosting integrations update to these new versions. Similarly, when a new NuGet version is available for a dependent client library, the corresponding client integration updates to the new version. This ensures the latest features and security updates are available to applications. When major breaking changes happen in dependent resources, integrations may temporarily split into version-dependent packages to ease updating across the breaking change. For more information, see the first example of such a breaking change. Official integrations .NET Aspire provides many integrations to help you build cloud-native applications. These integrations are designed to work seamlessly with the .NET Aspire app host and client libraries. The following sections detail cloud-agnostic, Azure-specific, Amazon Web Services (AWS), and Community Toolkit integrations. Cloud-agnostic integrations The following section details cloud-agnostic .NET Aspire integrations with links to their respective docs and NuGet packages, and provides a brief description of each integration. Integration docs and NuGet packages Description - Learn more : ðŸ“„ Apache Kafka - Hosting : ðŸ“¦ Aspire.Hosting.Kafka - Client : ðŸ“¦ Aspire.Confluent.Kafka A library for producing and consuming messages from an Apache Kafka broker. - Learn more : ðŸ“„ Dapr - Hosting : ðŸ“¦ Aspire.Hosting.Dapr - Client : N/A A library for modeling Dapr as a .NET Aspire resource. - Learn more : ðŸ“„ Elasticsearch - Hosting : ðŸ“¦ Aspire.Hosting.Elasticsearch - Client : ðŸ“¦ Aspire.Elastic.Clients.Elasticsearch A library for accessing Elasticsearch databases. - Learn more : ðŸ“„ Keycloak - Hosting : ðŸ“¦ Aspire.Hosting.Keycloak - Client : ðŸ“¦ Aspire.Keycloak.Authentication A library for accessing Keycloak authentication. - Learn more : ðŸ“„ Milvus - Hosting : ðŸ“¦ Aspire.Hosting.Milvus - Client : ðŸ“¦ Aspire.Milvus.Client A library for accessing Milvus databases. - Learn more : ðŸ“„ MongoDB Driver - Hosting : ðŸ“¦ Aspire.Hosting.MongoDB - Client : ðŸ“¦ Aspire.MongoDB.Driver A library for accessing MongoDB databases. - Learn more : ðŸ“„ MySqlConnector - Hosting : ðŸ“¦ Aspire.Hosting.MySql - Client : ðŸ“¦ Aspire.MySqlConnector A library for accessing MySqlConnector databases. - Learn more : ðŸ“„ NATS - Hosting : ðŸ“¦ Aspire.Hosting.Nats - Client : ðŸ“¦ Aspire.NATS.Net A library for accessing NATS messaging. - Learn more : ðŸ“„ Oracle - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.Oracle - Client : ðŸ“¦ Aspire.Oracle.EntityFrameworkCore A library for accessing Oracle databases with Entity Framework Core . - Learn more : ðŸ“„ Orleans - Hosting : ðŸ“¦ Aspire.Hosting.Orleans - Client : N/A A library for modeling Orleans as a .NET Aspire resource. - Learn more : ðŸ“„ Pomelo MySQL - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.MySql - Client : ðŸ“¦ Aspire.Pomelo.EntityFrameworkCore.MySql A library for accessing MySql databases with Entity Framework Core . - Learn more : ðŸ“„ PostgreSQL - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.PostgreSQL - Client : ðŸ“¦ Aspire.Npgsql.EntityFrameworkCore.PostgreSQL A library for accessing PostgreSQL databases using Entity Framework Core . - Learn more : ðŸ“„ PostgreSQL - Hosting : ðŸ“¦ Aspire.Hosting.PostgreSQL - Client : ðŸ“¦ Aspire.Npgsql A library for accessing PostgreSQL databases. - Learn more : ðŸ“„ Qdrant - Hosting : ðŸ“¦ Aspire.Hosting.Qdrant - Client : ðŸ“¦ Aspire.Qdrant.Client A library for accessing Qdrant databases. - Learn more : ðŸ“„ RabbitMQ - Hosting : ðŸ“¦ Aspire.Hosting.RabbitMQ - Client : ðŸ“¦ Aspire.RabbitMQ.Client A library for accessing RabbitMQ . - Learn more : ðŸ“„ Redis Distributed Caching - Hosting : ðŸ“¦ Aspire.Hosting.Redis , ðŸ“¦ Aspire.Hosting.Garnet , or ðŸ“¦ Aspire.Hosting.Valkey - Client : ðŸ“¦ Aspire.StackExchange.Redis.DistributedCaching A library for accessing Redis caches for distributed caching . - Learn more : ðŸ“„ Redis Output Caching - Hosting : ðŸ“¦ Aspire.Hosting.Redis , ðŸ“¦ Aspire.Hosting.Garnet , or ðŸ“¦ Aspire.Hosting.Valkey - Client : ðŸ“¦ Aspire.StackExchange.Redis.OutputCaching A library for accessing Redis caches for output caching . - Learn more : ðŸ“„ Redis - Hosting : ðŸ“¦ Aspire.Hosting.Redis , ðŸ“¦ Aspire.Hosting.Garnet , or ðŸ“¦ Aspire.Hosting.Valkey - Client : ðŸ“¦ Aspire.StackExchange.Redis A library for accessing Redis caches. - Learn more : ðŸ“„ Seq - Hosting : ðŸ“¦ Aspire.Hosting.Seq - Client : ðŸ“¦ Aspire.Seq A library for logging to Seq . - Learn more : ðŸ“„ SQL Server - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.SqlServer - Client : ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer A library for accessing SQL Server databases using EF Core . - Learn more : ðŸ“„ SQL Server - Hosting : ðŸ“¦ Aspire.Hosting.SqlServer - Client : ðŸ“¦ Aspire.Microsoft.Data.SqlClient A library for accessing SQL Server databases. For more information on working with .NET Aspire integrations in Visual Studio, see Visual Studio tooling. Azure integrations Azure integrations configure applications to use Azure resources. These hosting integrations are available in the Aspire.Hosting.Azure.* NuGet packages, while their client integrations are available in the Aspire.* NuGet packages: Integration docs and NuGet packages Description - Learn more : ðŸ“„ Azure App Configuration - Hosting : ðŸ“¦ Aspire.Hosting.Azure.AppConfiguration - Client : N/A A', '<2-hop>\n\nlibrary for interacting with Azure App Configuration . - Learn more : ðŸ“„ Azure Application Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ApplicationInsights - Client : N/A A library for interacting with Azure Application Insights . - Learn more : ðŸ“„ Azure Cosmos DB - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos A library for accessing Azure Cosmos DB databases with Entity Framework Core . - Learn more : ðŸ“„ Azure Cosmos DB - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.Azure.Cosmos A library for accessing Azure Cosmos DB databases. - Learn more : ðŸ“„ Azure Event Hubs - Hosting : ðŸ“¦ Aspire.Hosting.Azure.EventHubs - Client : ðŸ“¦ Aspire.Azure.Messaging.EventHubs A library for accessing Azure Event Hubs . - Learn more : ðŸ“„ Azure Functions - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Functions - Client : N/A A library for integrating with Azure Functions . - Learn more : ðŸ“„ Azure Key Vault - Hosting : ðŸ“¦ Aspire.Hosting.Azure.KeyVault - Client : ðŸ“¦ Aspire.Azure.Security.KeyVault A library for accessing Azure Key Vault . - Learn more : ðŸ“„ Azure Operational Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.OperationalInsights - Client : N/A A library for interacting with Azure Operational Insights . - Learn more : ðŸ“„ Azure AI OpenAI - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CognitiveServices - Client : ðŸ“¦ Aspire.Azure.AI.OpenAI A library for accessing Azure AI OpenAI or OpenAI functionality. - Learn more : ðŸ“„ Azure PostgreSQL - Hosting : ðŸ“¦ Aspire.Hosting.Azure.PostgreSQL - Client : N/A A library for interacting with Azure Database for PostgreSQL . - Learn more : ðŸ“„ Azure AI Search - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Search - Client : ðŸ“¦ Aspire.Azure.Search.Documents A library for accessing Azure AI Search functionality. - Learn more : ðŸ“„ Azure Service Bus - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ServiceBus - Client : ðŸ“¦ Aspire.Azure.Messaging.ServiceBus A library for accessing Azure Service Bus . - Learn more : ðŸ“„ Azure SignalR Service - Hosting : ðŸ“¦ Aspire.Hosting.Azure.SignalR - Client : Microsoft.Azure.SignalR A library for accessing Azure SignalR Service . - Learn more : ðŸ“„ Azure Blob Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Blobs A library for accessing Azure Blob Storage . - Learn more : ðŸ“„ Azure Storage Queues - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Queues A library for accessing Azure Storage Queues . - Learn more : ðŸ“„ Azure Table Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Data.Tables A library for accessing the Azure Table service. - Learn more : ðŸ“„ Azure Web PubSub - Hosting : ðŸ“¦ Aspire.Hosting.Azure.WebPubSub - Client : ðŸ“¦ Aspire.Azure.Messaging.WebPubSub A library for accessing the Azure Web PubSub service. Amazon Web Services (AWS) hosting integrations Integration docs and NuGet packages Description - Learn more : ðŸ“„ AWS Hosting - Hosting : ðŸ“¦ Aspire.Hosting.AWS - Client : N/A A library for modeling AWS resources . For more information, see GitHub: Aspire.Hosting.AWS library. Community Toolkit integrations [!NOTE] The Community Toolkit integrations are community-driven and maintained by the .NET Aspire community. These integrations are not officially supported by the .NET Aspire team. Integration docs and NuGet packages Description - Learn More : ðŸ“„ Azure Static Web Apps emulator - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps - Client : N/A A hosting integration for the Azure Static Web Apps emulator (Note: this does not support deployment of a project to Azure Static Web Apps). - Learn More : ðŸ“„ Bun hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Bun - Client : N/A A hosting integration for Bun apps. - Learn More : ðŸ“„ Deno hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Deno - Client : N/A A hosting integration for Deno apps. - Learn More : ðŸ“„ Go hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Golang - Client : N/A A hosting integration for Go apps. - Learn More : ðŸ“„ Java/Spring hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Java - Client : N/A A integration for running Java code in .NET Aspire either using the local JDK or using a container. - Learn More : ðŸ“„ Node.js hosting extensions - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.NodeJs.Extensions - Client : N/A An integration that contains some additional extensions for running Node.js applications - Learn More : ðŸ“„ Ollama - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Ollama - Client : ðŸ“¦ Aspire.CommunitToolkit.OllamaSharp An Aspire component leveraging the Ollama container with support for downloading a model on startup. - Learn More : ðŸ“„ Meilisearch hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Meilisearch - Client : ðŸ“¦ Aspire.CommunitToolkit.Meilisearch An Aspire component leveraging the Meilisearch container. - Learn More : ðŸ“„ Rust hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Rust - Client : N/A A hosting integration for Rust apps. - Learn More : ðŸ“„ SQL Database projects hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects - Client : N/A An Aspire hosting integration for SQL Database Projects. For more information, see .NET Aspire Community Toolkit.']","The client integration features related to Azure Application Insights in the .NET Aspire solution include a library for interacting with Azure Application Insights, which is available in the Aspire.Hosting.Azure.ApplicationInsights NuGet package. This integration allows applications to utilize Azure Application Insights for observability and telemetry, enhancing logging, tracing, and metrics configurations.",multi_hop_abstract_query_synthesizer
92,How do you add RabbitMQ server resource with management plugin in .NET Aspire RabbitMQ integration?,"['<1-hop>\n\ntitle: .NET Aspire RabbitMQ integration description: Learn how to use the .NET Aspire RabbitMQ message-broker integration, which includes both hosting and client integrations. ms.date: 10/11/2024 uid: messaging/rabbitmq-integration .NET Aspire RabbitMQ integration [!INCLUDE includes-hosting-and-client] RabbitMQ is a reliable messaging and streaming broker, which is easy to deploy on cloud environments, on-premises, and on your local machine. The .NET Aspire RabbitMQ integration enables you to connect to existing RabbitMQ instances, or create new instances from .NET with the docker.io/library/rabbitmq container image.', '<2-hop>\n\nHosting integration The RabbitMQ hosting integration models a RabbitMQ server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.RabbitMQ PackageReference xml <PackageReference Include=""Aspire.Hosting.RabbitMQ"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add RabbitMQ server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/rabbitmq image, it creates a new RabbitMQ server instance on your local machine. A reference to your RabbitMQ server (the rabbitmq variable) is added to the ExampleProject. The RabbitMQ server resource includes default credentials with a username of ""guest"" and randomly generated password using the The [!TIP] If you\'d rather connect to an existing RabbitMQ server, call Add RabbitMQ server resource with management plugin To add the RabbitMQ management plugin to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithManagementPlugin(); builder.AddProject // After adding all resources, run the app... ``` The RabbitMQ management plugin provides an HTTP-based API for management and monitoring of your RabbitMQ server. .NET Aspire adds another container image docker.io/library/rabbitmq-management to the app host that runs the management plugin. Add RabbitMQ server resource with data volume To add a data volume to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the RabbitMQ server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/rabbitmq path in the RabbitMQ server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add RabbitMQ server resource with data bind mount To add a data bind mount to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataBindMount( source: @""C:\\RabbitMQ\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the RabbitMQ server data across container restarts. The data bind mount is mounted at the C:\\RabbitMQ\\Data on Windows (or /RabbitMQ/Data on Unix) path on the host machine in the RabbitMQ server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add RabbitMQ server resource with parameters When you want to explicitly provide the username and password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username"", secret: true); var password = builder.AddParameter(""password"", secret: true); var rabbitmq = builder.AddRabbitMQ(""messaging"", username, password); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Hosting integration health checks The RabbitMQ hosting integration automatically adds a health check for the RabbitMQ server resource. The health check verifies that the RabbitMQ server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Rabbitmq NuGet package.']","To add a RabbitMQ server resource with the management plugin in .NET Aspire RabbitMQ integration, you can use the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithManagementPlugin(); builder.AddProject // After adding all resources, run the app... ``` This code snippet will add the RabbitMQ management plugin, which provides an HTTP-based API for management and monitoring of your RabbitMQ server.",multi_hop_abstract_query_synthesizer
93,How do you add a data volume to the Oracle resource in .NET Aspire and what is its purpose regarding data volume?,"['<1-hop>\n\ntitle: .NET Aspire Oracle Entity Framework Core integration description: Learn how to use the .NET Aspire Oracle Entity Framework Core integration, which includes both hosting and client integrations. ms.date: 01/21/2025 uid: database/oracle-entity-framework-integration .NET Aspire Oracle Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Oracle Database is a widely-used relational database management system owned and developed by Oracle. The .NET Aspire Oracle Entity Framework Core integration enables you to connect to existing Oracle servers or create new servers from .NET with the container-registry.orcale.com/databse/free container image. Hosting integration The .NET Aspire Oracle hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Oracle PackageReference xml <PackageReference Include=""Aspire.Hosting.Oracle"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications.', '<2-hop>\n\nAdd Oracle server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Oracle database container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the container-registry.oracle.com/database/free image, it creates a new Oracle server on your local machine. A reference to your Oracle resource builder (the oracle variable) is used to add a database. The database is named oracledb and then added to the ExampleProject. The Oracle resource includes a random password generated using the The [!TIP] If you\'d rather connect to an existing Oracle server, call Add Oracle resource with password parameter The Oracle resource includes default credentials with a random password. Oracle supports configuration-based default passwords by using the environment variable ORACLE_PWD. When you want to provide a password explicitly, you can provide it as a parameter: ```csharp var password = builder.AddParameter(""password"", secret: true); var oracle = builder.AddOracle(""oracle"", password) .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddOracle API, and internally assigns the parameter to the ORACLE_PWD environment variable of the Oracle container. The password parameter is usually specified as a user secret: json { ""Parameters"": { ""password"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Oracle resource with data volume To add a data volume to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataVolume() .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracle""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Oracle data outside the lifecycle of its container. The data volume is mounted at the /opt/oracle/oradata path in the Oracle container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add Oracle resource with data bind mount To add a data bind mount to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataBindMount(source: @""C:\\Oracle\\Data""); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Oracle data across container restarts. The data bind mount is mounted at the C:\\Oracle\\Data on Windows (or /Oracle/Data on Unix) path on the host machine in the Oracle container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Oracle hosting integration automatically adds a health check for the Oracle resource. The health check verifies that the Oracle server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Oracle NuGet package.', '<3-hop>\n\nClient integration You need an Oracle database and connection string for accessing the database. To get started with the .NET Aspire Oracle client integration, install the ðŸ“¦ Aspire.Oracle.EntityFrameworkCore NuGet package in the client-consuming project, that is, the project for the application that uses the Oracle client. The Oracle client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Oracle.EntityFrameworkCore PackageReference xml <PackageReference Include=""Aspire.Oracle.EntityFrameworkCore"" Version=""*"" /> Add Oracle client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(connectionName: ""oracledb""); [!TIP] The connectionName parameter must match the name used when adding the Oracle database resource in the app host project. In other words, when you call AddDatabase and provide a name of oracledb that same name should be used when calling AddOracleDatabaseDbContext. For more information, see Add Oracle server and database resources. You can then retrieve the csharp public class ExampleService(ExampleDbContext context) { // Use database context... } For more information on dependency injection, see .NET dependency injection. Add Oracle database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( connectionName: ""oracledb"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the Configuration The .NET Aspire Oracle Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling builder.AddOracleDatabaseDbContext<TContext>(): csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(""oracleConnection""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""oracleConnection"": ""Data Source=TORCL;User Id=OracleUser;Password=Non-default-P@ssw0rd;"" } } The EnrichOracleDatabaseDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it is called. For more information, see the ODP.NET documentation. Use configuration providers The .NET Aspire Oracle Entity Framework Core integration supports The following is an example of an :::no-loc text=""appsettings.json""::: that configures some of the available options: json { ""Aspire"": { ""Oracle"": { ""EntityFrameworkCore"": { ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableRetry"": false, ""CommandTimeout"": 30 } } } } [!TIP] The CommandTimeout property is in seconds. When set as shown in the preceding example, the timeout is 30 seconds. Use inline delegates You can also pass the Action<OracleEntityFrameworkCoreSettings> delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>( ""oracle"", static settings => settings.DisableHealthChecks = true); or csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( static settings => settings.DisableHealthChecks = true); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the Oracle database to connect to. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. DisableRetry A boolean value that indicates whether command retries should be disabled or not. CommandTimeout The time in seconds to wait for the command to execute. [!INCLUDE integration-health-checks] By default, the .NET Aspire Oracle Entity Framework Core integration handles the following: Checks if the If so, adds the DbContextHealthCheck, which calls EF Core\'s [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Oracle Entity Framework Core integration uses the following log categories: Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Database.Connection Microsoft.EntityFrameworkCore.Database.Transaction Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Migrations Microsoft.EntityFrameworkCore.Model Microsoft.EntityFrameworkCore.Model.Validation Microsoft.EntityFrameworkCore.Query Microsoft.EntityFrameworkCore.Update Tracing The .NET Aspire Oracle Entity Framework Core integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Oracle Entity Framework Core integration currently supports the following metrics: Microsoft.EntityFrameworkCore See also Oracle Database Oracle Database Documentation Entity Framework Core docs .NET Aspire integrations .NET Aspire GitHub repo', '<4-hop>\n\nAdd EventStore resource In the app host project, register and consume the EventStore integration using the AddEventStore extension method to add the EventStore container to the application builder. ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/eventstore/eventstore image, it creates a new EventStore instance on your local machine. A reference to your EventStore resource (the eventstore variable) is added to the ExampleProject. For more information, see Container resource lifecycle. Add EventStore resource with data volume To add a data volume to the EventStore resource, call the Aspire.Hosting.EventStoreBuilderExtensions.WithDataVolume method on the EventStore resource: ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore"") .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the EventStore data outside the lifecycle of its container. The data volume is mounted at the /var/lib/eventstore path in the EventStore container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add EventStore resource with data bind mount To add a data bind mount to the EventStore resource, call the Aspire.Hosting.EventStoreBuilderExtensions.WithDataBindMount method: ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore"") .WithDataBindMount(source: @""C:\\EventStore\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the EventStore data across container restarts. The data bind mount is mounted at the C:\\EventStore\\Data on Windows (or /EventStore/Data on Unix) path on the host machine in the EventStore container. For more information on data bind mounts, see Docker docs: Bind mounts. Add EventStore resource with log volume To add a log volume to the EventStore resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore"") .WithVolume(name: ""eventstore_logs"", target: ""/var/log/eventstore""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the EventStore logs outside the lifecycle of its container. The data volume must be mounted at the /var/log/eventstore target path in the EventStore container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. For more information about EventStore logs location, see EventStore Resources: Logs. Add EventStore resource with log bind mount To add a log bind mount to the EventStore resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore"") .WithBindMount(@""C:\\EventStore\\Logs"", ""/var/log/eventstore""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the EventStore logs across container restarts. The data bind mount is mounted at the C:\\EventStore\\Logs on Windows (or /EventStore/Logs on Unix) path on the host machine in the EventStore container. The target path must be set to the log folder used by the EventStore container (/var/log/eventstore). For more information about EventStore logs location, see EventStore Resources: Logs. For more information on data bind mounts, see Docker docs: Bind mounts.']","To add a data volume to the Oracle resource in .NET Aspire, you can call the method `WithDataVolume()` when adding the Oracle resource. The code snippet would look like this: ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataVolume() .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` The purpose of the data volume is to persist the Oracle data outside the lifecycle of its container, ensuring that the data remains intact even if the container is restarted. The data volume is mounted at the `/opt/oracle/oradata` path in the Oracle container.",multi_hop_abstract_query_synthesizer
94,"What are the key features of the .NET Aspire Azure Queue Storage integration, and how does it handle logging and tracing activities?","['<1-hop>\n\ntitle: .NET Aspire Azure Queue Storage integration description: This article describes the .NET Aspire Azure Queue Storage integration features and capabilities. ms.date: 12/09/2024 uid: storage/azure-queue-storage-integration .NET Aspire Azure Queue Storage integration [!INCLUDE includes-hosting-and-client] Azure Queue Storage is a service for storing large numbers of messages that can be accessed from anywhere in the world via authenticated calls. The .NET Aspire Azure Queue Storage integration enables you to connect to existing Azure Queue Storage instances or create new instances from .NET applications. Hosting integration [!INCLUDE storage-app-host] Add Azure Queue Storage resource In your app host project, register the Azure Queue Storage integration by chaining a call to ```csharp var builder = DistributedApplication.CreateBuilder(args); var queues = builder.AddAzureStorage(""storage"") .AddQueues(""queues""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Adds an Azure Storage resource named storage. Adds a queue named queues to the storage resource. Adds the storage resource to the ExampleProject and waits for it to be ready before starting the project. [!INCLUDE storage-hosting-health-checks] Client integration To get started with the .NET Aspire Azure Queue Storage client integration, install the ðŸ“¦ Aspire.Azure.Storage.Queues NuGet package in the client-consuming project, that is, the project for the application that uses the Azure Queue Storage client. The Azure Queue Storage client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Azure.Storage.Queues PackageReference xml <PackageReference Include=""Aspire.Azure.Storage.Queues"" Version=""*"" /> Add Azure Queue Storage client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureQueueClient(""queue""); You can then retrieve the QueueServiceClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(QueueServiceClient client) { // Use client... } Configuration The .NET Aspire Azure Queue Storage integration provides multiple options to configure the QueueServiceClient based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddAzureQueueClient(""queue""); Then the connection string is retrieved from the ConnectionStrings configuration section, and two connection formats are supported: Service URI The recommended approach is to use a ServiceUri, which works with the json { ""ConnectionStrings"": { ""queue"": ""https://{account_name}.queue.core.windows.net/"" } } Connection string Alternatively, an Azure Storage connection string can be used. json { ""ConnectionStrings"": { ""queue"": ""AccountName=myaccount;AccountKey=myaccountkey"" } } For more information, see Configure Azure Storage connection strings. Use configuration providers The .NET Aspire Azure Queue Storage integration supports json { ""Aspire"": { ""Azure"": { ""Storage"": { ""Queues"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Diagnostics"": { ""ApplicationId"": ""myapp"" } } } } } } } For the complete Azure Storage Queues client integration JSON schema, see Aspire.Azure.Data.Queues/ConfigurationSchema.json. Use inline delegates You can also pass the Action<AzureStorageQueuesSettings> configureSettings delegate to set up some or all the options inline, for example to configure health checks: csharp builder.AddAzureQueueClient( ""queue"", settings => settings.DisableHealthChecks = true); You can also set up the csharp builder.AddAzureQueueClient( ""queue"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Diagnostics.ApplicationId = ""myapp"")); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Queue Storage integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', ""<2-hop>\n\nLogging The .NET Aspire Azure Queue Storage integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Queue Storage integration emits the following tracing activities using OpenTelemetry: Azure.Storage.Queues.QueueClient Metrics The .NET Aspire Azure Queue Storage integration currently doesn't support metrics by default due to limitations with the Azure SDK. See also Azure Queue Storage docs .NET Aspire integrations .NET Aspire GitHub repo""]","The .NET Aspire Azure Queue Storage integration provides several key features, including the ability to connect to existing Azure Queue Storage instances or create new ones from .NET applications. It allows developers to register Azure Queue Storage resources in their app host projects and provides a client integration through the installation of the Aspire.Azure.Storage.Queues NuGet package. Additionally, the integration supports configuration options for the QueueServiceClient, including the use of connection strings and configuration providers. Regarding logging and tracing, the integration uses log categories such as Azure.Core and Azure.Identity, and it emits tracing activities using OpenTelemetry for Azure.Storage.Queues.QueueClient. However, it currently does not support metrics by default due to limitations with the Azure SDK.",multi_hop_abstract_query_synthesizer
95,How do you configure frontend authentication for the .NET Aspire dashboard and what are the options available for securing it?,"['<1-hop>\n\ntitle: .NET Aspire dashboard configuration description: .NET Aspire dashboard configuration options ms.date: 10/29/2024 ms.topic: reference Dashboard configuration The dashboard is configured when it starts up. Configuration includes frontend and OpenTelemetry Protocol (OTLP) addresses, the resource service endpoint, authentication, telemetry limits, and more. When the dashboard is launched with the .NET Aspire app host project, it\'s automatically configured to display the app\'s resources and telemetry. Configuration is provided when launching the dashboard in standalone mode. There are many ways to provide configuration: Command line arguments. Environment variables. The : delimiter should be replaced with double underscore (__) in environment variable names. Optional JSON configuration file. The DOTNET_DASHBOARD_CONFIG_FILE_PATH setting can be used to specify a JSON configuration file. Consider the following example, which shows how to configure the dashboard when started from a Docker container: Bash bash docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard \\ -e DASHBOARD__TELEMETRYLIMITS__MAXLOGCOUNT=\'1000\' \\ -e DASHBOARD__TELEMETRYLIMITS__MAXTRACECOUNT=\'1000\' \\ -e DASHBOARD__TELEMETRYLIMITS__MAXMETRICSCOUNT=\'1000\' \\ mcr.microsoft.com/dotnet/aspire-dashboard:9.0 PowerShell powershell docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard ` -e DASHBOARD__TELEMETRYLIMITS__MAXLOGCOUNT=\'1000\' ` -e DASHBOARD__TELEMETRYLIMITS__MAXTRACECOUNT=\'1000\' ` -e DASHBOARD__TELEMETRYLIMITS__MAXMETRICSCOUNT=\'1000\' ` mcr.microsoft.com/dotnet/aspire-dashboard:9.0 Alternatively, these same values could be configured using a JSON configuration file that is specified using DOTNET_DASHBOARD_CONFIG_FILE_PATH: json { ""Dashboard"": { ""TelemetryLimits"": { ""MaxLogCount"": 1000, ""MaxTraceCount"": 1000, ""MaxMetricsCount"": 1000 } } } [!IMPORTANT] The dashboard displays information about resources, including their configuration, console logs and in-depth telemetry. Data displayed in the dashboard can be sensitive. For example, secrets in environment variables, and sensitive runtime data in telemetry. Care should be taken to configure the dashboard to secure access. For more information, see dashboard security. [!NOTE] Configuration described on this page is for the standalone dashboard. To configure an .NET Aspire app host project, see App host configuration. Common configuration Option Default value Description ASPNETCORE_URLS http://localhost:18888 One or more HTTP endpoints through which the dashboard frontend is served. The frontend endpoint is used to view the dashboard in a browser. When the dashboard is launched by the .NET Aspire app host this address is secured with HTTPS. Securing the dashboard with HTTPS is recommended. DOTNET_DASHBOARD_OTLP_ENDPOINT_URL http://localhost:18889 The OTLP/gRPC endpoint. This endpoint hosts an OTLP service and receives telemetry using gRPC. When the dashboard is launched by the .NET Aspire app host this address is secured with HTTPS. Securing the dashboard with HTTPS is recommended. DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL http://localhost:18890 The OTLP/HTTP endpoint. This endpoint hosts an OTLP service and receives telemetry using Protobuf over HTTP. When the dashboard is launched by the .NET Aspire app host the OTLP/HTTP endpoint isn\'t configured by default. To configure an OTLP/HTTP endpoint with the app host, set an DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL env var value in launchSettings.json . Securing the dashboard with HTTPS is recommended. DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS false Configures the dashboard to not use authentication and accepts anonymous access. This setting is a shortcut to configuring Dashboard:Frontend:AuthMode and Dashboard:Otlp:AuthMode to Unsecured . DOTNET_DASHBOARD_CONFIG_FILE_PATH null The path for a JSON configuration file. If the dashboard is being run in a Docker container, then this is the path to the configuration file in a mounted volume. This value is optional. DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null The gRPC endpoint to which the dashboard connects for its data. If this value is unspecified, the dashboard shows telemetry data but no resource list or console logs. This setting is a shortcut to Dashboard:ResourceServiceClient:Url .', ""<2-hop>\n\nFrontend authentication The dashboard frontend endpoint authentication is configured with Dashboard:Frontend:AuthMode. The frontend can be secured with OpenID Connect (OIDC) or browser token authentication. Browser token authentication works by the frontend asking for a token. The token can either be entered in the UI or provided as a query string value to the login page. For example, https://localhost:1234/login?t=TheToken. When the token is successfully authenticated an auth cookie is persisted to the browser, and the browser is redirected to the app. Option Default value Description Dashboard:Frontend:AuthMode BrowserToken Can be set to BrowserToken , OpenIdConnect or Unsecured . Unsecured should only be used during local development. It's not recommended when hosting the dashboard publicly or in other settings. Dashboard:Frontend:BrowserToken null Specifies the browser token. If the browser token isn't specified, then the dashboard generates one. Tooling that wants to automate logging in with browser token authentication can specify a token and open a browser with the token in the query string. A new token should be generated each time the dashboard is launched. Dashboard:Frontend:OpenIdConnect:NameClaimType name Specifies one or more claim types that should be used to display the authenticated user's full name. Can be a single claim type or a comma-delimited list of claim types. Dashboard:Frontend:OpenIdConnect:UsernameClaimType preferred_username Specifies one or more claim types that should be used to display the authenticated user's username. Can be a single claim type or a comma-delimited list of claim types. Dashboard:Frontend:OpenIdConnect:RequiredClaimType null Specifies the claim that must be present for authorized users. Authorization fails without this claim. This value is optional. Dashboard:Frontend:OpenIdConnect:RequiredClaimValue null Specifies the value of the required claim. Only used if Dashboard:Frontend:OpenIdConnect:RequireClaimType is also specified. This value is optional. Authentication:Schemes:OpenIdConnect:Authority null URL to the identity provider (IdP). Authentication:Schemes:OpenIdConnect:ClientId null Identity of the relying party (RP). Authentication:Schemes:OpenIdConnect:ClientSecret null A secret that only the real RP would know. Other properties of null Values inside configuration section Authentication:Schemes:OpenIdConnect:* are bound to OpenIdConnectOptions , such as Scope . [!NOTE] Additional configuration may be required when using OpenIdConnect as authentication mode behind a reverse-proxy that terminates SSL. Check if you need ASPNETCORE_FORWARDEDHEADERS_ENABLED to be set to true. For more information, see Configure ASP.NET Core to work with proxy servers and load balancers.""]","Frontend authentication for the .NET Aspire dashboard is configured using the Dashboard:Frontend:AuthMode setting. The frontend can be secured with options such as OpenID Connect (OIDC) or browser token authentication. Browser token authentication works by the frontend requesting a token, which can be entered in the UI or provided as a query string value to the login page. The default value for Dashboard:Frontend:AuthMode is BrowserToken, but it can also be set to OpenIdConnect or Unsecured. It is important to note that Unsecured should only be used during local development and is not recommended for public hosting.",multi_hop_abstract_query_synthesizer
96,What are the dashboard configuration options for log entries and how do they relate to telemetry limits?,"['<1-hop>\n\nOTLP authentication The OTLP endpoint authentication is configured with Dashboard:Otlp:AuthMode. The OTLP endpoint can be secured with an API key or client certificate authentication. API key authentication works by requiring each OTLP request to have a valid x-otlp-api-key header value. It must match either the primary or secondary key. Option Default value Description Dashboard:Otlp:AuthMode Unsecured Can be set to ApiKey , Certificate or Unsecured . Unsecured should only be used during local development. It\'s not recommended when hosting the dashboard publicly or in other settings. Dashboard:Otlp:PrimaryApiKey null Specifies the primary API key. The API key can be any text, but a value with at least 128 bits of entropy is recommended. This value is required if auth mode is API key. Dashboard:Otlp:SecondaryApiKey null Specifies the secondary API key. The API key can be any text, but a value with at least 128 bits of entropy is recommended. This value is optional. If a second API key is specified, then the incoming x-otlp-api-key header value can match either the primary or secondary key. OTLP CORS Cross-origin resource sharing (CORS) can be configured to allow browser apps to send telemetry to the dashboard. By default, browser apps are restricted from making cross domain API calls. This impacts sending telemetry to the dashboard because the dashboard and the browser app are always on different domains. To configure CORS, use the Dashboard:Otlp:Cors section and specify the allowed origins and headers: json { ""Dashboard"": { ""Otlp"": { ""Cors"": { ""AllowedOrigins"": ""http://localhost:5000,https://localhost:5001"" } } } } Consider the following configuration options: Option Default value Description Dashboard:Otlp:Cors:AllowedOrigins null Specifies the allowed origins for CORS. It\'s a comma-delimited string and can include the * wildcard to allow any domain. This option is optional and can be set using the DASHBOARD__OTLP__CORS__ALLOWEDORIGINS environment variable. Dashboard:Otlp:Cors:AllowedHeaders null A comma-delimited string representing the allowed headers for CORS. This setting is optional and can be set using the DASHBOARD__OTLP__CORS__ALLOWEDHEADERS environment variable. [!NOTE] The dashboard only supports the POST method for sending telemetry and doesn\'t allow configuration of the allowed methods (Access-Control-Allow-Methods) for CORS. Resources The dashboard connects to a resource service to load and display resource information. The client is configured in the dashboard for how to connect to the service. The resource service client authentication is configured with Dashboard:ResourceServiceClient:AuthMode. The client can be configured to support API key or client certificate authentication. Option Default value Description Dashboard:ResourceServiceClient:Url null The gRPC endpoint to which the dashboard connects for its data. If this value is unspecified, the dashboard shows telemetry data but no resource list or console logs. Dashboard:ResourceServiceClient:AuthMode null Can be set to ApiKey , Certificate or Unsecured . Unsecured should only be used during local development. It\'s not recommended when hosting the dashboard publicly or in other settings. This value is required if a resource service URL is specified. Dashboard:ResourceServiceClient:ApiKey null The API to send to the resource service in the x-resource-service-api-key header. This value is required if auth mode is API key. Dashboard:ResourceServiceClient:ClientCertificate:Source null Can be set to File or KeyStore . This value is required if auth mode is client certificate. Dashboard:ResourceServiceClient:ClientCertificate:FilePath null The certificate file path. This value is required if source is File . Dashboard:ResourceServiceClient:ClientCertificate:Password null The password for the certificate file. This value is optional. Dashboard:ResourceServiceClient:ClientCertificate:Subject null The certificate subject. This value is required if source is KeyStore . Dashboard:ResourceServiceClient:ClientCertificate:Store My The certificate . Dashboard:ResourceServiceClient:ClientCertificate:Location CurrentUser The certificate .', '<2-hop>\n\nTelemetry limits Telemetry is stored in memory. To avoid excessive memory usage, the dashboard has limits on the count and size of stored telemetry. When a count limit is reached, new telemetry is added, and the oldest telemetry is removed. When a size limit is reached, data is truncated to the limit. Telemetry limits have different scopes depending upon the telemetry type: MaxLogCount and MaxTraceCount are shared across resources. For example, a MaxLogCount value of 5,000 configures the dashboard to store up to 5,000 total log entries for all resources. MaxMetricsCount is per-resource. For example, a MaxMetricsCount value of 10,000 configures the dashboard to store up to 10,000 metrics data points per-resource. Option Default value Description Dashboard:TelemetryLimits:MaxLogCount 10,000 The maximum number of log entries. Limit is shared across resources. Dashboard:TelemetryLimits:MaxTraceCount 10,000 The maximum number of log traces. Limit is shared across resources. Dashboard:TelemetryLimits:MaxMetricsCount 50,000 The maximum number of metric data points. Limit is per-resource. Dashboard:TelemetryLimits:MaxAttributeCount 128 The maximum number of attributes on telemetry. Dashboard:TelemetryLimits:MaxAttributeLength null The maximum length of attributes. Dashboard:TelemetryLimits:MaxSpanEventCount null The maximum number of events on span attributes. Other Option Default value Description Dashboard:ApplicationName Aspire The application name to be displayed in the UI. This applies only when no resource service URL is specified. When a resource service exists, the service specifies the application name. Next steps [!div class=""nextstepaction""] Security considerations for running the .NET Aspire dashboard']","The dashboard configuration options for log entries include the maximum number of log entries, which is set by the option Dashboard:TelemetryLimits:MaxLogCount. This limit is shared across resources and is configured to store up to 10,000 total log entries. Additionally, the configuration for the OTLP endpoint authentication, such as the API key settings, is crucial for ensuring that log entries are securely transmitted. The telemetry limits ensure that when the maximum count of log entries is reached, new telemetry is added while the oldest entries are removed, thus maintaining efficient memory usage.",multi_hop_abstract_query_synthesizer
97,"How does the .NET Aspire MongoDB database integration ensure compatibility with existing MongoDB instances, and what are the implications of code changes on compatibility in .NET?","['<1-hop>\n\ntitle: .NET Aspire MongoDB database integration description: Learn how to use the .NET Aspire MongoDB database integration, which includes both hosting and client integrations. ms.date: 12/03/2024 uid: database/mongodb-integration .NET Aspire MongoDB database integration [!INCLUDE includes-hosting-and-client] MongoDB is a NoSQL database that provides high performance, high availability, and easy scalability. The .NET Aspire MongoDB integration enables you to connect to existing MongoDB instances (including MongoDB Atlas) or create new instances from .NET with the docker.io/library/mongo container image Hosting integration The MongoDB server hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.MongoDB PackageReference xml <PackageReference Include=""Aspire.Hosting.MongoDB"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications.', '<2-hop>\n\ntitle: Compatibility description: Learn about the ways in which code changes can affect compatibility in .NET. ms.date: 10/24/2024 ms.topic: conceptual How code changes can affect compatibility Compatibility refers to the ability to compile or execute code on a version of a .NET implementation other than the one with which the code was originally developed. A particular change can affect compatibility in six different ways: Behavioral change Binary compatibility Source compatibility']","The .NET Aspire MongoDB database integration ensures compatibility with existing MongoDB instances by allowing connections to both existing MongoDB setups, including MongoDB Atlas, and by enabling the creation of new instances using the docker.io/library/mongo container image. This integration is facilitated through the .NET CLI, specifically using the command 'dotnet add package Aspire.Hosting.MongoDB'. On the other hand, compatibility in .NET refers to the ability to compile or execute code on different versions of .NET implementations. Code changes can affect compatibility in various ways, including behavioral changes, binary compatibility, and source compatibility, which are crucial for maintaining the functionality of applications across different environments.",multi_hop_abstract_query_synthesizer
98,"What are the key features of the .NET Aspire Azure Cosmos DB integration, and how does it handle logging and tracing for Azure Cosmos DB operations?","['<1-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nLogging The .NET Aspire Azure Cosmos DB integration uses the following log categories: Azure-Cosmos-Operation-Request-Diagnostics In addition to getting Azure Cosmos DB request diagnostics for failed requests, you can configure latency thresholds to determine which successful Azure Cosmos DB request diagnostics will be logged. The default values are 100 ms for point operations and 500 ms for non point operations. csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => { clientOptions.CosmosClientTelemetryOptions = new() { CosmosThresholdOptions = new() { PointOperationLatencyThreshold = TimeSpan.FromMilliseconds(50), NonPointOperationLatencyThreshold = TimeSpan.FromMilliseconds(300) } }; }); Tracing The .NET Aspire Azure Cosmos DB integration will emit the following tracing activities using OpenTelemetry: Azure.Cosmos.Operation Azure Cosmos DB tracing is currently in preview, so you must set the experimental switch to ensure traces are emitted. csharp AppContext.SetSwitch(""Azure.Experimental.EnableActivitySource"", true); For more information, see Azure Cosmos DB SDK observability: Trace attributes. Metrics The .NET Aspire Azure Cosmos DB integration currently doesn\'t support metrics by default due to limitations with the Azure SDK. See also Azure Cosmos DB .NET Aspire integrations overview .NET Aspire Azure integrations overview .NET Aspire GitHub repo']","The .NET Aspire Azure Cosmos DB integration provides several key features, including the ability to connect to existing Cosmos DB instances or create new ones using the Azure Cosmos DB emulator. It supports health checks to verify that the Cosmos DB resource is running and that a connection can be established. For client integration, developers can install the Aspire.Microsoft.Azure.Cosmos NuGet package and configure the connection using a connection string or configuration providers. Additionally, the integration allows for the registration of multiple CosmosClient instances with different connection names. Regarding logging, the integration uses specific log categories such as Azure-Cosmos-Operation-Request-Diagnostics, which can be configured to log latency thresholds for successful requests. For tracing, it emits tracing activities using OpenTelemetry, although this feature is currently in preview and requires enabling an experimental switch to emit traces.",multi_hop_abstract_query_synthesizer
99,"What are the steps to add an Azure Storage resource in a .NET Aspire application, and how can you connect to an existing Azure Storage account using a connection string?","['<1-hop>\n\nms.topic: include The .NET Aspire Azure Storage hosting integration models the various storage resources as the following types: To access these types and APIs for expressing them, add the ðŸ“¦ Aspire.Hosting.Azure.Storage NuGet package in the app host project. .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Storage PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Storage"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Azure Storage resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage""); // An Azure Storage resource is required to add any of the following: // // - Azure Blob storage resource. // - Azure Queue storage resource. // - Azure Table storage resource. // After adding all resources, run the app... ``` When you add an AzureStorageResource to the app host, it exposes other useful APIs to add Azure Blob, Queue, and Table storage resources. In other words, you must add an AzureStorageResource before adding any of the other storage resources. [!IMPORTANT] When you call Generated provisioning Bicep If you\'re new to Bicep, it\'s a domain-specific language for defining Azure resources. With .NET Aspire, you don\'t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Storage resource, the following Bicep is generated: The preceding Bicep is a module that provisions an Azure Storage account with the following defaults: kind: The kind of storage account. The default is StorageV2. sku: The SKU of the storage account. The default is Standard_GRS. properties: The properties of the storage account: accessTier: The access tier of the storage account. The default is Hot. allowSharedKeyAccess: A boolean value that indicates whether the storage account permits requests to be authorized with the account access key. The default is false. minimumTlsVersion: The minimum supported TLS version for the storage account. The default is TLS1_2. networkAcls: The network ACLs for the storage account. The default is { defaultAction: \'Allow\' }. In addition to the storage account, it also provisions a blob container. The following role assignments are added to the storage account to grant your application access. See the built-in Azure role-based access control (Azure RBAC) roles for more information: Role / ID Description Storage Blob Data Contributor ba92f5b4-2d11-453d-a403-e96b0029c9fe Read, write, and delete Azure Storage containers and blobs. Storage Table Data Contributor 0a9a7e1f-b9d0-4cc4-a60d-0319b160aaa3 Read, write, and delete Azure Storage tables and entities. Storage Queue Data Contributor 974c5e8b-45b9-4653-ba55-5f855dd0fb88 Read, write, and delete Azure Storage queues and queue messages. The generated Bicep is a starting point and can be customized to meet your specific requirements. Customize provisioning infrastructure All .NET Aspire Azure resources are subclasses of the :::code language=""csharp"" source=""../../snippets/azure/AppHost/Program.ConfigureStorageInfra.cs"" id=""configure""::: The preceding code: Chains a call to the The infra parameter is an instance of the The provisionable resources are retrieved by calling the The single The The A tag is added to the storage account with a key of ExampleKey and a value of Example value. There are many more configuration options available to customize the Azure Storage resource. For more information, see', '<2-hop>\n\nConnect to an existing Azure Storage account You might have an existing Azure Storage account that you want to connect to. Instead of representing a new Azure Storage resource, you can add a connection string to the app host. To add a connection to an existing Azure Storage account, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var blobs = builder.AddConnectionString(""blobs""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE connection-strings-alert] The connection string is configured in the app host\'s configuration, typically under User Secrets, under the ConnectionStrings section. The app host injects this connection string as an environment variable into all dependent resources, for example: json { ""ConnectionStrings"": { ""blobs"": ""https://{account_name}.blob.core.windows.net/"" } } The dependent resource can access the injected connection string by calling the', '<3-hop>\n\nAdd Azure Storage emulator resource To add an Azure Storage emulator resource, chain a call on an IResourceBuilder<AzureStorageResource> to the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"") .RunAsEmulator(); // After adding all resources, run the app... ``` When you call RunAsEmulator, it configures your storage resources to run locally using an emulator. The emulator in this case is Azurite. The Azurite open-source emulator provides a free local environment for testing your Azure Blob, Queue Storage, and Table Storage apps and it\'s a perfect companion to the .NET Aspire Azure hosting integration. Azurite isn\'t installed, instead, it\'s accessible to .NET Aspire as a container. When you add a container to the app host, as shown in the preceding example with the mcr.microsoft.com/azure-storage/azurite image, it creates and starts the container when the app host starts. For more information, see Container resource lifecycle. Configure Azurite container There are various configurations available to container resources, for example, you can configure the container\'s ports, environment variables, it\'s lifetime, and more. Configure Azurite container ports By default, the Azurite container when configured by .NET Aspire, exposes the following endpoints: Endpoint Container port Host port blob 10000 dynamic queue 10001 dynamic table 10002 dynamic The port that they\'re listening on is dynamic by default. When the container starts, the ports are mapped to a random port on the host machine. To configure the endpoint ports, chain calls on the container resource builder provided by the RunAsEmulator method as shown in the following example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithBlobPort(""blob"", 27000) .WithQueuePort(""queue"", 27001) .WithTablePort(""table"", 27002); }); // After adding all resources, run the app... ``` The preceding code configures the Azurite container\'s existing blob, queue, and table endpoints to listen on ports 27000, 27001, and 27002, respectively. The Azurite container\'s ports are mapped to the host ports as shown in the following table: Endpoint name Port mapping ( container:host ) blob 10000:27000 queue 10001:27001 table 10002:27002 Configure Azurite container with persistent lifetime To configure the Azurite container with a persistent lifetime, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithLifetime(ContainerLifetime.Persistent); }); // After adding all resources, run the app... ``` For more information, see Container resource lifetime. Configure Azurite container with data volume To add a data volume to the Azure Storage emulator resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithDataVolume(); }); // After adding all resources, run the app... ``` The data volume is used to persist the Azurite data outside the lifecycle of its container. The data volume is mounted at the /data path in the Azurite container and when a name parameter isn\'t provided, the name is formatted as .azurite/{resource name}. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Configure Azurite container with data bind mount To add a data bind mount to the Azure Storage emulator resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithDataBindMount(""../Azurite/Data""); }); // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Azurite data across container restarts. The data bind mount is mounted at the ../Azurite/Data path on the host machine relative to the app host directory ( Connect to storage resources When the .NET Aspire app host runs, the storage resources can be accessed by external tools, such as the Azure Storage Explorer. If your storage resource is running locally using Azurite, it will automatically be picked up by the Azure Storage Explorer. [!NOTE] The Azure Storage Explorer discovers Azurite storage resources assuming the default ports are used. If you\'ve configured the Azurite container to use different ports, you\'ll need to configure the Azure Storage Explorer to connect to the correct ports. To connect to the storage resource from Azure Storage Explorer, follow these steps: Run the .NET Aspire app host. Open the Azure Storage Explorer. View the Explorer pane. Select the Refresh all link to refresh the list of storage accounts. Expand the Emulator & Attached node. Expand the Storage Accounts node. You should see a storage account with your resource\'s name as a prefix: :::image type=""content"" source=""../media/azure-storage-explorer.png"" lightbox=""../media/azure-storage-explorer.png"" alt-text=""Azure Storage Explorer: Azurite storage resource discovered.""::: You\'re free to explore the storage account and its contents using the Azure Storage Explorer. For more information on using the Azure Storage Explorer, see Get started with Storage Explorer.', '<4-hop>\n\ntitle: .NET Aspire Azure Queue Storage integration description: This article describes the .NET Aspire Azure Queue Storage integration features and capabilities. ms.date: 12/09/2024 uid: storage/azure-queue-storage-integration .NET Aspire Azure Queue Storage integration [!INCLUDE includes-hosting-and-client] Azure Queue Storage is a service for storing large numbers of messages that can be accessed from anywhere in the world via authenticated calls. The .NET Aspire Azure Queue Storage integration enables you to connect to existing Azure Queue Storage instances or create new instances from .NET applications. Hosting integration [!INCLUDE storage-app-host] Add Azure Queue Storage resource In your app host project, register the Azure Queue Storage integration by chaining a call to ```csharp var builder = DistributedApplication.CreateBuilder(args); var queues = builder.AddAzureStorage(""storage"") .AddQueues(""queues""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Adds an Azure Storage resource named storage. Adds a queue named queues to the storage resource. Adds the storage resource to the ExampleProject and waits for it to be ready before starting the project. [!INCLUDE storage-hosting-health-checks] Client integration To get started with the .NET Aspire Azure Queue Storage client integration, install the ðŸ“¦ Aspire.Azure.Storage.Queues NuGet package in the client-consuming project, that is, the project for the application that uses the Azure Queue Storage client. The Azure Queue Storage client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Azure.Storage.Queues PackageReference xml <PackageReference Include=""Aspire.Azure.Storage.Queues"" Version=""*"" /> Add Azure Queue Storage client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureQueueClient(""queue""); You can then retrieve the QueueServiceClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(QueueServiceClient client) { // Use client... } Configuration The .NET Aspire Azure Queue Storage integration provides multiple options to configure the QueueServiceClient based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddAzureQueueClient(""queue""); Then the connection string is retrieved from the ConnectionStrings configuration section, and two connection formats are supported: Service URI The recommended approach is to use a ServiceUri, which works with the json { ""ConnectionStrings"": { ""queue"": ""https://{account_name}.queue.core.windows.net/"" } } Connection string Alternatively, an Azure Storage connection string can be used. json { ""ConnectionStrings"": { ""queue"": ""AccountName=myaccount;AccountKey=myaccountkey"" } } For more information, see Configure Azure Storage connection strings. Use configuration providers The .NET Aspire Azure Queue Storage integration supports json { ""Aspire"": { ""Azure"": { ""Storage"": { ""Queues"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Diagnostics"": { ""ApplicationId"": ""myapp"" } } } } } } } For the complete Azure Storage Queues client integration JSON schema, see Aspire.Azure.Data.Queues/ConfigurationSchema.json. Use inline delegates You can also pass the Action<AzureStorageQueuesSettings> configureSettings delegate to set up some or all the options inline, for example to configure health checks: csharp builder.AddAzureQueueClient( ""queue"", settings => settings.DisableHealthChecks = true); You can also set up the csharp builder.AddAzureQueueClient( ""queue"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Diagnostics.ApplicationId = ""myapp"")); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Queue Storage integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', ""<5-hop>\n\nLogging The .NET Aspire Azure Queue Storage integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Queue Storage integration emits the following tracing activities using OpenTelemetry: Azure.Storage.Queues.QueueClient Metrics The .NET Aspire Azure Queue Storage integration currently doesn't support metrics by default due to limitations with the Azure SDK. See also Azure Queue Storage docs .NET Aspire integrations .NET Aspire GitHub repo"", '<6-hop>\n\ntitle: NET Aspire Dapr integration description: Learn how to use the .NET Aspire Dapr integration, which can configure and orchestrate Dapr from a .NET Aspire app host project. ms.date: 01/16/2025 uid: frameworks/dapr .NET Aspire Dapr integration Distributed Application Runtime (Dapr) offers developer APIs that serve as a conduit for interacting with other services and dependencies and abstract the application from the specifics of those services and dependencies. Dapr and .NET Aspire can work together to improve your local development experience. By using Dapr with .NET Aspire, you can focus on writing and implementing .NET-based distributed applications instead of local on-boarding. In this guide, you\'ll learn how to take advantage of Dapr\'s abstraction and .NET Aspire\'s opinionated configuration of cloud technologies to build simple, portable, resilient, and secured microservices at scale. Comparing .NET Aspire and Dapr At first sight Dapr and .NET Aspire may look like they have overlapping functionality, and they do. However, they take different approaches. .NET Aspire is opinionated on how to build distributed applications on a cloud platform and focuses on improving the local development experience. Dapr is a runtime that abstracts away the common complexities of the underlying cloud platform both during development and in production. It relies on sidecars to provide abstractions for things like configuration, secret management, and messaging. The underlying technology can be easily switched out through configuration files, while your code does not need to change. Aspect .NET Aspire Dapr Purpose Designed to make it easier to develop cloud-native solutions on local development computers. Designed to make it easier to develop and run distributed apps with common APIs that can be easily swapped. APIs Developers must call resource APIs using their specific SDKs Developers call APIs in the Dapr sidecar, which forwards the call to the correct API. It\'s easy to swap resource APIs without changing code in your microservices. Languages You write microservices in .NET languages, Go, Python, Javascript, and others. You can call Dapr sidecar functions in any language that supports HTTP/gRPC interfaces. Security policies Doesn\'t include security policies but can securely configure connections between inter-dependent resources. Includes customizable security policies that control which microservices have access to other services or resources. Deployment There are deployment tools for Azure and Kubernetes. Doesn\'t include deployment tools. Apps are usually deployed with Continuous Integration/Continuous Development (CI/CD) systems. Dashboard Provides a comprehensive view of the resources and their telemetry and supports listening on any OTEL supported resource. Limited to Dapr resources only. .NET Aspire makes setting up and debugging Dapr applications easier by providing a straightforward API to configure Dapr sidecars, and by exposing the sidecars as resources in the dashboard. Explore Dapr components with .NET Aspire Dapr provides many built-in components, and when you use Dapr with .NET Aspire you can easily explore and configure these components. Don\'t confuse these components with .NET Aspire integrations. For example, consider the following: Daprâ€”State stores: Call Daprâ€”Pub Sub: Call Daprâ€”Components: Call Install Dapr This integration requires Dapr version 1.13 or later. To install Dapr, see Install the Dapr CLI. After installing the Dapr CLI, run the dapr init, as described in Initialize Dapr in your local environment. [!IMPORTANT] If you attempt to run the .NET Aspire solution without the Dapr CLI, you\'ll receive the following error: plaintext Unable to locate the Dapr CLI. Hosting integration In your .NET Aspire solution, to integrate Dapr and access its types and APIs, add the ðŸ“¦ Aspire.Hosting.Dapr NuGet package in the app host project. .NET CLI dotnetcli dotnet add package Aspire.Hosting.Dapr PackageReference xml <PackageReference Include=""Aspire.Hosting.Dapr"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications.', '<7-hop>\n\nAdd Dapr sidecar to .NET Aspire resources Dapr uses the sidecar pattern. The Dapr sidecar runs alongside your app as a lightweight, portable, and stateless HTTP server that listens for incoming HTTP requests from your app. To add a sidecar to a .NET Aspire resource, call the :::code language=""csharp"" source=""snippets/Dapr/Dapr.AppHost/Program.cs"" range=""1-7"" highlight=""7""::: Configure Dapr sidecars The WithDaprSidecar method offers overloads to configure your Dapr sidecar options like AppId and various ports. In the following example, the Dapr sidecar is configured with specific ports for GRPC, HTTP, metrics, and a specific app ID. :::code language=""csharp"" source=""snippets/Dapr/Dapr.AppHost/Program.cs"" range=""9-20"" highlight=""1-7,12""::: Complete Dapr app host example Putting everything together, consider the following example of a .NET Aspire app host project that includes: A backend API service that declares a Dapr sidecar with defaults. A web frontend project that declares a Dapr sidecar with specific options, such as explict ports. :::code language=""csharp"" source=""snippets/Dapr/Dapr.AppHost/Program.cs""::: When you start the .NET Aspire solution, the dashboard shows the Dapr sidecar as a resource, with its status and logs. :::image type=""content"" source=""media/aspire-dashboard-dapr-sidecar-resources.png"" lightbox=""media/aspire-dashboard-dapr-sidecar-resources.png"" alt-text="".NET Aspire dashboard showing Dapr sidecar resources""::: Use Dapr sidecars in consuming .NET Aspire projects To use Dapr APIs from .NET Aspire resources, you can use the ðŸ“¦ Dapr.AspNetCore/ NuGet package. The Dapr SDK provides a set of APIs to interact with Dapr sidecars. [!NOTE] Use the Dapr.AspNetCore library for the Dapr integration with ASP.NET (DI integration, registration of subscriptions, etc.). Non-ASP.NET apps (such as console apps) can just use the ðŸ“¦ Dapr.Client to make calls through the Dapr sidecar. .NET CLI dotnetcli dotnet add package Dapr.AspNetCore PackageReference xml <PackageReference Include=""Dapr.AspNetCore"" Version=""*"" /> Add Dapr client Once installed into an ASP.NET Core project, the SDK can be added to the service builder. :::code language=""csharp"" source=""snippets/Dapr/Dapr.Web/Program.cs"" range=""15""::: Invoke Dapr methods An instance of DaprClient can now be injected into your services to interact with the Dapr sidecar through the Dapr SDK: :::code language=""csharp"" source=""snippets/Dapr/Dapr.Web/WeatherApiClient.cs"" highlight=""5,11-15""::: InvokeMethodAsync is the method that sends an HTTP request to the Dapr sidecar. It is a generic method that takes: An HTTP verb. The Dapr app ID of the service to call. The method name. A cancellation token. Depending on the HTTP verb, it can also take a request body and headers. The generic type parameter is the type of the response body. The full :::no-loc text=""Program.cs""::: file for the frontend project shows: The Dapr client being added to the service builder. The WeatherApiClient class that uses the Dapr client to call the backend service. :::code language=""csharp"" source=""snippets/Dapr/Dapr.Web/Program.cs"" highlight=""15,17""::: For example, in a Blazor project, you can inject the WeatherApiClient class into a razor page and use it to call the backend service: :::code language=""csharp"" source=""snippets/Dapr/Dapr.Web/Components/Pages/Weather.razor"" highlight=""5,47""::: When the Dapr SDK is used, the Dapr sidecar is called over HTTP. The Dapr sidecar then forwards the request to the target service. While the target service runs in a separate process from the sidecar, the integration related to the service runs in the Dapr sidecar and is responsible for service discovery and routing the request to the target service. Next steps Dapr Dapr documentation Dapr GitHub repo .NET Aspire Dapr sample app .NET Aspire integrations .NET Aspire GitHub repo']","To add an Azure Storage resource in a .NET Aspire application, you first need to call the method to create a builder for your distributed application. You can do this by using the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage""); // An Azure Storage resource is required to add any of the following: // - Azure Blob storage resource. // - Azure Queue storage resource. // - Azure Table storage resource. ``` After adding the Azure Storage resource, you can connect to an existing Azure Storage account by adding a connection string to the app host. This is done by calling: ```csharp var blobs = builder.AddConnectionString(""blobs""); ``` The connection string should be configured in the app host's configuration, typically under User Secrets, in the ConnectionStrings section. The app host will then inject this connection string as an environment variable into all dependent resources.",multi_hop_abstract_query_synthesizer
