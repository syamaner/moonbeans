,user_input,reference_contexts,reference,synthesizer_name
0,Howw doo yoo use .NET Aspiree to connect an ASP.NET Coree app to Azuree Servicee Bus forr messagingg?,"['title: Use .NET Aspire messaging integrations in ASP.NET Core description: Learn how to connect an ASP.NET Core app to messaging services using .NET Aspire integrations. ms.date: 08/12/2024 ms.topic: tutorial zone_pivot_groups: dev-environment Tutorial: Use .NET Aspire messaging integrations in ASP.NET Core Cloud-native apps often require scalable messaging solutions that provide capabilities such as messaging queues and topics and subscriptions. .NET Aspire integrations simplify the process of connecting to various messaging providers, such as Azure Service Bus. In this tutorial, you\'ll create an ASP.NET Core app that uses .NET Aspire integrations to connect to Azure Service Bus to create a notification system. Submitted messages will be sent to a Service Bus topic for consumption by subscribers. You\'ll learn how to: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire integrations Add an .NET Aspire integration to connect to Azure Service Bus Configure and use .NET Aspire integration features to send and receive data [!INCLUDE aspire-prereqs] In addition to the preceding prerequisites, you also need to install the Azure CLI. To install the Azure CLI, follow the instructions in the Azure CLI installation guide. Set up the Azure Service Bus account For this tutorial, you\'ll need access to an Azure Service Bus namespace with a topic and subscription configured. Use one of the following options to set up the require resources: Azure portal: Create a service bus account with a topic and subscription. Alternatively: Azure CLI: Run the following commands in the Azure CLI or CloudShell to set up the required Azure Service Bus resources: azurecli-interactive az group create -n <your-resource-group-name> --location eastus az servicebus namespace create -g <your-resource-group-name> --name <your-namespace-name> --location eastus az servicebus topic create -g <your-resource-group-name> --namespace-name <your-namespace-name> --name notifications az servicebus topic subscription create -g <your-resource-group-name> --namespace-name <your-namespace-name> --topic-name notifications --name mobile [!NOTE] Replace the your-resource-group-name and your-namespace-name placeholders with your own values. Service Bus namespace names must be globally unique across Azure. Azure authentication This quickstart can be completed using either passwordless authentication or a connection string. Passwordless connections use Azure Active Directory and role-based access control (RBAC) to connect to a Service Bus namespace. You don\'t need to worry about having hard-coded connection string in your code, a configuration file, or in secure storage such as Azure Key Vault. You can also use a connection string to connect to a Service Bus namespace, but the passwordless approach is recommended for real-world applications and production environments. For more information, read about Authentication and authorization or visit the passwordless overview page. Passwordless (Recommended) On your Service Bus namespace, assign the following role to the user account you logged into Visual Studio or the Azure CLI with: Service Bus Data Owner: Assign an Azure RBAC role Connection string Retrieve the connection string for your Service Bus namespace from the Shared access policies menu in the Azure portal. Keep it somewhere safe for use during the quickstart. :::image type=""content"" source=""../media/aspire-service-bus.png"" alt-text=""Screenshot of Aspire service bus connection string menu."":::']","To use .NET Aspire to connect an ASP.NET Core app to Azure Service Bus for messaging, you need to create a basic .NET app set up with .NET Aspire integrations. Then, add a .NET Aspire integration to connect to Azure Service Bus. Configure and use .NET Aspire integration features to send and receive data. This involves setting up an Azure Service Bus account with a namespace, topic, and subscription, and using either passwordless authentication or a connection string for connecting to the Service Bus namespace.",single_hop_specifc_query_synthesizer
1,How is the AspireSample.ApiService structured within the Aspire Starter Application solution?,"['Create the sample solution To create a new .NET Aspire Starter Application, you can use either Visual Studio, Visual Studio Code, or the .NET CLI. :::zone pivot=""visual-studio"" [!INCLUDE visual-studio-file-new] :::zone-end :::zone pivot=""vscode"" [!INCLUDE vscode-file-new] :::zone-end :::zone pivot=""dotnet-cli"" [!INCLUDE dotnet-cli-file-new] :::zone-end Add the Worker Service project Next, add a Worker Service project to the solution to retrieve and process messages to and from Azure Service Bus. :::zone pivot=""visual-studio"" In the solution explorer, right click on the top level AspireSample solution node and select Add > New project. Search for and select the Worker Service template and choose Next. For the Project name, enter AspireSample.WorkerService and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Make sure Enlist in .NET Aspire orchestration is checked and select Create. Visual Studio adds the project to your solution and updates the :::no-loc text=""Program.cs""::: file of the AspireSample.AppHost project with a new line of code: csharp builder.AddProject<Projects.AspireSample_WorkerService>( ""aspiresample-workerservice""); Visual Studio tooling added this line of code to register your new project with the :::zone-end :::zone pivot=""vscode"" From the Solution Explorer in Visual Studio Code, select the + button next to the solution name to add a new project to the solution: :::image type=""content"" source=""media/vscode-add-project.png"" lightbox=""media/vscode-add-project.png"" alt-text=""Visual Studio Code: Add new project from C# DevKit Solution Explorer.""::: To filter the project templates, enter Worker in the search box and select the Worker Service template that\'s found: :::image type=""content"" source=""media/vscode-create-worker.png"" lightbox=""media/vscode-create-worker.png"" alt-text=""Visual Studio Code: Filter to Worker Service project template from Add project.""::: Choose the Worker Service template and enter the project name as AspireSample.WorkerService. Select Default directory to create the project in the same directory as the solution. Select Create project to add the project to the solution. Right-click on the AspireSample.AppHost project in the Solution Explorer and select Add Project Reference: :::image type=""content"" source=""media/vscode-add-project-reference.png"" lightbox=""media/vscode-add-project-reference.png"" alt-text=""Visual Studio Code: Add project reference from AspireSample.AppHost to AspireSample.WorkerService.""::: Add the following line of code to the :::no-loc text=""Program.cs""::: file in the AspireSample.AppHost project before the call to builder.Build().Run();: csharp builder.AddProject<Projects.AspireSample_WorkerService>( ""aspiresample-workerservice""); :::zone-end :::zone pivot=""dotnet-cli"" In the root directory of the app, use the dotnet new command to create a new Worker Service app: dotnetcli dotnet new worker --name AspireSample.WorkerService Use the dotnet sln command to add the project to the solution: dotnetcli dotnet sln AspireSample.sln add AspireSample.WorkerService/AspireSample.WorkerService.csproj Use the dotnet add command to add a project reference between the .AppHost and .WorkerService project: dotnetcli dotnet add AspireSample.AppHost/AspireSample.AppHost.csproj reference AspireSample.WorkerService/AspireSample.WorkerService.csproj Add the following line of code to the :::no-loc text=""Program.cs""::: file in the AspireSample.AppHost project before the call to builder.Build().Run();: csharp builder.AddProject<Projects.AspireSample_WorkerService>( ""aspiresample-workerservice""); :::zone-end The completed solution structure should resemble the following, assuming the top-level directory is named aspire-messaging: Directory â””â”€â”€â”€ðŸ“‚ aspire-messaging â”œâ”€â”€â”€ðŸ“‚ AspireSample.WorkerService â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.WorkerService.csproj â”‚ â”œâ”€â”€â”€ Program.cs â”‚ â””â”€â”€â”€ Worker.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.ApiService â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.ApiService.csproj â”‚ â””â”€â”€â”€ Program.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.AppHost â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.AppHost.csproj â”‚ â””â”€â”€â”€ Program.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.ServiceDefaults â”‚ â”œâ”€â”€â”€ AspireSample.ServiceDefaults.csproj â”‚ â””â”€â”€â”€ Extensions.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.Web â”‚ â”œâ”€â”€â”€ðŸ“‚ Components â”‚ â”‚ â”œâ”€â”€â”€ðŸ“‚ Layout â”‚ â”‚ â”‚ â”œâ”€â”€â”€ MainLayout.razor â”‚ â”‚ â”‚ â”œâ”€â”€â”€ MainLayout.razor.css â”‚ â”‚ â”‚ â”œâ”€â”€â”€ NavMenu.razor â”‚ â”‚ â”‚ â””â”€â”€â”€ NavMenu.razor.css â”‚ â”‚ â”œâ”€â”€â”€ðŸ“‚ Pages â”‚ â”‚ â”‚ â”œâ”€â”€â”€ Counter.razor â”‚ â”‚ â”‚ â”œâ”€â”€â”€ Error.razor â”‚ â”‚ â”‚ â”œâ”€â”€â”€ Home.razor â”‚ â”‚ â”‚ â””â”€â”€â”€ Weather.razor â”‚ â”‚ â”œâ”€â”€â”€ _Imports.razor â”‚ â”‚ â”œâ”€â”€â”€ App.razor â”‚ â”‚ â””â”€â”€â”€ Routes.razor â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ðŸ“‚ wwwroot â”‚ â”‚ â”œâ”€â”€â”€ðŸ“‚ bootstrap â”‚ â”‚ â”‚ â”œâ”€â”€â”€ bootstrap.min.css â”‚ â”‚ â”‚ â””â”€â”€â”€ bootstrap.min.css.map â”‚ â”‚ â”œâ”€â”€â”€ app.css â”‚ â”‚ â””â”€â”€â”€ favicon.png â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.Web.csproj â”‚ â”œâ”€â”€â”€ Program.cs â”‚ â””â”€â”€â”€ WeatherApiClient.cs â””â”€â”€â”€ AspireSample.sln']","The AspireSample.ApiService is structured within the Aspire Starter Application solution as a directory containing several files: Properties (with launchSettings.json), appsettings.Development.json, appsettings.json, AspireSample.ApiService.csproj, and Program.cs.",single_hop_specifc_query_synthesizer
2,how add visual studio nuget package?,"['Add the .NET Aspire integration to the API Add the .NET Aspire Azure Service Bus integration to your AspireSample.ApiService app: :::zone pivot=""visual-studio"" In the Solution Explorer, double-click the AspireSample.ApiService.csproj file to open its XML file. Add the following <PackageReference> item to the <ItemGroup> element: xml <ItemGroup> <PackageReference Include=""Aspire.Azure.Messaging.ServiceBus"" Version=""8.0.1"" /> </ItemGroup> :::zone-end :::zone pivot=""vscode"" In the Solution Explorer, right-click on the AspireSample.ApiService project and select Add NuGet Package: :::image type=""content"" source=""media/vscode-add-nuget-package.png"" lightbox=""media/vscode-add-nuget-package.png"" alt-text=""Visual Studio Code: Add NuGet package to AspireSample.ApiService project.""::: Enter Aspire.Azure.Messaging.ServiceBus in the search box and select the package from the list. Select the (latest) version to install the package. :::zone-end :::zone pivot=""dotnet-cli"" dotnetcli dotnet add package Aspire.Azure.Messaging.ServiceBus :::zone-end In the :::no-loc text=""Program.cs""::: file of the AspireSample.ApiService project, add a call to the AddAzureServiceBusClient extension methodâ€”replacing the existing call to AddServiceDefaults: csharp // Add service defaults & Aspire integrations. builder.AddServiceDefaults(); builder.AddAzureServiceBusClient(""serviceBusConnection""); For more information, see This method accomplishes the following tasks: Registers a Automatically enables corresponding health checks, logging, and telemetry for the respective services. In the :::no-loc text=""appsettings.json""::: file of the same project, add the corresponding connection information: Passwordless (Recommended) json { // Existing configuration is omitted for brevity. ""ConnectionStrings"": { ""serviceBusConnection"": ""{your_namespace}.servicebus.windows.net"" } } Connection String json { // Existing configuration is omitted for brevity. ""ConnectionStrings"": { ""serviceBusConnection"": ""Endpoint=sb://{your_namespace}.servicebus.windows.net/; SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey"" } } [!NOTE] Make sure to replace {your_namespace} in the service URIs with the name of your own Service Bus namespace. Create the API endpoint The API must provide an endpoint to receive data and publish it to the Service Bus topic and broadcast to subscribers. Add the following endpoint to the AspireSample.ApiService project to send a message to the Service Bus topic. Replace all of the contents of the :::no-loc text=""Program.cs""::: file with the following C# code: ```csharp using Azure.Messaging.ServiceBus; var builder = WebApplication.CreateBuilder(args); // Add service defaults & Aspire integrations. builder.AddServiceDefaults(); builder.AddAzureServiceBusClient(""serviceBusConnection""); // Add services to the container. builder.Services.AddProblemDetails(); var app = builder.Build(); // Configure the HTTP request pipeline. app.UseExceptionHandler(); app.MapPost(""/notify"", static async (ServiceBusClient client, string message) => { var sender = client.CreateSender(""notifications""); // Create a batch using ServiceBusMessageBatch messageBatch = await sender.CreateMessageBatchAsync(); if (messageBatch.TryAddMessage( new ServiceBusMessage($""Message {message}"")) is false) { // If it\'s too large for the batch. throw new Exception( $""The message {message} is too large to fit in the batch.""); } // Use the producer client to send the batch of // messages to the Service Bus topic. await sender.SendMessagesAsync(messageBatch); Console.WriteLine($""A message has been published to the topic.""); }); app.MapDefaultEndpoints(); app.Run(); ``` Add the .NET Aspire integration to the Worker Service Add the .NET Aspire Azure Service Bus integration to your AspireSample.WorkerService project. Follow the same steps as you did before when you added the Aspire.Azure.Messaging.ServiceBus NuGet package to the AspireSample.ApiService project. Once it\'s been added, you can configure the worker service to process messages from the Service Bus topic. In the :::no-loc text=""Program.cs""::: file of the AspireSample.WorkerService project, repace the existing code with the following: ```csharp using AspireSample.WorkerService; var builder = Host.CreateApplicationBuilder(args); builder.AddAzureServiceBusClient(""serviceBusConnection""); builder.Services.AddHostedService var host = builder.Build(); host.Run(); ``` The AddAzureServiceBusClient method accomplishes the following tasks: Registers a Automatically enables corresponding health checks, logging, and telemetry for the respective services. In the :::no-loc text=""appsettings.json""::: file of the AspireSample.WorkerService project, add the corresponding connection information: Passwordless (Recommended) json { // Existing configuration is omitted for brevity. ""ConnectionStrings"": { ""serviceBusConnection"": ""{your_namespace}.servicebus.windows.net"" } } Connection String json { // Existing configuration is omitted for brevity. ""ConnectionStrings"": { ""serviceBusConnection"": ""Endpoint=sb://{your_namespace}.servicebus.windows.net/; SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey"" } } [!NOTE] Make sure to replace {your_namespace} in the Service URIs with the name of your own Service Bus namespace. Process the message from the subscriber When a new message is placed on the messages queue, the worker service should retrieve, process, and delete the message. Update the :::no-loc text=""Worker.cs""::: class to match the following code: ```csharp using Azure.Messaging.ServiceBus; namespace AspireSample.WorkerService; public sealed class Worker( ILogger // Add handler to process messages processor.ProcessMessageAsync += MessageHandler; // Add handler to process any errors processor.ProcessErrorAsync += ErrorHandler; // Start processing await processor.StartProcessingAsync(); logger.LogInformation("""""" Wait for a minute and then press any key to end the processing """"""); Console.ReadKey(); // Stop processing logger.LogInformation("""""" Stopping the receiver... """"""); await processor.StopProcessingAsync(); logger.LogInformation(""Stopped receiving messages""); } } async Task MessageHandler(ProcessMessageEventArgs args) { string body = args.Message.Body.ToString(); logger.LogInformation(""Received: {Body} from subscription."", body); // Complete the message. messages is deleted from the subscription. await args.CompleteMessageAsync(args.Message); } // Handle any errors when receiving messages Task ErrorHandler(ProcessErrorEventArgs args) { logger.LogError(args.Exception, ""{Error}"", args.Exception.Message); return Task.CompletedTask; } } ``` Run and test the app locally The sample app is now ready for testing. Verify that the data submitted to the API is sent to the Azure Service Bus topic and consumed by the subscriber worker service: :::zone pivot=""visual-studio"" Launch the .NET Aspire project by selecting the Start debugging button, or by pressing F5. The .NET Aspire dashboard app should open in the browser. :::zone-end :::zone pivot=""vscode"" Launch the .NET Aspire project by selecting the Start debugging button, or by pressing F5. The .NET Aspire dashboard app should open in the browser. :::zone-end :::zone pivot=""dotnet-cli"" Launch the .NET Aspire project by running dotnet run --project AspireSample.AppHost. The .NET Aspire dashboard app should open in the browser. :::zone-end On the resources page, in the apiservice row, find the link in the Endpoints that opens the weatherforecast endpoint. Note the HTTPS port number. On the .NET Aspire dashboard, navigate to the logs for the aspiresample-workerservice project. In a terminal window, use the curl command to send a test message to the API: bash curl -X POST -H ""Content-Type: application/json"" https://localhost:{port}/notify?message=hello%20aspire Be sure to replace {port} with the port number from earlier. 5. Switch back to the aspiresample-workerservice logs. You should see the test message printed in the output logs. Congratulations! You created and configured an ASP.NET Core API that connects to Azure Service Bus using Aspire integrations. [!INCLUDE clean-up-resources]']","In Visual Studio, to add a NuGet package to the AspireSample.ApiService project, you need to double-click the AspireSample.ApiService.csproj file in the Solution Explorer to open its XML file and add the <PackageReference> item to the <ItemGroup> element.",single_hop_specifc_query_synthesizer
3,How do code changes impact compatibility in .NET?,['title: Compatibility description: Learn about the ways in which code changes can affect compatibility in .NET. ms.date: 10/24/2024 ms.topic: conceptual How code changes can affect compatibility Compatibility refers to the ability to compile or execute code on a version of a .NET implementation other than the one with which the code was originally developed. A particular change can affect compatibility in six different ways: Behavioral change Binary compatibility Source compatibility'],"Code changes can affect compatibility in .NET in six different ways, including behavioral change, binary compatibility, and source compatibility.",single_hop_specifc_query_synthesizer
4,How does Visual Studio ensure design-time compatibility across different versions?,"[""Design-time compatibility Backwards compatibility Forward compatibility (not a goal of .NET Aspire) Behavioral change A behavioral change represents a change to the behavior of a member. The change may be externally visible (for example, a method may throw a different exception), or it may represent a changed implementation (for example, a change in the way a return value is calculated, the addition or removal of internal method calls, or even a significant performance improvement). When behavioral changes are externally visible and modify a type's public contract, they are easy to evaluate since they affect binary compatibility. Implementation changes are much more difficult to evaluate; depending on the nature of the change and the frequency and patterns of use of the API, the impact of a change can range from severe to innocuous. Binary compatibility Binary compatibility refers to the ability of a consumer of an API to use the API on a newer version without recompilation. Changes such as adding methods or adding a new interface implementation to a type do not affect binary compatibility. However, removing or altering an assembly's public signatures so that consumers can no longer access the same interface exposed by the assembly does affect binary compatibility. A change of this kind is termed a binary incompatible change. Source compatibility Source compatibility refers to the ability of existing consumers of an API to recompile against a newer version without any source changes. A source incompatible change occurs when a consumer needs to modify source code for it to build successfully against a newer version of an API. Design-time compatibility Design-time compatibility refers to preserving the design-time experience across versions of Visual Studio and other design-time environments. While this can involve the behavior or the UI of designers, the most important aspect of design-time compatibility concerns project compatibility. A project or solution must be able to be opened and used on a newer version of the design-time environment. Backwards compatibility Backwards compatibility refers to the ability of an existing consumer of an API to run against a new version while behaving in the same way. Both behavioral changes and changes in binary compatibility affect backwards compatibility. If a consumer is not able to run or behaves differently when running against the newer version of the API, the API is backwards incompatible. Changes that affect backwards compatibility are discouraged, since developers expect backwards compatibility in newer versions of an API. Forward compatibility Forward compatibility refers to the ability of an existing consumer of an API to run against an older version while exhibiting the same behavior. If a consumer is not able to run or behaves differently when run against an older version of the API, the API is forward incompatible. Maintaining forward compatibility virtually precludes any changes or additions from version to version, since those changes prevent a consumer that targets a later version from running under an earlier version. Developers expect that a consumer that relies on a newer API may not function correctly against the older API. Maintaining forward compatibility is not a goal of .NET Aspire.""]","Design-time compatibility in Visual Studio involves preserving the design-time experience across versions, which includes the behavior or UI of designers. The most important aspect is project compatibility, ensuring that a project or solution can be opened and used on a newer version of the design-time environment.",single_hop_specifc_query_synthesizer
5,How are HTTP endpoints utilized in .NET Aspire health checks to monitor application health?,"['title: .NET Aspire health checks description: Explore .NET Aspire health checks ms.date: 09/24/2024 ms.topic: quickstart uid: dotnet/aspire/health-checks Health checks in .NET Aspire Health checks provide availability and state information about an app. Health checks are often exposed as HTTP endpoints, but can also be used internally by the app to write logs or perform other tasks based on the current health. Health checks are typically used in combination with an external monitoring service or container orchestrator to check the status of an app. The data reported by health checks can be used for various scenarios: Influence decisions made by container orchestrators, load balancers, API gateways, and other management services. For instance, if the health check for a containerized app fails, it might be skipped by a load balancer routing traffic. Verify that underlying dependencies are available, such as a database or cache, and return an appropriate status message. Trigger alerts or notifications when an app isn\'t responding as expected. .NET Aspire health check endpoints .NET Aspire exposes two default health check HTTP endpoints in Development environments when the AddServiceDefaults and MapDefaultEndpoints methods are called from the :::no-loc text=""Program.cs""::: file: The /health endpoint indicates if the app is running normally where it\'s ready to receive requests. All health checks must pass for app to be considered ready to accept traffic after starting. http GET /health The /health endpoint returns an HTTP status code 200 and a text/plain value of The /alive indicates if an app is running or has crashed and must be restarted. Only health checks tagged with the live tag must pass for app to be considered alive. http GET /alive The /alive endpoint returns an HTTP status code 200 and a text/plain value of The AddServiceDefaults and MapDefaultEndpoints methods also apply various configurations to your app beyond just health checks, such as OpenTelemetry and service discovery configurations. Non-development environments In non-development environments, the /health and /alive endpoints are disabled by default. If you need to enable them, its recommended to protect these endpoints with various routing features, such as host filtering and/or authorization. For more information, see Health checks in ASP.NET Core. Additionally, it may be advantageous to configure request timeouts and output caching for these endpoints to prevent abuse or denial-of-service attacks. To do so, consider the following modified AddDefaultHealthChecks method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""healthchecks""::: The preceding code: Adds a timeout of 5 seconds to the health check requests with a policy named HealthChecks. Adds a 10-second cache to the health check responses with a policy named HealthChecks. Now consider the updated MapDefaultEndpoints method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""mapendpoints""::: The preceding code: Groups the health check endpoints under the / path. Caches the output and specifies a request time with the corresponding HealthChecks policy. In addition to the updated AddDefaultHealthChecks and MapDefaultEndpoints methods, you must also add the corresponding services for both request timeouts and output caching. In the appropriate consuming app\'s entry point (usually the :::no-loc text=""Program.cs""::: file), add the following code: ```csharp // Wherever your services are being registered. // Before the call to Build(). builder.Services.AddRequestTimeouts(); builder.Services.AddOutputCache(); var app = builder.Build(); // Wherever your app has been built, before the call to Run(). app.UseRequestTimeouts(); app.UseOutputCache(); app.Run(); ``` For more information, see Request timeouts middleware in ASP.NET Core and Output caching middleware in ASP.NET Core.']","In .NET Aspire, health checks are often exposed as HTTP endpoints to provide availability and state information about an app. The /health endpoint indicates if the app is running normally and ready to receive requests, while the /alive endpoint indicates if an app is running or has crashed and must be restarted. These endpoints return an HTTP status code 200 when the app is in a healthy state.",single_hop_specifc_query_synthesizer
6,Wht is C# used for in .NET Aspire integrations?,"['Integration health checks .NET Aspire integrations can also register additional health checks for your app. These health checks contribute to the returned status of the /health and /alive endpoints. For example, the .NET Aspire PostgreSQL integration automatically adds a health check to verify the following conditions: A database connection could be established A database query could be executed successfully If either of these operations fail, the corresponding health check also fails. Configure health checks You can disable health checks for a given integration using one of the available configuration options. .NET Aspire integrations support Microsoft.Extensions.Configurations to apply settings through config files such as :::no-loc text=""appsettings.json"":::: json { ""Aspire"": { ""Npgsql"": { ""DisableHealthChecks"": true, } } } You can also use an inline delegate to configure health checks: csharp builder.AddNpgsqlDbContext<MyDbContext>( ""postgresdb"", static settings => settings.DisableHealthChecks = true); See also .NET app health checks in C# Health checks in ASP.NET Core']","C# is used in .NET Aspire integrations to configure health checks, such as disabling them using an inline delegate.",single_hop_specifc_query_synthesizer
7,Wht are the benfits of using Visul Studio Code with .NET Aspire for cloud app devlopment?,"['title: .NET Aspire overview description: Learn about .NET Aspire, an application stack designed to improve the experience of building distributed applications. ms.date: 11/12/2024 .NET Aspire overview :::row::: :::column::: :::image type=""icon"" border=""false"" source=""../../assets/dotnet-aspire-logo-128.svg""::: :::column-end::: :::column span=""3""::: .NET Aspire is a set of tools, templates, and packages for building observable, production ready apps.\u200b\u200b .NET Aspire is delivered through a collection of NuGet packages that bootstrap or improve specific challenges with modern app development. Today\'s apps generally consume a large number of services, such as databases, messaging, and caching, many of which are supported via .NET Aspire Integrations. For information on support, see the .NET Aspire Support Policy. :::column-end::: :::row-end::: Why .NET Aspire? .NET Aspire improves the experience of building apps that have a variety of projects and resources. With dev-time productivity enhancements that emulate deployed scenarios, you can quickly develop interconnected apps. Designed for flexibility, .NET Aspire allows you to replace or extend parts with your preferred tools and workflows. Key features include: Dev-Time Orchestration: .NET Aspire provides features for running and connecting multi-project applications, container resources, and other dependencies for local development environments. Integrations: .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects.  .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects. Dev-time orchestration In .NET Aspire, ""orchestration"" primarily focuses on enhancing the local development experience by simplifying the management of your app\'s configuration and interconnections. It\'s important to note that .NET Aspire\'s orchestration isn\'t intended to replace the robust systems used in production environments, such as Kubernetes. Instead, it\'s a set of abstractions that streamline the setup of service discovery, environment variables, and container configurations, eliminating the need to deal with low-level implementation details. With .NET Aspire, your code has a consistent bootstrapping experience on any dev machine without the need for complex manual steps, making it easier to manage during the development phase. .NET Aspire orchestration assists with the following concerns: App composition: Specify the .NET projects, containers, executables, and cloud resources that make up the application. Service discovery and connection string management: The app host injects the right connection strings, network configurations, and service discovery information to simplify the developer experience. For example, using .NET Aspire, the following code creates a local Redis container resource, waits for it to become available, and then configures the appropriate connection string in the ""frontend"" project with a few helper method calls: ```csharp // Create a distributed application builder given the command line arguments. var builder = DistributedApplication.CreateBuilder(args); // Add a Redis server to the application. var cache = builder.AddRedis(""cache""); // Add the frontend project to the application and configure it to use the // Redis server, defined as a referenced dependency. builder.AddProject For more information, see .NET Aspire orchestration overview. [!IMPORTANT] The call to .NET Aspire integrations .NET Aspire integrations are NuGet packages designed to simplify connections to popular services and platforms, such as Redis or PostgreSQL. .NET Aspire integrations handle cloud resource setup and interaction for you through standardized patterns, such as adding health checks and telemetry. Integrations are two-fold - ""hosting"" integrations represents the service you\'re connecting to, and ""client"" integrations represents the client or consumer of that service. In other words, for many hosting packages there\'s a corresponding client package that handles the service connection within your code. Each integration is designed to work with the .NET Aspire app host, and their configurations are injected automatically by referencing named resources. In other words, if Example.ServiceFoo references Example.ServiceBar, Example.ServiceFoo inherits the integration\'s required configurations to allow them to communicate with each other automatically. For example, consider the following code using the .NET Aspire Service Bus integration: csharp builder.AddAzureServiceBusClient(""servicebus""); The Registers a Applies Enables corresponding health checks, logging, and telemetry specific to the Azure Service Bus usage. A full list of available integrations is detailed on the .NET Aspire integrations overview page.']","Visual Studio Code, when used with .NET Aspire, provides project templates and tooling experiences that help developers create and interact with .NET Aspire projects. This enhances the development of distributed applications by offering dev-time productivity enhancements and orchestration features that simplify the management of app configurations and interconnections.",single_hop_specifc_query_synthesizer
8,what .NET CLI do for .NET Aspire projects?,"['Project templates and tooling .NET Aspire provides a set of project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI. These templates are designed to help you create and interact with .NET Aspire projects, or add .NET Aspire into your existing codebase. The templates include a set of opinionated defaults to help you get started quickly - for example, it has boilerplate code for turning on health checks and logging in .NET apps. These defaults are fully customizable, so you can edit and adapt them to suit your needs. .NET Aspire templates also include boilerplate extension methods that handle common service configurations for you: csharp builder.AddServiceDefaults(); For more information on what AddServiceDefaults does, see .NET Aspire service defaults. When added to your :::no-loc text=""Program.cs""::: file, the preceding code handles the following concerns: OpenTelemetry: Sets up formatted logging, runtime metrics, built-in meters, and tracing for ASP.NET Core, gRPC, and HTTP. For more information, see .NET Aspire telemetry. Default health checks: Adds default health check endpoints that tools can query to monitor your app. For more information, see .NET app health checks in C#. Service discovery: Enables service discovery for the app and configures Next steps [!div class=""nextstepaction""] Quickstart: Build your first .NET Aspire project']",".NET CLI provides a set of project templates and tooling experiences for .NET Aspire, helping you create and interact with .NET Aspire projects or add .NET Aspire into your existing codebase. These templates include opinionated defaults like boilerplate code for health checks and logging, which are customizable.",single_hop_specifc_query_synthesizer
9,What is the role of Redis in the .NET Aspire application?,"['title: Custom resource commands in .NET Aspire description: Learn how to create custom resource commands in .NET Aspire. ms.date: 11/07/2024 ms.topic: how-to Custom resource commands in .NET Aspire Each resource in the .NET Aspire app model is represented as an [!IMPORTANT] These .NET Aspire dashboard commands are only available when running the dashboard locally. They\'re not available when running the dashboard in Azure Container Apps. Add custom commands to a resource Start by creating a new .NET Aspire Starter App from the available templates. To create the solution from this template, follow the Quickstart: Build your first .NET Aspire solution. After creating this solution, add a new class named RedisResourceBuilderExtensions.cs to the app host project. Replace the contents of the file with the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/RedisResourceBuilderExtensions.cs""::: The preceding code: Shares the Is a static class so that it can contain extension methods. It defines a single extension method named WithClearCommand, extending the IResourceBuilder<RedisResource> interface. The WithClearCommand method registers a command named clear-cache that clears the cache of the Redis resource. The WithClearCommand method returns the IResourceBuilder<RedisResource> instance to allow chaining. The WithCommand API adds the appropriate annotations to the resource, which are consumed in the .NET Aspire dashboard. The dashboard uses these annotations to render the command in the UI. Before getting too far into those details, let\'s ensure that you first understand the parameters of the WithCommand method: name: The name of the command to invoke. displayName: The name of the command to display in the dashboard. executeCommand: The Func<ExecuteCommandContext, Task<ExecuteCommandResult>> to run when the command is invoked, which is where the command logic is implemented. updateState: The Func<UpdateCommandStateContext, ResourceCommandState> callback is invoked to determine the ""enabled"" state of the command, which is used to enable or disable the command in the dashboard. iconName: The name of the icon to display in the dashboard. The icon is optional, but when you do provide it, it should be a valid Fluent UI Blazor icon name. iconVariant: The variant of the icon to display in the dashboard, valid options are Regular (default) or Filled. Execute command logic The executeCommand delegate is where the command logic is implemented. This parameter is defined as a Func<ExecuteCommandContext, Task<ExecuteCommandResult>>. The ExecuteCommandContext provides the following properties: ExecuteCommandContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. ExecuteCommandContext.ResourceName: The name of the resource instance that the command is being executed on. ExecuteCommandContext.CancellationToken: The In the preceding example, the executeCommand delegate is implemented as an async method that clears the cache of the Redis resource. It delegates out to a private class-scoped function named OnRunClearCacheCommandAsync to perform the actual cache clearing. Consider the following code: ```csharp private static async Task await using var connection = ConnectionMultiplexer.Connect(connectionString); var database = connection.GetDatabase(); await database.ExecuteAsync(""FLUSHALL""); return CommandResults.Success(); } ``` The preceding code: Retrieves the connection string from the Redis resource. Connects to the Redis instance. Gets the database instance. Executes the FLUSHALL command to clear the cache. Returns a CommandResults.Success() instance to indicate that the command was successful. Update command state logic The updateState delegate is where the command state is determined. This parameter is defined as a Func<UpdateCommandStateContext, ResourceCommandState>. The UpdateCommandStateContext provides the following properties: UpdateCommandStateContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. UpdateCommandStateContext.ResourceSnapshot: The snapshot of the resource instance that the command is being executed on. The immutable snapshot is an instance of CustomResourceSnapshot, which exposes all sorts of valuable details about the resource instance. Consider the following code: ```csharp private static ResourceCommandState OnUpdateResourceState( UpdateCommandStateContext context) { var logger = context.ServiceProvider.GetRequiredService if (logger.IsEnabled(LogLevel.Information)) { logger.LogInformation( ""Updating resource state: {ResourceSnapshot}"", context.ResourceSnapshot); } return context.ResourceSnapshot.HealthStatus is HealthStatus.Healthy ? ResourceCommandState.Enabled : ResourceCommandState.Disabled; } ``` The preceding code: Retrieves the logger instance from the service provider. Logs the resource snapshot details. Returns ResourceCommandState.Enabled if the resource is healthy; otherwise, it returns ResourceCommandState.Disabled.']","In the .NET Aspire application, Redis is used as a resource where a custom command named clear-cache can be registered to clear the cache of the Redis resource. This is implemented using an extension method WithClearCommand, which is part of the RedisResourceBuilderExtensions class.",single_hop_specifc_query_synthesizer
10,Wut iz the purpuse of updating the Program.cs file in the context of testing a custom command?,"['Test the custom command To test the custom command, update your app host project\'s Program.cs file to include the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/Program.cs"" highlight=""4""::: The preceding code calls the WithClearCommand extension method to add the custom command to the Redis resource. Run the app and navigate to the .NET Aspire dashboard. You should see the custom command listed under the Redis resource. On the Resources page of the dashboard, select the ellipsis button under the Actions column: :::image source=""media/custom-clear-cache-command.png"" lightbox=""media/custom-clear-cache-command.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command displayed.""::: The preceding image shows the Clear cache command that was added to the Redis resource. The icon displays as a rabbit crosses out to indicate that the speed of the dependant resource is being cleared. Select the Clear cache command to clear the cache of the Redis resource. The command should execute successfully, and the cache should be cleared: :::image source=""media/custom-clear-cache-command-succeeded.png"" lightbox=""media/custom-clear-cache-command-succeeded.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command executed.""::: See also .NET Aspire orchestration overview .NET Aspire dashboard: Resource submenu actions']","To test the custom command, the Program.cs file is updated to include code that calls the WithClearCommand extension method, which adds the custom command to the Redis resource. This allows the custom command to be listed and executed from the .NET Aspire dashboard, clearing the cache of the Redis resource.",single_hop_specifc_query_synthesizer
11,How can Stack Exchange Redis caching be utilized in cloud applications with .NET Aspire?,"['title: Stack Exchange Redis caching overview description: Learn about Stack Exchange Redis caching and how to use it in your applications. ms.date: 11/05/2024 Stack Exchange RedisÂ®* caching overview With .NET Aspire, there are several ways to use caching in your applications. One popular option is to use Stack Exchange Redis, which is a high-performance data store that can be used to store frequently accessed data. This article provides an overview of Stack Exchange Redis caching and links to resources that help you use it in your applications. To use multiple Redis caching integrations in your application, see Tutorial: Implement caching with .NET Aspire integrations. If you\'re interested in using the Redis Cache for Azure, see Tutorial: Deploy a .NET Aspire project with a Redis Cache to Azure. Redis serialization protocol (RESP) The Redis serialization protocol (RESP) is a binary-safe protocol that Redis uses to communicate with clients. RESP is a simple, text-based protocol that is easy to implement and efficient to parse. RESP is used to send commands to Redis and receive responses from Redis. RESP is designed to be fast and efficient, making it well-suited for use in high-performance applications. For more information, see Redis serialization protocol specification. In addition to Redis itself, there are two well-maintained implementations of RESP for .NET: Garnet: Garnet is a remote cache-store from Microsoft Research that offers strong performance (throughput and latency), scalability, storage, recovery, cluster sharding, key migration, and replication features. Garnet can work with existing Redis clients. Valkey: A flexible distributed key-value datastore that supports both caching and beyond caching workloads. .NET Aspire lets you easily model either the Redis, Garnet, or Valkey RESP protocol in your applications and you can choose which one to use based on your requirements. All of the .NET Aspire Redis integrations can be used with either the Redis, Garnet, or Valkey RESP protocol. Caching Caching is a technique used to store frequently accessed data in memory. This helps to reduce the time it takes to retrieve the data from the original source, such as a database or a web service. Caching can significantly improve the performance of an application by reducing the number of requests made to the original source. To access the Redis IConnectionMultiplexer object, you use the Aspire.StackExchange.Redis NuGet package: [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis integration [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis integration (Garnet) [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis integration (Valkey) Distributed caching Distributed caching is a type of caching that stores data across multiple servers. This allows the data to be shared between multiple instances of an application, which can help to improve scalability and performance. Distributed caching can be used to store a wide variety of data, such as session state, user profiles, and frequently accessed data. To use Redis distributed caching in your application (the IDistributedCache interface), use the Aspire.StackExchange.Redis.DistributedCaching NuGet package: [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis distributed caching integration [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis distributed caching integration (Garnet) [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis distributed caching integration (Valkey)']","Stack Exchange Redis caching can be utilized in cloud applications with .NET Aspire by using it as a high-performance data store to store frequently accessed data. This can be achieved through various integrations such as Redis, Garnet, or Valkey RESP protocols. These integrations can be implemented using the Aspire.StackExchange.Redis NuGet package for caching and the Aspire.StackExchange.Redis.DistributedCaching NuGet package for distributed caching. This setup helps in improving application performance by reducing data retrieval time and enhancing scalability through distributed caching.",single_hop_specifc_query_synthesizer
12,How can .NET Aspire be used for output caching in web applications?,"['Output caching Output caching is a type of caching that stores the output of a web page or API response. This allows the response to be served directly from the cache, rather than generating it from scratch each time. Output caching can help to improve the performance of a web application by reducing the time it takes to generate a response. To use declarative Redis output caching with either the OutputCache attribute or the CacheOutput method in your application, use the Aspire.StackExchange.Redis.OutputCaching NuGet package: [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis output caching integration [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis output caching integration (Garnet) [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis output caching integration (Valkey) See also Caching in .NET Overview of Caching in ASP.NET Core Distributed caching in .NET Distributed caching in ASP.NET Core Output caching middleware in ASP.NET Core [!INCLUDE redis-trademark]']","To use declarative Redis output caching with either the OutputCache attribute or the CacheOutput method in your application, use the Aspire.StackExchange.Redis.OutputCaching NuGet package.",single_hop_specifc_query_synthesizer
13,how do you add .NET Aspire to a existing .NET app with microservices?,"['title: Add .NET Aspire to an existing .NET app description: Learn how to add .NET Aspire integrations, orchestration, and tooling to a microservices app that already exists. ms.date: 11/08/2024 ms.topic: how-to zone_pivot_groups: dev-environment Tutorial: Add .NET Aspire to an existing .NET app If you have existing microservices and .NET web app, you can add .NET Aspire to it and get all the included features and benefits. In this article, you add .NET Aspire orchestration to a simple, preexisting .NET 9 project. You learn how to: [!div class=""checklist""] Understand the structure of the existing microservices app. Enroll existing projects in .NET Aspire orchestration. Understand the changes enrollment makes in the projects. Start the .NET Aspire project. [!INCLUDE aspire-prereqs] Get started Let\'s start by obtaining the code for the solution: Open a command prompt and change directories to where you want to store the code. To clone to .NET 9 example solution, use the following git clone command: bash git clone https://github.com/MicrosoftDocs/mslearn-dotnet-cloudnative-devops.git eShopLite']","To add .NET Aspire to an existing .NET app with microservices, you can integrate .NET Aspire orchestration and tooling into your preexisting .NET 9 project. This involves understanding the structure of the existing microservices app, enrolling existing projects in .NET Aspire orchestration, and understanding the changes that enrollment makes in the projects. You can start by cloning the .NET 9 example solution using the provided git clone command.",single_hop_specifc_query_synthesizer
14,How can Visual Studio be used to debug a .NET 9 solution with multiple startup projects?,"['Explore the sample app This article uses a .NET 9 solution with three projects: Data Entities: This project is an example class library. It defines the Product class used in the Web App and Web API. Products: This example Web API returns a list of products in the catalog and their properties. Store: This example Blazor Web App displays the product catalog to website visitors. Open and start debugging the project to examine its default behavior: :::zone pivot=""visual-studio"" Start Visual Studio and then select File > Open > Project/Solution. Navigate to the top level folder of the solution you cloned, select eShopLite.sln, and then select Open. In the Solution Explorer, right-click the eShopLite solution, and then select Configure Startup Projects. Select Multiple startup projects. In the Action column, select Start for both the Products and Store projects. Select OK. To start debugging the solution, press F5 or select Start. Two pages open in the browser: A page displays products in JSON format from a call to the Products Web API. A page displays the homepage of the website. In the menu on the left, select Products to see the catalog obtained from the Web API. To stop debugging, close the browser. :::zone-end :::zone pivot=""vscode"" Start Visual Studio Code and open the folder that you cloned. From the terminal where you cloned the repo, run the following command: bash code . Select the Run and Debug menu item, or press Ctrl+Shift+D. Select the create a launch.json file link. :::image type=""content"" source=""media/vscode-launch.json.png"" lightbox=""media/vscode-launch.json.png"" alt-text=""Visual Studio Code: Run and Debug create launch.json file.""::: Copy and paste the following JSON into this file and Save: Unix json { ""version"": ""0.2.0"", ""compounds"": [ { ""name"": ""Run all"", ""configurations"": [ ""Run products"", ""Run store"", ] } ], ""configurations"": [ { ""name"": ""Run products"", ""type"": ""dotnet"", ""request"": ""launch"", ""projectPath"": ""${workspaceFolder}/Products/Products.csproj"" }, { ""name"": ""Run store"", ""type"": ""dotnet"", ""request"": ""launch"", ""projectPath"": ""${workspaceFolder}/Store/Store.csproj"" } ] } Windows json { ""version"": ""0.2.0"", ""compounds"": [ { ""name"": ""Run all"", ""configurations"": [ ""Run products"", ""Run store"", ] } ], ""configurations"": [ { ""name"": ""Run products"", ""type"": ""dotnet"", ""request"": ""launch"", ""projectPath"": ""${workspaceFolder}\\\\Products\\\\Products.csproj"" }, { ""name"": ""Run store"", ""type"": ""dotnet"", ""request"": ""launch"", ""projectPath"": ""${workspaceFolder}\\\\Store\\\\Store.csproj"" } ] } To start debugging the solution, press F5 or select Start. Two pages open in the browser: A page displays products in JSON format from a call to the Products Web API. A page displays the homepage of the website. In the menu on the left, select Products to see the catalog obtained from the Web API. To stop debugging, close the browser, and then select the Stop button twice (once for each running debug instance). :::zone-end :::zone pivot=""dotnet-cli"" Open a terminal window and change directories into the newly cloned repository. To start the Products app, run the following command: dotnetcli dotnet run --project ./Products/Products.csproj A browser page opens, displaying the JSON for the products. In a separate terminal window, again change directories to cloned repository. Start the Store app by running the following command: dotnetcli dotnet run --project ./Store/Store.csproj The browser opens a page that displays the homepage of the website. In the menu on the left, select Products to see the catalog obtained from the Web API. To stop debugging, close the browser, and press Ctrl+C in both terminals. :::zone-end']","To debug a .NET 9 solution with multiple startup projects using Visual Studio, start Visual Studio and select File > Open > Project/Solution. Navigate to the top-level folder of the solution you cloned, select eShopLite.sln, and then select Open. In the Solution Explorer, right-click the eShopLite solution, and then select Configure Startup Projects. Select Multiple startup projects. In the Action column, select Start for both the Products and Store projects. Select OK. To start debugging the solution, press F5 or select Start. Two pages open in the browser: one displays products in JSON format from a call to the Products Web API, and the other displays the homepage of the website. To stop debugging, close the browser.",single_hop_specifc_query_synthesizer
15,Could you elaborate on the role of eShopLite.ServiceDefaults within the .NET Aspire orchestration framework?,"['Add .NET Aspire to the Store web app Now, let\'s enroll the Store project, which implements the web user interface, in .NET Aspire orchestration: :::zone pivot=""visual-studio"" In Visual Studio, in the Solution Explorer, right-click the Store project, select Add, and then select .NET Aspire Orchestrator Support. In the Add .NET Aspire Orchestrator Support dialog, select OK. :::image type=""content"" loc-scope=""visual-studio"" source=""media/add-aspire-orchestrator-support.png"" alt-text=""Screenshot of the Add .NET Aspire Orchestrator Support dialog.""::: You should now have two new projects, both added to the solution: eShopLite.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator is set as the Startup project, and it depends on the eShopLite.Store project. eShopLite.ServiceDefaults: A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. In the eShopLite.AppHost project, open the :::no-loc text=""Program.cs""::: file. Notice this line of code, which registers the Store project in the .NET Aspire orchestration: csharp builder.AddProject<Projects.Store>(""store""); For more information, see To add the Products project to .NET Aspire: In Visual Studio, in the Solution Explorer, right-click the Products project, select Add, and then select .NET Aspire Orchestrator Support. A dialog indicating that .NET Aspire Orchestrator project already exists, select OK. :::image type=""content"" loc-scope=""visual-studio"" source=""media/orchestrator-already-added.png"" alt-text=""Screenshot indicating that the.NET Aspire Orchestrator was already added.""::: In the eShopLite.AppHost project, open the :::no-loc text=""Program.cs""::: file. Notice this line of code, which registers the Products project in the .NET Aspire orchestration: csharp builder.AddProject<Projects.Products>(""products""); Also notice that the eShopLite.AppHost project, now depends on both the Store and Products projects. :::zone-end :::zone pivot=""vscode,dotnet-cli"" Create an app host project In order to orchestrate the existing projects, you need to create a new app host project. To create a new app host project from the available .NET Aspire templates, use the following .NET CLI command: dotnetcli dotnet new aspire-apphost -o eShopLite.AppHost Add the app host project to existing solution: Unix dotnetcli dotnet sln ./eShopLite.sln add ./eShopLite.AppHost/eShopLite.AppHost.csproj Windows dotnetcli dotnet sln .\\eShopLite.sln add .\\eShopLite.AppHost\\eShopLite.AppHost.csproj Add the Store project as a project reference to the app host project using the following .NET CLI command: Unix dotnetcli dotnet add ./eShopLite.AppHost/eShopLite.AppHost.csproj reference ./Store/Store.csproj Windows dotnetcli dotnet add .\\eShopLite.AppHost\\eShopLite.AppHost.csproj reference .\\Store\\Store.csproj Create a service defaults project After the app host project is created, you need to create a new service defaults project. To create a new service defaults project from the available .NET Aspire templates, use the following .NET CLI command: dotnetcli dotnet new aspire-servicedefaults -o eShopLite.ServiceDefaults To add the project to the solution, use the following .NET CLI command: Unix dotnetcli dotnet sln ./eShopLite.sln add ./eShopLite.ServiceDefaults/eShopLite.ServiceDefaults.csproj Windows dotnetcli dotnet sln .\\eShopLite.sln add .\\eShopLite.ServiceDefaults\\eShopLite.ServiceDefaults.csproj Update the app host project to add a project reference to the Products project: Unix dotnetcli dotnet add ./eShopLite.AppHost/eShopLite.AppHost.csproj reference ./Products/Products.csproj Windows dotnetcli dotnet add .\\eShopLite.AppHost\\eShopLite.AppHost.csproj reference .\\Products\\Products.csproj Both the Store and Products projects need to reference the service defaults project so that they can easily include service discovery. To add a reference to the service defaults project in the Store project, use the following .NET CLI command: Unix dotnetcli dotnet add ./Store/Store.csproj reference ./eShopLite.ServiceDefaults/eShopLite.ServiceDefaults.csproj Windows dotnetcli dotnet add .\\Store\\Store.csproj reference .\\eShopLite.ServiceDefaults\\eShopLite.ServiceDefaults.csproj The same command with slightly different paths should be used to add a reference to the service defaults project in the Products project: Unix dotnetcli dotnet add ./Products/Products.csproj reference ./eShopLite.ServiceDefaults/eShopLite.ServiceDefaults.csproj Windows dotnetcli dotnet add .\\Products\\Products.csproj reference .\\eShopLite.ServiceDefaults\\eShopLite.ServiceDefaults.csproj In both the Store and Products projects, update their :::no-loc text=""Program.cs""::: files, adding the following line immediately after their var builder = WebApplication.CreateBuilder(args); line: csharp builder.AddServiceDefaults(); Update the app host project Open the :::no-loc text=""Program.cs""::: file of the app host project, and replace its contents with the following C# code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code: Creates a new DistributedApplicationBuilder instance. Adds the Store project to the orchestrator. Adds the Products project to the orchestrator. Builds and runs the orchestrator. :::zone-end Service Discovery At this point, both projects are part of .NET Aspire orchestration, but the Store needs to be able to discover the Products backend address through .NET Aspire\'s service discovery. To enable service discovery, open the :::no-loc text=""Program.cs""::: file in eShopLite.AppHost and update the code that the Store adds a reference to the Products project: ```csharp var builder = DistributedApplication.CreateBuilder(args); var products = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code expresses that the Store project depends on the Products project. For more information, see .NET Aspire app host: Reference resources. This reference is used to discover the address of the Products project. Additionally, the Store project is configured to use external HTTP endpoints. If you later choose to deploy this app, you\'d need the call to Next, update the :::no-loc text=""appsettings.json""::: in the Store project with the following JSON: json { ""DetailedErrors"": true, ""Logging"": { ""LogLevel"": { ""Default"": ""Information"", ""Microsoft.AspNetCore"": ""Warning"" } }, ""AllowedHosts"": ""*"", ""ProductEndpoint"": ""http://products"", ""ProductEndpointHttps"": ""https://products"" } The addresses for both the endpoints now uses the ""products"" name that was added to the orchestrator in the app host. These names are used to discover the address of the Products project.']","eShopLite.ServiceDefaults is a .NET Aspire shared project designed to manage configurations that are reused across the projects in your solution, specifically related to resilience, service discovery, and telemetry. It is referenced by both the Store and Products projects to facilitate service discovery and other shared configurations.",single_hop_specifc_query_synthesizer
16,how use visual studio for debug?,"['Explore the enrolled app Let\'s start the solution and examine the new behavior that .NET Aspire provides. :::zone pivot=""visual-studio"" [!NOTE] Notice that the eShopLite.AppHost project is the new startup project. In Visual Studio, to start debugging, press F5 Visual Studio builds the projects. If the Start Docker Desktop dialog appears, select Yes. Visual Studio starts the Docker engine and creates the necessary containers. When the deployment is complete, the .NET Aspire dashboard is displayed. In the dashboard, select the endpoint for the products project. A new browser tab appears and displays the product catalog in JSON format. In the dashboard, select the endpoint for the store project. A new browser tab appears and displays the home page for the web app. In the menu on the left, select Products. The product catalog is displayed. To stop debugging, close the browser. :::zone-end :::zone pivot=""vscode"" Delete the launch.json file that you created earlier, it no longer serves a purpose. Instead, start the app host project, which orchestrates the other projects: Start the app host project by right-clicking the eShopLite.AppHost project in the Solution Explorer and selecting Debug > Start New Instance: :::image type=""content"" source=""media/vscode-run-app-host.png"" lightbox=""media/vscode-run-app-host.png"" alt-text=""Visual Studio Code: Solution Explorer selecting Debug > Start New Instance."" ::: [!NOTE] If Docker Desktop (or Podman) isn\'t running, you\'ll experience an error. Start the OCI compliant container engine and try again. :::zone-end :::zone pivot=""dotnet-cli"" Start the app host project by running the following command: dotnetcli dotnet run --project ./eShopLite.AppHost/eShopLite.AppHost.csproj [!NOTE] If Docker Desktop (or Podman) isn\'t running, you\'ll experience an error. Start the OCI compliant container engine and try again. :::zone-end :::zone pivot=""vscode,dotnet-cli"" In the dashboard, select the endpoint for the products project. A new browser tab appears and displays the product catalog in JSON format. In the dashboard, select the endpoint for the store project. A new browser tab appears and displays the home page for the web app. In the menu on the left, select Products. The product catalog is displayed. To stop debugging, close the browser. :::zone-end Congratulations, you added .NET Aspire orchestration to your pre-existing web app. You can now add .NET Aspire integrations and use the .NET Aspire tooling to streamline your cloud-native web app development.']","In Visual Studio, to start debugging, press F5. Visual Studio builds the projects, starts the Docker engine, and creates the necessary containers. When the deployment is complete, the .NET Aspire dashboard is displayed.",single_hop_specifc_query_synthesizer
17,how use mcr.microsoft.com for dashboard?,"['title: .NET Aspire dashboard configuration description: .NET Aspire dashboard configuration options ms.date: 10/29/2024 ms.topic: reference Dashboard configuration The dashboard is configured when it starts up. Configuration includes frontend and OpenTelemetry Protocol (OTLP) addresses, the resource service endpoint, authentication, telemetry limits, and more. When the dashboard is launched with the .NET Aspire app host project, it\'s automatically configured to display the app\'s resources and telemetry. Configuration is provided when launching the dashboard in standalone mode. There are many ways to provide configuration: Command line arguments. Environment variables. The : delimiter should be replaced with double underscore (__) in environment variable names. Optional JSON configuration file. The DOTNET_DASHBOARD_CONFIG_FILE_PATH setting can be used to specify a JSON configuration file. Consider the following example, which shows how to configure the dashboard when started from a Docker container: Bash bash docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard \\ -e DASHBOARD__TELEMETRYLIMITS__MAXLOGCOUNT=\'1000\' \\ -e DASHBOARD__TELEMETRYLIMITS__MAXTRACECOUNT=\'1000\' \\ -e DASHBOARD__TELEMETRYLIMITS__MAXMETRICSCOUNT=\'1000\' \\ mcr.microsoft.com/dotnet/aspire-dashboard:9.0 PowerShell powershell docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard ` -e DASHBOARD__TELEMETRYLIMITS__MAXLOGCOUNT=\'1000\' ` -e DASHBOARD__TELEMETRYLIMITS__MAXTRACECOUNT=\'1000\' ` -e DASHBOARD__TELEMETRYLIMITS__MAXMETRICSCOUNT=\'1000\' ` mcr.microsoft.com/dotnet/aspire-dashboard:9.0 Alternatively, these same values could be configured using a JSON configuration file that is specified using DOTNET_DASHBOARD_CONFIG_FILE_PATH: json { ""Dashboard"": { ""TelemetryLimits"": { ""MaxLogCount"": 1000, ""MaxTraceCount"": 1000, ""MaxMetricsCount"": 1000 } } } [!IMPORTANT] The dashboard displays information about resources, including their configuration, console logs and in-depth telemetry. Data displayed in the dashboard can be sensitive. For example, secrets in environment variables, and sensitive runtime data in telemetry. Care should be taken to configure the dashboard to secure access. For more information, see dashboard security. [!NOTE] Configuration described on this page is for the standalone dashboard. To configure an .NET Aspire app host project, see App host configuration. Common configuration Option Default value Description ASPNETCORE_URLS http://localhost:18888 One or more HTTP endpoints through which the dashboard frontend is served. The frontend endpoint is used to view the dashboard in a browser. When the dashboard is launched by the .NET Aspire app host this address is secured with HTTPS. Securing the dashboard with HTTPS is recommended. DOTNET_DASHBOARD_OTLP_ENDPOINT_URL http://localhost:18889 The OTLP/gRPC endpoint. This endpoint hosts an OTLP service and receives telemetry using gRPC. When the dashboard is launched by the .NET Aspire app host this address is secured with HTTPS. Securing the dashboard with HTTPS is recommended. DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL http://localhost:18890 The OTLP/HTTP endpoint. This endpoint hosts an OTLP service and receives telemetry using Protobuf over HTTP. When the dashboard is launched by the .NET Aspire app host the OTLP/HTTP endpoint isn\'t configured by default. To configure an OTLP/HTTP endpoint with the app host, set an DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL env var value in launchSettings.json . Securing the dashboard with HTTPS is recommended. DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS false Configures the dashboard to not use authentication and accepts anonymous access. This setting is a shortcut to configuring Dashboard:Frontend:AuthMode and Dashboard:Otlp:AuthMode to Unsecured . DOTNET_DASHBOARD_CONFIG_FILE_PATH null The path for a JSON configuration file. If the dashboard is being run in a Docker container, then this is the path to the configuration file in a mounted volume. This value is optional. DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null The gRPC endpoint to which the dashboard connects for its data. If this value is unspecified, the dashboard shows telemetry data but no resource list or console logs. This setting is a shortcut to Dashboard:ResourceServiceClient:Url .']","To use mcr.microsoft.com for the dashboard, you can run a Docker container with the image mcr.microsoft.com/dotnet/aspire-dashboard:9.0, specifying necessary environment variables for configuration.",single_hop_specifc_query_synthesizer
18,Wht iz the purpse of using KeyStore in the cntext of client certificate authntication for the resource service client?,"['OTLP authentication The OTLP endpoint authentication is configured with Dashboard:Otlp:AuthMode. The OTLP endpoint can be secured with an API key or client certificate authentication. API key authentication works by requiring each OTLP request to have a valid x-otlp-api-key header value. It must match either the primary or secondary key. Option Default value Description Dashboard:Otlp:AuthMode Unsecured Can be set to ApiKey , Certificate or Unsecured . Unsecured should only be used during local development. It\'s not recommended when hosting the dashboard publicly or in other settings. Dashboard:Otlp:PrimaryApiKey null Specifies the primary API key. The API key can be any text, but a value with at least 128 bits of entropy is recommended. This value is required if auth mode is API key. Dashboard:Otlp:SecondaryApiKey null Specifies the secondary API key. The API key can be any text, but a value with at least 128 bits of entropy is recommended. This value is optional. If a second API key is specified, then the incoming x-otlp-api-key header value can match either the primary or secondary key. OTLP CORS Cross-origin resource sharing (CORS) can be configured to allow browser apps to send telemetry to the dashboard. By default, browser apps are restricted from making cross domain API calls. This impacts sending telemetry to the dashboard because the dashboard and the browser app are always on different domains. To configure CORS, use the Dashboard:Otlp:Cors section and specify the allowed origins and headers: json { ""Dashboard"": { ""Otlp"": { ""Cors"": { ""AllowedOrigins"": ""http://localhost:5000,https://localhost:5001"" } } } } Consider the following configuration options: Option Default value Description Dashboard:Otlp:Cors:AllowedOrigins null Specifies the allowed origins for CORS. It\'s a comma-delimited string and can include the * wildcard to allow any domain. This option is optional and can be set using the DASHBOARD__OTLP__CORS__ALLOWEDORIGINS environment variable. Dashboard:Otlp:Cors:AllowedHeaders null A comma-delimited string representing the allowed headers for CORS. This setting is optional and can be set using the DASHBOARD__OTLP__CORS__ALLOWEDHEADERS environment variable. [!NOTE] The dashboard only supports the POST method for sending telemetry and doesn\'t allow configuration of the allowed methods (Access-Control-Allow-Methods) for CORS. Resources The dashboard connects to a resource service to load and display resource information. The client is configured in the dashboard for how to connect to the service. The resource service client authentication is configured with Dashboard:ResourceServiceClient:AuthMode. The client can be configured to support API key or client certificate authentication. Option Default value Description Dashboard:ResourceServiceClient:Url null The gRPC endpoint to which the dashboard connects for its data. If this value is unspecified, the dashboard shows telemetry data but no resource list or console logs. Dashboard:ResourceServiceClient:AuthMode null Can be set to ApiKey , Certificate or Unsecured . Unsecured should only be used during local development. It\'s not recommended when hosting the dashboard publicly or in other settings. This value is required if a resource service URL is specified. Dashboard:ResourceServiceClient:ApiKey null The API to send to the resource service in the x-resource-service-api-key header. This value is required if auth mode is API key. Dashboard:ResourceServiceClient:ClientCertificate:Source null Can be set to File or KeyStore . This value is required if auth mode is client certificate. Dashboard:ResourceServiceClient:ClientCertificate:FilePath null The certificate file path. This value is required if source is File . Dashboard:ResourceServiceClient:ClientCertificate:Password null The password for the certificate file. This value is optional. Dashboard:ResourceServiceClient:ClientCertificate:Subject null The certificate subject. This value is required if source is KeyStore . Dashboard:ResourceServiceClient:ClientCertificate:Store My The certificate . Dashboard:ResourceServiceClient:ClientCertificate:Location CurrentUser The certificate .']",The KeyStore is used as a source for the client certificate when the authentication mode is set to client certificate for the resource service client. This value is required if the source is KeyStore.,single_hop_specifc_query_synthesizer
19,What is the role of Aspire in the context of telemetry limits on the dashboard?,"['Telemetry limits Telemetry is stored in memory. To avoid excessive memory usage, the dashboard has limits on the count and size of stored telemetry. When a count limit is reached, new telemetry is added, and the oldest telemetry is removed. When a size limit is reached, data is truncated to the limit. Telemetry limits have different scopes depending upon the telemetry type: MaxLogCount and MaxTraceCount are shared across resources. For example, a MaxLogCount value of 5,000 configures the dashboard to store up to 5,000 total log entries for all resources. MaxMetricsCount is per-resource. For example, a MaxMetricsCount value of 10,000 configures the dashboard to store up to 10,000 metrics data points per-resource. Option Default value Description Dashboard:TelemetryLimits:MaxLogCount 10,000 The maximum number of log entries. Limit is shared across resources. Dashboard:TelemetryLimits:MaxTraceCount 10,000 The maximum number of log traces. Limit is shared across resources. Dashboard:TelemetryLimits:MaxMetricsCount 50,000 The maximum number of metric data points. Limit is per-resource. Dashboard:TelemetryLimits:MaxAttributeCount 128 The maximum number of attributes on telemetry. Dashboard:TelemetryLimits:MaxAttributeLength null The maximum length of attributes. Dashboard:TelemetryLimits:MaxSpanEventCount null The maximum number of events on span attributes. Other Option Default value Description Dashboard:ApplicationName Aspire The application name to be displayed in the UI. This applies only when no resource service URL is specified. When a resource service exists, the service specifies the application name. Next steps [!div class=""nextstepaction""] Security considerations for running the .NET Aspire dashboard']","Aspire is the application name to be displayed in the UI when no resource service URL is specified. It does not directly relate to telemetry limits, which are concerned with the storage and management of telemetry data such as logs, traces, and metrics.",single_hop_specifc_query_synthesizer
20,Wht is the role of AspireRedis.ApiService in the .NET Aspire solution?,"['title: Implement caching with .NET Aspire integrations description: Learn how to connect to Redis and cache data using .NET Aspire integrations. ms.date: 11/08/2024 ms.topic: tutorial Tutorial: Implement caching with .NET Aspire integrations Cloud-native apps often require various types of scalable caching solutions to improve performance. .NET Aspire integrations simplify the process of connecting to popular caching services such as Redis. In this article, you\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET core app that is set up to use .NET Aspire. Add .NET Aspire integrations to connect to Redis and implement caching. Configure the .NET Aspire integrations to meet specific requirements. This article explores how to use two different types of ASP.NET Core caching using .NET Aspire and Redis: Output caching: A configurable, extensible caching method for storing entire HTTP responses for future requests. Distributed caching: A cache shared by multiple app servers that allows you to cache specific pieces of data. A distributed cache is typically maintained as an external service to the app servers that access it and can improve the performance and scalability of an ASP.NET Core app. [!INCLUDE aspire-prereqs] Create the project At the top of Visual Studio, navigate to File > New > Project.... In the dialog window, enter .NET Aspire into the project template search box and select .NET Aspire Starter Application. Choose Next. On the Configure your new project screen: Enter a Project name of AspireRedis. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Uncheck Use Redis for caching. You will implement your own caching setup. Select Create. Visual Studio creates a new .NET Aspire solution that consists of the following projects: AspireRedis.Web - A Blazor UI project with default .NET Aspire configurations. AspireRedis.ApiService - A Minimal API with default .NET Aspire configurations that provides the frontend with data. AspireRedis.AppHost - An orchestrator project designed to connect and configure the different projects and services of your app. AspireRedis.ServiceDefaults - A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. Configure the App Host project Add the ðŸ“¦ Aspire.Hosting.Redis NuGet package to the AspireRedis.AppHost project: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Redis PackageReference xml <PackageReference Include=""Aspire.Hosting.Redis"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Update the :::no-loc text=""Program.cs""::: file of the AspireRedis.AppHost project to match the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var redis = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code creates a local Redis container instance and configures the UI and API to use the instance automatically for both output and distributed caching. The code also configures communication between the frontend UI and the backend API using service discovery. With .NET Aspire\'s implicit service discovery, setting up and managing service connections is streamlined for developer productivity. In the context of this tutorial, the feature simplifies how you connect to Redis. Traditionally, you\'d manually specify the Redis connection string in each project\'s :::no-loc text=""appsettings.json""::: file: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } Configuring connection string with this method, while functional, requires duplicating the connection string across multiple projects, which can be cumbersome and error-prone.']",AspireRedis.ApiService is a Minimal API with default .NET Aspire configurations that provides the frontend with data.,single_hop_specifc_query_synthesizer
21,How can Docker Desktop be utilized when testing ASP.NET Core app caching locally?,"['Configure the UI with output caching Add the .NET Aspire Stack Exchange Redis output caching integration packages to your AspireRedis.Web app: dotnetcli dotnet add package Aspire.StackExchange.Redis.OutputCaching In the :::no-loc text=""Program.cs""::: file of the AspireRedis.Web Blazor project, immediately after the line var builder = WebApplication.CreateBuilder(args);, add a call to the csharp builder.AddRedisOutputCache(""cache""); This method accomplishes the following tasks: Configures ASP.NET Core output caching to use a Redis instance with the specified connection name. Automatically enables corresponding health checks, logging, and telemetry. Replace the contents of the Home.razor file of the AspireRedis.Web Blazor project with the following: ```razor @page ""/"" @attribute [OutputCache(Duration = 10)] Hello, world! Welcome to your new app on @DateTime.Now ``` The integration include the [OutputCache] attribute, which caches the entire rendered response. The page also include a call to @DateTime.Now to help verify that the response is cached. Configure the API with distributed caching Add the .NET Aspire Stack Exchange Redis distributed caching integration packages to your AspireRedis.ApiService app: dotnetcli dotnet add package Aspire.StackExchange.Redis.DistributedCaching Towards the top of the :::no-loc text=""Program.cs""::: file, add a call to csharp builder.AddRedisDistributedCache(""cache""); In the :::no-loc text=""Program.cs""::: file, add the following using statements: csharp using System.Text; using System.Text.Json; using Microsoft.Extensions.Caching.Distributed; In the :::no-loc text=""Program.cs""::: file, replace the existing /weatherforecast endpoint code with the following: ```csharp app.MapGet(""/weatherforecast"", async (IDistributedCache cache) => { var cachedForecast = await cache.GetAsync(""forecast""); if (cachedForecast is null) { var summaries = new[] { ""Freezing"", ""Bracing"", ""Chilly"", ""Cool"", ""Mild"", ""Warm"", ""Balmy"", ""Hot"", ""Sweltering"", ""Scorching"" }; var forecast = Enumerable.Range(1, 5).Select(index => new WeatherForecast ( DateOnly.FromDateTime(DateTime.Now.AddDays(index)), Random.Shared.Next(-20, 55), summaries[Random.Shared.Next(summaries.Length)] )) .ToArray(); await cache.SetAsync(""forecast"", Encoding.UTF8.GetBytes(JsonSerializer.Serialize(forecast)), new () { AbsoluteExpiration = DateTime.Now.AddSeconds(10) }); ; return forecast; } return JsonSerializer.Deserialize<IEnumerable<WeatherForecast>>(cachedForecast); }) .WithName(""GetWeatherForecast""); ``` Test the app locally Test the caching behavior of your app using the following steps: Run the app using Visual Studio by pressing F5. If the Start Docker Desktop dialog appears, select Yes to start the service. The .NET Aspire Dashboard loads in the browser and lists the UI and API projects. Test the output cache: On the projects page, in the webfrontend row, click the localhost link in the Endpoints column to open the UI of your app. The application will display the current time on the home page. Refresh the browser every few seconds to see the same page returned by output caching. After 10 seconds the cache expires and the page reloads with an updated time. Test the distributed cache: Navigate to the Weather page on the Blazor UI to load a table of randomized weather data. Refresh the browser every few seconds to see the same weather data returned by output caching. After 10 seconds the cache expires and the page reloads with updated weather data. Congratulations! You configured a ASP.NET Core app to use output and distributed caching with .NET Aspire.']","When testing the caching behavior of your ASP.NET Core app locally, if the Start Docker Desktop dialog appears, you should select Yes to start the service. This allows the .NET Aspire Dashboard to load in the browser, listing the UI and API projects for testing.",single_hop_specifc_query_synthesizer
22,How can Docker be utilized in the .NET Aspire Keycloak integration for hosting Keycloak instances?,"['title: .NET Aspire Keycloak integration (Preview) description: Learn how to use the .NET Aspire Keycloak integration, which includes both hosting and client integrations. ms.date: 12/06/2024 uid: authentication/keycloak-integration .NET Aspire Keycloak integration (Preview) [!INCLUDE includes-hosting-and-client] Keycloak is an open-source Identity and Access Management solution aimed at modern applications and services. The .NET Aspire Keycloak integration enables you to connect to existing Keycloak instances or create new instances from .NET with the quay.io/keycloak/keycloak container image. Hosting integration The .NET Aspire Keycloak hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Keycloak --prerelease PackageReference xml <PackageReference Include=""Aspire.Hosting.Keycloak"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Keycloak resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var keycloak = builder.AddKeycloak(""keycloak"", 8080); var apiService = builder.AddProject builder.AddProject // After adding all resources, run the app... ``` [!TIP] For local development use a stable port for the Keycloak resource (8080 in the preceding example). It can be any port, but it should be stable to avoid issues with browser cookies that will persist OIDC tokens (which include the authority URL, with port) beyond the lifetime of the app host. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the quay.io/keycloak/keycloak image, it creates a new Keycloak instance on your local machine. The Keycloak resource includes default credentials: KEYCLOAK_ADMIN: A value of admin. KEYCLOAK_ADMIN_PASSWORD: Random password generated using the When the app host runs, the password is stored in the app host\'s secret store. It\'s added to the Parameters section, for example: json { ""Parameters:keycloak-password"": ""<THE_GENERATED_PASSWORD>"" } The name of the parameter is keycloak-password, but really it\'s just formatting the resource name with a -password suffix. For more information, see Safe storage of app secrets in development in ASP.NET Core and Add Keycloak resource. The [!TIP] If you\'d rather connect to an existing Keycloak instance, call Add Keycloak resource with data volume To add a data volume to the Keycloak resource, call the ```csharp var keycloak = builder.AddKeycloak(""keycloak"", 8080) .WithDataVolume(); var apiService = builder.AddProject builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Keycloak data outside the lifecycle of its container. The data volume is mounted at the /opt/keycloak/data path in the Keycloak container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The admin credentials are stored in the data volume. When using a data volume and if the credentials change, it will not work until you delete the volume. Add Keycloak resource with data bind mount To add a data bind mount to the Keycloak resource, call the ```csharp var keycloak = builder.AddKeycloak(""keycloak"", 8080) .WithDataBindMount(@""C:\\Keycloak\\Data""); var apiService = builder.AddProject builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Keycloak data across container restarts. The data bind mount is mounted at the C:\\Keycloak\\Data on Windows (or /Keycloak/Data on Unix) path on the host machine in the Keycloak container. For more information on data bind mounts, see Docker docs: Bind mounts. Add Keycloak resource with parameters When you want to explicitly provide the admin username and password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username""); var password = builder.AddParameter(""password"", secret: true); var keycloak = builder.AddKeycloak(""keycloak"", 8080, username, password); var apiService = builder.AddProject builder.AddProject // After adding all resources, run the app... ``` The username and password parameters are usually provided as environment variables or secrets. The parameters are used to set the KEYCLOAK_ADMIN and KEYCLOAK_ADMIN_PASSWORD environment variables in the container. For more information on providing parameters, see External parameters. Add Keycloak resource with realm import To import a realm into Keycloak, call the :::code language=""csharp"" source=""snippets/AspireApp/AspireApp.AppHost/Program.cs""::: The realm import files are mounted at /opt/keycloak/data/import in the Keycloak container. Realm import files are JSON files that represent the realm configuration. For more information on realm import, see Keycloak docs: Importing a realm. As an example, the following JSON file could be added to the app host project in a /Realms folderâ€”to serve as a source realm configuration file: Hosting integration health checks The Keycloak hosting integration doesn\'t currently support a health checks, nor does it automatically add them.']","In the .NET Aspire Keycloak integration, Docker is used to create new Keycloak instances on your local machine by adding a container image to the app host with the quay.io/keycloak/keycloak image.",single_hop_specifc_query_synthesizer
23,How can ASP.NET Core be integrated with Keycloak for authentication?,"['Client integration To get started with the .NET Aspire Keycloak client integration, install the ðŸ“¦ Aspire.Keycloak.Authentication NuGet package in the client-consuming project, that is, the project for the application that uses the Keycloak client. The Keycloak client integration registers JwtBearer and OpenId Connect authentication handlers in the DI container for connecting to a Keycloak. .NET CLI dotnetcli dotnet add package Aspire.Keycloak.Authentication PackageReference xml <PackageReference Include=""Aspire.Keycloak.Authentication"" Version=""*"" /> Add JWT bearer authentication In the :::no-loc text=""Program.cs""::: file of your ASP.NET Core API project, call the csharp builder.Services.AddAuthentication() .AddKeycloakJwtBearer( serviceName: ""keycloak"", realm: ""api"", options => { options.Audience = ""store.api""; }); You can set many other options via the Action<JwtBearerOptions> configureOptions delegate. JWT bearer authentication example To further exemplify the JWT bearer authentication, consider the following example: :::code language=""csharp"" source=""snippets/AspireApp/AspireApp.ApiService/Program.cs"" highlight=""12-20,22,49""::: The preceding ASP.NET Core Minimal API Program class demonstrates: Adding authentication services to the DI container with the Adding JWT bearer authentication with the The serviceName as keycloak. The realm as WeatherShop. The options with the Audience set to weather.api and sets RequireHttpsMetadata to false. Adds authorization services to the DI container with the Calls the For a complete working sample, see .NET Aspire playground: Keycloak integration. Add OpenId Connect authentication In the :::no-loc text=""Program.cs""::: file of your API-consuming project (for example, Blazor), call the csharp builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme) .AddKeycloakOpenIdConnect( serviceName: ""keycloak"", realm: ""api"", options => { options.ClientId = ""StoreWeb""; options.ResponseType = OpenIdConnectResponseType.Code; options.Scope.Add(""store:all""); }); You can set many other options via the Action<OpenIdConnectOptions>? configureOptions delegate. OpenId Connect authentication example To further exemplify the OpenId Connect authentication, consider the following example: :::code language=""csharp"" source=""snippets/AspireApp/AspireApp.Web/Program.cs"" highlight=""21-22,24-30,32,34-45,47,70""::: The preceding ASP.NET Core Blazor Program class: Adds the HttpContextAccessor to the DI container with the Adds a custom AuthorizationHandler as a transient service to the DI container with the Adds an Chains a call to the Adds authentication services to the DI container with the Calls Adds cascading authentication state to the Blazor app with the The final callout is the MapLoginAndLogout extension method that adds login and logout routes to the Blazor app. This is defined as follows: :::code language=""csharp"" source=""snippets/AspireApp/AspireApp.Web/LoginLogoutEndpointRouteBuilderExtensions.cs""::: The preceding code: Maps a group for the authentication route and maps two endpoints for the login and logout routes: Maps a GET request to the /login route that\'s handler is the OnLogin methodâ€”this is an anonymous endpoint. Maps a GET request to the /logout route that\'s handler is the OnLogout method. The AuthorizationHandler is a custom handler that adds the Bearer token to the HttpClient request. The handler is defined as follows: :::code language=""csharp"" source=""snippets/AspireApp/AspireApp.Web/AuthorizationHandler.cs""::: The preceding code: Is a subclass of the Injects the IHttpContextAccessor service in the primary constructor. Overrides the SendAsync method to add the Bearer token to the HttpClient request: The access_token is retrieved from the HttpContext and added to the Authorization header. To help visualize the auth flow, consider the following sequence diagram: :::image type=""content"" source=""media/auth-flow-diagram.png"" lightbox=""media/auth-flow-diagram.png"" alt-text=""Authentication flow diagramâ€”demonstrating a user request for an access token, Keycloak returning a JWT, and the token being forward to the API.""::: For a complete working sample, see .NET Aspire playground: Keycloak integration. See also Keycloak .NET Aspire playground: Keycloak integration .NET Aspire integrations .NET Aspire GitHub repo']","To integrate ASP.NET Core with Keycloak for authentication, you need to install the Aspire.Keycloak.Authentication NuGet package in your client-consuming project. In the Program.cs file of your ASP.NET Core API project, you can add JWT bearer authentication by calling builder.Services.AddAuthentication().AddKeycloakJwtBearer with the serviceName set to 'keycloak', the realm set to 'api', and options such as Audience set to 'store.api'. Additionally, OpenId Connect authentication can be added by calling builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme).AddKeycloakOpenIdConnect with options like ClientId set to 'StoreWeb' and ResponseType set to OpenIdConnectResponseType.Code.",single_hop_specifc_query_synthesizer
24,What is MySqlConnector used for in .NET Aspire?,"['Integration features When you add a client integration to a project within your .NET Aspire solution, service defaults are automatically applied to that project; meaning the Service Defaults project is referenced and the AddServiceDefaults extension method is called. These defaults are designed to work well in most scenarios and can be customized as needed. The following service defaults are applied: Observability and telemetry: Automatically sets up logging, tracing, and metrics configurations: Logging: A technique where code is instrumented to produce logs of interesting events that occurred while the program was running. Tracing: A specialized form of logging that helps you localize failures and performance issues within applications distributed across multiple machines or processes. Metrics: Numerical measurements recorded over time to monitor application performance and health. Metrics are often used to generate alerts when potential problems are detected. Health checks: Exposes HTTP endpoints to provide basic availability and state information about an app. Health checks are used to influence decisions made by container orchestrators, load balancers, API gateways, and other management services. Resiliency: The ability of your system to react to failure and still remain functional. Resiliency extends beyond preventing failures to include recovering and reconstructing your cloud-native environment back to a healthy state. Versioning considerations Hosting and client integrations are updated each release to target the latest stable versions of dependent resources. When container images are updated with new image versions, the hosting integrations update to these new versions. Similarly, when a new NuGet version is available for a dependent client library, the corresponding client integration updates to the new version. This ensures the latest features and security updates are available to applications. When major breaking changes happen in dependent resources, integrations may temporarily split into version-dependent packages to ease updating across the breaking change. For more information, see the first example of such a breaking change. Official integrations .NET Aspire provides many integrations to help you build cloud-native applications. These integrations are designed to work seamlessly with the .NET Aspire app host and client libraries. The following sections detail cloud-agnostic, Azure-specific, Amazon Web Services (AWS), and Community Toolkit integrations. Cloud-agnostic integrations The following section details cloud-agnostic .NET Aspire integrations with links to their respective docs and NuGet packages, and provides a brief description of each integration. Integration docs and NuGet packages Description - Learn more : ðŸ“„ Apache Kafka - Hosting : ðŸ“¦ Aspire.Hosting.Kafka - Client : ðŸ“¦ Aspire.Confluent.Kafka A library for producing and consuming messages from an Apache Kafka broker. - Learn more : ðŸ“„ Dapr - Hosting : ðŸ“¦ Aspire.Hosting.Dapr - Client : N/A A library for modeling Dapr as a .NET Aspire resource. - Learn more : ðŸ“„ Elasticsearch - Hosting : ðŸ“¦ Aspire.Hosting.Elasticsearch - Client : ðŸ“¦ Aspire.Elastic.Clients.Elasticsearch A library for accessing Elasticsearch databases. - Learn more : ðŸ“„ Keycloak - Hosting : ðŸ“¦ Aspire.Hosting.Keycloak - Client : ðŸ“¦ Aspire.Keycloak.Authentication A library for accessing Keycloak authentication. - Learn more : ðŸ“„ Milvus - Hosting : ðŸ“¦ Aspire.Hosting.Milvus - Client : ðŸ“¦ Aspire.Milvus.Client A library for accessing Milvus databases. - Learn more : ðŸ“„ MongoDB Driver - Hosting : ðŸ“¦ Aspire.Hosting.MongoDB - Client : ðŸ“¦ Aspire.MongoDB.Driver A library for accessing MongoDB databases. - Learn more : ðŸ“„ MySqlConnector - Hosting : ðŸ“¦ Aspire.Hosting.MySql - Client : ðŸ“¦ Aspire.MySqlConnector A library for accessing MySqlConnector databases. - Learn more : ðŸ“„ NATS - Hosting : ðŸ“¦ Aspire.Hosting.Nats - Client : ðŸ“¦ Aspire.NATS.Net A library for accessing NATS messaging. - Learn more : ðŸ“„ Oracle - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.Oracle - Client : ðŸ“¦ Aspire.Oracle.EntityFrameworkCore A library for accessing Oracle databases with Entity Framework Core . - Learn more : ðŸ“„ Orleans - Hosting : ðŸ“¦ Aspire.Hosting.Orleans - Client : N/A A library for modeling Orleans as a .NET Aspire resource. - Learn more : ðŸ“„ Pomelo MySQL - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.MySql - Client : ðŸ“¦ Aspire.Pomelo.EntityFrameworkCore.MySql A library for accessing MySql databases with Entity Framework Core . - Learn more : ðŸ“„ PostgreSQL - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.PostgreSQL - Client : ðŸ“¦ Aspire.Npgsql.EntityFrameworkCore.PostgreSQL A library for accessing PostgreSQL databases using Entity Framework Core . - Learn more : ðŸ“„ PostgreSQL - Hosting : ðŸ“¦ Aspire.Hosting.PostgreSQL - Client : ðŸ“¦ Aspire.Npgsql A library for accessing PostgreSQL databases. - Learn more : ðŸ“„ Qdrant - Hosting : ðŸ“¦ Aspire.Hosting.Qdrant - Client : ðŸ“¦ Aspire.Qdrant.Client A library for accessing Qdrant databases. - Learn more : ðŸ“„ RabbitMQ - Hosting : ðŸ“¦ Aspire.Hosting.RabbitMQ - Client : ðŸ“¦ Aspire.RabbitMQ.Client A library for accessing RabbitMQ . - Learn more : ðŸ“„ Redis Distributed Caching - Hosting : ðŸ“¦ Aspire.Hosting.Redis , ðŸ“¦ Aspire.Hosting.Garnet , or ðŸ“¦ Aspire.Hosting.Valkey - Client : ðŸ“¦ Aspire.StackExchange.Redis.DistributedCaching A library for accessing Redis caches for distributed caching . - Learn more : ðŸ“„ Redis Output Caching - Hosting : ðŸ“¦ Aspire.Hosting.Redis , ðŸ“¦ Aspire.Hosting.Garnet , or ðŸ“¦ Aspire.Hosting.Valkey - Client : ðŸ“¦ Aspire.StackExchange.Redis.OutputCaching A library for accessing Redis caches for output caching . - Learn more : ðŸ“„ Redis - Hosting : ðŸ“¦ Aspire.Hosting.Redis , ðŸ“¦ Aspire.Hosting.Garnet , or ðŸ“¦ Aspire.Hosting.Valkey - Client : ðŸ“¦ Aspire.StackExchange.Redis A library for accessing Redis caches. - Learn more : ðŸ“„ Seq - Hosting : ðŸ“¦ Aspire.Hosting.Seq - Client : ðŸ“¦ Aspire.Seq A library for logging to Seq . - Learn more : ðŸ“„ SQL Server - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.SqlServer - Client : ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer A library for accessing SQL Server databases using EF Core . - Learn more : ðŸ“„ SQL Server - Hosting : ðŸ“¦ Aspire.Hosting.SqlServer - Client : ðŸ“¦ Aspire.Microsoft.Data.SqlClient A library for accessing SQL Server databases. For more information on working with .NET Aspire integrations in Visual Studio, see Visual Studio tooling. Azure integrations Azure integrations configure applications to use Azure resources. These hosting integrations are available in the Aspire.Hosting.Azure.* NuGet packages, while their client integrations are available in the Aspire.* NuGet packages: Integration docs and NuGet packages Description - Learn more : ðŸ“„ Azure App Configuration - Hosting : ðŸ“¦ Aspire.Hosting.Azure.AppConfiguration - Client : N/A A']",MySqlConnector is a library for accessing MySqlConnector databases in .NET Aspire.,single_hop_specifc_query_synthesizer
25,what postgresql do in .net aspire?,"['title: .NET Aspire integrations overview description: Explore the fundamental concepts of .NET Aspire integrations and learn how to integrate them into your apps. ms.date: 12/09/2024 ms.topic: conceptual uid: dotnet/aspire/integrations .NET Aspire integrations overview .NET Aspire integrations are a curated suite of NuGet packages selected to facilitate the integration of cloud-native applications with prominent services and platforms, such as Redis and PostgreSQL. Each integration furnishes essential cloud-native functionalities through either automatic provisioning or standardized configuration patterns. [!TIP] Always strive to use the latest version of .NET Aspire integrations to take advantage of the latest features, improvements, and security updates. Integration responsibilities Most .NET Aspire integrations are made up of two separate libraries, each with a different responsibility. One type represents resources within the app host projectâ€”known as hosting integrations. The other type of integration represents client libraries that connect to the resources modeled by hosting integrations, and they\'re known as client integrations. Hosting integrations Hosting integrations configure applications by provisioning resources (like containers or cloud resources) or pointing to existing instances (such as a local SQL server). These packages model various services, platforms, or capabilities, including caches, databases, logging, storage, and messaging systems. Hosting integrations extend the For information on creating a custom hosting integration, see Create custom .NET Aspire hosting integration. Client integrations Client integrations wire up client libraries to dependency injection (DI), define configuration schema, and add health checks, resiliency, and telemetry where applicable. .NET Aspire client integration libraries are prefixed with Aspire. and then include the full package name that they integrate with, such as Aspire.StackExchange.Redis. These packages configure existing client libraries to connect to hosting integrations. They extend the For more information on creating a custom client integration, see Create custom .NET Aspire client integrations. Relationship between hosting and client integrations Hosting and client integrations are best when used together, but are not coupled and can be used separately. Some hosting integrations don\'t have a corresponding client integration. Configuration is what makes the hosting integration work with the client integration. Consider the following diagram that depicts the relationship between hosting and client integrations: :::image type=""content"" source=""media/integrations-thumb.png"" lightbox=""media/integrations.png"" alt-text=""A diagram ""::: The app host project is where hosting integrations are used. Configuration, specifically environment variables, is injected into projects, executables, and containers, allowing client integrations to connect to the hosting integrations.']",.NET Aspire integrations include PostgreSQL as part of a curated suite of NuGet packages to facilitate the integration of cloud-native applications. These integrations provide essential cloud-native functionalities through automatic provisioning or standardized configuration patterns.,single_hop_specifc_query_synthesizer
26,what azure app configuration do?,"['library for interacting with Azure App Configuration . - Learn more : ðŸ“„ Azure Application Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ApplicationInsights - Client : N/A A library for interacting with Azure Application Insights . - Learn more : ðŸ“„ Azure Cosmos DB - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos A library for accessing Azure Cosmos DB databases with Entity Framework Core . - Learn more : ðŸ“„ Azure Cosmos DB - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.Azure.Cosmos A library for accessing Azure Cosmos DB databases. - Learn more : ðŸ“„ Azure Event Hubs - Hosting : ðŸ“¦ Aspire.Hosting.Azure.EventHubs - Client : ðŸ“¦ Aspire.Azure.Messaging.EventHubs A library for accessing Azure Event Hubs . - Learn more : ðŸ“„ Azure Functions - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Functions - Client : N/A A library for integrating with Azure Functions . - Learn more : ðŸ“„ Azure Key Vault - Hosting : ðŸ“¦ Aspire.Hosting.Azure.KeyVault - Client : ðŸ“¦ Aspire.Azure.Security.KeyVault A library for accessing Azure Key Vault . - Learn more : ðŸ“„ Azure Operational Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.OperationalInsights - Client : N/A A library for interacting with Azure Operational Insights . - Learn more : ðŸ“„ Azure AI OpenAI - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CognitiveServices - Client : ðŸ“¦ Aspire.Azure.AI.OpenAI A library for accessing Azure AI OpenAI or OpenAI functionality. - Learn more : ðŸ“„ Azure PostgreSQL - Hosting : ðŸ“¦ Aspire.Hosting.Azure.PostgreSQL - Client : N/A A library for interacting with Azure Database for PostgreSQL . - Learn more : ðŸ“„ Azure AI Search - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Search - Client : ðŸ“¦ Aspire.Azure.Search.Documents A library for accessing Azure AI Search functionality. - Learn more : ðŸ“„ Azure Service Bus - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ServiceBus - Client : ðŸ“¦ Aspire.Azure.Messaging.ServiceBus A library for accessing Azure Service Bus . - Learn more : ðŸ“„ Azure SignalR Service - Hosting : ðŸ“¦ Aspire.Hosting.Azure.SignalR - Client : Microsoft.Azure.SignalR A library for accessing Azure SignalR Service . - Learn more : ðŸ“„ Azure Blob Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Blobs A library for accessing Azure Blob Storage . - Learn more : ðŸ“„ Azure Storage Queues - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Queues A library for accessing Azure Storage Queues . - Learn more : ðŸ“„ Azure Table Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Data.Tables A library for accessing the Azure Table service. - Learn more : ðŸ“„ Azure Web PubSub - Hosting : ðŸ“¦ Aspire.Hosting.Azure.WebPubSub - Client : ðŸ“¦ Aspire.Azure.Messaging.WebPubSub A library for accessing the Azure Web PubSub service. Amazon Web Services (AWS) hosting integrations Integration docs and NuGet packages Description - Learn more : ðŸ“„ AWS Hosting - Hosting : ðŸ“¦ Aspire.Hosting.AWS - Client : N/A A library for modeling AWS resources . For more information, see GitHub: Aspire.Hosting.AWS library. Community Toolkit integrations [!NOTE] The Community Toolkit integrations are community-driven and maintained by the .NET Aspire community. These integrations are not officially supported by the .NET Aspire team. Integration docs and NuGet packages Description - Learn More : ðŸ“„ Azure Static Web Apps emulator - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps - Client : N/A A hosting integration for the Azure Static Web Apps emulator (Note: this does not support deployment of a project to Azure Static Web Apps). - Learn More : ðŸ“„ Bun hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Bun - Client : N/A A hosting integration for Bun apps. - Learn More : ðŸ“„ Deno hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Deno - Client : N/A A hosting integration for Deno apps. - Learn More : ðŸ“„ Go hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Golang - Client : N/A A hosting integration for Go apps. - Learn More : ðŸ“„ Java/Spring hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Java - Client : N/A A integration for running Java code in .NET Aspire either using the local JDK or using a container. - Learn More : ðŸ“„ Node.js hosting extensions - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.NodeJs.Extensions - Client : N/A An integration that contains some additional extensions for running Node.js applications - Learn More : ðŸ“„ Ollama - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Ollama - Client : ðŸ“¦ Aspire.CommunitToolkit.OllamaSharp An Aspire component leveraging the Ollama container with support for downloading a model on startup. - Learn More : ðŸ“„ Meilisearch hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Meilisearch - Client : ðŸ“¦ Aspire.CommunitToolkit.Meilisearch An Aspire component leveraging the Meilisearch container. - Learn More : ðŸ“„ Rust hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Rust - Client : N/A A hosting integration for Rust apps. - Learn More : ðŸ“„ SQL Database projects hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects - Client : N/A An Aspire hosting integration for SQL Database Projects. For more information, see .NET Aspire Community Toolkit.']",The context does not provide specific information about Azure App Configuration.,single_hop_specifc_query_synthesizer
27,what is Aspire.AppHost.Sdk do?,"['title: .NET Aspire orchestration overview description: Learn the fundamental concepts of .NET Aspire orchestration and explore the various APIs for adding resources and expressing dependencies. ms.date: 12/13/2024 ms.topic: overview uid: dotnet/aspire/app-host .NET Aspire orchestration overview .NET Aspire provides APIs for expressing resources and dependencies within your distributed application. In addition to these APIs, there\'s tooling that enables several compelling scenarios. The orchestrator is intended for local development purposes and isn\'t supported in production environments. Before continuing, consider some common terminology used in .NET Aspire: App model: A collection of resources that make up your distributed application ( App host/Orchestrator project: The .NET project that orchestrates the app model, named with the *.AppHost suffix (by convention). Resource: A resource is a dependent part of an application, such as a .NET project, container, executable, database, cache, or cloud service. It represents any part of the application that can be managed or referenced. Integration: An integration is a NuGet package for either the app host that models a resource or a package that configures a client for use in a consuming app. For more information, see .NET Aspire integrations overview. Reference: A reference defines a connection between resources, expressed as a dependency using the [!NOTE] .NET Aspire\'s orchestration is designed to enhance your local development experience by simplifying the management of your cloud-native app\'s configuration and interconnections. While it\'s an invaluable tool for development, it\'s not intended to replace production environment systems like Kubernetes, which are specifically designed to excel in that context. Define the app model .NET Aspire empowers you to seamlessly build, provision, deploy, configure, test, run, and observe your distributed applications. All of these capabilities are achieved through the utilization of an app model that outlines the resources in your .NET Aspire solution and their relationships. These resources encompass projects, executables, containers, and external services and cloud resources that your app depends on. Within every .NET Aspire solution, there\'s a designated App host project, where the app model is precisely defined using methods available on the ```csharp // Create a new app model builder var builder = DistributedApplication.CreateBuilder(args); // TODO: // Add resources to the app model // Express dependencies between resources builder.Build().Run(); ``` App host project The app host project handles running all of the projects that are part of the .NET Aspire project. In other words, it\'s responsible for orchestrating all apps within the app model. The project itself is a .NET executable project that references the ðŸ“¦ Aspire.Hosting.AppHost NuGet package, sets the IsAspireHost property to true, and references the .NET Aspire SDK: ```xml <Sdk Name=""Aspire.AppHost.Sdk"" Version=""9.0.0"" /> <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net9.0</TargetFramework> <IsAspireHost>true</IsAspireHost> <!-- Omitted for brevity --> </PropertyGroup> <ItemGroup> <PackageReference Include=""Aspire.Hosting.AppHost"" Version=""9.0.0"" /> </ItemGroup> <!-- Omitted for brevity --> ``` The following code describes an app host Program with two project references and a Redis cache: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code: Creates a new app model builder using the Adds a Redis cache resource named ""cache"" using the Adds a project resource named ""apiservice"" using the Adds a project resource named ""webfrontend"" using the Specifies that the project has external HTTP endpoints using the Adds a reference to the cache resource and waits for it to be ready using the Adds a reference to the apiservice resource and waits for it to be ready using the Builds and runs the app model using the The example code uses the .NET Aspire Redis hosting integration. To help visualize the relationship between the app host project and the resources it describes, consider the following diagram: :::image type=""content"" source=""../media/app-host-resource-diagram.png"" lightbox=""../media/app-host-resource-diagram.png"" alt-text=""The relationship between the projects in the .NET Aspire Starter Application template.""::: Each resource must be uniquely named. This diagram shows each resource and the relationships between them. The container resource is named ""cache"" and the project resources are named ""apiservice"" and ""webfrontend"". The web frontend project references the cache and API service projects. When you\'re expressing references in this way, the web frontend project is saying that it depends on these two resources, the ""cache"" and ""apiservice"" respectively.']",Aspire.AppHost.Sdk is a .NET SDK used in the app host project to orchestrate all apps within the app model. It is referenced in the project to set the IsAspireHost property to true and to manage the distributed application resources.,single_hop_specifc_query_synthesizer
28,How you use Podman for container management in .NET Aspire?,"['APIs for adding and expressing resources .NET Aspire hosting integrations and client integrations are both delivered as NuGet packages, but they serve different purposes. While client integrations provide client library configuration for consuming apps outside the scope of the app host, hosting integrations provide APIs for expressing resources and dependencies within the app host. For more information, see .NET Aspire integrations overview: Integration responsibilities. Express container resources To express a Docker ```csharp var builder = DistributedApplication.CreateBuilder(args); var ollama = builder.AddContainer(""ollama"", ""ollama/ollama"") .WithBindMount(""ollama"", ""/root/.ollama"") .WithBindMount(""./ollamaconfig"", ""/usr/config"") .WithHttpEndpoint(port: 11434, targetPort: 11434, name: ""ollama"") .WithEntrypoint(""/usr/config/entrypoint.sh"") .WithContainerRuntimeArgs(""--gpus=all""); ``` For more information, see GPU support in Docker Desktop. Podman ```csharp var builder = DistributedApplication.CreateBuilder(args); var ollama = builder.AddContainer(""ollama"", ""ollama/ollama"") .WithBindMount(""ollama"", ""/root/.ollama"") .WithBindMount(""./ollamaconfig"", ""/usr/config"") .WithHttpEndpoint(port: 11434, targetPort: 11434, name: ""ollama"") .WithEntrypoint(""/usr/config/entrypoint.sh"") .WithContainerRuntimeArgs(""--device"", ""nvidia.com/gpu=all""); ``` For more information, see GPU support in Podman. The preceding code adds a container resource named ""ollama"" with the image ollama/ollama. The container resource is configured with multiple bind mounts, a named HTTP endpoint, an entrypoint that resolves to Unix shell script, and container run arguments with the Customize container resources All To help exemplify this, imagine a scenario where you\'re using the .NET Aspire Redis integration. If the Redis integration relies on the 7.4 tag and you want to use the latest tag instead, you can chain a call to the ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache"") .WithImageTag(""latest""); // Instead of using the ""7.4"" tag, the ""cache"" // container resource now uses the ""latest"" tag. ``` For more information and additional APIs available, see Container resource lifecycle When the app host is run, the Docker First, the container is created using the docker container create command. Then, the container is started using the docker container start command. docker container create: Creates a new container from the specified image, without starting it. docker container start: Start one or more stopped containers. These commands are used instead of docker run to manage attached container networks, volumes, and ports. Calling these commands in this order allows any IP (network configuration) to already be present at initial startup. Podman First, the container is created using the podman container create command. Then, the container is started using the podman container start command. podman container create: Creates a writable container layer over the specified image and prepares it for running. podman container start: Start one or more stopped containers. These commands are used instead of podman run to manage attached container networks, volumes, and ports. Calling these commands in this order allows any IP (network configuration) to already be present at initial startup. Beyond the base resource types, Container resource lifetime By default, container resources use the session container lifetime. This means that every time the app host process is started, the container is created and started. When the app host stops, the container is stopped and removed. Container resources can opt-in to a persistent lifetime to avoid unnecessary restarts and use persisted container state. To achieve this, chain a call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var ollama = builder.AddContainer(""ollama"", ""ollama/ollama"") .WithLifetime(ContainerLifetime.Persistent); ``` The preceding code adds a container resource named ""ollama"" with the image ""ollama/ollama"" and a persistent lifetime. Connection string and endpoint references It\'s common to express dependencies between project resources. Consider the following example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject Project-to-project references are handled differently than resources that have well-defined connection strings. Instead of connection string being injected into the ""webfrontend"" resource, environment variables to support service discovery are injected. Method Environment variable WithReference(cache) ConnectionStrings__cache=""localhost:62354"" WithReference(apiservice) services__apiservice__http__0=""http://localhost:5455"" services__apiservice__https__0=""https://localhost:7356"" Adding a reference to the ""apiservice"" project results in service discovery environment variables being added to the frontend. This is because typically, project-to-project communication occurs over HTTP/gRPC. For more information, see .NET Aspire service discovery. To get specific endpoints from a Then call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var customContainer = builder.AddContainer(""myapp"", ""mycustomcontainer"") .WithHttpEndpoint(port: 9043, name: ""endpoint""); var endpoint = customContainer.GetEndpoint(""endpoint""); var apiservice = builder.AddProject Method Environment variable WithReference(endpoint) services__myapp__endpoint__0=https://localhost:9043 The port parameter is the port that the container is listening on. For more information on container ports, see Container ports. For more information on service discovery, see .NET Aspire service discovery. Service endpoint environment variable format In the preceding section, the When one resource depends on another resource, the app host injects environment variables into the dependent resource. These environment variables configure the dependent resource to connect to the resource it depends on. The format of the environment variables is specific to .NET Aspire and expresses service endpoints in a way that is compatible with Service Discovery. Service endpoint environment variable names are prefixed with services__ (double underscore), then the service name, the endpoint name, and finally the index. The index supports multiple endpoints for a single service, starting with 0 for the first endpoint and incrementing for each endpoint. Consider the following environment variable examples: Environment services__apiservice__http__0 The preceding environment variable expresses the first HTTP endpoint for the apiservice service. The value of the environment variable is the URL of the service endpoint. A named endpoint might be expressed as follows: Environment services__apiservice__myendpoint__0 In the preceding example, the apiservice service has a named endpoint called myendpoint. The value of the environment variable is the URL of the service endpoint. Reference existing resources Some situations warrant that you reference an existing resource, perhaps one that is deployed to a cloud provider. For example, you might want to reference an Azure database. In this case, you\'d rely on the Execution context to dynamically determine whether the app host is running in ""run"" mode or ""publish"" mode. If you\'re running locally and want to rely on a cloud resource, you can use the IsRunMode property to conditionally add the reference. You might choose to instead create the resource in publish mode. Some hosting integrations support providing a connection string directly, which can be used to reference an existing resource. Likewise, there might be use cases where you want to integrate .NET Aspire into']","Podman is used for container management in .NET Aspire by creating a container using the podman container create command, which creates a writable container layer over the specified image and prepares it for running. The container is then started using the podman container start command. These commands are used instead of podman run to manage attached container networks, volumes, and ports, allowing any IP (network configuration) to already be present at initial startup.",single_hop_specifc_query_synthesizer
29,Culd yu explane how Projects are used in .NET Aspire and how they can be scaled within the app model?,"['Built-in resource types .NET Aspire projects are made up of a set of resources. The primary base resource types in the ðŸ“¦ Aspire.Hosting.AppHost NuGet package are described in the following table: Method Resource type Description A .NET project, for example, an ASP.NET Core web app. A container image, such as a Docker image. An executable file, such as a Node.js app . A parameter resource that can be used to express external parameters . Project resources represent .NET projects that are part of the app model. When you add a project reference to the app host project, the .NET Aspire SDK generates a type in the Projects namespace for each referenced project. For more information, see .NET Aspire SDK: Project references. To add a project to the app model, use the ```csharp var builder = DistributedApplication.CreateBuilder(args); // Adds the project ""apiservice"" of type ""Projects.AspireApp_ApiService"". var apiservice = builder.AddProject Projects can be replicated and scaled out by adding multiple instances of the same project to the app model. To configure replicas, use the ```csharp var builder = DistributedApplication.CreateBuilder(args); // Adds the project ""apiservice"" of type ""Projects.AspireApp_ApiService"". var apiservice = builder.AddProject The preceding code adds three replicas of the ""apiservice"" project resource to the app model. For more information, see .NET Aspire dashboard: Resource replicas. Reference resources A reference represents a dependency between resources. For example, you can probably imagine a scenario where you a web frontend depends on a Redis cache. Consider the following example app host Program C# code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); builder.AddProject The ""webfrontend"" project resource uses Waiting for resources In some cases, you might want to wait for a resource to be ready before starting another resource. For example, you might want to wait for a database to be ready before starting an API that depends on it. To express this dependency, use the ```csharp var builder = DistributedApplication.CreateBuilder(args); var postgres = builder.AddPostgres(""postgres""); var postgresdb = postgres.AddDatabase(""postgresdb""); builder.AddProject In the preceding code, the ""apiservice"" project resource waits for the ""postgresdb"" database resource to enter the Other cases might warrant waiting for a resource to run to completion, either ```csharp var builder = DistributedApplication.CreateBuilder(args); var postgres = builder.AddPostgres(""postgres""); var postgresdb = postgres.AddDatabase(""postgresdb""); var migration = builder.AddProject builder.AddProject In the preceding code, the ""apiservice"" project resource waits for the ""migration"" project resource to run to completion before starting. The ""migration"" project resource waits for the ""postgresdb"" database resource to enter the']","In .NET Aspire, projects are part of the app model and are represented as project resources. When you add a project reference to the app host project, the .NET Aspire SDK generates a type in the Projects namespace for each referenced project. Projects can be replicated and scaled out by adding multiple instances of the same project to the app model. For example, you can add three replicas of the 'apiservice' project resource to the app model using the DistributedApplication.CreateBuilder method.",single_hop_specifc_query_synthesizer
30,How does the .NET AspireApp facilitate the integration of dependencies and manage life cycle events within a cloud-native application architecture?,"['an existing solution. One common approach is to add the .NET Aspire app host project to an existing solution. Within your app host, you express dependencies by adding project references to the app host and building out the app model. For example, one project might depend on another. These dependencies are expressed using the App host life cycles The .NET Aspire app host exposes several life cycles that you can hook into by implementing the Order Method Description 1 Executes before the distributed application starts. 2 Executes after the orchestrator allocates endpoints for resources in the application model. 3 Executes after the resource was created by the orchestrator. While the app host provides life cycle hooks, you might want to register custom events. For more information, see Eventing in .NET Aspire. Register a life cycle hook To register a life cycle hook, implement the :::code source=""snippets/lifecycles/AspireApp/AspireApp.AppHost/Program.cs""::: The preceding code: Implements the Registers the life cycle hook with the app host using the Logs a message for all the events. When this app host is run, the life cycle hook is executed for each event. The following output is generated: Output info: LifecycleLogger[0] BeforeStartAsync info: Aspire.Hosting.DistributedApplication[0] Aspire version: 9.0.0 info: Aspire.Hosting.DistributedApplication[0] Distributed application starting. info: Aspire.Hosting.DistributedApplication[0] Application host directory is: ..\\AspireApp\\AspireApp.AppHost info: LifecycleLogger[0] AfterEndpointsAllocatedAsync info: Aspire.Hosting.DistributedApplication[0] Now listening on: https://localhost:17043 info: Aspire.Hosting.DistributedApplication[0] Login to the dashboard at https://localhost:17043/login?t=d80f598bc8a64c7ee97328a1cbd55d72 info: LifecycleLogger[0] AfterResourcesCreatedAsync info: Aspire.Hosting.DistributedApplication[0] Distributed application started. Press Ctrl+C to shut down. The preferred way to hook into the app host life cycle is to use the eventing API. For more information, see Eventing in .NET Aspire. Execution context The This information can be useful when you want to conditionally execute code based on the current operation. Consider the following example that demonstrates using the IsRunMode property. In this case, an extension method is used to generate a stable node name for RabbitMQ for local development runs. ```csharp private static IResourceBuilder return builder; } ``` The execution context is often used to conditionally add resources or connection strings that point to existing resources. Consider the following example that demonstrates conditionally adding Redis or a connection string based on the execution context: ```csharp var builder = DistributedApplication.CreateBuilder(args); var redis = builder.ExecutionContext.IsRunMode ? builder.AddRedis(""redis"") : builder.AddConnectionString(""redis""); builder.AddProject builder.Build().Run(); ``` In the preceding code: If the app host is running in ""run"" mode, a Redis container resource is added. If the app host is running in ""publish"" mode, a connection string is added. This logic can easily be inverted to connect to an existing Redis resource when you\'re running locally, and create a new Redis resource when you\'re publishing. [!IMPORTANT] .NET Aspire provides common APIs to control the modality of resource builders, allowing resources to behave differently based on the execution mode. The fluent APIs are prefixed with RunAs* and PublishAs*. The RunAs* APIs influence the local development (or run mode) behavior, whereas the PublishAs* APIs influence the publishing of the resource. See also .NET Aspire integrations overview .NET Aspire SDK Eventing in .NET Aspire Service discovery in .NET Aspire .NET Aspire service defaults Expressing external parameters .NET Aspire inner-loop networking overview']","The .NET AspireApp facilitates the integration of dependencies by allowing the addition of project references to the app host, which helps in building out the app model. It manages life cycle events by exposing several life cycles that can be hooked into, such as executing before the distributed application starts, after the orchestrator allocates endpoints, and after resources are created. These life cycle hooks can be registered using the app host, and custom events can be registered for more specific needs. The app host logs messages for all events, providing detailed information about the application's state and operations.",single_hop_specifc_query_synthesizer
31,How does Visual Studio facilitate the selection of launch profiles for .NET applications?,"['title: .NET Aspire and launch profiles description: Learn how .NET Aspire integrates with .NET launch profiles. ms.date: 04/23/2024 .NET Aspire and launch profiles .NET Aspire makes use of launch profiles defined in both the app host and service projects to simplify the process of configuring multiple aspects of the debugging and publishing experience for .NET Aspire-based distributed applications. Launch profile basics When creating a new .NET application from a template developers will often see a Properties directory which contains a file named launchSettings.json. The launch settings file contains a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. The code below is an example of launch profiles in a launchSettings.json file for an ASP.NET Core application. json { ""$schema"": ""http://json.schemastore.org/launchsettings.json"", ""profiles"": { ""http"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": false, ""applicationUrl"": ""http://localhost:5130"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"" } }, ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": false, ""applicationUrl"": ""https://localhost:7106;http://localhost:5130"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"" } } } } The launchSettings.json file above defines two launch profiles, http and https. Each has its own set of environment variables, launch URLs and other options. When launching a .NET Core application developers can choose which launch profile to use. dotnetcli dotnet run --launch-profile https If no launch profile is specified, then the first launch profile is selected by default. It is possible to launch a .NET Core application without a launch profile using the --no-launch-profile option. Some fields from the launchSettings.json file are translated to environment variables. For example, the applicationUrl field is converted to the ASPNETCORE_URLS environment variable which controls which address and port ASP.NET Core binds to. In Visual Studio it\'s possible to select the launch profile when launching the application making it easy to switch between configuration scenarios when manually debugging issues: :::image type=""content"" loc-scope=""visual-studio"" source=""./media/launch-profiles/vs-launch-profile-toolbar.png"" lightbox=""./media/launch-profiles/vs-launch-profile-toolbar.png"" alt-text=""Screenshot of the standard toolbar in Visual Studio with the launch profile selector highlighted.""::: When a .NET application is launched with a launch profile a special environment variable called DOTNET_LAUNCH_PROFILE is populated with the name of the launch profile that was used when launching the process. Launch profiles for .NET Aspire app host In .NET Aspire, the AppHost is just a .NET application. As a result it has a launchSettings.json file just like any other application. Here is an example of the launchSettings.json file generated when creating a new .NET Aspire project from the starter template (dotnet new aspire-starter). json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } }, ""http"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""http://localhost:19240"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""http://localhost:20154"" } } } } The .NET Aspire templates have a very similar set of launch profiles to a regular ASP.NET Core application. When the .NET Aspire app project launches, it starts a For information about app host configuration options, see .NET Aspire app host configuration.']","In Visual Studio, it's possible to select the launch profile when launching the application, making it easy to switch between configuration scenarios when manually debugging issues.",single_hop_specifc_query_synthesizer
32,How does .NET Aspire manage launch profiles for ASP.NET Core service projects?,"['Relationship between app host launch profiles and service projects In .NET Aspire the app host is responsible for coordinating the launch of multiple service projects. When you run the app host either via the command line or from Visual Studio (or other development environment) a launch profile is selected for the app host. In turn, the app host will attempt to find a matching launch profile in the service projects it is launching and use those options to control the environment and default networking configuration for the service project. When the app host launches a service project it doesn\'t simply launch the service project using the --launch-profile option. Therefore, there will be no DOTNET_LAUNCH_PROFILE environment variable set for service projects. This is because .NET Aspire modifies the ASPNETCORE_URLS environment variable (derived from the applicationUrl field in the launch profile) to use a different port. By default, .NET Aspire inserts a reverse proxy in front of the ASP.NET Core application to allow for multiple instances of the application using the Other settings such as options from the environmentVariables field are passed through to the application without modification. Control launch profile selection Ideally, it\'s possible to align the launch profile names between the app host and the service projects to make it easy to switch between configuration options on all projects coordinated by the app host at once. However, it may be desirable to control launch profile that a specific project uses. The csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject<Projects.InventoryService>( ""inventoryservice"", launchProfileName: ""mylaunchprofile""); The preceding code shows that the inventoryservice resource (a .NET project) is launched using the options from the mylaunchprofile launch profile. The launch profile precedence logic is as follows: Use the launch profile specified by launchProfileName argument if specified. Use the launch profile with the same name as the AppHost (determined by reading the DOTNET_LAUNCH_PROFILE environment variable). Use the default (first) launch profile in launchSettings.json. Don\'t use a launch profile. To force a service project to launch without a launch profile the launchProfileName argument on the Launch profiles and endpoints When adding an ASP.NET Core project to the app host, .NET Aspire will parse the launchSettings.json file selecting the appropriate launch profile and automatically generate endpoints in the application model based on the URL(s) present in the applicationUrl field. To modify the endpoints that are automatically injected the csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject<Projects.InventoryService>(""inventoryservice"") .WithEndpoint(""https"", endpoint => endpoint.IsProxied = false); The preceding code shows how to disable the reverse proxy that .NET Aspire deploys in front for the .NET Core application and instead allows the .NET Core application to respond directly on requests over HTTP(S). For more information on networking options within .NET Aspire see .NET Aspire inner loop networking overview. See also Kestrel configured endpoints']",".NET Aspire manages launch profiles for ASP.NET Core service projects by coordinating the launch of multiple service projects through the app host. When the app host is run, a launch profile is selected, and it attempts to find a matching launch profile in the service projects. The ASPNETCORE_URLS environment variable is modified to use a different port, and a reverse proxy is inserted by default. Launch profile selection can be controlled by specifying a launchProfileName argument, using the same name as the AppHost, or defaulting to the first launch profile in launchSettings.json.",single_hop_specifc_query_synthesizer
33,How does ExampleService utilize Meilisearch clients?,"['title: .NET Aspire Community Toolkit Meilisearch integration description: Learn how to use the .NET Aspire Meilisearch hosting and client integration to run the Meilisearch container and accessing it via the Meilisearch client. ms.date: 10/24/2024 .NET Aspire Community Toolkit Meilisearch integration [!INCLUDE includes-hosting-and-client] [!INCLUDE banner] In this article, you learn how to use the .NET Aspire Meilisearch hosting integration to run Meilisearch container and accessing it via the Meilisearch client. Hosting integration To run the Meilisearch container, install the ðŸ“¦ CommunityToolkit.Aspire.Hosting.Meilisearch NuGet package in the app host project. .NET CLI dotnetcli dotnet add package CommunityToolkit.Aspire.Hosting.Meilisearch PackageReference xml <PackageReference Include=""CommunityToolkit.Aspire.Hosting.Meilisearch"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Meilisearch resource In the app host project, register and consume the Meilisearch integration using the AddMeilisearch extension method to add the Meilisearch container to the application builder. ```csharp var builder = DistributedApplication.CreateBuilder(args); var meilisearch = builder.AddMeilisearch(""meilisearch""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/getmeili/meilisearch image, it creates a new Meilisearch instance on your local machine. A reference to your Meilisearch resource (the meilisearch variable) is added to the ExampleProject. The Meilisearch resource includes a randomly generated master key using the For more information, see Container resource lifecycle. Add Meilisearch resource with data volume To add a data volume to the Meilisearch resource, call the Aspire.Hosting.MeilisearchBuilderExtensions.WithDataVolume method on the Meilisearch resource: ```csharp var builder = DistributedApplication.CreateBuilder(args); var meilisearch = builder.AddMeilisearch(""meilisearch"") .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Meilisearch data outside the lifecycle of its container. The data volume is mounted at the /meili_data path in the Meilisearch container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Meilisearch resource with data bind mount To add a data bind mount to the Meilisearch resource, call the Aspire.Hosting.MeilisearchBuilderExtensions.WithDataBindMount method: ```csharp var builder = DistributedApplication.CreateBuilder(args); var meilisearch = builder.AddMeilisearch(""meilisearch"") .WithDataBindMount( source: @""C:\\Meilisearch\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Meilisearch data across container restarts. The data bind mount is mounted at the C:\\Meilisearch\\Data on Windows (or /Meilisearch/Data on Unix) path on the host machine in the Meilisearch container. For more information on data bind mounts, see Docker docs: Bind mounts. Add Meilisearch resource with master key parameter When you want to explicitly provide the master key used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var masterkey = builder.AddParameter(""masterkey"", secret: true); var meilisearch = builder.AddMeilisearch(""meilisearch"", masterkey); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Client integration To get started with the .NET Aspire Meilisearch client integration, install the ðŸ“¦ CommunityToolkit.Aspire.Meilisearch NuGet package in the client-consuming project, that is, the project for the application that uses the Meilisearch client. .NET CLI dotnetcli dotnet add package CommunityToolkit.Aspire.Meilisearch PackageReference xml <PackageReference Include=""CommunityToolkit.Aspire.Meilisearch"" Version=""*"" /> Add Meilisearch client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the Microsoft.Extensions.Hosting.AspireMeilisearchExtensions.AddMeilisearchClient extension method on any csharp builder.AddMeilisearchClient(connectionName: ""meilisearch""); [!TIP] The connectionName parameter must match the name used when adding the Meilisearch resource in the app host project. For more information, see Add Meilisearch resource. You can then retrieve the MeilisearchClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(MeilisearchClient client) { // Use client... } Add keyed Meilisearch client There might be situations where you want to register multiple MeilisearchClient instances with different connection names. To register keyed Meilisearch clients, call the Microsoft.Extensions.Hosting.AspireMeilisearchExtensions.AddKeyedMeilisearchClient csharp builder.AddKeyedMeilisearchClient(name: ""products""); builder.AddKeyedMeilisearchClient(name: ""orders""); Then you can retrieve the MeilisearchClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""products"")] MeilisearchClient productsClient, [FromKeyedServices(""orders"")] MeilisearchClient ordersClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services.']","In the ExampleService, MeilisearchClient instances are retrieved using dependency injection. For example, the service can retrieve connections from keyed services such as 'products' and 'orders' using the MeilisearchClient.",single_hop_specifc_query_synthesizer
34,"How do you connect an ASP.NET Core app to Azure Blob Storage using .NET Aspire integrations, and how can you verify the data submission locally?","['<1-hop>\n\ntitle: Connect an ASP.NET Core app to .NET Aspire storage integrations description: Learn how to connect an ASP.NET Core app to .NET Aspire storage integrations. ms.date: 11/08/2024 ms.topic: tutorial zone_pivot_groups: azure-storage-mechanism ms.custom: devx-track-extended-azdevcli Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations Cloud-native apps often require scalable storage solutions that provide capabilities like blob storage, queues, or semi-structured NoSQL databases. .NET Aspire integrations simplify connections to various storage services, such as Azure Blob Storage. In this tutorial, you\'ll create an ASP.NET Core app that uses .NET Aspire integrations to connect to Azure Blob Storage and Azure Queue Storage to submit support tickets. The app sends the tickets to a queue for processing and uploads an attachment to storage. You\'ll learn how to: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire integrations Add .NET Aspire integrations to connect to multiple storage services Configure and use .NET Aspire Component features to send and receive data [!INCLUDE aspire-prereqs] Explore the completed sample app A completed version of the sample app from this tutorial is available on GitHub. The project is also structured as a template for the Azure Developer CLI, meaning you can use the azd up command to automate Azure resource provisioning if you have the tool installed. bash git clone https://github.com/Azure-Samples/dotnet-aspire-connect-storage.git Set up the Azure Storage resources :::zone pivot=""azure-portal,azure-cli"" For this article, you\'ll need data contributor access to an Azure Storage account with a blob container and storage queue. Ensure you have the following resources and configurations available: :::zone-end :::zone pivot=""azurite"" For this article, you\'ll need to create a blob container and storage queue resource in your local development environment using an emulator. To do so, use Azurite. Azurite is a free, open source, cross-platform Azure Storage API compatible server (emulator) that runs in a Docker container. To use the emulator you need to install Azurite. :::zone-end :::zone pivot=""azure-portal"" An Azure Storage account - Create a storage account. A Blob Storage container named fileuploads - Create a blob storage container. A Storage Queue named tickets - Create a storage queue. :::zone-end :::zone pivot=""azure-cli"" Run the following commands in the Azure CLI or CloudShell to set up the required Azure Storage resources: azurecli-interactive az group create --name aspirestorage --location eastus2 az storage account create -n aspirestorage -g aspirestorage -l eastus2 az storage container create -n fileuploads --account-name aspirestorage az storage queue create -n tickets --account-name aspirestorage :::zone-end :::zone pivot=""azure-portal,azure-cli"" You also need to assign the following roles to the user account you are logged into Visual Studio with: Storage Blob Data Contributor - Assign an Azure RBAC role Storage Queue Data Contributor - Assign an Azure RBAC role :::zone-end :::zone pivot=""azure-developer-cli"" The Azure Developer CLI enables you to provision and deploy Azure resources using a template system. This tutorial provides a complete template that provisions the required Azure resources and includes the completed sample application code. Run the following commands to initialize and run the template: Run azd auth login to sign-in to Azure: azurecli azd auth login Run azd init to clone and initialize the sample template: azurecli azd init --template dotnet-aspire-connect-storage Run azd up to provision the Azure resources: azurecli azd up When prompted, select the subscription and Azure region for the provisioned resources. The template runs and completes the following tasks for you: Creates an Azure Storage Account with blob and queue services enabled Creates a blob storage container named fileUploads Creates a queue named tickets Assigns the following roles to the user account that ran the template. Storage Blob Data Contributor Storage Queue Data Contributor After the operation completes successfully, you have two options moving forward: Option 1: Run the .NET sample app in the template src directory to experiment with the completed app. Option 2: Build the sample app step by step using the sections ahead and connect it to the Azure resources provisioned by azd. :::zone-end', '<2-hop>\n\nRun and test the app locally The sample app is now ready for testing. Verify that the submitted form data is sent to Azure Blob Storage and Azure Queue Storage by completing the following steps: Visual Studio Press the run button at the top of Visual Studio to launch your .NET Aspire project dashboard in the browser. On the resources page, in the aspirestorage.web row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: .NET CLI In a terminal window at the root of your project, use the dotnet run command to start the app: dotnetcli dotnet run --project AspireStorage.AppHost On the resources page, in the aspirestorage row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: Summary The example app that you built demonstrates persisting blobs from an ASP.NET Core Blazor Web App and processing queues in a .NET Worker Service. Your app connects to Azure Storage using .NET Aspire integrations. The app sends the support tickets to a queue for processing and uploads an attachment to storage. :::zone pivot=""azurite"" Since you choose to use Azurite, there\'s no need to clean up these resources when you\'re done testing them, as you created them locally in the context of an emulator. The emulator enabled you to test your app locally without incurring any costs, as no Azure resources were provisioned or created. :::zone-end :::zone pivot=""azure-portal,azure-cli"" [!INCLUDE clean-up-resources] :::zone-end']","To connect an ASP.NET Core app to Azure Blob Storage using .NET Aspire integrations, you need to set up the app with .NET Aspire integrations to connect to Azure Blob Storage and Azure Queue Storage. This involves creating a storage account, a blob storage container named 'fileuploads', and a storage queue named 'tickets'. You can use the Azure Developer CLI to automate the provisioning of these resources. Once set up, you can run and test the app locally by submitting form data through the app's UI, which sends the data to Azure Blob Storage and Azure Queue Storage. Verification can be done by checking the uploaded file in the Azure Storage Account's 'Documents' container and reviewing the queue processing logs in the .NET Aspire dashboard.",multi_hop_abstract_query_synthesizer
35,how .NET Aspire do integration health checks?,"['<1-hop>\n\ntitle: .NET Aspire health checks description: Explore .NET Aspire health checks ms.date: 09/24/2024 ms.topic: quickstart uid: dotnet/aspire/health-checks Health checks in .NET Aspire Health checks provide availability and state information about an app. Health checks are often exposed as HTTP endpoints, but can also be used internally by the app to write logs or perform other tasks based on the current health. Health checks are typically used in combination with an external monitoring service or container orchestrator to check the status of an app. The data reported by health checks can be used for various scenarios: Influence decisions made by container orchestrators, load balancers, API gateways, and other management services. For instance, if the health check for a containerized app fails, it might be skipped by a load balancer routing traffic. Verify that underlying dependencies are available, such as a database or cache, and return an appropriate status message. Trigger alerts or notifications when an app isn\'t responding as expected. .NET Aspire health check endpoints .NET Aspire exposes two default health check HTTP endpoints in Development environments when the AddServiceDefaults and MapDefaultEndpoints methods are called from the :::no-loc text=""Program.cs""::: file: The /health endpoint indicates if the app is running normally where it\'s ready to receive requests. All health checks must pass for app to be considered ready to accept traffic after starting. http GET /health The /health endpoint returns an HTTP status code 200 and a text/plain value of The /alive indicates if an app is running or has crashed and must be restarted. Only health checks tagged with the live tag must pass for app to be considered alive. http GET /alive The /alive endpoint returns an HTTP status code 200 and a text/plain value of The AddServiceDefaults and MapDefaultEndpoints methods also apply various configurations to your app beyond just health checks, such as OpenTelemetry and service discovery configurations. Non-development environments In non-development environments, the /health and /alive endpoints are disabled by default. If you need to enable them, its recommended to protect these endpoints with various routing features, such as host filtering and/or authorization. For more information, see Health checks in ASP.NET Core. Additionally, it may be advantageous to configure request timeouts and output caching for these endpoints to prevent abuse or denial-of-service attacks. To do so, consider the following modified AddDefaultHealthChecks method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""healthchecks""::: The preceding code: Adds a timeout of 5 seconds to the health check requests with a policy named HealthChecks. Adds a 10-second cache to the health check responses with a policy named HealthChecks. Now consider the updated MapDefaultEndpoints method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""mapendpoints""::: The preceding code: Groups the health check endpoints under the / path. Caches the output and specifies a request time with the corresponding HealthChecks policy. In addition to the updated AddDefaultHealthChecks and MapDefaultEndpoints methods, you must also add the corresponding services for both request timeouts and output caching. In the appropriate consuming app\'s entry point (usually the :::no-loc text=""Program.cs""::: file), add the following code: ```csharp // Wherever your services are being registered. // Before the call to Build(). builder.Services.AddRequestTimeouts(); builder.Services.AddOutputCache(); var app = builder.Build(); // Wherever your app has been built, before the call to Run(). app.UseRequestTimeouts(); app.UseOutputCache(); app.Run(); ``` For more information, see Request timeouts middleware in ASP.NET Core and Output caching middleware in ASP.NET Core.', '<2-hop>\n\nIntegration health checks .NET Aspire integrations can also register additional health checks for your app. These health checks contribute to the returned status of the /health and /alive endpoints. For example, the .NET Aspire PostgreSQL integration automatically adds a health check to verify the following conditions: A database connection could be established A database query could be executed successfully If either of these operations fail, the corresponding health check also fails. Configure health checks You can disable health checks for a given integration using one of the available configuration options. .NET Aspire integrations support Microsoft.Extensions.Configurations to apply settings through config files such as :::no-loc text=""appsettings.json"":::: json { ""Aspire"": { ""Npgsql"": { ""DisableHealthChecks"": true, } } } You can also use an inline delegate to configure health checks: csharp builder.AddNpgsqlDbContext<MyDbContext>( ""postgresdb"", static settings => settings.DisableHealthChecks = true); See also .NET app health checks in C# Health checks in ASP.NET Core']",".NET Aspire allows integrations to register additional health checks for your app, which contribute to the status of the /health and /alive endpoints. For instance, the .NET Aspire PostgreSQL integration automatically adds a health check to verify if a database connection can be established and if a database query can be executed successfully. If either operation fails, the corresponding health check also fails. These health checks can be configured or disabled using Microsoft.Extensions.Configurations through config files like appsettings.json or by using an inline delegate in the code.",multi_hop_abstract_query_synthesizer
36,"How can a cloud application developer orchestrate a distributed application using Microsoft.Extensions.Hosting.AspireEventStoreExtensions, and what are the benefits of using data volumes and bind mounts for EventStore resources?","['<1-hop>\n\nAdd EventStore resource In the app host project, register and consume the EventStore integration using the AddEventStore extension method to add the EventStore container to the application builder. ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/eventstore/eventstore image, it creates a new EventStore instance on your local machine. A reference to your EventStore resource (the eventstore variable) is added to the ExampleProject. For more information, see Container resource lifecycle. Add EventStore resource with data volume To add a data volume to the EventStore resource, call the Aspire.Hosting.EventStoreBuilderExtensions.WithDataVolume method on the EventStore resource: ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore"") .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the EventStore data outside the lifecycle of its container. The data volume is mounted at the /var/lib/eventstore path in the EventStore container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add EventStore resource with data bind mount To add a data bind mount to the EventStore resource, call the Aspire.Hosting.EventStoreBuilderExtensions.WithDataBindMount method: ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore"") .WithDataBindMount(source: @""C:\\EventStore\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the EventStore data across container restarts. The data bind mount is mounted at the C:\\EventStore\\Data on Windows (or /EventStore/Data on Unix) path on the host machine in the EventStore container. For more information on data bind mounts, see Docker docs: Bind mounts. Add EventStore resource with log volume To add a log volume to the EventStore resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore"") .WithVolume(name: ""eventstore_logs"", target: ""/var/log/eventstore""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the EventStore logs outside the lifecycle of its container. The data volume must be mounted at the /var/log/eventstore target path in the EventStore container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. For more information about EventStore logs location, see EventStore Resources: Logs. Add EventStore resource with log bind mount To add a log bind mount to the EventStore resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventstore = builder.AddEventStore(""eventstore"") .WithBindMount(@""C:\\EventStore\\Logs"", ""/var/log/eventstore""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the EventStore logs across container restarts. The data bind mount is mounted at the C:\\EventStore\\Logs on Windows (or /EventStore/Logs on Unix) path on the host machine in the EventStore container. The target path must be set to the log folder used by the EventStore container (/var/log/eventstore). For more information about EventStore logs location, see EventStore Resources: Logs. For more information on data bind mounts, see Docker docs: Bind mounts.', '<2-hop>\n\nClient integration To get started with the .NET Aspire EventStore client integration, install the ðŸ“¦ CommunityToolkit.Aspire.EventStore NuGet package in the client-consuming project, that is, the project for the application that uses the EventStore client. .NET CLI dotnetcli dotnet add package CommunityToolkit.Aspire.EventStore PackageReference xml <PackageReference Include=""CommunityToolkit.Aspire.EventStore"" Version=""*"" /> Add EventStore client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the Microsoft.Extensions.Hosting.AspireEventStoreExtensions.AddEventStoreClient extension method on any csharp builder.AddEventStoreClient(connectionName: ""eventstore""); [!TIP] The connectionName parameter must match the name used when adding the EventStore resource in the app host project. For more information, see Add EventStore resource. You can then retrieve the EventStoreClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(EventStoreClient client) { // Use client... } Add keyed EventStore client There might be situations where you want to register multiple EventStoreClient instances with different connection names. To register keyed EventStore clients, call the Microsoft.Extensions.Hosting.AspireEventStoreExtensions.AddKeyedEventStoreClient csharp builder.AddKeyedEventStoreClient(name: ""accounts""); builder.AddKeyedEventStoreClient(name: ""orders""); Then you can retrieve the EventStoreClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""accounts"")] EventStoreClient accountsClient, [FromKeyedServices(""orders"")] EventStoreClient ordersClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire EventStore client integration provides multiple options to configure the server connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddEventStoreClient: csharp builder.AddEventStoreClient(""eventstore""); Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""eventstore"": ""esdb://localhost:22113?tls=false"" } } Use configuration providers The .NET Aspire EventStore Client integration supports json { ""Aspire"": { ""EventStore"": { ""Client"": { ""ConnectionString"": ""esdb://localhost:22113?tls=false"", ""DisableHealthChecks"": true } } } } Use inline delegates Also you can pass the Action<EventStoreSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddEventStoreClient( ""eventstore"", static settings => settings.DisableHealthChecks = true); Client integration health checks The .NET Aspire EventStore integration uses the configured client to perform a IsHealthyAsync. If the result is true, the health check is considered healthy, otherwise it\'s unhealthy. Likewise, if there\'s an exception, the health check is considered unhealthy with the error propagating through the health check failure. See also EventStore EventStore Client .NET Aspire Community Toolkit GitHub repo']","A cloud application developer can orchestrate a distributed application by utilizing the Microsoft.Extensions.Hosting.AspireEventStoreExtensions to integrate EventStore into their application. This is achieved by using the AddEventStore extension method to add the EventStore container to the application builder, as demonstrated in the provided C# code snippets. The developer can further enhance the setup by adding data volumes or bind mounts to the EventStore resource. Data volumes are used to persist EventStore data and logs outside the lifecycle of its container, ensuring data persistence across container restarts. They are mounted at specific paths within the EventStore container, such as /var/lib/eventstore for data and /var/log/eventstore for logs. Alternatively, data bind mounts can be used, which rely on the host machine's filesystem to persist data and logs. These are mounted at paths like C:\EventStore\Data and C:\EventStore\Logs on Windows. The choice between data volumes and bind mounts depends on the specific requirements and preferences of the developer, with volumes generally preferred for their ease of use and management. Additionally, the .NET Aspire EventStore client integration allows for flexible configuration of server connections, including the use of connection strings, configuration providers, and inline delegates, which further aids in the orchestration of distributed applications.",multi_hop_abstract_query_synthesizer
37,How does .NET Aspire enhance the development of distributed applications using Visual Studio?,"['<1-hop>\n\ntitle: .NET Aspire overview description: Learn about .NET Aspire, an application stack designed to improve the experience of building distributed applications. ms.date: 11/12/2024 .NET Aspire overview :::row::: :::column::: :::image type=""icon"" border=""false"" source=""../../assets/dotnet-aspire-logo-128.svg""::: :::column-end::: :::column span=""3""::: .NET Aspire is a set of tools, templates, and packages for building observable, production ready apps.\u200b\u200b .NET Aspire is delivered through a collection of NuGet packages that bootstrap or improve specific challenges with modern app development. Today\'s apps generally consume a large number of services, such as databases, messaging, and caching, many of which are supported via .NET Aspire Integrations. For information on support, see the .NET Aspire Support Policy. :::column-end::: :::row-end::: Why .NET Aspire? .NET Aspire improves the experience of building apps that have a variety of projects and resources. With dev-time productivity enhancements that emulate deployed scenarios, you can quickly develop interconnected apps. Designed for flexibility, .NET Aspire allows you to replace or extend parts with your preferred tools and workflows. Key features include: Dev-Time Orchestration: .NET Aspire provides features for running and connecting multi-project applications, container resources, and other dependencies for local development environments. Integrations: .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects.  .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects. Dev-time orchestration In .NET Aspire, ""orchestration"" primarily focuses on enhancing the local development experience by simplifying the management of your app\'s configuration and interconnections. It\'s important to note that .NET Aspire\'s orchestration isn\'t intended to replace the robust systems used in production environments, such as Kubernetes. Instead, it\'s a set of abstractions that streamline the setup of service discovery, environment variables, and container configurations, eliminating the need to deal with low-level implementation details. With .NET Aspire, your code has a consistent bootstrapping experience on any dev machine without the need for complex manual steps, making it easier to manage during the development phase. .NET Aspire orchestration assists with the following concerns: App composition: Specify the .NET projects, containers, executables, and cloud resources that make up the application. Service discovery and connection string management: The app host injects the right connection strings, network configurations, and service discovery information to simplify the developer experience. For example, using .NET Aspire, the following code creates a local Redis container resource, waits for it to become available, and then configures the appropriate connection string in the ""frontend"" project with a few helper method calls: ```csharp // Create a distributed application builder given the command line arguments. var builder = DistributedApplication.CreateBuilder(args); // Add a Redis server to the application. var cache = builder.AddRedis(""cache""); // Add the frontend project to the application and configure it to use the // Redis server, defined as a referenced dependency. builder.AddProject For more information, see .NET Aspire orchestration overview. [!IMPORTANT] The call to .NET Aspire integrations .NET Aspire integrations are NuGet packages designed to simplify connections to popular services and platforms, such as Redis or PostgreSQL. .NET Aspire integrations handle cloud resource setup and interaction for you through standardized patterns, such as adding health checks and telemetry. Integrations are two-fold - ""hosting"" integrations represents the service you\'re connecting to, and ""client"" integrations represents the client or consumer of that service. In other words, for many hosting packages there\'s a corresponding client package that handles the service connection within your code. Each integration is designed to work with the .NET Aspire app host, and their configurations are injected automatically by referencing named resources. In other words, if Example.ServiceFoo references Example.ServiceBar, Example.ServiceFoo inherits the integration\'s required configurations to allow them to communicate with each other automatically. For example, consider the following code using the .NET Aspire Service Bus integration: csharp builder.AddAzureServiceBusClient(""servicebus""); The Registers a Applies Enables corresponding health checks, logging, and telemetry specific to the Azure Service Bus usage. A full list of available integrations is detailed on the .NET Aspire integrations overview page.', '<2-hop>\n\nProject templates and tooling .NET Aspire provides a set of project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI. These templates are designed to help you create and interact with .NET Aspire projects, or add .NET Aspire into your existing codebase. The templates include a set of opinionated defaults to help you get started quickly - for example, it has boilerplate code for turning on health checks and logging in .NET apps. These defaults are fully customizable, so you can edit and adapt them to suit your needs. .NET Aspire templates also include boilerplate extension methods that handle common service configurations for you: csharp builder.AddServiceDefaults(); For more information on what AddServiceDefaults does, see .NET Aspire service defaults. When added to your :::no-loc text=""Program.cs""::: file, the preceding code handles the following concerns: OpenTelemetry: Sets up formatted logging, runtime metrics, built-in meters, and tracing for ASP.NET Core, gRPC, and HTTP. For more information, see .NET Aspire telemetry. Default health checks: Adds default health check endpoints that tools can query to monitor your app. For more information, see .NET app health checks in C#. Service discovery: Enables service discovery for the app and configures Next steps [!div class=""nextstepaction""] Quickstart: Build your first .NET Aspire project']",".NET Aspire enhances the development of distributed applications by providing a set of project templates and tooling experiences specifically for Visual Studio, Visual Studio Code, and the .NET CLI. These templates include opinionated defaults and boilerplate code for features like health checks and logging, which can be customized to suit specific needs. Additionally, .NET Aspire offers integrations through NuGet packages that simplify connections to popular services, ensuring consistent and seamless integration with your app. This setup streamlines the development process by managing service discovery, connection strings, and other configurations, thereby improving developer productivity and service observability.",multi_hop_abstract_query_synthesizer
38,"How does .NET Aspire facilitate the integration of Node.js applications, and what role do launch profiles play in this process?","['<1-hop>\n\ntitle: .NET Aspire and launch profiles description: Learn how .NET Aspire integrates with .NET launch profiles. ms.date: 04/23/2024 .NET Aspire and launch profiles .NET Aspire makes use of launch profiles defined in both the app host and service projects to simplify the process of configuring multiple aspects of the debugging and publishing experience for .NET Aspire-based distributed applications. Launch profile basics When creating a new .NET application from a template developers will often see a Properties directory which contains a file named launchSettings.json. The launch settings file contains a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. The code below is an example of launch profiles in a launchSettings.json file for an ASP.NET Core application. json { ""$schema"": ""http://json.schemastore.org/launchsettings.json"", ""profiles"": { ""http"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": false, ""applicationUrl"": ""http://localhost:5130"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"" } }, ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": false, ""applicationUrl"": ""https://localhost:7106;http://localhost:5130"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"" } } } } The launchSettings.json file above defines two launch profiles, http and https. Each has its own set of environment variables, launch URLs and other options. When launching a .NET Core application developers can choose which launch profile to use. dotnetcli dotnet run --launch-profile https If no launch profile is specified, then the first launch profile is selected by default. It is possible to launch a .NET Core application without a launch profile using the --no-launch-profile option. Some fields from the launchSettings.json file are translated to environment variables. For example, the applicationUrl field is converted to the ASPNETCORE_URLS environment variable which controls which address and port ASP.NET Core binds to. In Visual Studio it\'s possible to select the launch profile when launching the application making it easy to switch between configuration scenarios when manually debugging issues: :::image type=""content"" loc-scope=""visual-studio"" source=""./media/launch-profiles/vs-launch-profile-toolbar.png"" lightbox=""./media/launch-profiles/vs-launch-profile-toolbar.png"" alt-text=""Screenshot of the standard toolbar in Visual Studio with the launch profile selector highlighted.""::: When a .NET application is launched with a launch profile a special environment variable called DOTNET_LAUNCH_PROFILE is populated with the name of the launch profile that was used when launching the process. Launch profiles for .NET Aspire app host In .NET Aspire, the AppHost is just a .NET application. As a result it has a launchSettings.json file just like any other application. Here is an example of the launchSettings.json file generated when creating a new .NET Aspire project from the starter template (dotnet new aspire-starter). json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } }, ""http"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""http://localhost:19240"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""http://localhost:20154"" } } } } The .NET Aspire templates have a very similar set of launch profiles to a regular ASP.NET Core application. When the .NET Aspire app project launches, it starts a For information about app host configuration options, see .NET Aspire app host configuration.', '<2-hop>\n\nRelationship between app host launch profiles and service projects In .NET Aspire the app host is responsible for coordinating the launch of multiple service projects. When you run the app host either via the command line or from Visual Studio (or other development environment) a launch profile is selected for the app host. In turn, the app host will attempt to find a matching launch profile in the service projects it is launching and use those options to control the environment and default networking configuration for the service project. When the app host launches a service project it doesn\'t simply launch the service project using the --launch-profile option. Therefore, there will be no DOTNET_LAUNCH_PROFILE environment variable set for service projects. This is because .NET Aspire modifies the ASPNETCORE_URLS environment variable (derived from the applicationUrl field in the launch profile) to use a different port. By default, .NET Aspire inserts a reverse proxy in front of the ASP.NET Core application to allow for multiple instances of the application using the Other settings such as options from the environmentVariables field are passed through to the application without modification. Control launch profile selection Ideally, it\'s possible to align the launch profile names between the app host and the service projects to make it easy to switch between configuration options on all projects coordinated by the app host at once. However, it may be desirable to control launch profile that a specific project uses. The csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject<Projects.InventoryService>( ""inventoryservice"", launchProfileName: ""mylaunchprofile""); The preceding code shows that the inventoryservice resource (a .NET project) is launched using the options from the mylaunchprofile launch profile. The launch profile precedence logic is as follows: Use the launch profile specified by launchProfileName argument if specified. Use the launch profile with the same name as the AppHost (determined by reading the DOTNET_LAUNCH_PROFILE environment variable). Use the default (first) launch profile in launchSettings.json. Don\'t use a launch profile. To force a service project to launch without a launch profile the launchProfileName argument on the Launch profiles and endpoints When adding an ASP.NET Core project to the app host, .NET Aspire will parse the launchSettings.json file selecting the appropriate launch profile and automatically generate endpoints in the application model based on the URL(s) present in the applicationUrl field. To modify the endpoints that are automatically injected the csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject<Projects.InventoryService>(""inventoryservice"") .WithEndpoint(""https"", endpoint => endpoint.IsProxied = false); The preceding code shows how to disable the reverse proxy that .NET Aspire deploys in front for the .NET Core application and instead allows the .NET Core application to respond directly on requests over HTTP(S). For more information on networking options within .NET Aspire see .NET Aspire inner loop networking overview. See also Kestrel configured endpoints', ""<3-hop>\n\ntitle: Orchestrate Node.js apps in .NET Aspire description: Learn how to integrate Node.js and npm apps into a .NET Aspire App Host project. ms.date: 11/20/2024 Orchestrate Node.js apps in .NET Aspire In this article, you learn how to use Node.js and Node Package Manager (npm) apps in a .NET Aspire project. The sample app in this article demonstrates Angular, React, and Vue client experiences. The following .NET Aspire APIs exist to support these scenariosâ€”and they're part of the Aspire.Hosting.NodeJS NuGet package: Node.js: npm apps: The difference between these two APIs is that the former is used to host Node.js apps, while the latter is used to host apps that execute from a package.json file's scripts sectionâ€”and the corresponding npm run <script-name> command. [!TIP] The sample source code for this article is available on GitHub, and there are details available on the Code Samples: .NET Aspire with Angular, React and Vue page. [!IMPORTANT] While this article is focused on Single-Page App (SPA) frontend bits, there's an additional Node.js sample available on the Code Samples: .NET Aspire Node.js sample page, that demonstrates how to use Node.js as a server app with express. [!INCLUDE aspire-prereqs] Additionally, you need to install Node.js on your machine. The sample app in this article was built with Node.js version 20.12.2 and npm version 10.5.1. To verify your Node.js and npm versions, run the following commands: nodejs node --version nodejs npm --version To download Node.js (including npm), see the Node.js download page. Clone sample source code To clone the sample source code from GitHub, run the following command: bash git clone https://github.com/dotnet/aspire-samples.git After cloning the repository, navigate to the samples/AspireWithJavaScript folder: bash cd samples/AspireWithJavaScript From this directory, there are six child directories described in the following list: AspireJavaScript.Angular: An Angular app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.AppHost: A .NET Aspire project that orchestrates the other apps in this sample. For more information, see .NET Aspire orchestration overview. AspireJavaScript.MinimalApi: An HTTP API that returns randomly generated weather forecast data. AspireJavaScript.React: A React app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.ServiceDefaults: The default shared project for .NET Aspire projects. For more information, see .NET Aspire service defaults. AspireJavaScript.Vue: A Vue app that consumes the weather forecast API and displays the data in a table. Install client dependencies The sample app demonstrates how to use JavaScript client apps that are built on top of Node.js. Each client app was written either using a npm create template command or manually. The following table lists the template commands used to create each client app, along with the default port: App type Create template command Default port Angular npm create @angular@latest 4200 React Didn't use a template. PORT env var Vue npm create vue@latest 5173 [!TIP] You don't need to run any of these commands, since the sample app already includes the clients. Instead, this is a point of reference from which the clients were created. For more information, see npm-init. To run the app, you first need to install the dependencies for each client. To do so, navigate to each client folder and run npm install (or the install alias npm i) commands. Install Angular dependencies nodejs npm i ./AspireJavaScript.Angular/ For more information on the Angular app, see explore the Angular client. Install React dependencies nodejs npm i ./AspireJavaScript.React/ For more information on the React app, see explore the React client. Install Vue dependencies nodejs npm i ./AspireJavaScript.Vue/ For more information on the Vue app, see explore the Vue client."", '<4-hop>\n\nRun the sample app To run the sample app, call the dotnet run command given the orchestrator app host AspireJavaScript.AppHost.csproj as the --project switch: dotnetcli dotnet run --project ./AspireJavaScript.AppHost/AspireJavaScript.AppHost.csproj The .NET Aspire dashboard launches in your default browser, and each client app endpoint displays under the Endpoints column of the Resources page. The following image depicts the dashboard for this sample app: :::image type=""content"" source=""media/aspire-dashboard-with-nodejs.png"" lightbox=""media/aspire-dashboard-with-nodejs.png"" alt-text="".NET Aspire dashboard with multiple JavaScript client apps.""::: The weatherapi service endpoint resolves to a Swagger UI page that documents the HTTP API. Each client app consumes this service to display the weather forecast data. You can view each client app by navigating to the corresponding endpoint in the .NET Aspire dashboard. Their screenshots and the modifications made from the template starting point are detailed in the following sections. In the same terminal session that you used to run the app, press Ctrl + C to stop the app. Explore the app host To help understand how each client app resource is orchestrated, look to the app host project. The app host requires the Aspire.Hosting.NodeJS NuGet package to host Node.js apps: :::code language=""xml"" highlight=""15,22-30"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.AppHost/AspireJavaScript.AppHost.csproj""::: The project file also defines a build target that ensures that the npm dependencies are installed before the app host is built. The app host code (Program.cs) declares the client app resources using the :::code source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.AppHost/Program.cs""::: The preceding code: Creates a Adds the ""weatherapi"" service as a project to the app host. Marks the HTTP endpoints as external. With a reference to the ""weatherapi"" service, adds the ""angular"", ""react"", and ""vue"" client apps as npm apps. Each client app is configured to run on a different container port, and uses the PORT environment variable to determine the port. All client apps also rely on a Dockerfile to build their container image and are configured to express themselves in the publishing manifest as a container from the For more information on inner-loop networking, see .NET Aspire inner-loop networking overview. For more information on deploying apps, see .NET Aspire manifest format for deployment tool builders. When the app host orchestrates the launch of each client app, it uses the npm run start command. This command is defined in the scripts section of the package.json file for each client app. The start script is used to start the client app on the specified port. Each client app relies on a proxy to request the ""weatherapi"" service. The proxy is configured in: The proxy.conf.js file for the Angular client. The webpack.config.js file for the React client. The vite.config.ts file for the Vue client. and passing environment variables to JavaScript-based apps, whether they are client or server apps, use parameters. For more information, see .NET Aspire: External parametersâ€”secrets. Use the OpenTelemetry JavaScript SDK To export OpenTelemetry logs, traces, and metrics from a Node.js server app, you use the OpenTelemetry JavaScript SDK. For a complete example of a Node.js server app using the OpenTelemetry JavaScript SDK, you can refer to the Code Samples: .NET Aspire Node.js sample page. Consider the sample\'s instrumentation.js file, which demonstrates how to configure the OpenTelemetry JavaScript SDK to export logs, traces, and metrics: :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithNode/NodeFrontend/instrumentation.js""::: [!TIP] To configure the .NET Aspire dashboard OTEL CORS settings, see the .NET Aspire dashboard OTEL CORS settings page. Summary While there are several considerations that are beyond the scope of this article, you learned how to build .NET Aspire projects that use Node.js and Node Package Manager (npm). You also learned how to use the See also Code Samples: .NET Aspire with Angular, React, and Vue Code Samples: .NET Aspire Node.js App']",".NET Aspire facilitates the integration of Node.js applications by using the Aspire.Hosting.NodeJS NuGet package, which supports hosting Node.js apps and npm apps. This integration allows for orchestrating client experiences with frameworks like Angular, React, and Vue within a .NET Aspire project. The app host project in .NET Aspire orchestrates these Node.js applications by declaring them as resources and configuring them to run on different container ports using the PORT environment variable. Launch profiles in .NET Aspire play a crucial role in coordinating the launch of multiple service projects. The app host uses launch profiles to control the environment and networking configuration for service projects, ensuring that the appropriate settings are applied when orchestrating the Node.js applications. This setup allows for seamless integration and management of Node.js apps alongside .NET applications within the Aspire framework.",multi_hop_abstract_query_synthesizer
39,How do container orchestrators and Azure Container Apps enhance the deployment and management of .NET Aspire applications with health checks and Azure Functions integration?,"['<1-hop>\n\ntitle: .NET Aspire health checks description: Explore .NET Aspire health checks ms.date: 09/24/2024 ms.topic: quickstart uid: dotnet/aspire/health-checks Health checks in .NET Aspire Health checks provide availability and state information about an app. Health checks are often exposed as HTTP endpoints, but can also be used internally by the app to write logs or perform other tasks based on the current health. Health checks are typically used in combination with an external monitoring service or container orchestrator to check the status of an app. The data reported by health checks can be used for various scenarios: Influence decisions made by container orchestrators, load balancers, API gateways, and other management services. For instance, if the health check for a containerized app fails, it might be skipped by a load balancer routing traffic. Verify that underlying dependencies are available, such as a database or cache, and return an appropriate status message. Trigger alerts or notifications when an app isn\'t responding as expected. .NET Aspire health check endpoints .NET Aspire exposes two default health check HTTP endpoints in Development environments when the AddServiceDefaults and MapDefaultEndpoints methods are called from the :::no-loc text=""Program.cs""::: file: The /health endpoint indicates if the app is running normally where it\'s ready to receive requests. All health checks must pass for app to be considered ready to accept traffic after starting. http GET /health The /health endpoint returns an HTTP status code 200 and a text/plain value of The /alive indicates if an app is running or has crashed and must be restarted. Only health checks tagged with the live tag must pass for app to be considered alive. http GET /alive The /alive endpoint returns an HTTP status code 200 and a text/plain value of The AddServiceDefaults and MapDefaultEndpoints methods also apply various configurations to your app beyond just health checks, such as OpenTelemetry and service discovery configurations. Non-development environments In non-development environments, the /health and /alive endpoints are disabled by default. If you need to enable them, its recommended to protect these endpoints with various routing features, such as host filtering and/or authorization. For more information, see Health checks in ASP.NET Core. Additionally, it may be advantageous to configure request timeouts and output caching for these endpoints to prevent abuse or denial-of-service attacks. To do so, consider the following modified AddDefaultHealthChecks method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""healthchecks""::: The preceding code: Adds a timeout of 5 seconds to the health check requests with a policy named HealthChecks. Adds a 10-second cache to the health check responses with a policy named HealthChecks. Now consider the updated MapDefaultEndpoints method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""mapendpoints""::: The preceding code: Groups the health check endpoints under the / path. Caches the output and specifies a request time with the corresponding HealthChecks policy. In addition to the updated AddDefaultHealthChecks and MapDefaultEndpoints methods, you must also add the corresponding services for both request timeouts and output caching. In the appropriate consuming app\'s entry point (usually the :::no-loc text=""Program.cs""::: file), add the following code: ```csharp // Wherever your services are being registered. // Before the call to Build(). builder.Services.AddRequestTimeouts(); builder.Services.AddOutputCache(); var app = builder.Build(); // Wherever your app has been built, before the call to Run(). app.UseRequestTimeouts(); app.UseOutputCache(); app.Run(); ``` For more information, see Request timeouts middleware in ASP.NET Core and Output caching middleware in ASP.NET Core.', '<2-hop>\n\ntitle: .NET Aspire Azure Functions integration (Preview) description: Learn how to integrate Azure Functions with .NET Aspire. ms.date: 11/13/2024 zone_pivot_groups: dev-environment .NET Aspire Azure Functions integration (Preview) [!INCLUDE includes-hosting] [!IMPORTANT] The .NET Aspire Azure Functions integration is currently in preview and is subject to change. Azure Functions is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. The .NET Aspire Azure Functions integration enables you to develop, debug, and orchestrate an Azure Functions .NET project as part of the app host. It\'s expected that you\'ve installed the required Azure tooling: :::zone pivot=""visual-studio"" Configure Visual Studio for Azure development with .NET :::zone-end :::zone pivot=""vscode"" Configure Visual Studio Code for Azure development with .NET :::zone-end :::zone pivot=""dotnet-cli"" Install the Azure Functions Core Tools :::zone-end Supported scenarios The .NET Aspire Azure Functions integration has several key supported scenarios. This section outlines the scenarios and provides details related to the implementation of each approach. Supported triggers The following table lists the supported triggers for Azure Functions in the .NET Aspire integration: Trigger Attribute Details Azure Event Hubs trigger EventHubTrigger ðŸ“¦ Aspire.Hosting.Azure.EventHubs Azure Service Bus trigger ServiceBusTrigger ðŸ“¦ Aspire.Hosting.Azure.ServiceBus Azure Storage Blobs trigger BlobTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage Azure Storage Queues trigger QueueTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage HTTP trigger HttpTrigger Supported without any additional resource dependencies. Timer trigger TimerTrigger Supported without any additional resource dependenciesâ€”relies on implicit host storage. [!IMPORTANT] Other Azure Functions triggers and bindings aren\'t currently supported in the .NET Aspire Azure Functions integration. Deployment Currently, deployment is supported only to containers on Azure Container Apps (ACA) using the SDK container publish function in Microsoft.Azure.Functions.Worker.Sdk. This deployment methodology doesn\'t currently support KEDA-based autoscaling. Configure external HTTP endpoints To make HTTP triggers publicly accessible, call the']","Container orchestrators enhance the deployment and management of .NET Aspire applications by utilizing health checks to monitor the availability and state of an app. These health checks can influence decisions made by container orchestrators, such as skipping a containerized app by a load balancer if the health check fails. Azure Container Apps (ACA) support the deployment of .NET Aspire applications integrated with Azure Functions, allowing for serverless solutions that reduce code maintenance and infrastructure costs. The integration supports various triggers like HTTP, Event Hubs, and Service Bus, and deployment is facilitated through the SDK container publish function. This setup allows for efficient orchestration and management of distributed applications in a cloud-native environment.",multi_hop_abstract_query_synthesizer
40,How does the .NET Aspire app host configuration integrate with Azure Event Hubs to enhance productivity and observability?,"['<1-hop>\n\ntitle: .NET Aspire app host configuration description: Learn about the .NET Aspire app host configuration options. ms.date: 11/21/2024 ms.topic: reference App host configuration The app host project configures and starts your distributed application ( Configuration includes: Settings for hosting the resource service, such as the address and authentication options. Settings used to start the .NET Aspire dashboard, such the dashboard\'s frontend and OpenTelemetry Protocol (OTLP) addresses. Internal settings that .NET Aspire uses to run the app host. These are set internally but can be accessed by integrations that extend .NET Aspire. App host configuration is provided by the app host launch profile. The app host has a launch settings file call launchSettings.json which has a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } } } } The preceding launch settings file: Has one launch profile named https. Configures an .NET Aspire app host project: The applicationUrl property configures the dashboard launch address (ASPNETCORE_URLS). Environment variables such as DOTNET_DASHBOARD_OTLP_ENDPOINT_URL and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL are set on the app host. For more information, see .NET Aspire and launch profiles. [!NOTE] Configuration described on this page is for .NET Aspire app host project. To configure the standalone dashboard, see dashboard configuration. Common configuration Option Default value Description ASPIRE_ALLOW_UNSECURED_TRANSPORT false Allows communication with the app host without https. ASPNETCORE_URLS (dashboard address) and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL (app host resource service address) must be secured with HTTPS unless true. DOTNET_ASPIRE_CONTAINER_RUNTIME docker Allows the user of alternative container runtimes for resources backed by containers. Possible values are docker (default) or podman . See Setup and tooling overview for more details . Resource service A resource service is hosted by the app host. The resource service is used by the dashboard to fetch information about resources which are being orchestrated by .NET Aspire. Option Default value Description DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null Configures the address of the resource service hosted by the app host. Automatically generated with launchSettings.json to have a random port on localhost. For example, https://localhost:17037 . DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key is required if the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . ', '<2-hop>\n\ntitle: .NET Aspire Azure Event Hubs integration description: This article describes the .NET Aspire Azure Event Hubs integration features and capabilities. ms.topic: how-to ms.date: 08/26/2024 .NET Aspire Azure Event Hubs integration In this article, you learn how to use the .NET Aspire Azure Event Hubs integration. The Aspire.Azure.Messaging.EventHubs library offers options for registering the following types: These type are registered in the DI container for connecting to Azure Event Hubs. Prerequisites Azure subscription: create one for free. Azure Event Hubs namespace: for more information, see add an Event Hubs namespace. Alternatively, you can use a connection string, which isn\'t recommended in production environments. Get started To get started with the .NET Aspire Azure Event Hubs integration, install the ðŸ“¦ Aspire.Azure.Messaging.EventHubs NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Event Hubs client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.EventHubs PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.EventHubs"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Supported clients with options classes The following clients are supported by the library, along with their corresponding options and settings classes: Azure Client type Azure Options class .NET Aspire Settings class EventHubProducerClient EventHubProducerClientOptions AzureMessagingEventHubsProducerSettings EventHubBufferedProducerClient EventHubBufferedProducerClientOptions AzureMessagingEventHubsBufferedProducerSettings EventHubConsumerClient EventHubConsumerClientOptions AzureMessagingEventHubsConsumerSettings EventProcessorClient EventProcessorClientOptions AzureMessagingEventHubsProcessorSettings PartitionReceiver PartitionReceiverOptions AzureMessagingEventHubsPartitionReceiverSettings The client type are from the Azure SDK for .NET, as are the corresponding options classes. The settings classes are provided by the .NET Aspire Azure Event Hubs integration library.', '<3-hop>\n\nExample usage The following example assumes that you have an Azure Event Hubs namespace and an Event Hub created and wish to configure an EventHubProducerClient to send events to the Event Hub. The EventHubBufferedProducerClient, EventHubConsumerClient, EventProcessorClient, and PartitionReceiverare configured in a similar manner. In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the AddAzureEventHubProducerClient extension to register a EventHubProducerClient for use via the dependency injection container. csharp builder.AddAzureEventHubProducerClient(""eventHubsConnectionName""); You can then retrieve the EventHubProducerClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(EventHubProducerClient client) { // Use client... } For more information, see the Azure.Messaging.EventHubs documentation for examples on using the EventHubProducerClient. App host usage To add Azure Event Hub hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.EventHubs PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.EventHubs"" Version=""*"" /> In your app host project, add an Event Hubs connection and an Event Hub resource and consume the connection using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .AddEventHub(""MyHub""); var exampleService = builder.AddProject The AddAzureEventHubs method will read connection information from the AppHost\'s configuration (for example, from ""user secrets"") under the ConnectionStrings:eventHubsConnectionName config key. The WithReference method passes that connection information into a connection string named eventHubsConnectionName in the ExampleService project. As of .NET Aspire 8.1, the Azure EventHubs extension for .NET Aspire supports launching a local emulator for EventHubs. You can use the emulator by applying the RunAsEmulator() extension method as follows: csharp var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .RunAsEmulator() .AddEventHub(""MyHub""); The emulator for Azure EventHubs results in two container resources being launched inside .NET Aspire derived from the name of the Event Hubs resource name. [!IMPORTANT] Even though we are creating an Event Hub using the AddEventHub at the same time as the namespace, as of .NET Aspire version preview-5, the connection string will not include the EntityPath property, so the EventHubName property must be set in the settings callback for the preferred client. Future versions of Aspire will include the EntityPath property in the connection string and will not require the EventHubName property to be set in this scenario. In the :::no-loc text=""Program.cs""::: file of ExampleService, the connection can be consumed using by calling of the supported Event Hubs client extension methods: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; }); Configuration The .NET Aspire Azure Event Hubs library provides multiple options to configure the Azure Event Hubs connection based on the requirements and conventions of your project. Either a FullyQualifiedNamespace or a ConnectionString is a required to be supplied. Use a connection string When using a connection string from the ConnectionStrings configuration section, provide the name of the connection string when calling builder.AddAzureEventHubProducerClient() and other supported Event Hubs clients. In this example, the connection string does not include the EntityPath property, so the EventHubName property must be set in the settings callback: csharp builder.AddAzureEventHubProducerClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; }); And then the connection information will be retrieved from the ConnectionStrings configuration section. Two connection formats are supported: Fully Qualified Namespace (FQN) The recommended approach is to use a fully qualified namespace, which works with the AzureMessagingEventHubsSettings.Credential property to establish a connection. If no credential is configured, the json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""{your_namespace}.servicebus.windows.net"" } } Connection string Alternatively, use a connection string: json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""Endpoint=sb://mynamespace.servicebus.windows.net/;SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey;EntityPath=MyHub"" } } Use configuration providers The .NET Aspire Azure Event Hubs library supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""EventHubs"": { ""EventProcessorClient"": { ""EventHubName"": ""MyHub"", ""ClientOptions"": { ""Identifier"": ""PROCESSOR_ID"" } } } } } } } You can also setup the Options type using the optional Action<IAzureClientBuilder<EventProcessorClient, EventProcessorClientOptions>> configureClientBuilder parameter of the AddAzureEventProcessorClient method. For example, to set the processor\'s client ID for this client: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Identifier = ""PROCESSOR_ID"")); [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Azure Event Hubs integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Event Hubs integration will emit the following tracing activities using OpenTelemetry: ""Azure.Messaging.EventHubs.*"" Metrics The .NET Aspire Azure Event Hubs integration currently doesn\'t support metrics by default due to limitations with the Azure SDK for .NET. If that changes in the future, this section will be updated to reflect those changes. See also Azure Event Hubs .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire app host configuration integrates with Azure Event Hubs by utilizing the Aspire.Azure.Messaging.EventHubs library, which registers various client types in the dependency injection container for connecting to Azure Event Hubs. The app host project configures settings such as the DOTNET_DASHBOARD_OTLP_ENDPOINT_URL for observability. Additionally, the app host can add Azure Event Hub hosting support by using methods like AddAzureEventHubs and AddEventHub, which read connection information from the app host's configuration. This integration allows for enhanced productivity by enabling seamless event processing and observability through OpenTelemetry tracing activities emitted by the Azure Event Hubs integration.",multi_hop_abstract_query_synthesizer
41,How do health checks in .NET Aspire SQL Server integration relate to the deployment process using Azure DevOps pipelines?,"['<1-hop>\n\ntitle: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nCreate the Azure DevOps repository and pipeline [!IMPORTANT] As mentioned in the prerequisites, you\'ll need to create an Azure DevOps organization or select an existing organization to complete the steps ahead. You will also need to create a Personal Access Token (PAT) with the permissions listed in the prerequisites. The Azure Developer CLI enables you to automatically create pipelines with the correct configurations and permissions to provision and deploy resources to Azure. azd can also create an Azure Pipelines repository for your app if it doesn\'t exist already. Run the azd pipeline config command to configure your deployment pipeline and securely connect it to Azure. Include the --provider azdo option to use Azure Pipelines instead of the default GitHub Actions configuration. azdeveloper azd pipeline config --provider azdo Select the subscription to provision and deploy the app resources to. Select the Azure location to use for the resources. Paste the Personal Access Token you created earlier. Enter the Azure DevOps Organization name you created or selected. When prompted to create a new repository in the current directory, enter y and press Enter. When prompted to configure the git remote, select Create a new Azure DevOps Project. Enter a unique name of your choice for the new repository, such as aspireazd. azd creates a new repository in Azure Repos and configures it with the necessary secrets required to authenticate to Azure. :::image type=""content"" loc-scope=""other"" source=""media/pipeline-configuration.png"" lightbox=""media/pipeline-configuration.png"" alt-text=""A screenshot showing the pipeline configuration steps.""::: Enter y to proceed when azd prompts you to commit and push your local changes to start the configured pipeline. Explore the pipeline and deployed app Navigate to your new Azure Pipeline using the status link output by azd. :::image type=""content"" loc-scope=""azure"" source=""media/azure-pipeline-run.png"" lightbox=""media/azure-pipeline-run.png"" alt-text=""A screenshot showing the successful Azure Pipelines run.""::: Select the completed pipeline run to view the summary. :::image type=""content"" source=""media/azure-pipeline-summary.png"" alt-text=""A screenshot showing the summary view of the Azure Pipelines run.""::: Select the job link at the bottom of the view to navigate to the job details. :::image type=""content"" loc-scope=""azure"" source=""media/azure-pipeline-run-details.png"" lightbox=""media/azure-pipeline-run-details.png"" alt-text=""A screenshot showing the detailed view of the Azure Pipelines run."" ::: The job details page shows the status of all the individual stages. Select Provision Infrastructure to view the logs for that stage, which detail all of the provisioning steps completed by azd. At the bottom of the logs take note of the final status message and link to the provisioned Azure resource group. Select the link at the bottom of the provisioning output logs to navigate to the new Azure resource group. :::image type=""content"" loc-scope=""azure"" source=""media/azure-pipeline-resource-group.png"" lightbox=""media/azure-pipeline-resource-group.png"" alt-text=""A screenshot showing the deployed Azure resources.""::: [!NOTE] You can also navigate directly to your new resource group by searching for it in the Azure Portal. Your resource group name will be the environment name you provided to azd prefixed with rg-. Select the webfrontend container app, which hosts the public facing portion of your site. On the webfrontend details page, select the Application Url link to open your site in the browser. [!IMPORTANT] If you encounter a 403 Forbidden error when viewing your site in the browser, make sure the ingress settings are configured correctly. On the webfrontend app page in the Azure Portal, navigate to Ingress on the left navigation. Make sure Ingress traffic is set to Accepting traffic from anywhere and save your changes. Congratulations! You successfully deployed a .NET Aspire project using the Azure Developer CLI and Azure Pipelines. :::zone-end [!INCLUDE clean-up-resources]']","In the .NET Aspire SQL Server integration, health checks are automatically added for the SQL Server resource to verify that the server is running and a connection can be established. This is achieved using the AspNetCore.HealthChecks.SqlServer NuGet package. These health checks integrate with the /health HTTP endpoint, ensuring that all registered health checks must pass for the application to be considered ready to accept traffic. In the context of deploying applications using Azure DevOps pipelines, these health checks play a crucial role in the deployment process. When configuring a deployment pipeline with Azure DevOps, the pipeline ensures that the application is provisioned and deployed correctly to Azure resources. The health checks ensure that the application is in a healthy state post-deployment, which is essential for the pipeline to consider the deployment successful and for the application to start accepting traffic.",multi_hop_abstract_query_synthesizer
42,"How does the .NET Aspire Elasticsearch integration facilitate both hosting and client interactions, and what are the key features of each integration?","['<1-hop>\n\ntitle: .NET Aspire Elasticsearch integration description: Learn how to use the .NET Aspire Elasticsearch integration, which includes both hosting and client integrations. ms.date: 10/11/2024 uid: search/elasticsearch-integration .NET Aspire Elasticsearch integration [!INCLUDE includes-hosting-and-client] Elasticsearch is a distributed, RESTful search and analytics engine, scalable data store, and vector database capable of addressing a growing number of use cases. The .NET Aspire Elasticsearch integration enables you to connect to existing Elasticsearch instances, or create new instances from .NET with the docker.io/library/elasticsearch container image. Hosting integration The Elasticsearch hosting integration models an Elasticsearch instance as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Elasticsearch PackageReference xml <PackageReference Include=""Aspire.Hosting.Elasticsearch"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Elasticsearch resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var elasticsearch = builder.AddElasticsearch(""elasticsearch""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/elasticsearch image, it creates a new Elasticsearch instance on your local machine. A reference to your Elasticsearch resource (the elasticsearch variable) is added to the ExampleProject. The Elasticsearch resource includes default credentials with a username of ""elastic"" and randomly generated password using the The [!TIP] If you\'d rather connect to an existing Elasticsearch instance, call Add Elasticsearch resource with data volume To add a data volume to the Elasticsearch resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var elasticsearch = builder.AddElasticsearch(""elasticsearch"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Elasticsearch data outside the lifecycle of its container. The data volume is mounted at the /usr/share/elasticsearch/data path in the Elasticsearch container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Elasticsearch resource with data bind mount To add a data bind mount to the Elasticsearch resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var elasticsearch = builder.AddElasticsearch(""elasticsearch"") .WithDataBindMount( source: @""C:\\Elasticsearch\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Elasticsearch data across container restarts. The data bind mount is mounted at the C:\\Elasticsearch\\Data on Windows (or /Elasticsearch/Data on Unix) path on the host machine in the Elasticsearch container. For more information on data bind mounts, see Docker docs: Bind mounts. Add Elasticsearch resource with password parameter When you want to explicitly provide the password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var password = builder.AddParameter(""password"", secret: true); var elasticsearch = builder.AddElasticsearch(""elasticsearch"", password); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Hosting integration health checks The Elasticsearch hosting integration automatically adds a health check for the Elasticsearch resource. The health check verifies that the Elasticsearch instance is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Elasticsearch NuGet package.', '<2-hop>\n\nClient integration To get started with the .NET Aspire Elasticsearch client integration, install the ðŸ“¦ Aspire.Elastic.Clients.Elasticsearch NuGet package in the client-consuming project, that is, the project for the application that uses the Elasticsearch client. The Elasticsearch client integration registers an ElasticsearchClient instance that you can use to interact with Elasticsearch. .NET CLI dotnetcli dotnet add package Aspire.Elastic.Clients.Elasticsearch PackageReference xml <PackageReference Include=""Aspire.Elastic.Clients.Elasticsearch"" Version=""*"" /> Add Elasticsearch client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddElasticsearchClient(connectionName: ""elasticsearch""); [!TIP] The connectionName parameter must match the name used when adding the Elasticsearch resource in the app host project. For more information, see Add Elasticsearch resource. You can then retrieve the ElasticsearchClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(ElasticsearchClient client) { // Use client... } Add keyed Elasticsearch client There might be situations where you want to register multiple ElasticsearchClient instances with different connection names. To register keyed Elasticsearch clients, call the csharp builder.AddKeyedElasticsearchClient(name: ""products""); builder.AddKeyedElasticsearchClient(name: ""orders""); Then you can retrieve the ElasticsearchClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""products"")] ElasticsearchClient productsClient, [FromKeyedServices(""orders"")] ElasticsearchClient ordersClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Elasticsearch client integration provides multiple options to configure the server connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddElasticsearchClient: csharp builder.AddElasticsearchClient(""elasticsearch""); Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""elasticsearch"": ""http://elastic:password@localhost:27011"" } } Use configuration providers The .NET Aspire Elasticsearch Client integration supports json { ""Aspire"": { ""Elastic"": { ""Clients"": { ""Elasticsearch"": { ""DisableHealthChecks"": false, ""DisableTracing"": false, ""HealthCheckTimeout"": ""00:00:03"", ""ApiKey"": ""<Valid ApiKey>"", ""Endpoint"": ""http://elastic:password@localhost:27011"", ""CloudId"": ""<Valid CloudId>"" } } } } } For the complete Elasticsearch client integration JSON schema, see Aspire.Elastic.Clients.Elasticsearch/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<ElasticClientsElasticsearchSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddElasticsearchClient( ""elasticsearch"", static settings => settings.Endpoint = new Uri(""http://elastic:password@localhost:27011"")); Use a CloudId and an ApiKey with configuration providers When using Elastic Cloud, you can provide the CloudId and ApiKey in Aspire:Elastic:Clients:Elasticsearch section when calling builder.AddElasticsearchClient. csharp builder.AddElasticsearchClient(""elasticsearch""); Consider the following example appsettings.json that configures the options: json { ""Aspire"": { ""Elastic"": { ""Clients"": { ""Elasticsearch"": { ""ApiKey"": ""<Valid ApiKey>"", ""CloudId"": ""<Valid CloudId>"" } } } } } Use a CloudId and an ApiKey with inline delegates csharp builder.AddElasticsearchClient( ""elasticsearch"", static settings => { settings.ApiKey = ""<Valid ApiKey>""; settings.CloudId = ""<Valid CloudId>""; }); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Elasticsearch integration uses the configured client to perform a PingAsync. If the result is an HTTP 200 OK, the health check is considered healthy, otherwise it\'s unhealthy. Likewise, if there\'s an exception, the health check is considered unhealthy with the error propagating through the health check failure. Observability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Tracing The .NET Aspire Elasticsearch integration will emit the following tracing activities using OpenTelemetry: Elastic.Transport See also Elasticsearch .NET .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire Elasticsearch integration facilitates both hosting and client interactions by providing comprehensive tools for connecting to Elasticsearch instances. For hosting integration, it models an Elasticsearch instance using the .NET CLI, allowing developers to add an Elasticsearch resource to their app host project. This includes creating new instances with the docker.io/library/elasticsearch container image and managing data persistence through data volumes or bind mounts. Additionally, it supports health checks to ensure the Elasticsearch instance is running properly. On the client side, the integration involves installing the Aspire.Elastic.Clients.Elasticsearch NuGet package, which registers an ElasticsearchClient instance for interacting with Elasticsearch. It allows for configuration through connection strings, CloudId, and ApiKey, and supports multiple client instances with different connection names. The client integration also includes health checks and observability features such as logging, tracing, and metrics, enhancing the overall productivity and reliability of cloud-native applications.",multi_hop_abstract_query_synthesizer
43,How does .NET Aspire utilize project templates to enhance developer productivity and service observability?,"['<1-hop>\n\ntitle: .NET Aspire overview description: Learn about .NET Aspire, an application stack designed to improve the experience of building distributed applications. ms.date: 11/12/2024 .NET Aspire overview :::row::: :::column::: :::image type=""icon"" border=""false"" source=""../../assets/dotnet-aspire-logo-128.svg""::: :::column-end::: :::column span=""3""::: .NET Aspire is a set of tools, templates, and packages for building observable, production ready apps.\u200b\u200b .NET Aspire is delivered through a collection of NuGet packages that bootstrap or improve specific challenges with modern app development. Today\'s apps generally consume a large number of services, such as databases, messaging, and caching, many of which are supported via .NET Aspire Integrations. For information on support, see the .NET Aspire Support Policy. :::column-end::: :::row-end::: Why .NET Aspire? .NET Aspire improves the experience of building apps that have a variety of projects and resources. With dev-time productivity enhancements that emulate deployed scenarios, you can quickly develop interconnected apps. Designed for flexibility, .NET Aspire allows you to replace or extend parts with your preferred tools and workflows. Key features include: Dev-Time Orchestration: .NET Aspire provides features for running and connecting multi-project applications, container resources, and other dependencies for local development environments. Integrations: .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects.  .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects. Dev-time orchestration In .NET Aspire, ""orchestration"" primarily focuses on enhancing the local development experience by simplifying the management of your app\'s configuration and interconnections. It\'s important to note that .NET Aspire\'s orchestration isn\'t intended to replace the robust systems used in production environments, such as Kubernetes. Instead, it\'s a set of abstractions that streamline the setup of service discovery, environment variables, and container configurations, eliminating the need to deal with low-level implementation details. With .NET Aspire, your code has a consistent bootstrapping experience on any dev machine without the need for complex manual steps, making it easier to manage during the development phase. .NET Aspire orchestration assists with the following concerns: App composition: Specify the .NET projects, containers, executables, and cloud resources that make up the application. Service discovery and connection string management: The app host injects the right connection strings, network configurations, and service discovery information to simplify the developer experience. For example, using .NET Aspire, the following code creates a local Redis container resource, waits for it to become available, and then configures the appropriate connection string in the ""frontend"" project with a few helper method calls: ```csharp // Create a distributed application builder given the command line arguments. var builder = DistributedApplication.CreateBuilder(args); // Add a Redis server to the application. var cache = builder.AddRedis(""cache""); // Add the frontend project to the application and configure it to use the // Redis server, defined as a referenced dependency. builder.AddProject For more information, see .NET Aspire orchestration overview. [!IMPORTANT] The call to .NET Aspire integrations .NET Aspire integrations are NuGet packages designed to simplify connections to popular services and platforms, such as Redis or PostgreSQL. .NET Aspire integrations handle cloud resource setup and interaction for you through standardized patterns, such as adding health checks and telemetry. Integrations are two-fold - ""hosting"" integrations represents the service you\'re connecting to, and ""client"" integrations represents the client or consumer of that service. In other words, for many hosting packages there\'s a corresponding client package that handles the service connection within your code. Each integration is designed to work with the .NET Aspire app host, and their configurations are injected automatically by referencing named resources. In other words, if Example.ServiceFoo references Example.ServiceBar, Example.ServiceFoo inherits the integration\'s required configurations to allow them to communicate with each other automatically. For example, consider the following code using the .NET Aspire Service Bus integration: csharp builder.AddAzureServiceBusClient(""servicebus""); The Registers a Applies Enables corresponding health checks, logging, and telemetry specific to the Azure Service Bus usage. A full list of available integrations is detailed on the .NET Aspire integrations overview page.', '<2-hop>\n\nProject templates and tooling .NET Aspire provides a set of project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI. These templates are designed to help you create and interact with .NET Aspire projects, or add .NET Aspire into your existing codebase. The templates include a set of opinionated defaults to help you get started quickly - for example, it has boilerplate code for turning on health checks and logging in .NET apps. These defaults are fully customizable, so you can edit and adapt them to suit your needs. .NET Aspire templates also include boilerplate extension methods that handle common service configurations for you: csharp builder.AddServiceDefaults(); For more information on what AddServiceDefaults does, see .NET Aspire service defaults. When added to your :::no-loc text=""Program.cs""::: file, the preceding code handles the following concerns: OpenTelemetry: Sets up formatted logging, runtime metrics, built-in meters, and tracing for ASP.NET Core, gRPC, and HTTP. For more information, see .NET Aspire telemetry. Default health checks: Adds default health check endpoints that tools can query to monitor your app. For more information, see .NET app health checks in C#. Service discovery: Enables service discovery for the app and configures Next steps [!div class=""nextstepaction""] Quickstart: Build your first .NET Aspire project', '<3-hop>\n\nms.topic: include The .NET Aspire Azure Storage hosting integration models the various storage resources as the following types: To access these types and APIs for expressing them, add the ðŸ“¦ Aspire.Hosting.Azure.Storage NuGet package in the app host project. .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Storage PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Storage"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Azure Storage resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage""); // An Azure Storage resource is required to add any of the following: // // - Azure Blob storage resource. // - Azure Queue storage resource. // - Azure Table storage resource. // After adding all resources, run the app... ``` When you add an AzureStorageResource to the app host, it exposes other useful APIs to add Azure Blob, Queue, and Table storage resources. In other words, you must add an AzureStorageResource before adding any of the other storage resources. [!IMPORTANT] When you call Generated provisioning Bicep If you\'re new to Bicep, it\'s a domain-specific language for defining Azure resources. With .NET Aspire, you don\'t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Storage resource, the following Bicep is generated: The preceding Bicep is a module that provisions an Azure Storage account with the following defaults: kind: The kind of storage account. The default is StorageV2. sku: The SKU of the storage account. The default is Standard_GRS. properties: The properties of the storage account: accessTier: The access tier of the storage account. The default is Hot. allowSharedKeyAccess: A boolean value that indicates whether the storage account permits requests to be authorized with the account access key. The default is false. minimumTlsVersion: The minimum supported TLS version for the storage account. The default is TLS1_2. networkAcls: The network ACLs for the storage account. The default is { defaultAction: \'Allow\' }. In addition to the storage account, it also provisions a blob container. The following role assignments are added to the storage account to grant your application access. See the built-in Azure role-based access control (Azure RBAC) roles for more information: Role / ID Description Storage Blob Data Contributor ba92f5b4-2d11-453d-a403-e96b0029c9fe Read, write, and delete Azure Storage containers and blobs. Storage Table Data Contributor 0a9a7e1f-b9d0-4cc4-a60d-0319b160aaa3 Read, write, and delete Azure Storage tables and entities. Storage Queue Data Contributor 974c5e8b-45b9-4653-ba55-5f855dd0fb88 Read, write, and delete Azure Storage queues and queue messages. The generated Bicep is a starting point and can be customized to meet your specific requirements. Customize provisioning infrastructure All .NET Aspire Azure resources are subclasses of the :::code language=""csharp"" source=""../../snippets/azure/AppHost/Program.ConfigureStorageInfra.cs"" id=""configure""::: The preceding code: Chains a call to the The infra parameter is an instance of the The provisionable resources are retrieved by calling the The single The The A tag is added to the storage account with a key of ExampleKey and a value of Example value. There are many more configuration options available to customize the Azure Storage resource. For more information, see', '<4-hop>\n\nAdd Azure Storage emulator resource To add an Azure Storage emulator resource, chain a call on an IResourceBuilder<AzureStorageResource> to the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"") .RunAsEmulator(); // After adding all resources, run the app... ``` When you call RunAsEmulator, it configures your storage resources to run locally using an emulator. The emulator in this case is Azurite. The Azurite open-source emulator provides a free local environment for testing your Azure Blob, Queue Storage, and Table Storage apps and it\'s a perfect companion to the .NET Aspire Azure hosting integration. Azurite isn\'t installed, instead, it\'s accessible to .NET Aspire as a container. When you add a container to the app host, as shown in the preceding example with the mcr.microsoft.com/azure-storage/azurite image, it creates and starts the container when the app host starts. For more information, see Container resource lifecycle. Configure Azurite container There are various configurations available to container resources, for example, you can configure the container\'s ports, environment variables, it\'s lifetime, and more. Configure Azurite container ports By default, the Azurite container when configured by .NET Aspire, exposes the following endpoints: Endpoint Container port Host port blob 10000 dynamic queue 10001 dynamic table 10002 dynamic The port that they\'re listening on is dynamic by default. When the container starts, the ports are mapped to a random port on the host machine. To configure the endpoint ports, chain calls on the container resource builder provided by the RunAsEmulator method as shown in the following example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithBlobPort(""blob"", 27000) .WithQueuePort(""queue"", 27001) .WithTablePort(""table"", 27002); }); // After adding all resources, run the app... ``` The preceding code configures the Azurite container\'s existing blob, queue, and table endpoints to listen on ports 27000, 27001, and 27002, respectively. The Azurite container\'s ports are mapped to the host ports as shown in the following table: Endpoint name Port mapping ( container:host ) blob 10000:27000 queue 10001:27001 table 10002:27002 Configure Azurite container with persistent lifetime To configure the Azurite container with a persistent lifetime, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithLifetime(ContainerLifetime.Persistent); }); // After adding all resources, run the app... ``` For more information, see Container resource lifetime. Configure Azurite container with data volume To add a data volume to the Azure Storage emulator resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithDataVolume(); }); // After adding all resources, run the app... ``` The data volume is used to persist the Azurite data outside the lifecycle of its container. The data volume is mounted at the /data path in the Azurite container and when a name parameter isn\'t provided, the name is formatted as .azurite/{resource name}. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Configure Azurite container with data bind mount To add a data bind mount to the Azure Storage emulator resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator( azurite => { azurite.WithDataBindMount(""../Azurite/Data""); }); // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Azurite data across container restarts. The data bind mount is mounted at the ../Azurite/Data path on the host machine relative to the app host directory ( Connect to storage resources When the .NET Aspire app host runs, the storage resources can be accessed by external tools, such as the Azure Storage Explorer. If your storage resource is running locally using Azurite, it will automatically be picked up by the Azure Storage Explorer. [!NOTE] The Azure Storage Explorer discovers Azurite storage resources assuming the default ports are used. If you\'ve configured the Azurite container to use different ports, you\'ll need to configure the Azure Storage Explorer to connect to the correct ports. To connect to the storage resource from Azure Storage Explorer, follow these steps: Run the .NET Aspire app host. Open the Azure Storage Explorer. View the Explorer pane. Select the Refresh all link to refresh the list of storage accounts. Expand the Emulator & Attached node. Expand the Storage Accounts node. You should see a storage account with your resource\'s name as a prefix: :::image type=""content"" source=""../media/azure-storage-explorer.png"" lightbox=""../media/azure-storage-explorer.png"" alt-text=""Azure Storage Explorer: Azurite storage resource discovered.""::: You\'re free to explore the storage account and its contents using the Azure Storage Explorer. For more information on using the Azure Storage Explorer, see Get started with Storage Explorer.']",".NET Aspire utilizes project templates to enhance developer productivity and service observability by providing a set of opinionated defaults and boilerplate code that help developers get started quickly. These templates are available for Visual Studio, Visual Studio Code, and the .NET CLI, and they include features such as turning on health checks and logging in .NET apps. The templates are fully customizable, allowing developers to edit and adapt them to suit their needs. Additionally, .NET Aspire integrates with commonly used services through NuGet packages, ensuring consistent and seamless connections, which further enhances the observability and management of services within the application.",multi_hop_abstract_query_synthesizer
44,How does the .NET Aspire Azure Functions integration support HTTP triggers and what are the project constraints for using this integration?,"['<1-hop>\n\ntitle: .NET Aspire Azure Functions integration (Preview) description: Learn how to integrate Azure Functions with .NET Aspire. ms.date: 11/13/2024 zone_pivot_groups: dev-environment .NET Aspire Azure Functions integration (Preview) [!INCLUDE includes-hosting] [!IMPORTANT] The .NET Aspire Azure Functions integration is currently in preview and is subject to change. Azure Functions is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. The .NET Aspire Azure Functions integration enables you to develop, debug, and orchestrate an Azure Functions .NET project as part of the app host. It\'s expected that you\'ve installed the required Azure tooling: :::zone pivot=""visual-studio"" Configure Visual Studio for Azure development with .NET :::zone-end :::zone pivot=""vscode"" Configure Visual Studio Code for Azure development with .NET :::zone-end :::zone pivot=""dotnet-cli"" Install the Azure Functions Core Tools :::zone-end Supported scenarios The .NET Aspire Azure Functions integration has several key supported scenarios. This section outlines the scenarios and provides details related to the implementation of each approach. Supported triggers The following table lists the supported triggers for Azure Functions in the .NET Aspire integration: Trigger Attribute Details Azure Event Hubs trigger EventHubTrigger ðŸ“¦ Aspire.Hosting.Azure.EventHubs Azure Service Bus trigger ServiceBusTrigger ðŸ“¦ Aspire.Hosting.Azure.ServiceBus Azure Storage Blobs trigger BlobTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage Azure Storage Queues trigger QueueTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage HTTP trigger HttpTrigger Supported without any additional resource dependencies. Timer trigger TimerTrigger Supported without any additional resource dependenciesâ€”relies on implicit host storage. [!IMPORTANT] Other Azure Functions triggers and bindings aren\'t currently supported in the .NET Aspire Azure Functions integration. Deployment Currently, deployment is supported only to containers on Azure Container Apps (ACA) using the SDK container publish function in Microsoft.Azure.Functions.Worker.Sdk. This deployment methodology doesn\'t currently support KEDA-based autoscaling. Configure external HTTP endpoints To make HTTP triggers publicly accessible, call the', '<2-hop>\n\nAzure Function project constraints The .NET Aspire Azure Functions integration has the following project constraints: You must target .NET 8.0 or later. You must use a .NET 9 SDK. It currently only supports .NET workers with the isolated worker model. Requires the following NuGet packages: ðŸ“¦ Microsoft.Azure.Functions.Worker: Use the FunctionsApplicationBuilder. ðŸ“¦ Microsoft.Azure.Functions.Worker.Sdk: Adds support for dotnet run and azd publish. ðŸ“¦ Microsoft.Azure.Functions.Http.AspNetCore: Adds HTTP trigger-supporting APIs. :::zone pivot=""visual-studio"" If you encounter issues with the Azure Functions project, such as: There is no Functions runtime available that matches the version specified in the project In Visual Studio, try checking for an update on the Azure Functions tooling. Open the Options dialog, navigate to Projects and Solutions, and then select Azure Functions. Select the Check for updates button to ensure you have the latest version of the Azure Functions tooling: :::image type=""content"" source=""media/visual-studio-auzre-functions-options.png"" alt-text=""Visual Studio: Options / Projects and Solutions / Azure Functions.""::: :::zone-end Hosting integration The Azure Functions hosting integration models an Azure Functions resource as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Functions --prerelease PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Functions"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Azure Functions resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var functions = builder.AddAzureFunctionsProject builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds an Azure Functions project resource the app host, as shown in the preceding example, the functions resource can be referenced by other project resources. The Add Azure Functions resource with host storage If you want to modify the default host storage account that the Azure Functions host uses, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"") .RunAsEmulator(); var functions = builder.AddAzureFunctionsProject builder.AddProject // After adding all resources, run the app... ``` The preceding code relies on the ðŸ“¦ Aspire.Hosting.Azure.Storage NuGet package to add an Azure Storage resource that runs as an emulator. The storage resource is then passed to the WithHostStorage API, explicitly setting the host storage to the emulated resource. [!NOTE] If you\'re not using the implicit host storage, you must manually assign the StorageAccountContributor role to your resource for deployed instances. This role is automatically assigned for the implicitly generated host storage. Reference resources in Azure Functions To reference other Azure resources in an Azure Functions project, chain a call to WithReference on the Azure Functions project resource and provide the resource to reference: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage"").RunAsEmulator(); var blobs = storage.AddBlobs(""blobs""); builder.AddAzureFunctionsProject builder.Build().Run(); ``` The preceding code adds an Azure Storage resource to the app host and references it in the Azure Functions project. The blobs resource is added to the storage resource and then referenced by the functions resource. The connection information required to connect to the blobs resource is automatically injected into the Azure Functions project and enables the project to define a BlobTrigger that relies on blobs resource. See also .NET Aspire integrations .NET Aspire GitHub repo Azure Functions documentation .NET Aspire and Functions image gallery sample', '<3-hop>\n\ntitle: Persist data with .NET Aspire using volume mounts description: Learn about .NET Aspire volume configurations. ms.date: 04/26/2024 ms.topic: how-to Persist .NET Aspire project data using volumes In this article, you learn how to configure .NET Aspire projects to persist data across app launches using volumes. A continuous set of data during local development is useful in many scenarios. Various .NET Aspire resource container types are able to leverage volume storage, such as PostgreSQL, Redis and Azure Storage. When to use volumes By default, every time you start and stop a .NET Aspire project, the app also creates and destroys the app resource containers. This setup creates problems when you want to persist data in a database or storage services between app launches for testing or debugging. For example, you may want to handle the following scenarios: Work with a continuous set of data in a database during an extended development session. Test or debug a changing set of files in an Azure Blob Storage emulator. Maintain cached data or messages in a Redis instance across app launches. These goals can all be accomplished using volumes. With volumes, you decide which services retain data between launches of your .NET Aspire project. Understand volumes Volumes are the recommended way to persist data generated by containers and supported on both Windows and Linux. Volumes can store data from multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume, which is the physical location on the host. Target: The target path in the container of the data you want to persist. For the remainder of this article, imagine that your exploring a Program class in a .NET Aspire app host project that\'s already defined the distributed app builder bits: ```csharp var builder = DistributedApplication.CreateBuilder(args); // TODO: // Consider various code snippets for configuring // volumes here and persistent passwords. builder.Build().Run(); ``` The first code snippet to consider uses the WithBindMount API to configure a volume for a SQL Server resource. The following code demonstrates how to configure a volume for a SQL Server resource in a .NET Aspire app host project: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.WithBindMount.cs"" id=""mount""::: In this example: VolumeMount.AppHost-sql-data sets where the volume will be stored on the host. /var/opt/mssql sets the path to the database files in the container. All .NET Aspire container resources can utilize volume mounts, and some provide convenient APIs for adding named volumes derived from resources. Using the WithDataVolume as an example, the following code is functionally equivalent to the previous example but more succinct: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.Implicit.cs"" id=""implicit""::: With the app host project being named VolumeMount.AppHost, the WithDataVolume method automatically creates a named volume as VolumeMount.AppHost-sql-data and is mounted to the /var/opt/mssql path in the SQL Server container. The naming convention is as follows: {appHostProjectName}-{resourceName}-data: The volume name is derived from the app host project name and the resource name. Create a persistent password Named volumes require a consistent password between app launches. .NET Aspire conveniently provides random password generation functionality. Consider the previous example once more, where a password is generated automatically: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.Implicit.cs"" id=""implicit""::: Since the password parameter isn\'t provided when calling AddSqlServer, .NET Aspire automatically generates a password for the SQL Server resource. [!IMPORTANT] This isn\'t a persistent password! Instead, it changes every time the app host runs. To create a persistent password, you must override the generated password. To do this, run the following command in your app host project directory to set a local password in your .NET user secrets: dotnetcli dotnet user-secrets set Parameters:sql-password <password> The naming convention for these secrets is important to understand. The password is stored in configuration with the Parameters:sql-password key. The naming convention follows this pattern: Parameters:{resourceName}-password: In the case of the SQL Server resource (which was named ""sql""), the password is stored in the configuration with the key Parameters:sql-password. The same pattern applies to the other server-based resource types, such as those shown in the following table: | Resource type | Hosting package | Example resource name | Override key | |--|--|--| | MySQL | ðŸ“¦ Aspire.Hosting.MySql | mysql | Parameters:mysql-password | | Oracle | ðŸ“¦ Aspire.Hosting.Oracle | oracle | Parameters:oracle-password | | PostgreSQL | ðŸ“¦ Aspire.Hosting.PostgreSQL | postgresql | Parameters:postgresql-password | | RabbitMQ | ðŸ“¦ Aspire.Hosting.RabbitMq | rabbitmq | Parameters:rabbitmq-password | | SQL Server | ðŸ“¦ Aspire.Hosting.SqlServer | sql | Parameters:sql-password | By overriding the generated password, you can ensure that the password remains consistent between app launches, thus creating a persistent password. An alternative approach is to use the AddParameter method to create a parameter that can be used as a password. The following code demonstrates how to create a persistent password for a SQL Server resource: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.ExplicitStable.cs"" id=""explicit""::: The preceding code snippet demonstrates how to create a persistent password for a SQL Server resource. The AddParameter method is used to create a parameter named sql-password that\'s considered a secret. The AddSqlServer method is then called with the password parameter to set the password for the SQL Server resource. For more information, see External parameters.', '<4-hop>\n\nNext steps You can apply the volume concepts in the preceding code to a variety of services, including seeding a database with data that will persist across app launches. Try combining these techniques with the resource implementations demonstrated in the following tutorials: Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations Tutorial: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core .NET Aspire orchestration overview']","The .NET Aspire Azure Functions integration supports HTTP triggers without any additional resource dependencies, allowing them to be publicly accessible. However, the integration has specific project constraints: it requires targeting .NET 8.0 or later, using a .NET 9 SDK, and only supports .NET workers with the isolated worker model. Additionally, it necessitates the use of certain NuGet packages such as Microsoft.Azure.Functions.Worker, Microsoft.Azure.Functions.Worker.Sdk, and Microsoft.Azure.Functions.Http.AspNetCore.",multi_hop_abstract_query_synthesizer
45,How does the integration of .NET Aspire with Azure Event Hubs enhance the testing and deployment of cloud-native applications?,"['<1-hop>\n\ntitle: Write your first .NET Aspire test description: Learn how to test your .NET Aspire solutions using the xUnit, NUnit, and MSTest testing frameworks. ms.date: 11/11/2024 zone_pivot_groups: unit-testing-framework Write your first .NET Aspire test In this article, you learn how to create a test project, write tests, and run them for your .NET Aspire solutions. The tests in this article aren\'t unit tests, but rather functional or integration tests. .NET Aspire includes several variations of testing project templates that you can use to test your .NET Aspire resource dependenciesâ€”and their communications. The testing project templates are available for MSTest, NUnit, and xUnit testing frameworks and include a sample test that you can use as a starting point for your tests. The .NET Aspire test project templates rely on the ðŸ“¦ Aspire.Hosting.Testing NuGet package. This package exposes the Create a test project The easiest way to create a .NET Aspire test project is to use the testing project template. If you\'re starting a new .NET Aspire project and want to include test projects, the Visual Studio tooling supports that option. If you\'re adding a test project to an existing .NET Aspire project, you can use the dotnet new command to create a test project: :::zone pivot=""xunit"" dotnetcli dotnet new aspire-xunit :::zone-end :::zone pivot=""mstest"" dotnetcli dotnet new aspire-mstest :::zone-end :::zone pivot=""nunit"" dotnetcli dotnet new aspire-nunit :::zone-end For more information, see the .NET CLI dotnet new command documentation. Explore the test project The following example test project was created as part of the .NET Aspire Starter Application template. If you\'re unfamiliar with it, see Quickstart: Build your first .NET Aspire project. The .NET Aspire test project takes a project reference dependency on the target app host. Consider the template project: :::zone pivot=""xunit"" :::code language=""xml"" source=""snippets/testing/xunit/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end :::zone pivot=""mstest"" :::code language=""xml"" source=""snippets/testing/mstest/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end :::zone pivot=""nunit"" :::code language=""xml"" source=""snippets/testing/nunit/AspireApp.Tests/AspireApp.Tests.csproj""::: :::zone-end The preceding project file is fairly standard. There\'s a PackageReference to the ðŸ“¦ Aspire.Hosting.Testing NuGet package, which includes the required types to write tests for .NET Aspire projects. The template test project includes a IntegrationTest1 class with a single test. The test verifies the following scenario: The app host is successfully created and started. The webfrontend resource is available and running. An HTTP request can be made to the webfrontend resource and returns a successful response (HTTP 200 OK). Consider the following test class: :::zone pivot=""xunit"" :::code language=""csharp"" source=""snippets/testing/xunit/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end :::zone pivot=""mstest"" :::code language=""csharp"" source=""snippets/testing/mstest/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end :::zone pivot=""nunit"" :::code language=""csharp"" source=""snippets/testing/nunit/AspireApp.Tests/IntegrationTest1.cs""::: :::zone-end The preceding code: Relies on the The appHost is an instance of IDistributedApplicationTestingBuilder that represents the app host. The appHost instance has its service collection configured with the standard HTTP resilience handler. For more information, see Build resilient HTTP apps: Key development patterns. The appHost has its The app has its service provider get the The app is started asynchronously. An The resourceNotificationService is used to wait for the webfrontend resource to be available and running. A simple HTTP GET request is made to the root of the webfrontend resource. The test asserts that the response status code is OK.', '<2-hop>\n\ntitle: .NET Aspire Azure Event Hubs integration description: This article describes the .NET Aspire Azure Event Hubs integration features and capabilities. ms.topic: how-to ms.date: 08/26/2024 .NET Aspire Azure Event Hubs integration In this article, you learn how to use the .NET Aspire Azure Event Hubs integration. The Aspire.Azure.Messaging.EventHubs library offers options for registering the following types: These type are registered in the DI container for connecting to Azure Event Hubs. Prerequisites Azure subscription: create one for free. Azure Event Hubs namespace: for more information, see add an Event Hubs namespace. Alternatively, you can use a connection string, which isn\'t recommended in production environments. Get started To get started with the .NET Aspire Azure Event Hubs integration, install the ðŸ“¦ Aspire.Azure.Messaging.EventHubs NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Event Hubs client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.EventHubs PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.EventHubs"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Supported clients with options classes The following clients are supported by the library, along with their corresponding options and settings classes: Azure Client type Azure Options class .NET Aspire Settings class EventHubProducerClient EventHubProducerClientOptions AzureMessagingEventHubsProducerSettings EventHubBufferedProducerClient EventHubBufferedProducerClientOptions AzureMessagingEventHubsBufferedProducerSettings EventHubConsumerClient EventHubConsumerClientOptions AzureMessagingEventHubsConsumerSettings EventProcessorClient EventProcessorClientOptions AzureMessagingEventHubsProcessorSettings PartitionReceiver PartitionReceiverOptions AzureMessagingEventHubsPartitionReceiverSettings The client type are from the Azure SDK for .NET, as are the corresponding options classes. The settings classes are provided by the .NET Aspire Azure Event Hubs integration library.', '<3-hop>\n\nExample usage The following example assumes that you have an Azure Event Hubs namespace and an Event Hub created and wish to configure an EventHubProducerClient to send events to the Event Hub. The EventHubBufferedProducerClient, EventHubConsumerClient, EventProcessorClient, and PartitionReceiverare configured in a similar manner. In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the AddAzureEventHubProducerClient extension to register a EventHubProducerClient for use via the dependency injection container. csharp builder.AddAzureEventHubProducerClient(""eventHubsConnectionName""); You can then retrieve the EventHubProducerClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(EventHubProducerClient client) { // Use client... } For more information, see the Azure.Messaging.EventHubs documentation for examples on using the EventHubProducerClient. App host usage To add Azure Event Hub hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.EventHubs PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.EventHubs"" Version=""*"" /> In your app host project, add an Event Hubs connection and an Event Hub resource and consume the connection using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .AddEventHub(""MyHub""); var exampleService = builder.AddProject The AddAzureEventHubs method will read connection information from the AppHost\'s configuration (for example, from ""user secrets"") under the ConnectionStrings:eventHubsConnectionName config key. The WithReference method passes that connection information into a connection string named eventHubsConnectionName in the ExampleService project. As of .NET Aspire 8.1, the Azure EventHubs extension for .NET Aspire supports launching a local emulator for EventHubs. You can use the emulator by applying the RunAsEmulator() extension method as follows: csharp var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .RunAsEmulator() .AddEventHub(""MyHub""); The emulator for Azure EventHubs results in two container resources being launched inside .NET Aspire derived from the name of the Event Hubs resource name. [!IMPORTANT] Even though we are creating an Event Hub using the AddEventHub at the same time as the namespace, as of .NET Aspire version preview-5, the connection string will not include the EntityPath property, so the EventHubName property must be set in the settings callback for the preferred client. Future versions of Aspire will include the EntityPath property in the connection string and will not require the EventHubName property to be set in this scenario. In the :::no-loc text=""Program.cs""::: file of ExampleService, the connection can be consumed using by calling of the supported Event Hubs client extension methods: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; }); Configuration The .NET Aspire Azure Event Hubs library provides multiple options to configure the Azure Event Hubs connection based on the requirements and conventions of your project. Either a FullyQualifiedNamespace or a ConnectionString is a required to be supplied. Use a connection string When using a connection string from the ConnectionStrings configuration section, provide the name of the connection string when calling builder.AddAzureEventHubProducerClient() and other supported Event Hubs clients. In this example, the connection string does not include the EntityPath property, so the EventHubName property must be set in the settings callback: csharp builder.AddAzureEventHubProducerClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; }); And then the connection information will be retrieved from the ConnectionStrings configuration section. Two connection formats are supported: Fully Qualified Namespace (FQN) The recommended approach is to use a fully qualified namespace, which works with the AzureMessagingEventHubsSettings.Credential property to establish a connection. If no credential is configured, the json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""{your_namespace}.servicebus.windows.net"" } } Connection string Alternatively, use a connection string: json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""Endpoint=sb://mynamespace.servicebus.windows.net/;SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey;EntityPath=MyHub"" } } Use configuration providers The .NET Aspire Azure Event Hubs library supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""EventHubs"": { ""EventProcessorClient"": { ""EventHubName"": ""MyHub"", ""ClientOptions"": { ""Identifier"": ""PROCESSOR_ID"" } } } } } } } You can also setup the Options type using the optional Action<IAzureClientBuilder<EventProcessorClient, EventProcessorClientOptions>> configureClientBuilder parameter of the AddAzureEventProcessorClient method. For example, to set the processor\'s client ID for this client: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Identifier = ""PROCESSOR_ID"")); [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Azure Event Hubs integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Event Hubs integration will emit the following tracing activities using OpenTelemetry: ""Azure.Messaging.EventHubs.*"" Metrics The .NET Aspire Azure Event Hubs integration currently doesn\'t support metrics by default due to limitations with the Azure SDK for .NET. If that changes in the future, this section will be updated to reflect those changes. See also Azure Event Hubs .NET Aspire integrations .NET Aspire GitHub repo', '<4-hop>\n\ntitle: .NET Aspire Oracle Entity Framework Core integration description: Learn how to use the .NET Aspire Oracle Entity Framework Core integration, which includes both hosting and client integrations. ms.date: 01/21/2025 uid: database/oracle-entity-framework-integration .NET Aspire Oracle Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Oracle Database is a widely-used relational database management system owned and developed by Oracle. The .NET Aspire Oracle Entity Framework Core integration enables you to connect to existing Oracle servers or create new servers from .NET with the container-registry.orcale.com/databse/free container image. Hosting integration The .NET Aspire Oracle hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Oracle PackageReference xml <PackageReference Include=""Aspire.Hosting.Oracle"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Oracle server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Oracle database container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the container-registry.oracle.com/database/free image, it creates a new Oracle server on your local machine. A reference to your Oracle resource builder (the oracle variable) is used to add a database. The database is named oracledb and then added to the ExampleProject. The Oracle resource includes a random password generated using the The [!TIP] If you\'d rather connect to an existing Oracle server, call Add Oracle resource with password parameter The Oracle resource includes default credentials with a random password. Oracle supports configuration-based default passwords by using the environment variable ORACLE_PWD. When you want to provide a password explicitly, you can provide it as a parameter: ```csharp var password = builder.AddParameter(""password"", secret: true); var oracle = builder.AddOracle(""oracle"", password) .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddOracle API, and internally assigns the parameter to the ORACLE_PWD environment variable of the Oracle container. The password parameter is usually specified as a user secret: json { ""Parameters"": { ""password"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Oracle resource with data volume To add a data volume to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataVolume() .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracle""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Oracle data outside the lifecycle of its container. The data volume is mounted at the /opt/oracle/oradata path in the Oracle container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add Oracle resource with data bind mount To add a data bind mount to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataBindMount(source: @""C:\\Oracle\\Data""); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Oracle data across container restarts. The data bind mount is mounted at the C:\\Oracle\\Data on Windows (or /Oracle/Data on Unix) path on the host machine in the Oracle container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Oracle hosting integration automatically adds a health check for the Oracle resource. The health check verifies that the Oracle server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Oracle NuGet package.']","The integration of .NET Aspire with Azure Event Hubs enhances the testing and deployment of cloud-native applications by providing a robust framework for managing event-driven architectures. The .NET Aspire Azure Event Hubs integration allows developers to use the Aspire.Azure.Messaging.EventHubs library to register various client types, such as EventHubProducerClient and EventProcessorClient, within the dependency injection container. This integration supports the creation of test projects using frameworks like xUnit, NUnit, and MSTest, which can be used to verify the functionality of applications that depend on Azure Event Hubs. By leveraging the Aspire.Hosting.Azure.EventHubs package, developers can configure and consume Event Hubs connections within their applications, facilitating seamless deployment and observability. Additionally, the integration supports launching a local emulator for Event Hubs, enabling developers to test their applications in a controlled environment before deploying them to production.",multi_hop_abstract_query_synthesizer
46,How does the .NET Aspire Redis integration enhance observability through logging and tracing?,"['<1-hop>\n\ntitle: .NET Aspire Redis integration description: Learn how to use the .NET Aspire Redis integration, which includes both hosting and client integrations. ms.date: 11/05/2024 zone_pivot_groups: resp-host .NET Aspire RedisÂ®* integration [!INCLUDE includes-hosting-and-client] :::zone pivot=""redis"" Redis is the world\'s fastest data platform for caching, vector search, and NoSQL databases. The .NET Aspire Redis integration enables you to connect to existing Redis instances, or create new instances from .NET with the docker.io/library/redis container image. :::zone-end :::zone pivot=""garnet"" Garnet is a a high-performance cache-store from Microsoft Research and complies with the Redis serialization protocol (RESP). The .NET Aspire Redis integration enables you to connect to existing Garnet instances, or create new instances from .NET with the ghcr.io/microsoft/garnet container image. :::zone-end :::zone pivot=""valkey"" Valkey is a Redis fork and complies with the Redis serialization protocol (RESP). It\'s a high-performance key/value datastore that supports a variety of workloads such as caching, message queues, and can act as a primary database. The .NET Aspire Redis integration enables you to connect to existing Valkey instances, or create new instances from .NET with the docker.io/valkey/valkey container image. :::zone-end Hosting integration :::zone pivot=""redis"" [!INCLUDE redis-app-host] :::zone-end :::zone pivot=""garnet"" [!INCLUDE garnet-app-host] :::zone-end :::zone pivot=""valkey"" [!INCLUDE valkey-app-host] :::zone-end Hosting integration health checks [!INCLUDE redis-hosting-health-checks] Client integration To get started with the .NET Aspire Stack Exchange Redis client integration, install the ðŸ“¦ Aspire.StackExchange.Redis NuGet package in the client-consuming project, that is, the project for the application that uses the Redis client. The Redis client integration registers an an IConnectionMultiplexer instance that you can use to interact with Redis. .NET CLI dotnetcli dotnet add package Aspire.StackExchange.Redis PackageReference xml <PackageReference Include=""Aspire.StackExchange.Redis"" Version=""*"" /> Add Redis client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddRedisClient(connectionName: ""cache""); :::zone pivot=""redis"" [!TIP] The connectionName parameter must match the name used when adding the Redis resource in the app host project. For more information, see Add Redis resource. :::zone-end :::zone pivot=""garnet"" [!TIP] The connectionName parameter must match the name used when adding the Garnet resource in the app host project. For more information, see Add Garnet resource. :::zone-end :::zone pivot=""valkey"" [!TIP] The connectionName parameter must match the name used when adding the Valkey resource in the app host project. For more information, see Add Valkey resource. :::zone-end You can then retrieve the IConnection instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(IConnectionMultiplexer connectionMux) { // Use connection multiplexer... } For more information on dependency injection, see .NET dependency injection. Add keyed Redis client There might be situations where you want to register multiple IConnectionMultiplexer instances with different connection names. To register keyed Redis clients, call the csharp builder.AddKeyedRedisClient(name: ""chat""); builder.AddKeyedRedisClient(name: ""queue""); Then you can retrieve the IConnectionMultiplexer instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] IConnectionMultiplexer chatConnectionMux, [FromKeyedServices(""queue"")] IConnectionMultiplexer queueConnectionMux) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Stack Exchange Redis client integration provides multiple options to configure the Redis connection based on the requirements and conventions of your project. Use a connection string :::zone pivot=""redis"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddRedis(""cache""); :::zone-end :::zone pivot=""garnet"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddGarnet(""cache""); :::zone-end :::zone pivot=""valkey"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddValkey(""cache""); :::zone-end Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } For more information on how to format this connection string, see the Stack Exchange Redis configuration docs. Use configuration providers [!INCLUDE redis-client-json-settings] Use inline delegates You can also pass the Action<StackExchangeRedisSettings> delegate to set up some or all the options inline, for example to configure DisableTracing: csharp builder.AddRedisClient( ""cache"", static settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Stack Exchange Redis integration handles the following: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.', '<2-hop>\n\nObservability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations might only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire Stack Exchange Redis integration uses the following log categories: Aspire.StackExchange.Redis Tracing The .NET Aspire Stack Exchange Redis integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.StackExchangeRedis Metrics The .NET Aspire Stack Exchange Redis integration currently doesn\'t support metrics by default due to limitations with the StackExchange.Redis library. :::zone pivot=""redis"" [!INCLUDE azure-redis-app-host] [!INCLUDE azure-redis-client] :::zone-end See also Stack Exchange Redis docs .NET Aspire integrations .NET Aspire GitHub repo [!INCLUDE redis-trademark]']","The .NET Aspire Redis integration enhances observability by automatically setting up logging and tracing configurations. It uses specific log categories such as Aspire.StackExchange.Redis and emits tracing activities using OpenTelemetry, specifically OpenTelemetry.Instrumentation.StackExchangeRedis. These features are part of the broader observability and telemetry setup provided by .NET Aspire integrations.",multi_hop_abstract_query_synthesizer
47,How does the .NET Aspire integration with Apache Kafka utilize NuGet packages to enhance developer productivity and service observability?,"['<1-hop>\n\ntitle: .NET Aspire Apache Kafka integration description: Learn how to use the .NET Aspire Apache Kafka client message-broker integration. ms.date: 10/11/2024 uid: messaging/kafka-integration .NET Aspire Apache Kafka integration [!INCLUDE includes-hosting-and-client] Apache Kafka is an open-source distributed event streaming platform. It\'s useful for building real-time data pipelines and streaming applications. The .NET Aspire Apache Kafka integration enables you to connect to existing Kafka instances, or create new instances from .NET with the docker.io/confluentinc/confluent-local container image. Hosting integration The Apache Kafka hosting integration models a Kafka server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Kafka PackageReference xml <PackageReference Include=""Aspire.Hosting.Kafka"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Kafka server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/confluentinc/confluent-local image, it creates a new Kafka server instance on your local machine. A reference to your Kafka server (the kafka variable) is added to the ExampleProject. The Kafka server resource includes default ports The [!TIP] If you\'d rather connect to an existing Kafka server, call Add Kafka UI To add the Kafka UI to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithKafkaUI(); builder.AddProject // After adding all resources, run the app... ``` The Kafka UI is a free, open-source web UI to monitor and manage Apache Kafka clusters. .NET Aspire adds another container image docker.io/provectuslabs/kafka-ui to the app host that runs the Kafka UI. Change the Kafka UI host port To change the Kafka UI host port, chain a call to the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithKafkaUI(kafkaUI => kafkaUI.WithHostPort(9100)); builder.AddProject // After adding all resources, run the app... ``` The Kafka UI is accessible at http://localhost:9100 in the preceding example. Add Kafka server resource with data volume To add a data volume to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Kafka server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/kafka/data path in the Kafka server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Kafka server resource with data bind mount To add a data bind mount to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithDataBindMount( source: @""C:\\Kafka\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Kafka server data across container restarts. The data bind mount is mounted at the C:\\Kafka\\Data on Windows (or /Kafka/Data on Unix) path on the host machine in the Kafka server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Kafka hosting integration automatically adds a health check for the Kafka server resource. The health check verifies that a Kafka producer with the specified connection name is able to connect and persist a topic to the Kafka server. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Kafka NuGet package.', '<2-hop>\n\nClient integration To get started with the .NET Aspire Apache Kafka integration, install the ðŸ“¦ Aspire.Confluent.Kafka NuGet package in the client-consuming project, that is, the project for the application that uses the Apache Kafka client. .NET CLI dotnetcli dotnet add package Aspire.Confluent.Kafka PackageReference xml <PackageReference Include=""Aspire.Confluent.Kafka"" Version=""*"" /> Add Kafka producer In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddKafkaProducer<string, string>(""messaging""); You can then retrieve the IProducer<TKey, TValue> instance using dependency injection. For example, to retrieve the producer from an IHostedService: csharp internal sealed class Worker(IProducer<string, string> producer) : BackgroundService { // Use producer... } For more information on workers, see Worker services in .NET. Add Kafka consumer To register an IConsumer<TKey, TValue> for use via the dependency injection container, call the csharp builder.AddKafkaConsumer<string, string>(""messaging""); You can then retrieve the IConsumer<TKey, TValue> instance using dependency injection. For example, to retrieve the consumer from an IHostedService: csharp internal sealed class Worker(IConsumer<string, string> consumer) : BackgroundService { // Use consumer... } Add keyed Kafka producers or consumers There might be situations where you want to register multiple producer or consumer instances with different connection names. To register keyed Kafka producers or consumers, call the appropriate API: For more information on keyed services, see .NET dependency injection: Keyed services.', '<3-hop>\n\ntitle: Local Azure provisioning description: Learn how to use Azure resources in your local development environment. ms.date: 12/13/2024 uid: dotnet/aspire/local-azure-provisioning Local Azure provisioning .NET Aspire simplifies local cloud-native app development with its compelling app host model. This model allows you to run your app locally with the same configuration and services as in Azure. In this article you learn how to provision Azure resources from your local development environment through the .NET Aspire app host. [!NOTE] To be clear, resources are provisioned in Azure, but the provisioning process is initiated from your local development environment. To optimize your local development experience, consider using emulator or containers when available. For more information, see Typical developer experience. Requirements This article assumes that you have an Azure account and subscription. If you don\'t have an Azure account, you can create a free one at Azure Free Account. For provisioning functionality to work correctly, you\'ll need to be authenticated with Azure. Ensure that you have the Azure Developer CLI installed. Additionally, you\'ll need to provide some configuration values so that the provisioning logic can create resources on your behalf. App host provisioning APIs The app host provides a set of APIs to express Azure resources. These APIs are available as extension methods in .NET Aspire Azure hosting libraries, extending the When the app host starts, the following provisioning logic is executed: The Azure configuration section is validated. When invalid the dashboard and app host output provides hints as to what\'s missing. For more information, see Missing configuration value hints. When valid Azure resources are conditionally provisioned: If an Azure deployment for a given resource doesn\'t exist, it\'s created and configured as a deployment. The configuration of said deployment is stamped with a checksum as a means to support only provisioning resources as necessary. Use existing Azure resources The app host automatically manages provisioning of Azure resources. The first time the app host runs, it provisions the resources specified in the app host. Subsequent runs don\'t provision the resources again unless the app host configuration changes. If you\'ve already provisioned Azure resources outside of the app host and want to use them, you can provide the connection string with the ```csharp // Service registration var secrets = builder.ExecutionContext.IsPublishMode ? builder.AddAzureKeyVault(""secrets"") : builder.AddConnectionString(""secrets""); // Service consumption builder.AddProject The preceding code snippet shows how to add an Azure Key Vault to the app host. The Alternatively, for some Azure resources, you can opt-in to running them as an emulator with the RunAsEmulator API. This API is available for Azure Cosmos DB and Azure Storage integrations. For example, to run Azure Cosmos DB as an emulator, you can use the following code snippet: csharp var cosmos = builder.AddAzureCosmosDB(""cosmos"") .RunAsEmulator(); The', '<4-hop>\n\n.NET Aspire Azure hosting integrations If you\'re using Azure resources in your app host, you\'re using one or more of the .NET Aspire Azure hosting integrations. These hosting libraries provide extension methods to the Configuration When utilizing Azure resources in your local development environment, you need to provide the necessary configuration values. Configuration values are specified under the Azure section: SubscriptionId: The Azure subscription ID. AllowResourceGroupCreation: A boolean value that indicates whether to create a new resource group. ResourceGroup: The name of the resource group to use. Location: The Azure region to use. Consider the following example :::no-loc text=""appsettings.json""::: configuration: json { ""Azure"": { ""SubscriptionId"": ""<Your subscription id>"", ""AllowResourceGroupCreation"": true, ""ResourceGroup"": ""<Valid resource group name>"", ""Location"": ""<Valid Azure location>"" } } [!IMPORTANT] It\'s recommended to store these values as app secrets. For more information, see Manage app secrets. After you\'ve configured the necessary values, you can start provisioning Azure resources in your local development environment. Azure provisioning credential store The .NET Aspire app host uses a credential store for Azure resource authentication and authorization. Depending on your subscription, the correct credential store may be needed for multi-tenant provisioning scenarios. With the ðŸ“¦ Aspire.Hosting.Azure NuGet package installed, and if your app host depends on Azure resources, the default Azure credential store relies on the json { ""Azure"": { ""CredentialSource"": ""AzureCli"" } } As with all configuration-based settings, you can configure these with alternative providers, such as user secrets or environment variables. The Azure:CredentialSource value can be set to one of the following values: AzureCli: Delegates to the AzurePowerShell: Delegates to the VisualStudio: Delegates to the VisualStudioCode: Delegates to the AzureDeveloperCli: Delegates to the InteractiveBrowser: Delegates to the [!TIP] For more information about the Azure SDK authentication and authorization, see Credential chains in the Azure Identity library for .NET. Tooling support In Visual Studio, you can use Connected Services to configure the default Azure provisioning settings. Select the app host project, right-click on the Connected Services node, and select Azure Resource Provisioning Settings: :::image type=""content"" loc-scope=""visual-studio"" source=""media/azure-resource-provisioning-settings.png"" lightbox=""media/azure-resource-provisioning-settings.png"" alt-text=""Visual Studio 2022: .NET Aspire App Host project, Connected Services context menu.""::: This will open a dialog where you can configure the Azure provisioning settings, as shown in the following screenshot: :::image type=""content"" loc-scope=""visual-studio"" source=""media/azure-provisioning-settings-dialog.png"" lightbox=""media/azure-provisioning-settings-dialog.png"" alt-text=""Visual Studio 2022: Azure Resource Provisioning Settings dialog.""::: Missing configuration value hints When the Azure configuration section is missing, has missing values, or is invalid, the .NET Aspire dashboard provides useful hints. For example, consider an app host that\'s missing the SubscriptionId configuration value that\'s attempting to use an Azure Key Vault resource. The Resources page indicates the State as Missing subscription configuration: :::image type=""content"" source=""media/resources-kv-missing-subscription.png"" alt-text="".NET Aspire dashboard: Missing subscription configuration.""::: Additionally, the Console logs display this information as well, consider the following screenshot: :::image type=""content"" source=""media/console-logs-kv-missing-subscription.png"" lightbox=""media/console-logs-kv-missing-subscription.png"" alt-text="".NET Aspire dashboard: Console logs, missing subscription configuration.""::: Known limitations After provisioning Azure resources in this way, you must manually clean up the resources in the Azure portal as .NET Aspire doesn\'t provide a built-in mechanism to delete Azure resources. The easiest way to achieve this is by deleting the configured resource group. This can be done in the Azure portal or by using the Azure CLI: azurecli az group delete --name <ResourceGroupName> Replace <ResourceGroupName> with the name of the resource group you want to delete. For more information, see az group delete.']","The .NET Aspire integration with Apache Kafka utilizes NuGet packages to enhance developer productivity and service observability by providing specific packages for both hosting and client integration. For hosting integration, the Aspire.Hosting.Kafka NuGet package is used to model a Kafka server as a .NET CLI project, allowing developers to add Kafka server resources and manage them through the .NET Aspire app host. This integration includes features like health checks using the AspNetCore.HealthChecks.Kafka NuGet package to ensure the Kafka server's connectivity and functionality. For client integration, the Aspire.Confluent.Kafka NuGet package is used to facilitate the addition of Kafka producers and consumers in client-consuming projects, enabling dependency injection for these components. This setup allows developers to efficiently manage Kafka messaging within their applications, thereby improving productivity and observability.",multi_hop_abstract_query_synthesizer
48,How do user interactions and distributed tracing work together in the .NET Aspire dashboard using browser telemetry and OTLP endpoints?,"['<1-hop>\n\ntitle: Enable browser telemetry description: Learn how to enable browser telemetry in the .NET Aspire dashboard. ms.date: 11/11/2024 Enable browser telemetry The .NET Aspire dashboard can be configured to receive telemetry sent from browser apps. This feature is useful for monitoring client-side performance and user interactions. Browser telemetry requires additional dashboard configuration and that the JavaScript OTEL SDK is added to the browser apps. This article discusses how to enable browser telemetry in the .NET Aspire dashboard. Dashboard configuration Browser telemetry requires the dashboard to enable these features: OTLP HTTP endpoint. This endpoint is used by the dashboard to receive telemetry from browser apps. Cross-origin resource sharing (CORS). CORS allows browser apps to make requests to the dashboard. OTLP configuration The .NET Aspire dashboard receives telemetry through OTLP endpoints. HTTP OTLP endpoints and gRPC OTLP endpoints are supported by the dashboard. Browser apps must use HTTP OLTP to send telemetry to the dashboard because browser apps don\'t support gRPC. To configure the gPRC or HTTP endpoints, specify the following environment variables: DOTNET_DASHBOARD_OTLP_ENDPOINT_URL: The gRPC endpoint to which the dashboard connects for its data. DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL: The HTTP endpoint to which the dashboard connects for its data. Configuration of the HTTP OTLP endpoint depends on whether the dashboard is started by the app host or is run standalone. Configure OTLP HTTP with app host If the dashboard and your app are started by the app host, the dashboard OTLP endpoints are configured in the app host\'s launchSettings.json file. Consider the following example JSON file: :::code language=""json"" source=""snippets/BrowserTelemetry/BrowserTelemetry.AppHost/Properties/launchSettings.json"" highlight=""12,25""::: The preceding launch settings JSON file configures all profiles to include the DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL environment variable. Configure OTLP HTTP with standalone dashboard If the dashboard is used standalone, without the rest of .NET Aspire, the OTLP HTTP endpoint is enabled by default on port 18890. However, the port must be mapped when the dashboard container is started: Bash bash docker run --rm -it -d \\ -p 18888:18888 \\ -p 4317:18889 \\ -p 4318:18890 \\ --name aspire-dashboard \\ mcr.microsoft.com/dotnet/aspire-dashboard:9.0 PowerShell powershell docker run --rm -it -d ` -p 18888:18888 ` -p 4317:18889 ` -p 4318:18890 ` --name aspire-dashboard ` mcr.microsoft.com/dotnet/aspire-dashboard:9.0 The preceding command runs the dashboard container and maps gRPC OTLP to port 4317 and HTTP OTLP to port 4318. CORS configuration By default, browser apps are restricted from making cross domain API calls. This impacts sending telemetry to the dashboard because the dashboard and the browser app are always on different domains. Configuring CORS in the .NET Aspire dashboard removes the restriction. If the dashboard and your app are started by the app host, no CORS configuration is required. .NET Aspire automatically configures the dashboard to allow all resource origins. If the dashboard is used standlone then CORS must be configured manually. The domain used to view the browser app must be configured as an allowed origin by specifing the DASHBOARD__OTLP__CORS__ALLOWEDORIGINS environment variable when the dashboard container is started: Bash bash docker run --rm -it -d \\ -p 18888:18888 \\ -p 4317:18889 \\ -p 4318:18890 \\ -e DASHBOARD__OTLP__CORS__ALLOWEDORIGINS=https://localhost:8080 \\ --name aspire-dashboard \\ mcr.microsoft.com/dotnet/aspire-dashboard:9.0 PowerShell powershell docker run --rm -it -d ` -p 18888:18888 ` -p 4317:18889 ` -p 4318:18890 ` -e DASHBOARD__OTLP__CORS__ALLOWEDORIGINS=https://localhost:8080 ` --name aspire-dashboard ` mcr.microsoft.com/dotnet/aspire-dashboard:9.0 The preceding command runs the dashboard container and configures https://localhost:8080 as an allowed origin. That means a browser app that is accessed using https://localhost:8080 has permission to send the dashboard telemetry. Multiple origins can be allowed with a comma separated value. Or all origins can be allowed with the * wildcard. For example, DASHBOARD__OTLP__CORS__ALLOWEDORIGINS=*. For more information, see .NET Aspire dashboard configuration: OTLP CORS.', '<2-hop>\n\nOTLP endpoint security Dashboard OTLP endpoints can be secured with API key authentication. When enabled, HTTP OTLP requests to the dashboard must include the API key as the x-otlp-api-key header. By default a new API key is generated each time the dashboard is run. API key authentication is automatically enabled when the dashboard is run from the app host. Dashboard authentication can be disabled by setting DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS to true in the app host\'s launchSettings.json file. OTLP endpoints are unsecured by default in the standalone dashboard. Browser app configuration A browser app uses the JavaScript OTEL SDK to send telemetry to the dashboard. Successfully sending telemetry to the dashboard requires the SDK to be correctly configured. OTLP exporter OTLP exporters must be included in the browser app and configured with the SDK. For example, exporting distributed tracing with OTLP uses the @opentelemetry/exporter-trace-otlp-proto package. When OTLP is added to the SDK, OTLP options must be specified. OTLP options includes: url: The address that HTTP OTLP requests are made to. The address should be the dashboard HTTP OTLP endpoint and the path to the OTLP HTTP API. For example, https://localhost:4318/v1/traces for the trace OTLP exporter. If the browser app is launched by the app host then the HTTP OTLP endpoint is available from the OTEL_EXPORTER_OTLP_ENDPOINT environment variable. headers: The headers sent with requests. If OTLP endpoint API key authentication is enabled the x-otlp-api-key header must be sent with OTLP requests. If the browser app is launched by the app host then the API key is available from the OTEL_EXPORTER_OTLP_HEADERS environment variable. Browser metadata When a browser app is configured to collect distributed traces, the browser app can set the trace parent a browser\'s spans using the meta element in the HTML. The value of the name=""traceparent"" meta element should correspond to the current trace. In a .NET app, for example, the trace parent value would likely be assigned from the razor <head> @if (Activity.Current is { } currentActivity) { <meta name=""traceparent"" content=""@currentActivity.Id"" /> } <!-- Other elements omitted for brevity... --> </head> The preceding code sets the traceparent meta element to the current activity ID. Example browser telemetry code The following JavaScript code demonstrates the initialization of the OpenTelemetry JavaScript SDK and the sending of telemetry data to the dashboard: :::code language=""javascript"" source=""snippets/BrowserTelemetry/BrowserTelemetry.Web/Scripts/index.js""::: The preceding JavaScript code defines an initializeTelemetry function that expects the OTLP endpoint URL, the headers, and the resource attributes. These parameters are provided by the consuming browser app that pulls them from the environment variables set by the app host. Consider the following Razor code: :::code language=""razor"" source=""snippets/BrowserTelemetry/BrowserTelemetry.Web/Pages/Shared/_Layout.cshtml"" highlight=""31-38""::: [!TIP] The bundling and minification of the JavaScript code is beyond the scope of this article. For the complete working example of how to configure the JavaScript OTEL SDK to send telemetry to the dashboard, see the browser telemetry sample. See also .NET Aspire dashboard configuration Standalone .NET Aspire dashboard Browser telemetry sample']","In the .NET Aspire dashboard, user interactions are monitored through browser telemetry, which requires configuring the dashboard to receive telemetry from browser apps. This involves setting up OTLP HTTP endpoints, as browser apps use HTTP OLTP to send telemetry data. Distributed tracing is achieved by configuring the JavaScript OTEL SDK in the browser app, which includes setting up OTLP exporters like the @opentelemetry/exporter-trace-otlp-proto package. The OTLP options must specify the URL of the dashboard's HTTP OTLP endpoint and include necessary headers, such as the x-otlp-api-key if API key authentication is enabled. The browser app can also set the trace parent using the meta element in HTML to correspond to the current trace, allowing for detailed tracing of user interactions. This setup ensures that user interactions and distributed tracing are effectively captured and sent to the .NET Aspire dashboard for analysis.",multi_hop_abstract_query_synthesizer
49,How can Azure Blob storage be integrated into a .NET Aspire application using User Secrets for connection strings?,"['<1-hop>\n\nms.topic: include The .NET Aspire Azure Storage hosting integration models the various storage resources as the following types: To access these types and APIs for expressing them, add the ðŸ“¦ Aspire.Hosting.Azure.Storage NuGet package in the app host project. .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Storage PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Storage"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Azure Storage resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage""); // An Azure Storage resource is required to add any of the following: // // - Azure Blob storage resource. // - Azure Queue storage resource. // - Azure Table storage resource. // After adding all resources, run the app... ``` When you add an AzureStorageResource to the app host, it exposes other useful APIs to add Azure Blob, Queue, and Table storage resources. In other words, you must add an AzureStorageResource before adding any of the other storage resources. [!IMPORTANT] When you call Generated provisioning Bicep If you\'re new to Bicep, it\'s a domain-specific language for defining Azure resources. With .NET Aspire, you don\'t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Storage resource, the following Bicep is generated: The preceding Bicep is a module that provisions an Azure Storage account with the following defaults: kind: The kind of storage account. The default is StorageV2. sku: The SKU of the storage account. The default is Standard_GRS. properties: The properties of the storage account: accessTier: The access tier of the storage account. The default is Hot. allowSharedKeyAccess: A boolean value that indicates whether the storage account permits requests to be authorized with the account access key. The default is false. minimumTlsVersion: The minimum supported TLS version for the storage account. The default is TLS1_2. networkAcls: The network ACLs for the storage account. The default is { defaultAction: \'Allow\' }. In addition to the storage account, it also provisions a blob container. The following role assignments are added to the storage account to grant your application access. See the built-in Azure role-based access control (Azure RBAC) roles for more information: Role / ID Description Storage Blob Data Contributor ba92f5b4-2d11-453d-a403-e96b0029c9fe Read, write, and delete Azure Storage containers and blobs. Storage Table Data Contributor 0a9a7e1f-b9d0-4cc4-a60d-0319b160aaa3 Read, write, and delete Azure Storage tables and entities. Storage Queue Data Contributor 974c5e8b-45b9-4653-ba55-5f855dd0fb88 Read, write, and delete Azure Storage queues and queue messages. The generated Bicep is a starting point and can be customized to meet your specific requirements. Customize provisioning infrastructure All .NET Aspire Azure resources are subclasses of the :::code language=""csharp"" source=""../../snippets/azure/AppHost/Program.ConfigureStorageInfra.cs"" id=""configure""::: The preceding code: Chains a call to the The infra parameter is an instance of the The provisionable resources are retrieved by calling the The single The The A tag is added to the storage account with a key of ExampleKey and a value of Example value. There are many more configuration options available to customize the Azure Storage resource. For more information, see', '<2-hop>\n\nConnect to an existing Azure Storage account You might have an existing Azure Storage account that you want to connect to. Instead of representing a new Azure Storage resource, you can add a connection string to the app host. To add a connection to an existing Azure Storage account, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var blobs = builder.AddConnectionString(""blobs""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE connection-strings-alert] The connection string is configured in the app host\'s configuration, typically under User Secrets, under the ConnectionStrings section. The app host injects this connection string as an environment variable into all dependent resources, for example: json { ""ConnectionStrings"": { ""blobs"": ""https://{account_name}.blob.core.windows.net/"" } } The dependent resource can access the injected connection string by calling the']","To integrate Azure Blob storage into a .NET Aspire application, you first need to add the Aspire.Hosting.Azure.Storage NuGet package to your app host project. This allows you to model various Azure storage resources, including Azure Blob storage. Once the package is added, you can create an Azure Storage resource by calling `builder.AddAzureStorage(""storage"")`. If you have an existing Azure Storage account, you can connect to it by adding a connection string to the app host. This connection string is typically configured under User Secrets in the app host's configuration, under the ConnectionStrings section. The app host then injects this connection string as an environment variable into all dependent resources, allowing them to access the Azure Blob storage.",multi_hop_abstract_query_synthesizer
50,How can Python integration be achieved in a .NET Aspire app while also utilizing Azure Service Bus for messaging services?,"['<1-hop>\n\ntitle: Orchestrate Python apps in .NET Aspire description: Learn how to integrate Python apps into a .NET Aspire app host project. ms.date: 11/11/2024 Orchestrate Python apps in .NET Aspire In this article, you learn how to use Python apps in a .NET Aspire app host. The sample app in this article demonstrates launching a Python application. The Python extension for .NET Aspire requires the use of virtual environments. [!INCLUDE aspire-prereqs] Additionally, you need to install Python on your machine. The sample app in this article was built with Python version 3.12.4 and pip version 24.1.2. To verify your Python and pip versions, run the following commands: python python --version python pip --version To download Python (including pip), see the Python download page. Create a .NET Aspire project using the template To get started launching a Python project in .NET Aspire first use the starter template to create a .NET Aspire application host: dotnetcli dotnet new aspire -o PythonSample In the same terminal session, change directories into the newly created project: dotnetcli cd PythonSample Once the template has been created launch the app host with the following command to ensure that the app host and the .NET Aspire dashboard launches successfully: dotnetcli dotnet run --project PythonSample.AppHost/PythonSample.AppHost.csproj Once the app host starts it should be possible to click on the dashboard link in the console output. At this point the dashboard will not show any resources. Stop the app host by pressing Ctrl + C in the terminal. Prepare a Python app From your previous terminal session where you created the .NET Aspire solution, create a new directory to contain the Python source code. Console mkdir hello-python Change directories into the newly created hello-python directory: Console cd hello-python Initialize the Python virtual environment To work with Python apps, they need to be within a virtual environment. To create a virtual environment, run the following command: python python -m venv .venv For more information on virtual environments, see the Python: Install packages in a virtual environment using pip and venv. To activate the virtual environment, enabling installation and usage of packages, run the following command: Unix/macOS bash source .venv/bin/activate Windows powershell .venv\\Scripts\\Activate.ps1 Ensure that pip within the virtual environment is up-to-date by running the following command: python python -m pip install --upgrade pip Install Python packages Install the Flask package by creating a requirements.txt file in the hello-python directory and adding the following line: python Flask==3.0.3 Then, install the Flask package by running the following command: python python -m pip install -r requirements.txt After Flask is installed, create a new file named main.py in the hello-python directory and add the following code: ```python import os import flask app = flask.Flask(name) @app.route(\'/\', methods=[\'GET\']) def hello_world(): return \'Hello, World!\' if name == \'main\': port = int(os.environ.get(\'PORT\', 8111)) app.run(host=\'0.0.0.0\', port=port) ``` The preceding code creates a simple Flask app that listens on port 8111 and returns the message ""Hello, World!"" when the root endpoint is accessed. Update the app host project Install the Python hosting package by running the following command: dotnetcli dotnet add ../PythonSample.AppHost/PythonSample.AppHost.csproj package Aspire.Hosting.Python --version 9.0.0 After the package is installed, the project XML should have a new package reference similar to the following: :::code language=""xml"" source=""snippets/PythonSample/PythonSample.AppHost/PythonSample.AppHost.csproj""::: Update the app host Program.cs file to include the Python project, by calling the AddPythonApp API and specifying the project name, project path, and the entry point file: :::code source=""snippets/PythonSample/PythonSample.AppHost/Program.cs""::: [!IMPORTANT] The AddPythonApp API is experimental and may change in future releases. For more information, see ASPIREHOSTINGPYTHON001. Run the app Now that you\'ve added the Python hosting package, updated the app host Program.cs file, and created a Python project, you can run the app host: dotnetcli dotnet run --project ../PythonSample.AppHost/PythonSample.AppHost.csproj Launch the dashboard by clicking the link in the console output. The dashboard should display the Python project as a resource. :::image source=""media/python-dashboard.png"" lightbox=""media/python-dashboard.png"" alt-text="".NET Aspire dashboard: Python sample app.""::: Select the Endpoints link to open the hello-python endpoint in a new browser tab. The browser should display the message ""Hello, World!"": :::image source=""media/python-hello-world.png"" lightbox=""media/python-hello-world.png"" alt-text="".NET Aspire dashboard: Python sample app endpoint.""::: Stop the app host by pressing Ctrl + C in the terminal.', '<2-hop>\n\ntitle: .NET Aspire Azure Service Bus integration description: This article describes the .NET Aspire Azure Service Bus integration features and capabilities ms.topic: how-to ms.date: 08/12/2024 .NET Aspire Azure Service Bus integration Cloud-native apps often require communication with messaging services such as Azure Service Bus. Messaging services help decouple applications and enable scenarios that rely on features such as queues, topics and subscriptions, atomic transactions, load balancing, and more. The .NET Aspire Service Bus integration handles the following concerns to connect your app to Azure Service Bus: A Applies ServiceBusClient configurations either inline through code or through configuration file settings. Prerequisites Azure subscription - create one for free Azure Service Bus namespace, learn more about how to add a Service Bus namespace. Alternatively, you can use a connection string, which is not recommended in production environments. Get started To get started with the .NET Aspire Azure Service Bus integration, install the ðŸ“¦ Aspire.Azure.Messaging.ServiceBus NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Service Bus client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.ServiceBus"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Example usage In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureServiceBusClient(""messaging""); To retrieve the configured csharp public class ExampleService(ServiceBusClient client) { // ... } App host usage To add Azure Service Bus hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.ServiceBus"" Version=""*"" /> In your app host project, register the Service Bus integration and consume the service using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var serviceBus = builder.ExecutionContext.IsPublishMode ? builder.AddAzureServiceBus(""messaging"") : builder.AddConnectionString(""messaging""); builder.AddProject Configuration The .NET Aspire Service Bus integration provides multiple options to configure the ServiceBusClient based on the requirements and conventions of your project. Use configuration providers The Service Bus integration supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""ServiceBus"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Identifier"": ""CLIENT_ID"" } } } } } } If you have set up your configurations in the Aspire:Azure:Messaging:ServiceBus section of your :::no-loc text=""appsettings.json""::: file you can just call the method AddAzureServiceBusClient without passing any parameters. Use inline delegates You can also pass the Action<AzureMessagingServiceBusSettings> delegate to set up some or all the options inline, for example to set the FullyQualifiedNamespace: csharp builder.AddAzureServiceBusClient( ""messaging"", static settings => settings.FullyQualifiedNamespace = ""YOUR_SERVICE_BUS_NAMESPACE""); You can also set up the ServiceBusClientOptions using Action<IAzureClientBuilder<ServiceBusClient, ServiceBusClientOptions>> delegate, the second parameter of the AddAzureServiceBus method. For example to set the ServiceBusClient ID to identify the client: csharp builder.AddAzureServiceBusClient( ""messaging"", static clientBuilder => clientBuilder.ConfigureOptions( static options => options.Identifier = ""CLIENT_ID"")); Configuration options The following configurable options are exposed through the Name Description ConnectionString The connection string used to connect to the Service Bus namespace. Credential The credential used to authenticate to the Service Bus namespace. FullyQualifiedNamespace The fully qualified Service Bus namespace. DisableTracing Disables tracing for the Service Bus client. â€  HealthCheckQueueName The name of the queue used for health checks. â€  HealthCheckTopicName The name of the topic used for health checks. â€  At least one of the name options are mandatory when enabling health checks. [!INCLUDE integration-observability-and-telemetry]']","To achieve Python integration in a .NET Aspire app, you need to create a .NET Aspire project using a starter template and incorporate a Python application by setting up a virtual environment and installing necessary packages like Flask. The Python app can be hosted within the .NET Aspire app using the Aspire.Hosting.Python package. For utilizing Azure Service Bus, you can integrate it into your .NET Aspire app by installing the Aspire.Azure.Messaging.ServiceBus NuGet package. This allows the app to communicate with Azure Service Bus, enabling features such as queues and topics for decoupling applications. Configuration can be done through code or configuration files to set up the ServiceBusClient.",multi_hop_abstract_query_synthesizer
51,How can a custom command be created and tested in .NET Aspire to clear the cache of a Redis resource?,"['<1-hop>\n\ntitle: Custom resource commands in .NET Aspire description: Learn how to create custom resource commands in .NET Aspire. ms.date: 11/07/2024 ms.topic: how-to Custom resource commands in .NET Aspire Each resource in the .NET Aspire app model is represented as an [!IMPORTANT] These .NET Aspire dashboard commands are only available when running the dashboard locally. They\'re not available when running the dashboard in Azure Container Apps. Add custom commands to a resource Start by creating a new .NET Aspire Starter App from the available templates. To create the solution from this template, follow the Quickstart: Build your first .NET Aspire solution. After creating this solution, add a new class named RedisResourceBuilderExtensions.cs to the app host project. Replace the contents of the file with the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/RedisResourceBuilderExtensions.cs""::: The preceding code: Shares the Is a static class so that it can contain extension methods. It defines a single extension method named WithClearCommand, extending the IResourceBuilder<RedisResource> interface. The WithClearCommand method registers a command named clear-cache that clears the cache of the Redis resource. The WithClearCommand method returns the IResourceBuilder<RedisResource> instance to allow chaining. The WithCommand API adds the appropriate annotations to the resource, which are consumed in the .NET Aspire dashboard. The dashboard uses these annotations to render the command in the UI. Before getting too far into those details, let\'s ensure that you first understand the parameters of the WithCommand method: name: The name of the command to invoke. displayName: The name of the command to display in the dashboard. executeCommand: The Func<ExecuteCommandContext, Task<ExecuteCommandResult>> to run when the command is invoked, which is where the command logic is implemented. updateState: The Func<UpdateCommandStateContext, ResourceCommandState> callback is invoked to determine the ""enabled"" state of the command, which is used to enable or disable the command in the dashboard. iconName: The name of the icon to display in the dashboard. The icon is optional, but when you do provide it, it should be a valid Fluent UI Blazor icon name. iconVariant: The variant of the icon to display in the dashboard, valid options are Regular (default) or Filled. Execute command logic The executeCommand delegate is where the command logic is implemented. This parameter is defined as a Func<ExecuteCommandContext, Task<ExecuteCommandResult>>. The ExecuteCommandContext provides the following properties: ExecuteCommandContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. ExecuteCommandContext.ResourceName: The name of the resource instance that the command is being executed on. ExecuteCommandContext.CancellationToken: The In the preceding example, the executeCommand delegate is implemented as an async method that clears the cache of the Redis resource. It delegates out to a private class-scoped function named OnRunClearCacheCommandAsync to perform the actual cache clearing. Consider the following code: ```csharp private static async Task await using var connection = ConnectionMultiplexer.Connect(connectionString); var database = connection.GetDatabase(); await database.ExecuteAsync(""FLUSHALL""); return CommandResults.Success(); } ``` The preceding code: Retrieves the connection string from the Redis resource. Connects to the Redis instance. Gets the database instance. Executes the FLUSHALL command to clear the cache. Returns a CommandResults.Success() instance to indicate that the command was successful. Update command state logic The updateState delegate is where the command state is determined. This parameter is defined as a Func<UpdateCommandStateContext, ResourceCommandState>. The UpdateCommandStateContext provides the following properties: UpdateCommandStateContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. UpdateCommandStateContext.ResourceSnapshot: The snapshot of the resource instance that the command is being executed on. The immutable snapshot is an instance of CustomResourceSnapshot, which exposes all sorts of valuable details about the resource instance. Consider the following code: ```csharp private static ResourceCommandState OnUpdateResourceState( UpdateCommandStateContext context) { var logger = context.ServiceProvider.GetRequiredService if (logger.IsEnabled(LogLevel.Information)) { logger.LogInformation( ""Updating resource state: {ResourceSnapshot}"", context.ResourceSnapshot); } return context.ResourceSnapshot.HealthStatus is HealthStatus.Healthy ? ResourceCommandState.Enabled : ResourceCommandState.Disabled; } ``` The preceding code: Retrieves the logger instance from the service provider. Logs the resource snapshot details. Returns ResourceCommandState.Enabled if the resource is healthy; otherwise, it returns ResourceCommandState.Disabled.', '<2-hop>\n\nTest the custom command To test the custom command, update your app host project\'s Program.cs file to include the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/Program.cs"" highlight=""4""::: The preceding code calls the WithClearCommand extension method to add the custom command to the Redis resource. Run the app and navigate to the .NET Aspire dashboard. You should see the custom command listed under the Redis resource. On the Resources page of the dashboard, select the ellipsis button under the Actions column: :::image source=""media/custom-clear-cache-command.png"" lightbox=""media/custom-clear-cache-command.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command displayed.""::: The preceding image shows the Clear cache command that was added to the Redis resource. The icon displays as a rabbit crosses out to indicate that the speed of the dependant resource is being cleared. Select the Clear cache command to clear the cache of the Redis resource. The command should execute successfully, and the cache should be cleared: :::image source=""media/custom-clear-cache-command-succeeded.png"" lightbox=""media/custom-clear-cache-command-succeeded.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command executed.""::: See also .NET Aspire orchestration overview .NET Aspire dashboard: Resource submenu actions']","To create a custom command in .NET Aspire for clearing the cache of a Redis resource, you start by creating a new .NET Aspire Starter App from the available templates. After setting up the solution, add a new class named RedisResourceBuilderExtensions.cs to the app host project. This class should define a static extension method named WithClearCommand, which registers a command called clear-cache. The command logic is implemented in the executeCommand delegate, which connects to the Redis instance and executes the FLUSHALL command to clear the cache. To test the custom command, update the Program.cs file in your app host project to call the WithClearCommand method, adding the custom command to the Redis resource. Run the app and navigate to the .NET Aspire dashboard, where the custom command should be visible under the Redis resource. Selecting the Clear cache command will execute it, successfully clearing the cache.",multi_hop_abstract_query_synthesizer
52,How do you use the NuGet package for Azure-Messaging-ServiceBus in .NET Aspire integration?,"['<1-hop>\n\ntitle: .NET Aspire Azure Service Bus integration description: This article describes the .NET Aspire Azure Service Bus integration features and capabilities ms.topic: how-to ms.date: 08/12/2024 .NET Aspire Azure Service Bus integration Cloud-native apps often require communication with messaging services such as Azure Service Bus. Messaging services help decouple applications and enable scenarios that rely on features such as queues, topics and subscriptions, atomic transactions, load balancing, and more. The .NET Aspire Service Bus integration handles the following concerns to connect your app to Azure Service Bus: A Applies ServiceBusClient configurations either inline through code or through configuration file settings. Prerequisites Azure subscription - create one for free Azure Service Bus namespace, learn more about how to add a Service Bus namespace. Alternatively, you can use a connection string, which is not recommended in production environments. Get started To get started with the .NET Aspire Azure Service Bus integration, install the ðŸ“¦ Aspire.Azure.Messaging.ServiceBus NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Service Bus client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.ServiceBus"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Example usage In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureServiceBusClient(""messaging""); To retrieve the configured csharp public class ExampleService(ServiceBusClient client) { // ... } App host usage To add Azure Service Bus hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.ServiceBus"" Version=""*"" /> In your app host project, register the Service Bus integration and consume the service using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var serviceBus = builder.ExecutionContext.IsPublishMode ? builder.AddAzureServiceBus(""messaging"") : builder.AddConnectionString(""messaging""); builder.AddProject Configuration The .NET Aspire Service Bus integration provides multiple options to configure the ServiceBusClient based on the requirements and conventions of your project. Use configuration providers The Service Bus integration supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""ServiceBus"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Identifier"": ""CLIENT_ID"" } } } } } } If you have set up your configurations in the Aspire:Azure:Messaging:ServiceBus section of your :::no-loc text=""appsettings.json""::: file you can just call the method AddAzureServiceBusClient without passing any parameters. Use inline delegates You can also pass the Action<AzureMessagingServiceBusSettings> delegate to set up some or all the options inline, for example to set the FullyQualifiedNamespace: csharp builder.AddAzureServiceBusClient( ""messaging"", static settings => settings.FullyQualifiedNamespace = ""YOUR_SERVICE_BUS_NAMESPACE""); You can also set up the ServiceBusClientOptions using Action<IAzureClientBuilder<ServiceBusClient, ServiceBusClientOptions>> delegate, the second parameter of the AddAzureServiceBus method. For example to set the ServiceBusClient ID to identify the client: csharp builder.AddAzureServiceBusClient( ""messaging"", static clientBuilder => clientBuilder.ConfigureOptions( static options => options.Identifier = ""CLIENT_ID"")); Configuration options The following configurable options are exposed through the Name Description ConnectionString The connection string used to connect to the Service Bus namespace. Credential The credential used to authenticate to the Service Bus namespace. FullyQualifiedNamespace The fully qualified Service Bus namespace. DisableTracing Disables tracing for the Service Bus client. â€  HealthCheckQueueName The name of the queue used for health checks. â€  HealthCheckTopicName The name of the topic used for health checks. â€  At least one of the name options are mandatory when enabling health checks. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nLogging The .NET Aspire Azure Service Bus integration uses the following log categories: Azure.Core Azure.Identity Azure-Messaging-ServiceBus Tracing [!NOTE] Service Bus ActivitySource support in the Azure SDK for .NET is experimental, and the shape of activities may change in the future without notice. You can enable tracing in several ways: Setting the Azure.Experimental.EnableActivitySource runtime configuration setting to true. Which can be done with either: Call AppContext.SetSwitch(""Azure.Experimental.EnableActivitySource"", true);. Add the RuntimeHostConfigurationOption setting to your project file: xml <ItemGroup> <RuntimeHostConfigurationOption Include=""Azure.Experimental.EnableActivitySource"" Value=""true"" /> </ItemGroup> Set the AZURE_EXPERIMENTAL_ENABLE_ACTIVITY_SOURCE environment variable to ""true"". Can be achieved by chaining a call to WithEnvironment(""AZURE_EXPERIMENTAL_ENABLE_ACTIVITY_SOURCE"", ""true"") When enabled, the .NET Aspire Azure Service Bus integration will emit the following tracing activities using OpenTelemetry: Message ServiceBusSender.Send ServiceBusSender.Schedule ServiceBusSender.Cancel ServiceBusReceiver.Receive ServiceBusReceiver.ReceiveDeferred ServiceBusReceiver.Peek ServiceBusReceiver.Abandon ServiceBusReceiver.Complete ServiceBusReceiver.DeadLetter ServiceBusReceiver.Defer ServiceBusReceiver.RenewMessageLock ServiceBusSessionReceiver.RenewSessionLock ServiceBusSessionReceiver.GetSessionState ServiceBusSessionReceiver.SetSessionState ServiceBusProcessor.ProcessMessage ServiceBusSessionProcessor.ProcessSessionMessage ServiceBusRuleManager.CreateRule ServiceBusRuleManager.DeleteRule ServiceBusRuleManager.GetRules For more information, see: Azure SDK for .NET: Distributed tracing and the Service Bus client. Azure SDK for .NET: OpenTelemetry configuration. Azure SDK for .NET: Enabling experimental tracing features. Metrics The .NET Aspire Azure Service Bus integration currently doesn\'t support metrics by default due to limitations with the Azure SDK for .NET. If that changes in the future, this section will be updated to reflect those changes. See also Azure Service Bus .NET Aspire integrations .NET Aspire GitHub repo', '<3-hop>\n\ntitle: .NET Aspire Azure Event Hubs integration description: This article describes the .NET Aspire Azure Event Hubs integration features and capabilities. ms.topic: how-to ms.date: 08/26/2024 .NET Aspire Azure Event Hubs integration In this article, you learn how to use the .NET Aspire Azure Event Hubs integration. The Aspire.Azure.Messaging.EventHubs library offers options for registering the following types: These type are registered in the DI container for connecting to Azure Event Hubs. Prerequisites Azure subscription: create one for free. Azure Event Hubs namespace: for more information, see add an Event Hubs namespace. Alternatively, you can use a connection string, which isn\'t recommended in production environments. Get started To get started with the .NET Aspire Azure Event Hubs integration, install the ðŸ“¦ Aspire.Azure.Messaging.EventHubs NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Event Hubs client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.EventHubs PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.EventHubs"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Supported clients with options classes The following clients are supported by the library, along with their corresponding options and settings classes: Azure Client type Azure Options class .NET Aspire Settings class EventHubProducerClient EventHubProducerClientOptions AzureMessagingEventHubsProducerSettings EventHubBufferedProducerClient EventHubBufferedProducerClientOptions AzureMessagingEventHubsBufferedProducerSettings EventHubConsumerClient EventHubConsumerClientOptions AzureMessagingEventHubsConsumerSettings EventProcessorClient EventProcessorClientOptions AzureMessagingEventHubsProcessorSettings PartitionReceiver PartitionReceiverOptions AzureMessagingEventHubsPartitionReceiverSettings The client type are from the Azure SDK for .NET, as are the corresponding options classes. The settings classes are provided by the .NET Aspire Azure Event Hubs integration library.']","To use the NuGet package for Azure-Messaging-ServiceBus in .NET Aspire integration, you need to install the Aspire.Azure.Messaging.ServiceBus package in the client-consuming project. This can be done using the .NET CLI with the command 'dotnet add package Aspire.Azure.Messaging.ServiceBus'. Once installed, you can configure the ServiceBusClient either inline through code or through configuration file settings. For example, in the Program.cs file, you can call 'builder.AddAzureServiceBusClient(""messaging"")' to set up the client. Additionally, you can enable tracing by setting the Azure.Experimental.EnableActivitySource runtime configuration to true, which allows the integration to emit tracing activities using OpenTelemetry.",multi_hop_abstract_query_synthesizer
53,How does the .NET Aspire PostgreSQL integration utilize OpenTelemetry and health checks to ensure successful database query execution?,"['<1-hop>\n\ntitle: .NET Aspire health checks description: Explore .NET Aspire health checks ms.date: 09/24/2024 ms.topic: quickstart uid: dotnet/aspire/health-checks Health checks in .NET Aspire Health checks provide availability and state information about an app. Health checks are often exposed as HTTP endpoints, but can also be used internally by the app to write logs or perform other tasks based on the current health. Health checks are typically used in combination with an external monitoring service or container orchestrator to check the status of an app. The data reported by health checks can be used for various scenarios: Influence decisions made by container orchestrators, load balancers, API gateways, and other management services. For instance, if the health check for a containerized app fails, it might be skipped by a load balancer routing traffic. Verify that underlying dependencies are available, such as a database or cache, and return an appropriate status message. Trigger alerts or notifications when an app isn\'t responding as expected. .NET Aspire health check endpoints .NET Aspire exposes two default health check HTTP endpoints in Development environments when the AddServiceDefaults and MapDefaultEndpoints methods are called from the :::no-loc text=""Program.cs""::: file: The /health endpoint indicates if the app is running normally where it\'s ready to receive requests. All health checks must pass for app to be considered ready to accept traffic after starting. http GET /health The /health endpoint returns an HTTP status code 200 and a text/plain value of The /alive indicates if an app is running or has crashed and must be restarted. Only health checks tagged with the live tag must pass for app to be considered alive. http GET /alive The /alive endpoint returns an HTTP status code 200 and a text/plain value of The AddServiceDefaults and MapDefaultEndpoints methods also apply various configurations to your app beyond just health checks, such as OpenTelemetry and service discovery configurations. Non-development environments In non-development environments, the /health and /alive endpoints are disabled by default. If you need to enable them, its recommended to protect these endpoints with various routing features, such as host filtering and/or authorization. For more information, see Health checks in ASP.NET Core. Additionally, it may be advantageous to configure request timeouts and output caching for these endpoints to prevent abuse or denial-of-service attacks. To do so, consider the following modified AddDefaultHealthChecks method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""healthchecks""::: The preceding code: Adds a timeout of 5 seconds to the health check requests with a policy named HealthChecks. Adds a 10-second cache to the health check responses with a policy named HealthChecks. Now consider the updated MapDefaultEndpoints method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""mapendpoints""::: The preceding code: Groups the health check endpoints under the / path. Caches the output and specifies a request time with the corresponding HealthChecks policy. In addition to the updated AddDefaultHealthChecks and MapDefaultEndpoints methods, you must also add the corresponding services for both request timeouts and output caching. In the appropriate consuming app\'s entry point (usually the :::no-loc text=""Program.cs""::: file), add the following code: ```csharp // Wherever your services are being registered. // Before the call to Build(). builder.Services.AddRequestTimeouts(); builder.Services.AddOutputCache(); var app = builder.Build(); // Wherever your app has been built, before the call to Run(). app.UseRequestTimeouts(); app.UseOutputCache(); app.Run(); ``` For more information, see Request timeouts middleware in ASP.NET Core and Output caching middleware in ASP.NET Core.', '<2-hop>\n\nIntegration health checks .NET Aspire integrations can also register additional health checks for your app. These health checks contribute to the returned status of the /health and /alive endpoints. For example, the .NET Aspire PostgreSQL integration automatically adds a health check to verify the following conditions: A database connection could be established A database query could be executed successfully If either of these operations fail, the corresponding health check also fails. Configure health checks You can disable health checks for a given integration using one of the available configuration options. .NET Aspire integrations support Microsoft.Extensions.Configurations to apply settings through config files such as :::no-loc text=""appsettings.json"":::: json { ""Aspire"": { ""Npgsql"": { ""DisableHealthChecks"": true, } } } You can also use an inline delegate to configure health checks: csharp builder.AddNpgsqlDbContext<MyDbContext>( ""postgresdb"", static settings => settings.DisableHealthChecks = true); See also .NET app health checks in C# Health checks in ASP.NET Core']","The .NET Aspire PostgreSQL integration utilizes health checks to ensure successful database query execution by automatically adding checks that verify if a database connection can be established and if a database query can be executed successfully. These health checks contribute to the status of the /health and /alive endpoints. Additionally, the AddServiceDefaults and MapDefaultEndpoints methods apply configurations such as OpenTelemetry, which can enhance observability and monitoring of these operations. If either the database connection or query execution fails, the corresponding health check also fails, indicating an issue with the database operations.",multi_hop_abstract_query_synthesizer
54,How does the .NET Aspire SQL Server Entity Framework Core integration utilize NuGet packages to enhance logging and tracing capabilities?,"['<1-hop>\n\ntitle: .NET Aspire SQL Server Entity Framework Core integration description: Learn how to use the .NET Aspire SQL Server Entity Framework integration, which includes both hosting and client integrations. ms.date: 12/02/2024 uid: database/sql-server-ef-core-integration .NET Aspire SQL Server Entity Framework Core integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server Entity Framework Core integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server Entity Framework Core integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server Entity Framework Core client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.SqlServer"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add SQL Server database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerDbContext. For more information, see Add SQL Server resource and database resource. To retrieve ExampleDbContext object from a service: csharp public class ExampleService(ExampleDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add SQL Server database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichSqlServerDbContext<ExampleDbContext>( connectionName: ""database"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the', '<2-hop>\n\nConfiguration The .NET Aspire SQL Server Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling builder.AddSqlServerDbContext<TContext>(): csharp builder.AddSqlServerDbContext<ExampleDbContext>(""sql""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""sql"": ""Data Source=myserver;Initial Catalog=master"" } } The EnrichSqlServerDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it\'s called. For more information, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server Entity Framework Core integration supports The following is an example of an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""SqlServer"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableMetrics"": false } } } } } Use inline configurations You can also pass the Action<MicrosoftEntityFrameworkCoreSqlServerSettings> delegate to set up some or all the options inline, for example to turn off the metrics: csharp builder.AddSqlServerDbContext<YourDbContext>( ""sql"", static settings => settings.DisableMetrics = true); Configure multiple DbContext connections If you want to register more than one DbContext with different configuration, you can use $""Aspire.Microsoft.EntityFrameworkCore.SqlServer:{typeof(TContext).Name}"" configuration section name. The json configuration would look like: json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""SqlServer"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableMetrics"": false, ""AnotherDbContext"": { ""ConnectionString"": ""AnotherDbContext_CONNECTIONSTRING"", ""DisableTracing"": false } } } } } } Then calling the AddSqlServerDbContext method with AnotherDbContext type parameter would load the settings from Aspire:Microsoft:EntityFrameworkCore:SqlServer:AnotherDbContext section. csharp builder.AddSqlServerDbContext<AnotherDbContext>(""another-sql""); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the SQL Server database to connect to. DbContextPooling A boolean value that indicates whether the db context will be pooled or explicitly created every time it\'s requested MaxRetryCount The maximum number of retry attempts. Default value is 6, set it to 0 to disable the retry mechanism. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. DisableMetrics A boolean value that indicates whether the OpenTelemetry metrics are disabled or not. Timeout The time in seconds to wait for the command to execute. [!INCLUDE integration-health-checks] By default, the .NET Aspire Sql Server Entity Framework Core integration handles the following: Adds the DbContextHealthCheck, which calls EF Core\'s Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire SQL Server Entity Framework Core integration uses the following Log categories: Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Database.Connection Microsoft.EntityFrameworkCore.Database.Transaction Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Migrations Microsoft.EntityFrameworkCore.Model Microsoft.EntityFrameworkCore.Model.Validation Microsoft.EntityFrameworkCore.Query Microsoft.EntityFrameworkCore.Update Tracing The .NET Aspire SQL Server Entity Framework Core integration will emit the following Tracing activities using OpenTelemetry: ""OpenTelemetry.Instrumentation.EntityFrameworkCore"" Metrics The .NET Aspire SQL Server Entity Framework Core integration will emit the following metrics using OpenTelemetry: Microsoft.EntityFrameworkCore: ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second See also Azure SQL Database documentation .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire SQL Server Entity Framework Core integration utilizes NuGet packages to enhance logging and tracing capabilities by incorporating the AspNetCore.HealthChecks.SqlServer NuGet package for hosting integration, which includes health checks for SQL Server resources. Additionally, the integration supports OpenTelemetry for tracing, emitting activities such as 'OpenTelemetry.Instrumentation.EntityFrameworkCore'. The logging is facilitated through various log categories like Microsoft.EntityFrameworkCore.ChangeTracking and Microsoft.EntityFrameworkCore.Database.Command, among others. These features are configured through the EnrichSqlServerDbContext method, which allows for additional services like logging and telemetry to be added to the DbContext.",multi_hop_abstract_query_synthesizer
55,"How does .NET Aspire utilize app host launch profiles to coordinate service projects, and what role do these profiles play in configuring the environment and networking settings?","['<1-hop>\n\ntitle: .NET Aspire and launch profiles description: Learn how .NET Aspire integrates with .NET launch profiles. ms.date: 04/23/2024 .NET Aspire and launch profiles .NET Aspire makes use of launch profiles defined in both the app host and service projects to simplify the process of configuring multiple aspects of the debugging and publishing experience for .NET Aspire-based distributed applications. Launch profile basics When creating a new .NET application from a template developers will often see a Properties directory which contains a file named launchSettings.json. The launch settings file contains a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. The code below is an example of launch profiles in a launchSettings.json file for an ASP.NET Core application. json { ""$schema"": ""http://json.schemastore.org/launchsettings.json"", ""profiles"": { ""http"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": false, ""applicationUrl"": ""http://localhost:5130"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"" } }, ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": false, ""applicationUrl"": ""https://localhost:7106;http://localhost:5130"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"" } } } } The launchSettings.json file above defines two launch profiles, http and https. Each has its own set of environment variables, launch URLs and other options. When launching a .NET Core application developers can choose which launch profile to use. dotnetcli dotnet run --launch-profile https If no launch profile is specified, then the first launch profile is selected by default. It is possible to launch a .NET Core application without a launch profile using the --no-launch-profile option. Some fields from the launchSettings.json file are translated to environment variables. For example, the applicationUrl field is converted to the ASPNETCORE_URLS environment variable which controls which address and port ASP.NET Core binds to. In Visual Studio it\'s possible to select the launch profile when launching the application making it easy to switch between configuration scenarios when manually debugging issues: :::image type=""content"" loc-scope=""visual-studio"" source=""./media/launch-profiles/vs-launch-profile-toolbar.png"" lightbox=""./media/launch-profiles/vs-launch-profile-toolbar.png"" alt-text=""Screenshot of the standard toolbar in Visual Studio with the launch profile selector highlighted.""::: When a .NET application is launched with a launch profile a special environment variable called DOTNET_LAUNCH_PROFILE is populated with the name of the launch profile that was used when launching the process. Launch profiles for .NET Aspire app host In .NET Aspire, the AppHost is just a .NET application. As a result it has a launchSettings.json file just like any other application. Here is an example of the launchSettings.json file generated when creating a new .NET Aspire project from the starter template (dotnet new aspire-starter). json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } }, ""http"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""http://localhost:19240"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""http://localhost:20154"" } } } } The .NET Aspire templates have a very similar set of launch profiles to a regular ASP.NET Core application. When the .NET Aspire app project launches, it starts a For information about app host configuration options, see .NET Aspire app host configuration.', '<2-hop>\n\nRelationship between app host launch profiles and service projects In .NET Aspire the app host is responsible for coordinating the launch of multiple service projects. When you run the app host either via the command line or from Visual Studio (or other development environment) a launch profile is selected for the app host. In turn, the app host will attempt to find a matching launch profile in the service projects it is launching and use those options to control the environment and default networking configuration for the service project. When the app host launches a service project it doesn\'t simply launch the service project using the --launch-profile option. Therefore, there will be no DOTNET_LAUNCH_PROFILE environment variable set for service projects. This is because .NET Aspire modifies the ASPNETCORE_URLS environment variable (derived from the applicationUrl field in the launch profile) to use a different port. By default, .NET Aspire inserts a reverse proxy in front of the ASP.NET Core application to allow for multiple instances of the application using the Other settings such as options from the environmentVariables field are passed through to the application without modification. Control launch profile selection Ideally, it\'s possible to align the launch profile names between the app host and the service projects to make it easy to switch between configuration options on all projects coordinated by the app host at once. However, it may be desirable to control launch profile that a specific project uses. The csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject<Projects.InventoryService>( ""inventoryservice"", launchProfileName: ""mylaunchprofile""); The preceding code shows that the inventoryservice resource (a .NET project) is launched using the options from the mylaunchprofile launch profile. The launch profile precedence logic is as follows: Use the launch profile specified by launchProfileName argument if specified. Use the launch profile with the same name as the AppHost (determined by reading the DOTNET_LAUNCH_PROFILE environment variable). Use the default (first) launch profile in launchSettings.json. Don\'t use a launch profile. To force a service project to launch without a launch profile the launchProfileName argument on the Launch profiles and endpoints When adding an ASP.NET Core project to the app host, .NET Aspire will parse the launchSettings.json file selecting the appropriate launch profile and automatically generate endpoints in the application model based on the URL(s) present in the applicationUrl field. To modify the endpoints that are automatically injected the csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject<Projects.InventoryService>(""inventoryservice"") .WithEndpoint(""https"", endpoint => endpoint.IsProxied = false); The preceding code shows how to disable the reverse proxy that .NET Aspire deploys in front for the .NET Core application and instead allows the .NET Core application to respond directly on requests over HTTP(S). For more information on networking options within .NET Aspire see .NET Aspire inner loop networking overview. See also Kestrel configured endpoints']",".NET Aspire utilizes app host launch profiles to coordinate the launch of multiple service projects by selecting a launch profile for the app host, which then attempts to find a matching launch profile in the service projects it is launching. This coordination allows the app host to control the environment and default networking configuration for the service projects. The launch profiles, defined in the launchSettings.json file, specify options such as environment variables and application URLs, which are used to configure the ASPNETCORE_URLS environment variable and other settings. This setup enables .NET Aspire to insert a reverse proxy in front of the ASP.NET Core application, allowing for multiple instances of the application. Additionally, the launch profile names can be aligned between the app host and service projects to facilitate easy switching between configuration options across all projects managed by the app host.",multi_hop_abstract_query_synthesizer
56,How does the .NET Aspire Azure Queue Storage integration enhance productivity and observability in cloud-native applications?,"['<1-hop>\n\ntitle: .NET Aspire Azure Queue Storage integration description: This article describes the .NET Aspire Azure Queue Storage integration features and capabilities. ms.date: 12/09/2024 uid: storage/azure-queue-storage-integration .NET Aspire Azure Queue Storage integration [!INCLUDE includes-hosting-and-client] Azure Queue Storage is a service for storing large numbers of messages that can be accessed from anywhere in the world via authenticated calls. The .NET Aspire Azure Queue Storage integration enables you to connect to existing Azure Queue Storage instances or create new instances from .NET applications. Hosting integration [!INCLUDE storage-app-host] Add Azure Queue Storage resource In your app host project, register the Azure Queue Storage integration by chaining a call to ```csharp var builder = DistributedApplication.CreateBuilder(args); var queues = builder.AddAzureStorage(""storage"") .AddQueues(""queues""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Adds an Azure Storage resource named storage. Adds a queue named queues to the storage resource. Adds the storage resource to the ExampleProject and waits for it to be ready before starting the project. [!INCLUDE storage-hosting-health-checks] Client integration To get started with the .NET Aspire Azure Queue Storage client integration, install the ðŸ“¦ Aspire.Azure.Storage.Queues NuGet package in the client-consuming project, that is, the project for the application that uses the Azure Queue Storage client. The Azure Queue Storage client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Azure.Storage.Queues PackageReference xml <PackageReference Include=""Aspire.Azure.Storage.Queues"" Version=""*"" /> Add Azure Queue Storage client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureQueueClient(""queue""); You can then retrieve the QueueServiceClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(QueueServiceClient client) { // Use client... } Configuration The .NET Aspire Azure Queue Storage integration provides multiple options to configure the QueueServiceClient based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddAzureQueueClient(""queue""); Then the connection string is retrieved from the ConnectionStrings configuration section, and two connection formats are supported: Service URI The recommended approach is to use a ServiceUri, which works with the json { ""ConnectionStrings"": { ""queue"": ""https://{account_name}.queue.core.windows.net/"" } } Connection string Alternatively, an Azure Storage connection string can be used. json { ""ConnectionStrings"": { ""queue"": ""AccountName=myaccount;AccountKey=myaccountkey"" } } For more information, see Configure Azure Storage connection strings. Use configuration providers The .NET Aspire Azure Queue Storage integration supports json { ""Aspire"": { ""Azure"": { ""Storage"": { ""Queues"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Diagnostics"": { ""ApplicationId"": ""myapp"" } } } } } } } For the complete Azure Storage Queues client integration JSON schema, see Aspire.Azure.Data.Queues/ConfigurationSchema.json. Use inline delegates You can also pass the Action<AzureStorageQueuesSettings> configureSettings delegate to set up some or all the options inline, for example to configure health checks: csharp builder.AddAzureQueueClient( ""queue"", settings => settings.DisableHealthChecks = true); You can also set up the csharp builder.AddAzureQueueClient( ""queue"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Diagnostics.ApplicationId = ""myapp"")); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Queue Storage integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', ""<2-hop>\n\nLogging The .NET Aspire Azure Queue Storage integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Queue Storage integration emits the following tracing activities using OpenTelemetry: Azure.Storage.Queues.QueueClient Metrics The .NET Aspire Azure Queue Storage integration currently doesn't support metrics by default due to limitations with the Azure SDK. See also Azure Queue Storage docs .NET Aspire integrations .NET Aspire GitHub repo"", '<3-hop>\n\ntitle: Create custom .NET Aspire hosting integrations description: Learn how to create a custom .NET Aspire hosting integration for an existing containerized application. ms.date: 11/11/2024 ms.topic: how-to Create custom .NET Aspire hosting integrations .NET Aspire improves the development experience by providing reusable building blocks that can be used to quickly arrange application dependencies and expose them to your own code. One of the key building blocks of an Aspire-based application is the resource. Consider the code below: ```csharp var builder = DistributedApplication.CreateBuilder(args); var redis = builder.AddRedis(""cache""); var db = builder.AddPostgres(""pgserver"") .AddDatabase(""inventorydb""); builder.AddProject In the preceding code there are four resources represented: cache: A Redis container. pgserver: A Postgres container. inventorydb: A database hosted on pgserver. inventoryservice: An ASP.NET Core application. Most .NET Aspire-related code that the average developer writes, centers around adding resources to the app model and creating references between them. Key elements of a .NET Aspire custom resource Building a custom resource in .NET Aspire requires the following: A custom resource type that implements An extension method for When custom resource requires optional configuration, developers may wish to implement With* suffixed extension methods to make these configuration options discoverable using the builder pattern. A practical example: MailDev To help understand how to develop custom resources, this article shows an example of how to build a custom resource for MailDev. MailDev is an open-source tool which provides a local mail server designed to allow developers to test e-mail sending behaviors within their app. For more information, see the MailDev GitHub repository. In this example you create a new .NET Aspire project as a test environment for the MailDev resource that you create. While you can create custom resources in existing .NET Aspire projects it\'s a good idea to consider whether the custom resource might be used across multiple .NET Aspire-based solutions and should be developed as a reusable integration. Set up the starter project Create a new .NET Aspire project that is used to test out the new resource that we\'re developing. dotnetcli dotnet new aspire -o MailDevResource cd MailDevResource dir Once the project is created, you should see a listing containing the following: MailDevResource.AppHost: The app host used to test out the custom resource. MailDevResource.ServiceDefaults: The service defaults project for use in service-related projects. MailDevResource.sln: The solution file referencing both projects. Verify that the project can build and run successfully by executing the following command: dotnetcli dotnet run --project MailDevResource.AppHost/MailDevResource.AppHost.csproj The console output should look similar to the following: dotnetcli Building... info: Aspire.Hosting.DistributedApplication[0] Aspire version: 9.0.0 info: Aspire.Hosting.DistributedApplication[0] Distributed application starting. info: Aspire.Hosting.DistributedApplication[0] Application host directory is: ..\\docs-aspire\\docs\\extensibility\\snippets\\MailDevResource\\MailDevResource.AppHost info: Aspire.Hosting.DistributedApplication[0] Now listening on: https://localhost:17251 info: Aspire.Hosting.DistributedApplication[0] Login to the dashboard at https://localhost:17251/login?t=928db244c720c5022a7a9bf5cf3a3526 info: Aspire.Hosting.DistributedApplication[0] Distributed application started. Press Ctrl+C to shut down. Select the dashboard link in the browser to see the .NET Aspire dashboard: :::image type=""content"" source=""media/maildevresource-empty-dashboard.png"" lightbox=""media/maildevresource-empty-dashboard.png"" alt-text=""A screenshot of the empty .NET Aspire dashboard for test project.""::: Press Ctrl+C to shut down the app (you can close the browser tab).', '<4-hop>\n\nCreate library for resource extension .NET Aspire resources are just classes and methods contained within a class library that references the .NET Aspire Hosting library (Aspire.Hosting). By placing the resource in a separate project, you can more easily share it between .NET Aspire-based apps and potentially package and share it on NuGet. Create the class library project named MailDev.Hosting. dotnetcli dotnet new classlib -o MailDev.Hosting Add Aspire.Hosting to the class library as a package reference. dotnetcli dotnet add ./MailDev.Hosting/MailDev.Hosting.csproj package Aspire.Hosting --version 9.0.0 [!IMPORTANT] The version you specify here should match the version of the .NET Aspire workload installed. Add class library reference to the MailDevResource.AppHost project. dotnetcli dotnet add ./MailDevResource.AppHost/MailDevResource.AppHost.csproj reference ./MailDev.Hosting/MailDev.Hosting.csproj Add class library project to the solution file. dotnetcli dotnet sln ./MailDevResource.sln add ./MailDev.Hosting/MailDev.Hosting.csproj Once the following steps are performed, you can launch the project: dotnetcli dotnet run --project ./MailDevResource.AppHost/MailDevResource.AppHost.csproj This results in a warning being displayed to the console: Output .\\.nuget\\packages\\aspire.hosting.apphost\\9.0.0\\build\\Aspire.Hosting.AppHost.targets(174,5): warning ASPIRE004: \'..\\MailDev.Hosting\\MailDev.Hosting.csproj\' is referenced by an A spire Host project, but it is not an executable. Did you mean to set IsAspireProjectResource=""false""? [D:\\source\\repos\\docs-aspire\\docs\\extensibility\\snippets\\MailDevResource\\MailDevResource.AppHost\\MailDevRe source.AppHost.csproj] This is because .NET Aspire treats project references in the app host as if they\'re service projects. To tell .NET Aspire that the project reference should be treated as a nonservice project modify the :::no-loc text=""MailDevResource.AppHost\\MailDevResource.AppHost.csproj""::: files reference to the MailDev.Hosting project to be the following: ```xml ``` Now when you launch the app host, there\'s no warning displayed to the console. Define the resource types The MailDev.Hosting class library contains the resource type and extension methods for adding the resource to the app host. You should first think about the experience that you want to give developers when using your custom resource. In the case of this custom resource, you would want developers to be able to write code like the following: ```csharp var builder = DistributedApplication.CreateBuilder(args); var maildev = builder.AddMailDev(""maildev""); builder.AddProject To achieve this, you need a custom resource named MailDevResource which implements MailDev is available as a container resource, so you\'ll also want to derive from Replace the contents of the :::no-loc text=""Class1.cs""::: file in the MailDev.Hosting project, and rename the file to :::no-loc text=""MailDevResource.cs""::: with the following code: :::code language=""csharp"" source=""snippets/MailDevResource/MailDev.Hosting/MailDevResource.cs""::: In the preceding custom resource, the Define the resource extensions To make it easy for developers to use the custom resource an extension method named AddMailDev needs to be added to the :::no-loc text=""MailDev.Hosting""::: project. The AddMailDev extension method is responsible for configuring the resource so it can start successfully as a container. Add the following code to a new file named MailDevResourceBuilderExtensions.cs in the MailDev.Hosting project: :::code language=""csharp"" source=""snippets/MailDevResource/MailDev.Hosting/MailDevResourceBuilderExtensions.cs""::: Validate custom integration inside the app host Now that the basic structure for the custom resource is complete it\'s time to test it in a real AppHost project. Open the :::no-loc text=""Program.cs""::: file in the :::no-loc text=""MailDevResource.AppHost""::: project and update it with the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var maildev = builder.AddMailDev(""maildev""); builder.Build().Run(); ``` After updating the :::no-loc text=""Program.cs""::: file, launch the app host project and open the dashboard: dotnetcli dotnet run --project ./MailDevResource.AppHost/MailDevResource.AppHost.csproj After a few moments the dashboard shows that the maildev resource is running and a hyperlink will be available that navigates to the MailDev web app, which shows the content of each e-mail that your app sends. The .NET Aspire dashboard should look similar to the following: :::image type=""content"" source=""media/maildev-in-aspire-dashboard.png"" lightbox=""media/maildev-in-aspire-dashboard.png"" alt-text=""MailDev resource visible in .NET Aspire dashboard.""::: The MailDev web app should look similar to the following: :::image type=""content"" source=""media/maildev-web-ui.png"" lightbox=""media/maildev-web-ui.png"" alt-text=""MailDev web-based user interface running as a container managed by .NET Aspire."":::', '<5-hop>\n\nazd and other deployment tools interpret. Rather than specifying concrete values for connection information between resources an expression syntax is used which deployment tools evaluate. Generally the manifest file isn\'t visible to developers but it\'s possible to generate one for manual inspection. The command below can be used on the app host to produce a manifest. dotnetcli dotnet run --project MailDevResource.AppHost/MailDevResource.AppHost.csproj -- --publisher manifest --output-path aspire-manifest.json This command produces a manifest file like the following: json { ""resources"": { ""maildev"": { ""type"": ""container.v0"", ""connectionString"": ""smtp://{maildev.bindings.smtp.host}:{maildev.bindings.smtp.port}"", ""image"": ""docker.io/maildev/maildev:2.1.0"", ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""targetPort"": 1080 }, ""smtp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""targetPort"": 1025 } } }, ""newsletterservice"": { ""type"": ""project.v0"", ""path"": ""../MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj"", ""env"": { ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES"": ""true"", ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES"": ""true"", ""OTEL_DOTNET_EXPERIMENTAL_OTLP_RETRY"": ""in_memory"", ""ASPNETCORE_FORWARDEDHEADERS_ENABLED"": ""true"", ""ConnectionStrings__maildev"": ""{maildev.connectionString}"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"" }, ""https"": { ""scheme"": ""https"", ""protocol"": ""tcp"", ""transport"": ""http"" } } } } } Because the MailDevResource implements json { // ... other content omitted. ""connectionString"": ""smtp://{maildev.bindings.smtp.host}:{maildev.bindings.smtp.port}"" } .NET Aspire knows how to form this string because it looks at The MailDevResource automatically gets included in the manifest because it\'s derived from ```csharp public static IResourceBuilder return builder.AddResource(resource) .WithImage(MailDevContainerImageTags.Image) .WithImageRegistry(MailDevContainerImageTags.Registry) .WithImageTag(MailDevContainerImageTags.Tag) .WithHttpEndpoint( targetPort: 1080, port: httpPort, name: MailDevResource.HttpEndpointName) .WithEndpoint( targetPort: 1025, port: smtpPort, name: MailDevResource.SmtpEndpointName) .ExcludeFromManifest(); // This line was added } ``` Careful consideration should be given as to whether the resource should be present in the manifest, or whether it should be suppressed. If the resource is being added to the manifest, it should be configured in such a way that it\'s safe and secure to use. Summary In the custom resource tutorial, you learned how to create a custom .NET Aspire resource which uses an existing containerized application (MailDev). You then used that to improve the local development experience by making it easy to test e-mail capabilities that might be used within an app. These learnings can be applied to building out other custom resources that can be used in .NET Aspire-based applications. This specific example didn\'t include any custom integrations, but it\'s possible to build out custom integrations to make it easier for developers to use the resource. In this scenario you were able to rely on the existing SmtpClient class in the .NET platform to send e-mails. Next steps [!div class=""nextstepaction""] Create custom .NET Aspire client integrations']","The .NET Aspire Azure Queue Storage integration enhances productivity by allowing developers to easily connect to existing Azure Queue Storage instances or create new ones directly from .NET applications. This integration simplifies the process of adding Azure Queue Storage resources to an application, as demonstrated by the ability to register the storage and queues in the app host project using a straightforward builder pattern. Additionally, the integration supports client configuration through connection strings and inline delegates, providing flexibility in setup. Observability is improved through the use of logging and tracing activities, such as those emitted by Azure.Storage.Queues.QueueClient, which are integrated with OpenTelemetry. This allows developers to monitor and trace the operations of their applications effectively, although metrics support is currently limited due to Azure SDK constraints.",multi_hop_abstract_query_synthesizer
57,"How do container orchestrators utilize .NET Aspire health checks, and what is the process for upgrading to .NET Aspire 9.0?","['<1-hop>\n\ntitle: .NET Aspire health checks description: Explore .NET Aspire health checks ms.date: 09/24/2024 ms.topic: quickstart uid: dotnet/aspire/health-checks Health checks in .NET Aspire Health checks provide availability and state information about an app. Health checks are often exposed as HTTP endpoints, but can also be used internally by the app to write logs or perform other tasks based on the current health. Health checks are typically used in combination with an external monitoring service or container orchestrator to check the status of an app. The data reported by health checks can be used for various scenarios: Influence decisions made by container orchestrators, load balancers, API gateways, and other management services. For instance, if the health check for a containerized app fails, it might be skipped by a load balancer routing traffic. Verify that underlying dependencies are available, such as a database or cache, and return an appropriate status message. Trigger alerts or notifications when an app isn\'t responding as expected. .NET Aspire health check endpoints .NET Aspire exposes two default health check HTTP endpoints in Development environments when the AddServiceDefaults and MapDefaultEndpoints methods are called from the :::no-loc text=""Program.cs""::: file: The /health endpoint indicates if the app is running normally where it\'s ready to receive requests. All health checks must pass for app to be considered ready to accept traffic after starting. http GET /health The /health endpoint returns an HTTP status code 200 and a text/plain value of The /alive indicates if an app is running or has crashed and must be restarted. Only health checks tagged with the live tag must pass for app to be considered alive. http GET /alive The /alive endpoint returns an HTTP status code 200 and a text/plain value of The AddServiceDefaults and MapDefaultEndpoints methods also apply various configurations to your app beyond just health checks, such as OpenTelemetry and service discovery configurations. Non-development environments In non-development environments, the /health and /alive endpoints are disabled by default. If you need to enable them, its recommended to protect these endpoints with various routing features, such as host filtering and/or authorization. For more information, see Health checks in ASP.NET Core. Additionally, it may be advantageous to configure request timeouts and output caching for these endpoints to prevent abuse or denial-of-service attacks. To do so, consider the following modified AddDefaultHealthChecks method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""healthchecks""::: The preceding code: Adds a timeout of 5 seconds to the health check requests with a policy named HealthChecks. Adds a 10-second cache to the health check responses with a policy named HealthChecks. Now consider the updated MapDefaultEndpoints method: :::code language=""csharp"" source=""snippets/healthz/Healthz.ServiceDefaults/Extensions.cs"" id=""mapendpoints""::: The preceding code: Groups the health check endpoints under the / path. Caches the output and specifies a request time with the corresponding HealthChecks policy. In addition to the updated AddDefaultHealthChecks and MapDefaultEndpoints methods, you must also add the corresponding services for both request timeouts and output caching. In the appropriate consuming app\'s entry point (usually the :::no-loc text=""Program.cs""::: file), add the following code: ```csharp // Wherever your services are being registered. // Before the call to Build(). builder.Services.AddRequestTimeouts(); builder.Services.AddOutputCache(); var app = builder.Build(); // Wherever your app has been built, before the call to Run(). app.UseRequestTimeouts(); app.UseOutputCache(); app.Run(); ``` For more information, see Request timeouts middleware in ASP.NET Core and Output caching middleware in ASP.NET Core.', ""<2-hop>\n\ntitle: Upgrade to .NET Aspire 9.0 description: Learn how to upgrade all your .NET Aspire 8.x projects to .NET Aspire 9.0. ms.date: 11/11/2024 zone_pivot_groups: dev-environment Upgrade to .NET Aspire 9.0 .NET Aspire 9.0 is now generally available. In this article, you learn the steps involved in updating your existing .NET Aspire 8.x projects to .NET Aspire 9.0. There are a few ways in which you can update your projects to .NET Aspire 9.0: Manually upgrade your projects to .NET Aspire 9.0. Use the Upgrade Assistant to upgrade your projects to .NET Aspire 9.0. [!TIP] If you're new to .NET Aspire, there's no reason to upgrade anything. For more information, see .NET Aspire setup and tooling. Prerequisites Before you upgrade your projects to .NET Aspire 9.0, ensure that you have the following prerequisites: Install the latest tooling. Use the .NET Aspire SDK. [!NOTE] Feel free to uninstall the .NET Aspire workload as you'll no longer need it. dotnetcli dotnet workload uninstall aspire For more information, see dotnet workload uninstall. If you don't uninstall the .NET Aspire workload, and you're using the new .NET Aspire SDK and templates, you see both .NET Aspire 8.0 and .NET Aspire 9.0 templates. ""]","Container orchestrators utilize .NET Aspire health checks to monitor the availability and state of an application. Health checks are exposed as HTTP endpoints and can influence decisions made by container orchestrators, such as skipping a containerized app by a load balancer if the health check fails. To upgrade to .NET Aspire 9.0 from 8.x, you can either manually upgrade your projects or use the Upgrade Assistant. Before upgrading, ensure you have the latest tooling and the .NET Aspire SDK installed. It's also recommended to uninstall the .NET Aspire workload if it's no longer needed.",multi_hop_abstract_query_synthesizer
58,How does the command logic in .NET Aspire facilitate the orchestration of custom commands for Redis resources?,"['<1-hop>\n\ntitle: Custom resource commands in .NET Aspire description: Learn how to create custom resource commands in .NET Aspire. ms.date: 11/07/2024 ms.topic: how-to Custom resource commands in .NET Aspire Each resource in the .NET Aspire app model is represented as an [!IMPORTANT] These .NET Aspire dashboard commands are only available when running the dashboard locally. They\'re not available when running the dashboard in Azure Container Apps. Add custom commands to a resource Start by creating a new .NET Aspire Starter App from the available templates. To create the solution from this template, follow the Quickstart: Build your first .NET Aspire solution. After creating this solution, add a new class named RedisResourceBuilderExtensions.cs to the app host project. Replace the contents of the file with the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/RedisResourceBuilderExtensions.cs""::: The preceding code: Shares the Is a static class so that it can contain extension methods. It defines a single extension method named WithClearCommand, extending the IResourceBuilder<RedisResource> interface. The WithClearCommand method registers a command named clear-cache that clears the cache of the Redis resource. The WithClearCommand method returns the IResourceBuilder<RedisResource> instance to allow chaining. The WithCommand API adds the appropriate annotations to the resource, which are consumed in the .NET Aspire dashboard. The dashboard uses these annotations to render the command in the UI. Before getting too far into those details, let\'s ensure that you first understand the parameters of the WithCommand method: name: The name of the command to invoke. displayName: The name of the command to display in the dashboard. executeCommand: The Func<ExecuteCommandContext, Task<ExecuteCommandResult>> to run when the command is invoked, which is where the command logic is implemented. updateState: The Func<UpdateCommandStateContext, ResourceCommandState> callback is invoked to determine the ""enabled"" state of the command, which is used to enable or disable the command in the dashboard. iconName: The name of the icon to display in the dashboard. The icon is optional, but when you do provide it, it should be a valid Fluent UI Blazor icon name. iconVariant: The variant of the icon to display in the dashboard, valid options are Regular (default) or Filled. Execute command logic The executeCommand delegate is where the command logic is implemented. This parameter is defined as a Func<ExecuteCommandContext, Task<ExecuteCommandResult>>. The ExecuteCommandContext provides the following properties: ExecuteCommandContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. ExecuteCommandContext.ResourceName: The name of the resource instance that the command is being executed on. ExecuteCommandContext.CancellationToken: The In the preceding example, the executeCommand delegate is implemented as an async method that clears the cache of the Redis resource. It delegates out to a private class-scoped function named OnRunClearCacheCommandAsync to perform the actual cache clearing. Consider the following code: ```csharp private static async Task await using var connection = ConnectionMultiplexer.Connect(connectionString); var database = connection.GetDatabase(); await database.ExecuteAsync(""FLUSHALL""); return CommandResults.Success(); } ``` The preceding code: Retrieves the connection string from the Redis resource. Connects to the Redis instance. Gets the database instance. Executes the FLUSHALL command to clear the cache. Returns a CommandResults.Success() instance to indicate that the command was successful. Update command state logic The updateState delegate is where the command state is determined. This parameter is defined as a Func<UpdateCommandStateContext, ResourceCommandState>. The UpdateCommandStateContext provides the following properties: UpdateCommandStateContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. UpdateCommandStateContext.ResourceSnapshot: The snapshot of the resource instance that the command is being executed on. The immutable snapshot is an instance of CustomResourceSnapshot, which exposes all sorts of valuable details about the resource instance. Consider the following code: ```csharp private static ResourceCommandState OnUpdateResourceState( UpdateCommandStateContext context) { var logger = context.ServiceProvider.GetRequiredService if (logger.IsEnabled(LogLevel.Information)) { logger.LogInformation( ""Updating resource state: {ResourceSnapshot}"", context.ResourceSnapshot); } return context.ResourceSnapshot.HealthStatus is HealthStatus.Healthy ? ResourceCommandState.Enabled : ResourceCommandState.Disabled; } ``` The preceding code: Retrieves the logger instance from the service provider. Logs the resource snapshot details. Returns ResourceCommandState.Enabled if the resource is healthy; otherwise, it returns ResourceCommandState.Disabled.', '<2-hop>\n\nTest the custom command To test the custom command, update your app host project\'s Program.cs file to include the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/Program.cs"" highlight=""4""::: The preceding code calls the WithClearCommand extension method to add the custom command to the Redis resource. Run the app and navigate to the .NET Aspire dashboard. You should see the custom command listed under the Redis resource. On the Resources page of the dashboard, select the ellipsis button under the Actions column: :::image source=""media/custom-clear-cache-command.png"" lightbox=""media/custom-clear-cache-command.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command displayed.""::: The preceding image shows the Clear cache command that was added to the Redis resource. The icon displays as a rabbit crosses out to indicate that the speed of the dependant resource is being cleared. Select the Clear cache command to clear the cache of the Redis resource. The command should execute successfully, and the cache should be cleared: :::image source=""media/custom-clear-cache-command-succeeded.png"" lightbox=""media/custom-clear-cache-command-succeeded.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command executed.""::: See also .NET Aspire orchestration overview .NET Aspire dashboard: Resource submenu actions']","In .NET Aspire, the command logic is implemented through the executeCommand delegate, which is defined as a Func<ExecuteCommandContext, Task<ExecuteCommandResult>>. This delegate is responsible for executing the command logic, such as clearing the cache of a Redis resource. The orchestration of custom commands is facilitated by the WithClearCommand extension method, which registers the command and adds the appropriate annotations to the resource. These annotations are then consumed by the .NET Aspire dashboard to render the command in the UI, allowing users to execute the command and clear the cache of the Redis resource. The orchestration overview in .NET Aspire provides a framework for managing these custom commands and their execution within the application.",multi_hop_abstract_query_synthesizer
59,"How do .NET Aspire tests utilize lifecycle methods to manage the app host, and what role does the DistributedApplicationFactory class play in this process?","['<1-hop>\n\ntitle: Manage the app host in .NET Aspire tests description: Learn how to manage the app host in .NET Aspire tests. ms.date: 10/21/2024 zone_pivot_groups: unit-testing-framework Manage the app host in .NET Aspire tests When writing functional or integration tests with .NET Aspire, it\'s important to consider how the app host instance is managed across tests, since the app host represents the full application environment and thus can be expensive to create and tear down. In this article, you\'ll learn how to manage the app host instance in your .NET Aspire tests. For writing tests with .NET Aspire, you use the ðŸ“¦ Aspire.Hosting.Testing NuGet package which contains some helper classes to manage the app host instance in your tests. Use the DistributedApplicationTestingBuilder class In the tutorial on writing your first test, you were introduced to the csharp var appHost = await DistributedApplicationTestingBuilder .CreateAsync<Projects.AspireApp_AppHost>(); The :::zone pivot=""xunit"" With xUnit, you implement the IAsyncLifetime interface on the test class to support asynchronous initialization and disposal of the app host instance. The InitializeAsync method is used to create the app host instance before the tests are run and the DisposeAsync method disposes the app host once the tests are completed. ```csharp public class WebTests : IAsyncLifetime { private DistributedApplication _app; public async Task InitializeAsync() { var appHost = await DistributedApplicationTestingBuilder .CreateAsync<Projects.AspireApp_AppHost>(); _app = await appHost.BuildAsync(); } public async Task DisposeAsync() => await _app.DisposeAsync(); [Fact] public async Task GetWebResourceRootReturnsOkStatusCode() { // test code here } } ``` :::zone-end :::zone pivot=""mstest"" With MSTest, you use the ```csharp [TestClass] public class WebTests { private static DistributedApplication _app; [ClassInitialize] public static async Task ClassInitialize(TestContext context) { var appHost = await DistributedApplicationTestingBuilder .CreateAsync<Projects.AspireApp_AppHost>(); _app = await appHost.BuildAsync(); } [ClassCleanup] public static async Task ClassCleanup() => await _app.DisposeAsync(); [TestMethod] public async Task GetWebResourceRootReturnsOkStatusCode() { // test code here } } ``` :::zone-end :::zone pivot=""nunit"" With NUnit, you use the OneTimeSetUp and OneTimeTearDown attributes on methods of the test class to provide the setup and teardown of the app host instance. The OneTimeSetUp method is used to create the app host instance before the tests are run and the OneTimeTearDown method disposes the app host instance once the tests are completed. ```csharp public class WebTests { private DistributedApplication _app; [OneTimeSetUp] public async Task OneTimeSetup() { var appHost = await DistributedApplicationTestingBuilder .CreateAsync<Projects.AspireApp_AppHost>(); _app = await appHost.BuildAsync(); } [OneTimeTearDown] public async Task OneTimeTearDown() => await _app.DisposeAsync(); [Test] public async Task GetWebResourceRootReturnsOkStatusCode() { // test code here } } ``` :::zone-end By capturing the app host in a field when the test run is started, you can access it in each test without the need to recreate it, decreasing the time it takes to run the tests. Then, when the test run has completed, the app host is disposed, which will clean up any resources that were created during the test run, such as containers. Use the DistributedApplicationFactory class While the DistributedApplicationTestingBuilder class is useful for many scenarios, there might be situations where you want more control over starting the app host, such as executing code before the builder is created or after the app host is built. In these cases, you implement your own version of the csharp public class TestingAspireAppHost : DistributedApplicationFactory(typeof(Projects.AspireApp_AppHost)) { // override methods here } The constructor requires the type of the app host project reference as a parameter. Optionally, you can provide arguments to the underlying host application builder. These arguments control how the app host starts and provide values to the args variable used by the Program.cs file to start the app host instance.', '<2-hop>\n\nLifecycle methods The DistributionApplicationFactory class provides several lifecycle methods that can be overridden to provide custom behavior throughout the preperation and creation of the app host. The available methods are OnBuilderCreating, OnBuilderCreated, OnBuilding and OnBuilt. For example, we can use the OnBuilderCreating method to set environment variables, such as the subscription and resource group information for Azure, before the app host is created and any dependent Azure resources are provisioned, resulting in our tests using the correct Azure environment. csharp public class TestingAspireAppHost : DistributedApplicationFactory(typeof(Projects.AspireApp_AppHost)) { protected override void OnBuilderCreating(DistributedApplicationOptions applicationOptions, HostApplicationBuilderSettings hostOptions) { builder.EnvironmentVariables[""AZURE_SUBSCRIPTION_ID""] = ""00000000-0000-0000-0000-000000000000""; builder.EnvironmentVariables[""AZURE_RESOURCE_GROUP""] = ""my-resource-group""; } } Because of the order of precedence in the .NET configuration system, the environment variables will be used over anything in the appsettings.json or secrets.json file. Another scenario you might want to use in the lifecycle is to configure the services used by the app host. In the following example, consider a scenario where you override the OnBuilderCreated API to add resilience to the HttpClient: csharp protected override void OnBuilderCreated( DistributedApplicationBuilder applicationBuilder) { applicationBuilder.Services.ConfigureHttpClientDefaults(clientBuilder => { clientBuilder.AddStandardResilienceHandler(); }); } See also Write your first .NET Aspire test']","In .NET Aspire tests, lifecycle methods are crucial for managing the app host efficiently. The DistributedApplicationFactory class provides several lifecycle methods, such as OnBuilderCreating, OnBuilderCreated, OnBuilding, and OnBuilt, which can be overridden to customize the behavior during the preparation and creation of the app host. For instance, the OnBuilderCreating method can be used to set environment variables like Azure subscription and resource group information before the app host is created, ensuring that tests use the correct Azure environment. Additionally, the OnBuilderCreated method can be overridden to configure services, such as adding resilience to the HttpClient. These lifecycle methods allow for precise control over the app host's setup and teardown, enhancing the testing process by ensuring that the app host is correctly configured and resources are efficiently managed.",multi_hop_abstract_query_synthesizer
60,How does the .NET Aspire dashboard facilitate communication orchestration and enhance observability in cloud-native applications?,"['<1-hop>\n\ntitle: Build your first .NET Aspire solution description: Learn how to build your first .NET Aspire solution using the .NET Aspire Started Application template. ms.date: 11/07/2024 ms.topic: quickstart zone_pivot_groups: dev-environment Quickstart: Build your first .NET Aspire solution Cloud-native apps often require connections to various services such as databases, storage and caching solutions, messaging providers, or other web services. .NET Aspire is designed to streamline connections and configurations between these types of services. This quickstart shows how to create a .NET Aspire Starter Application template solution. In this quickstart, you explore the following tasks: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire. Add and configure a .NET Aspire integration to implement caching at project creation time. Create an API and use service discovery to connect to it. Orchestrate communication between a front end UI, a back end API, and a local Redis cache. [!INCLUDE aspire-prereqs] Create the .NET Aspire template To create a new .NET Aspire Starter Application, you can use either Visual Studio, Visual Studio Code, or the .NET CLI. :::zone pivot=""visual-studio"" [!INCLUDE visual-studio-file-new] :::zone-end :::zone pivot=""vscode"" [!INCLUDE vscode-file-new] :::zone-end :::zone pivot=""dotnet-cli"" [!INCLUDE dotnet-cli-file-new] :::zone-end For more information on the available templates, see .NET Aspire templates.', '<2-hop>\n\nExplore the .NET Aspire dashboard When you run a .NET Aspire project, a dashboard launches that you use to monitor various parts of your app. The dashboard resembles the following screenshot: :::image type=""content"" source=""media/aspire-dashboard.png"" lightbox=""media/aspire-dashboard.png"" alt-text=""A screenshot of the .NET Aspire Dashboard, depicting the Projects tab.""::: Visit each page using the left navigation to view different information about the .NET Aspire resources: Resources: Lists basic information for all of the individual .NET projects in your .NET Aspire project, such as the app state, endpoint addresses, and the environment variables that were loaded in. Console: Displays the console output from each of the projects in your app. Structured: Displays structured logs in table format. These logs support basic filtering, free-form search, and log level filtering as well. You should see logs from the apiservice and the webfrontend. You can expand the details of each log entry by selecting the View button on the right end of the row. Traces: Displays the traces for your application, which can track request paths through your apps. Locate a request for /weather and select View on the right side of the page. The dashboard should display the request in stages as it travels through the different parts of your app. :::image type=""content"" source=""media/aspire-dashboard-trace.png"" lightbox=""media/aspire-dashboard-trace.png"" alt-text=""A screenshot showing an .NET Aspire dashboard trace for the webfrontend /weather route.""::: Metrics: Displays various instruments and meters that are exposed and their corresponding dimensions for your app. Metrics conditionally expose filters based on their available dimensions. :::image type=""content"" source=""media/aspire-dashboard-metrics.png"" lightbox=""media/aspire-dashboard-metrics.png"" alt-text=""A screenshot showing an Aspire dashboard metrics page for the webfrontend.""::: For more information, see .NET Aspire dashboard overview.']","The .NET Aspire dashboard facilitates communication orchestration in cloud-native applications by providing a comprehensive interface to monitor and manage various parts of the application. It allows users to view basic information about individual .NET projects, such as app state and endpoint addresses, which are crucial for orchestrating communication between different services like a front end UI, a back end API, and a local Redis cache. Additionally, the dashboard enhances observability by displaying structured logs, console outputs, and traces that track request paths through the application. This detailed monitoring capability helps in identifying and resolving issues efficiently, thereby improving the overall productivity and reliability of the application.",multi_hop_abstract_query_synthesizer
61,How does the .NET Aspire dashboard facilitate resource management and service discovery?,"['<1-hop>\n\nResources page The Resources page is the default home page of the .NET Aspire dashboard. This page lists all of the .NET projects, containers, and executables included in your .NET Aspire solution. For example, the starter application includes two projects: apiservice: A back-end API project built using Minimal APIs. webfrontend: The front-end UI project built using Blazor. The dashboard also provides essential details about each resource: Type: Displays whether the resource is a project, container, or executable. Name: The name of the resource. State: Displays whether or not the resource is currently running. Errors: Within the State column, errors are displayed as a badge with the error count. It\'s useful to understand quickly what resources are reporting errors. Selecting the badge takes you to the semantic logs for that resource with the filter at an error level. Start time: When the resource started running. Source: The location of the resource on the device. Endpoints: One or more URLs to reach the running resource directly. Logs: A link to the resource logs page. Actions: A set of actions that can be performed on the resource: Stop / Start: Stop (or Start) the resourceâ€”depending on the current State. Console logs: Navigate to the resource\'s console logs. Ellipsis: A submenu with extra resource specific actions: View details: View the resource details. Console log: Navigate to the resource\'s console logs. Structured logs: Navigate to the resource\'s structured logs. Traces: Navigate to the resource\'s traces. Metrics: Navigate to the resource\'s metrics. Restart: Stop and then start the resource. Consider the following screenshot of the resources page: :::image type=""content"" source=""media/explore/projects.png"" lightbox=""media/explore/projects.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page.""::: Resource actions Each resource has a set of available actions that are conditionally enabled based on the resource\'s current state. For example, if a resource is running, the Stop action is enabled. If the resource is stopped, the Start action is enabled. Likewise, some actions are disabled when they\'re unavailable, for example, some resources don\'t have structured logs. In these situations, the Structured logs action is disabled. Stop or Start a resource The .NET Aspire dashboard allows you to stop or start a resource by selecting the Stop or Start button in the Actions column. Consider the following screenshot of the resources page with the Stop button selected: :::image type=""content"" source=""media/explore/resource-stop-action.png"" lightbox=""media/explore/resource-stop-action.png"" alt-text="".NET Aspire dashboard stop resource.""::: When you select Stop, the resource stops running, and the State column updates to reflect the change. [!NOTE] For project resources, when the debugger is attached, it\'s reattached on restart. The Start button is then enabled, allowing you to start the resource again. Additionally, the dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-stopped-action.png"" lightbox=""media/explore/resource-stopped-action.png"" alt-text="".NET Aspire dashboard resource stopped.""::: When a resource is in a non-running state, the Start button is enabled. Selecting Start starts the resource, and the State column updates to reflect the change. The Stop button is then enabled, allowing you to stop the resource again. The dashboard displays a toast notification of the result of the action: :::image type=""content"" source=""media/explore/resource-started-action.png"" lightbox=""media/explore/resource-started-action.png"" alt-text="".NET Aspire dashboard started resource.""::: [!TIP] Resources that depend on other resources that are stopped, or restarted, might experience temporary errors. This is expected behavior and is typically resolved when the dependent resources are in a Running state once again. Resource submenu actions Selecting the horizontal ellipsis icon in the Actions column opens a submenu with additional resource-specific actions. In addition to the built-in resource submenu actions, you can also define custom resource actions by defining custom commands. For more information, see Custom resource commands in .NET Aspire. For the built-in resource submenu actions, consider the following screenshot: :::image type=""content"" source=""media/explore/resource-actions.png"" lightbox=""media/explore/resource-actions.png"" alt-text="".NET Aspire dashboard resource submenu actions.""::: The following submenu actions are available: View details: View the resource details. Console log: Navigate to the resource\'s console logs. Structured logs: Navigate to the resource\'s structured logs. Traces: Navigate to the resource\'s traces. Metrics: Navigate to the resource\'s metrics. Restart: Stop and then start the resource. [!IMPORTANT] There might be resources with disabled submenu actions. They\'re greyed out when they\'re disabled. For example, the following screenshot shows the submenu actions disabled: :::image type=""content"" source=""media/explore/resource-submenu-actions.png"" lightbox=""media/explore/resource-submenu-actions.png"" border=""true"" alt-text="".NET Aspire dashboard disabled submenu actions.""::: Copy or Open in text visualizer To view a text visualizer of certain columns, on hover you see a vertical ellipsis icon. Select the icon to display the available options: Copy to clipboard Open in text visualizer Consider the following screenshot of the ellipsis menu options: :::image type=""content"" source=""media/explore/text-visualizer-selection-menu.png"" lightbox=""media/explore/text-visualizer-selection-menu.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing the ellipsis menu options.""::: When you select the Open in text visualizer option, a modal dialog opens with the text displayed in a larger format. Consider the following screenshot of the text visualizer modal dialog: :::image type=""content"" source=""media/explore/text-visualizer-resources.png"" lightbox=""media/explore/text-visualizer-resources.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing the text visualizer.""::: Some values are formatted as JSON or XML. In these cases, the text visualizer enables the Select format dropdown to switch between the different formats. Resource details You can obtain full details about each resource by selecting the ellipsis button in the Actions column and then selecting View details. The Details page provides a comprehensive view of the resource: :::image type=""content"" source=""media/explore/resource-details.png"" lightbox=""media/explore/resource-details.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page with the details of a selected resource displayed.""::: The search bar in the upper right of the dashboard also provides the option to filter the list, which is useful for .NET Aspire projects with many resources. To select the types of resources that are displayed, drop down the arrow to the left of the filter textbox: :::image type=""content"" source=""media/explore/select-resource-type.png"" alt-text=""A screenshot of the resource type selector list in the .NET Aspire dashboard Resources page.""::: In this example, only containers are displayed in the list. For example, if you enable Use Redis for caching when creating a .NET Aspire project, you should see a Redis container listed: :::image type=""content"" source=""media/explore/resources-filtered-containers.png"" lightbox=""media/explore/resources-filtered-containers.png"" alt-text=""A screenshot of', '<2-hop>\n\nalt-text="".NET Aspire dashboard resource submenu actions.""::: The following submenu actions are available: View details: View the resource details. Console log: Navigate to the resource\'s console logs. Structured logs: Navigate to the resource\'s structured logs. Traces: Navigate to the resource\'s traces. Metrics: Navigate to the resource\'s metrics. Restart: Stop and then start the resource. [!IMPORTANT] There might be resources with disabled submenu actions. They\'re greyed out when they\'re disabled. For example, the following screenshot shows the submenu actions disabled: :::image type=""content"" source=""media/explore/resource-submenu-actions.png"" lightbox=""media/explore/resource-submenu-actions.png"" border=""true"" alt-text="".NET Aspire dashboard disabled submenu actions.""::: Copy or Open in text visualizer To view a text visualizer of certain columns, on hover you see a vertical ellipsis icon. Select the icon to display the available options: Copy to clipboard Open in text visualizer Consider the following screenshot of the ellipsis menu options: :::image type=""content"" source=""media/explore/text-visualizer-selection-menu.png"" lightbox=""media/explore/text-visualizer-selection-menu.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing the ellipsis menu options.""::: When you select the Open in text visualizer option, a modal dialog opens with the text displayed in a larger format. Consider the following screenshot of the text visualizer modal dialog: :::image type=""content"" source=""media/explore/text-visualizer-resources.png"" lightbox=""media/explore/text-visualizer-resources.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing the text visualizer.""::: Some values are formatted as JSON or XML. In these cases, the text visualizer enables the Select format dropdown to switch between the different formats. Resource details You can obtain full details about each resource by selecting the ellipsis button in the Actions column and then selecting View details. The Details page provides a comprehensive view of the resource: :::image type=""content"" source=""media/explore/resource-details.png"" lightbox=""media/explore/resource-details.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page with the details of a selected resource displayed.""::: The search bar in the upper right of the dashboard also provides the option to filter the list, which is useful for .NET Aspire projects with many resources. To select the types of resources that are displayed, drop down the arrow to the left of the filter textbox: :::image type=""content"" source=""media/explore/select-resource-type.png"" alt-text=""A screenshot of the resource type selector list in the .NET Aspire dashboard Resources page.""::: In this example, only containers are displayed in the list. For example, if you enable Use Redis for caching when creating a .NET Aspire project, you should see a Redis container listed: :::image type=""content"" source=""media/explore/resources-filtered-containers.png"" lightbox=""media/explore/resources-filtered-containers.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page filtered to show only containers.""::: Executables are stand-alone processes. You can configure a .NET Aspire project to run a stand-alone executable during startup, though the default starter templates don\'t include any executables by default. The following screenshot shows an example of a project that has errors: :::image type=""content"" source=""media/explore/projects-errors.png"" lightbox=""media/explore/projects-errors.png"" alt-text=""A screenshot of the .NET Aspire dashboard Resources page, showing a project with errors.""::: Selecting the error count badge navigates to the Structured logs page with a filter applied to show only the logs relevant to the resource: :::image type=""content"" source=""media/explore/structured-logs-errors.png"" lightbox=""media/explore/structured-logs-errors.png"" alt-text=""A screenshot of the .NET Aspire dashboard Structured logs page, showing a filter applied to show only the logs relevant to the resource.""::: To see the log entry in detail for the error, select the View button to open a window below the list with the structured log entry details: :::image type=""content"" source=""media/explore/structured-logs-errors-view.png"" lightbox=""media/explore/structured-logs-errors-view.png"" alt-text=""A screenshot of the .NET Aspire dashboard Structured logs page, showing a lower window with the structured log entry details.""::: For more information and examples of Structured logs, see the Structured logs page section. [!NOTE] The resources page isn\'t available if the dashboard is started without a configured resource service. The dashboard starts on the Structured logs page instead. This is the default experience when the dashboard is run in standalone mode without additional configuration. For more information about configuring a resource service, see Dashboard configuration. Monitoring pages The .NET Aspire dashboard provides various ways to view logs, traces, and metrics for your app. This information enables you to track the behavior and performance of your app and to diagnose any issues that arise. Console logs page The Console logs page displays text that each resource in your app has sent to standard output. Logs are a useful way to monitor the health of your app and diagnose issues. Logs are displayed differently depending on the source, such as project, container, or executable. When you open the Console logs page, you must select a source in the Select a resource drop-down list. If you select a project, the live logs are rendered with a stylized set of colors that correspond to the severity of the log; green for information as an example. Consider the following example screenshot of project logs with the apiservice project selected: :::image type=""content"" source=""media/explore/project-logs.png"" lightbox=""media/explore/project-logs.png"" alt-text=""A screenshot of the .NET Aspire dashboard Console Logs page with a source selected.""::: When errors occur, they\'re styled in the logs such that they\'re easy to identify. Consider the following example screenshot of project logs with errors: :::image type=""content"" source=""media/explore/project-logs-error.png"" lightbox=""media/explore/project-logs-error.png"" alt-text=""A screenshot of the .NET Aspire dashboard Console Logs page, showing logs with errors.""::: If you select a container or executable, formatting is different from a project but verbose behavior information is still available. Consider the following example screenshot of a container log with the cache container selected: :::image type=""content"" source=""media/explore/container-logs.png"" lightbox=""media/explore/container-logs.png"" alt-text=""A screenshot of the .NET Aspire dashboard Console logs page with a container source selected.""::: Resource replicas When project resources are replicated using the :::image type=""content"" source=""media/explore/console-logs-with-replicas.png"" lightbox=""media/explore/console-logs-with-replicas.png"" alt-text="".NET Aspire dashboard: Console logs page resource selector with nested replica resources.""::: The preceding screenshot shows the catalogservice (application) project with two replicas, catalogservice-2bpj2qdq6k and catalogservice-6ljdin0hc0. Each replica has its own set of logs that can be viewed by selecting the replica name. Structured logs page .NET Aspire automatically configures your projects with logging using OpenTelemetry. Navigate to the Structured logs page to view the semantic logs for your .NET Aspire project. Semantic, or structured logging makes it easier to store and query log-events, as the log-event message-template and message-parameters are preserved, instead of just transforming them into a formatted message.', '<3-hop>\n\ntitle: .NET Aspire service defaults description: Learn about the .NET Aspire service defaults project. ms.date: 11/04/2024 ms.topic: reference uid: dotnet/aspire/service-defaults .NET Aspire service defaults In this article, you learn about the .NET Aspire service defaults project, a set of extension methods that: Connect telemetry, health checks, service discovery to your app. Are customizable and extensible. Cloud-native applications often require extensive configurations to ensure they work across different environments reliably and securely. .NET Aspire provides many helper methods and tools to streamline the management of configurations for OpenTelemetry, health checks, environment variables, and more. Explore the service defaults project When you either Enlist in .NET Aspire orchestration or create a new .NET Aspire project, the YourAppName.ServiceDefaults.csproj project is added to your solution. For example, when building an API, you call the AddServiceDefaults method in the :::no-loc text=""Program.cs""::: file of your apps: csharp builder.AddServiceDefaults(); The AddServiceDefaults method handles the following tasks: Configures OpenTelemetry metrics and tracing. Adds default health check endpoints. Adds service discovery functionality. Configures For more information, see Provided extension methods for details on the AddServiceDefaults method. [!IMPORTANT] The .NET Aspire service defaults project is specifically designed for sharing the Extensions.cs file and its functionality. Don\'t include other shared functionality or models in this project. Use a conventional shared class library project for those purposes.  Provided extension methods for details on the AddServiceDefaults method. [!IMPORTANT] The .NET Aspire service defaults project is specifically designed for sharing the Extensions.cs file and its functionality. Don\'t include other shared functionality or models in this project. Use a conventional shared class library project for those purposes. Project characteristics The YourAppName.ServiceDefaults project is a .NET 9.0 library that contains the following XML: :::code language=""xml"" source=""snippets/template/YourAppName/YourAppName.ServiceDefaults.csproj"" highlight=""11""::: The service defaults project template imposes a FrameworkReference dependency on Microsoft.AspNetCore.App. [!TIP] If you don\'t want to take a dependency on Microsoft.AspNetCore.App, you can create a custom service defaults project. For more information, see']","The .NET Aspire dashboard facilitates resource management by providing a comprehensive Resources page that lists all .NET projects, containers, and executables in a solution. It allows users to perform actions such as starting, stopping, and restarting resources, and provides detailed information about each resource, including logs and metrics. For service discovery, the .NET Aspire service defaults project includes extension methods that add service discovery functionality to applications, ensuring they work reliably across different environments. This is achieved by configuring OpenTelemetry metrics and tracing, and adding default health check endpoints.",multi_hop_abstract_query_synthesizer
62,How do you configure Azure SQL resource types and provide a master key parameter in .NET Aspire applications?,"['<1-hop>\n\nAzure-specific resource types The following resources are available in the ðŸ“¦ Aspire.Hosting.Azure NuGet package. App Model usage Manifest resource type Heading link azure.bicep.v0 Azure App Configuration resource types azure.bicep.v0 Azure Key Vault resource type AddAzureRedis azure.bicep.v0 Azure Redis resource types azure.bicep.v0 Azure Service Bus resource type AddAzureSqlServer(...) azure.bicep.v0 Azure SQL resource types AddAzureSqlServer(...).AddDatabase(...) value.v0 Azure SQL resource types AddAzurePostgresFlexibleServer(...) azure.bicep.v0 Azure Postgres resource types AddAzurePostgresFlexibleServer(...).AddDatabase(...) value.v0 Azure Postgres resource types azure.storage.v0 Azure Storage resource types value.v0 Azure Storage resource types value.v0 Azure Storage resource types value.v0 Azure Storage resource types Azure Key Vault resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureKeyVault(""keyvault1""); ``` Example manifest: json { ""resources"": { ""keyvault1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{keyvault1.outputs.vaultUri}"", ""path"": ""aspire.hosting.azure.bicep.keyvault.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""vaultName"": ""keyvault1"" } } } } Azure Service Bus resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureServiceBus(""sb1"") .AddTopic(""topic1"", []) .AddTopic(""topic2"", []) .AddQueue(""queue1"") .AddQueue(""queue2""); ``` Example manifest: json { ""resources"": { ""sb1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{sb1.outputs.serviceBusEndpoint}"", ""path"": ""aspire.hosting.azure.bicep.servicebus.bicep"", ""params"": { ""serviceBusNamespaceName"": ""sb1"", ""principalId"": """", ""principalType"": """", ""queues"": [ ""queue1"", ""queue2"" ], ""topics"": [ { ""name"": ""topic1"", ""subscriptions"": [] }, { ""name"": ""topic2"", ""subscriptions"": [] } ] } } } } Azure Storage resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""images""); storage.AddBlobs(""blobs""); storage.AddQueues(""queues""); storage.AddTables(""tables""); ``` Example manifest: json { ""resources"": { ""images"": { ""type"": ""azure.bicep.v0"", ""path"": ""aspire.hosting.azure.bicep.storage.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""storageName"": ""images"" } }, ""blobs"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.blobEndpoint}"" }, ""queues"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.queueEndpoint}"" }, ""tables"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.tableEndpoint}"" } } } Azure Redis resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureRedis(""azredis1""); ``` Example manifest: json { ""resources"": { ""azredis"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{azredis.outputs.connectionString}"", ""path"": ""azredis.module.bicep"", ""params"": { ""principalId"": """", ""principalName"": """" } } } } Azure App Configuration resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureAppConfiguration(""appconfig1""); ``` Example manifest: json { ""resources"": { ""appconfig1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{appconfig1.outputs.appConfigEndpoint}"", ""path"": ""aspire.hosting.azure.bicep.appconfig.bicep"", ""params"": { ""configName"": ""appconfig1"", ""principalId"": """", ""principalType"": """" } } } } Azure SQL resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureSqlServer(""sql"") .AddDatabase(""inventory""); ``` Example manifest: json { ""resources"": { ""sql"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""Server=tcp:{sql.outputs.sqlServerFqdn},1433;Encrypt=True;Authentication=\\u0022Active Directory Default\\u0022"", ""path"": ""sql.module.bicep"", ""params"": { ""principalId"": """", ""principalName"": """" } }, ""inventory"": { ""type"": ""value.v0"", ""connectionString"": ""{sql.connectionString};Database=inventory"" } } } Azure Postgres resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzurePostgresFlexibleServer(""postgres"") .AddDatabase(""db""); ``` Example manifest: json { ""resources"": { ""postgres"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{postgres.outputs.connectionString}"", ""path"": ""postgres.module.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""principalName"": """" } }, ""db"": { ""type"": ""value.v0"", ""connectionString"": ""{postgres.connectionString};Database=db"" } } } Resource types supported in the Azure Developer CLI The Azure Developer CLI (azd) is a tool that can be used to deploy .NET Aspire projects to Azure Container Apps. With the azure.bicep.v0 resource type, cloud-agnostic resource container types can be mapped to Azure-specific resources. The following table lists the resource types that are supported in the Azure Developer CLI: Name Cloud-agnostic API Azure API Redis AddAzureRedis Postgres AddAzurePostgresFlexibleServer SQL Server AddAzureSqlServer When resources as configured as Azure resources, the azure.bicep.v0 resource type is generated in the manifest. For more information, see Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide). See also .NET Aspire overview .NET Aspire orchestration overview .NET Aspire integrations overview Service discovery in .NET Aspire', '<2-hop>\n\ntitle: .NET Aspire Community Toolkit Meilisearch integration description: Learn how to use the .NET Aspire Meilisearch hosting and client integration to run the Meilisearch container and accessing it via the Meilisearch client. ms.date: 10/24/2024 .NET Aspire Community Toolkit Meilisearch integration [!INCLUDE includes-hosting-and-client] [!INCLUDE banner] In this article, you learn how to use the .NET Aspire Meilisearch hosting integration to run Meilisearch container and accessing it via the Meilisearch client. Hosting integration To run the Meilisearch container, install the ðŸ“¦ CommunityToolkit.Aspire.Hosting.Meilisearch NuGet package in the app host project. .NET CLI dotnetcli dotnet add package CommunityToolkit.Aspire.Hosting.Meilisearch PackageReference xml <PackageReference Include=""CommunityToolkit.Aspire.Hosting.Meilisearch"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Meilisearch resource In the app host project, register and consume the Meilisearch integration using the AddMeilisearch extension method to add the Meilisearch container to the application builder. ```csharp var builder = DistributedApplication.CreateBuilder(args); var meilisearch = builder.AddMeilisearch(""meilisearch""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/getmeili/meilisearch image, it creates a new Meilisearch instance on your local machine. A reference to your Meilisearch resource (the meilisearch variable) is added to the ExampleProject. The Meilisearch resource includes a randomly generated master key using the For more information, see Container resource lifecycle. Add Meilisearch resource with data volume To add a data volume to the Meilisearch resource, call the Aspire.Hosting.MeilisearchBuilderExtensions.WithDataVolume method on the Meilisearch resource: ```csharp var builder = DistributedApplication.CreateBuilder(args); var meilisearch = builder.AddMeilisearch(""meilisearch"") .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Meilisearch data outside the lifecycle of its container. The data volume is mounted at the /meili_data path in the Meilisearch container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Meilisearch resource with data bind mount To add a data bind mount to the Meilisearch resource, call the Aspire.Hosting.MeilisearchBuilderExtensions.WithDataBindMount method: ```csharp var builder = DistributedApplication.CreateBuilder(args); var meilisearch = builder.AddMeilisearch(""meilisearch"") .WithDataBindMount( source: @""C:\\Meilisearch\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Meilisearch data across container restarts. The data bind mount is mounted at the C:\\Meilisearch\\Data on Windows (or /Meilisearch/Data on Unix) path on the host machine in the Meilisearch container. For more information on data bind mounts, see Docker docs: Bind mounts. Add Meilisearch resource with master key parameter When you want to explicitly provide the master key used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var masterkey = builder.AddParameter(""masterkey"", secret: true); var meilisearch = builder.AddMeilisearch(""meilisearch"", masterkey); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Client integration To get started with the .NET Aspire Meilisearch client integration, install the ðŸ“¦ CommunityToolkit.Aspire.Meilisearch NuGet package in the client-consuming project, that is, the project for the application that uses the Meilisearch client. .NET CLI dotnetcli dotnet add package CommunityToolkit.Aspire.Meilisearch PackageReference xml <PackageReference Include=""CommunityToolkit.Aspire.Meilisearch"" Version=""*"" /> Add Meilisearch client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the Microsoft.Extensions.Hosting.AspireMeilisearchExtensions.AddMeilisearchClient extension method on any csharp builder.AddMeilisearchClient(connectionName: ""meilisearch""); [!TIP] The connectionName parameter must match the name used when adding the Meilisearch resource in the app host project. For more information, see Add Meilisearch resource. You can then retrieve the MeilisearchClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(MeilisearchClient client) { // Use client... } Add keyed Meilisearch client There might be situations where you want to register multiple MeilisearchClient instances with different connection names. To register keyed Meilisearch clients, call the Microsoft.Extensions.Hosting.AspireMeilisearchExtensions.AddKeyedMeilisearchClient csharp builder.AddKeyedMeilisearchClient(name: ""products""); builder.AddKeyedMeilisearchClient(name: ""orders""); Then you can retrieve the MeilisearchClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""products"")] MeilisearchClient productsClient, [FromKeyedServices(""orders"")] MeilisearchClient ordersClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services.']","In .NET Aspire applications, Azure SQL resource types can be configured using the AddAzureSqlServer method, which is part of the azure.bicep.v0 resource type. This method allows you to add an Azure SQL Server and databases to your application. For example, you can use the following code to add an Azure SQL Server and a database named 'inventory':

```csharp
var builder = DistributedApplication.CreateBuilder(args);
builder.AddAzureSqlServer(""sql"")
    .AddDatabase(""inventory"");
```

The configuration is specified in a manifest file, where the SQL Server and database are defined with their respective connection strings.

To provide a master key parameter, especially when integrating with Meilisearch, you can explicitly provide the master key used by the container image as a parameter. This is done by adding a parameter in the application builder, as shown in the following example:

```csharp
var builder = DistributedApplication.CreateBuilder(args);
var masterkey = builder.AddParameter(""masterkey"", secret: true);
var meilisearch = builder.AddMeilisearch(""meilisearch"", masterkey);
```

This approach allows you to securely manage sensitive information like master keys within your .NET Aspire application.",multi_hop_abstract_query_synthesizer
63,How does the Azure Developer CLI facilitate the deployment of a .NET Aspire project using both GitHub Actions and Azure DevOps pipelines?,"['<1-hop>\n\ntitle: Deploy a .NET Aspire project using the Azure Developer CLI description: Learn how to use azd to deploy .NET Aspire projects. ms.date: 01/08/2025 zone_pivot_groups: deployment-platform ms.custom: devx-track-extended-azdevcli Tutorial: Deploy a .NET Aspire project using the Azure Developer CLI The Azure Developer CLI (azd) enables you to deploy .NET Aspire projects using GitHub Actions or Azure Devops pipelines by automatically configuring the required authentication and environment settings. This article walks you through the process of creating and deploying a .NET Aspire project on Azure Container Apps using azd. You learn the following concepts: [!div class=""checklist""] Explore how azd integration works with .NET Aspire projects Create and configure a GitHub or Azure DevOps repository for a .NET Aspire project using azd Monitor and explore GitHub Actions workflow or Azure DevOps pipeline executions and Azure deployments [!INCLUDE aspire-prereqs] :::zone pivot=""azure-pipelines"" Create an Azure DevOps organization or choose an existing organization Create an Azure DevOps Personal Access Token (PAT) and save it for later use. Configure the token with the following permissions: Agent Pools (read, manage) Build (read and execute) Code (full) Project and team (read, write and manage) Release (read, write, execute and manage) Service Connections (read, query and manage) :::zone-end You also need to have the Azure Developer CLI installed locally (version 1.5.1 or higher). Common install options include the following: Windows powershell winget install microsoft.azd macOS bash brew tap azure/azd && brew install azd Linux bash curl -fsSL https://aka.ms/install-azd.sh | bash Create a .NET Aspire solution As a starting point, this article assumes that you\'ve created a .NET Aspire solution from the .NET Aspire Starter Application template. For more information, see Quickstart: Build your first .NET Aspire app. [!INCLUDE init workflow] :::zone pivot=""github-actions"" Create the GitHub repository and pipeline The Azure Developer CLI enables you to automatically create CI/CD pipelines with the correct configurations and permissions to provision and deploy resources to Azure. azd can also create a GitHub repository for your app if it doesn\'t exist already. Run the azd pipeline config command to configure your deployment pipeline and securely connect it to Azure: azdeveloper azd pipeline config Select the subscription to provision and deploy the app resources to. Select the Azure location to use for the resources. When prompted whether to create a new Git repository in the directory, enter y and press Enter. [!NOTE] Creating a GitHub repository required you being logged into GitHub. There are a few selections that vary based on your preferences. After logging in, you will be prompted to create a new repository in the current directory. Select Create a new private GitHub repository to configure the git remote. Enter a name of your choice for the new GitHub repository or press enter to use the default name. azd creates a new repository in GitHub and configures it with the necessary secrets required to authenticate to Azure. :::image type=""content"" loc-scope=""other"" source=""media/pipeline-configuration.png"" alt-text=""A screenshot showing the pipeline configuration steps.""::: Enter y to proceed when azd prompts you to commit and push your local changes to start the configured pipeline. Explore the GitHub Actions workflow and deployment Navigate to your new GitHub repository using the link output by azd. Select the Actions tab to view the repository workflows. You should see the new workflow either running or already completed. Select the workflow to view the job steps and details in the logs of the run. For example, you can expand steps such as Install .NET Aspire Workload or Deploy application to see the details of the completed action. :::image type=""content"" loc-scope=""github"" source=""media/github-action.png"" alt-text=""A screenshot showing the GitHub Action workflow steps.""::: Select Deploy Application to expand the logs for that step. You should see two endpoint urls printed out for the apiservice and webfrontend. Select either of these links to open them in another browser tab and explore the deployed application. :::image type=""content"" loc-scope=""github"" source=""media/deployment-links.png"" alt-text=""A screenshot showing the deployed app links.""::: Congratulations! You successfully deployed a .NET Aspire project using the Azure Developer CLI and GitHub Actions. :::zone-end :::zone pivot=""azure-pipelines""', '<2-hop>\n\nCreate the Azure DevOps repository and pipeline [!IMPORTANT] As mentioned in the prerequisites, you\'ll need to create an Azure DevOps organization or select an existing organization to complete the steps ahead. You will also need to create a Personal Access Token (PAT) with the permissions listed in the prerequisites. The Azure Developer CLI enables you to automatically create pipelines with the correct configurations and permissions to provision and deploy resources to Azure. azd can also create an Azure Pipelines repository for your app if it doesn\'t exist already. Run the azd pipeline config command to configure your deployment pipeline and securely connect it to Azure. Include the --provider azdo option to use Azure Pipelines instead of the default GitHub Actions configuration. azdeveloper azd pipeline config --provider azdo Select the subscription to provision and deploy the app resources to. Select the Azure location to use for the resources. Paste the Personal Access Token you created earlier. Enter the Azure DevOps Organization name you created or selected. When prompted to create a new repository in the current directory, enter y and press Enter. When prompted to configure the git remote, select Create a new Azure DevOps Project. Enter a unique name of your choice for the new repository, such as aspireazd. azd creates a new repository in Azure Repos and configures it with the necessary secrets required to authenticate to Azure. :::image type=""content"" loc-scope=""other"" source=""media/pipeline-configuration.png"" lightbox=""media/pipeline-configuration.png"" alt-text=""A screenshot showing the pipeline configuration steps.""::: Enter y to proceed when azd prompts you to commit and push your local changes to start the configured pipeline. Explore the pipeline and deployed app Navigate to your new Azure Pipeline using the status link output by azd. :::image type=""content"" loc-scope=""azure"" source=""media/azure-pipeline-run.png"" lightbox=""media/azure-pipeline-run.png"" alt-text=""A screenshot showing the successful Azure Pipelines run.""::: Select the completed pipeline run to view the summary. :::image type=""content"" source=""media/azure-pipeline-summary.png"" alt-text=""A screenshot showing the summary view of the Azure Pipelines run.""::: Select the job link at the bottom of the view to navigate to the job details. :::image type=""content"" loc-scope=""azure"" source=""media/azure-pipeline-run-details.png"" lightbox=""media/azure-pipeline-run-details.png"" alt-text=""A screenshot showing the detailed view of the Azure Pipelines run."" ::: The job details page shows the status of all the individual stages. Select Provision Infrastructure to view the logs for that stage, which detail all of the provisioning steps completed by azd. At the bottom of the logs take note of the final status message and link to the provisioned Azure resource group. Select the link at the bottom of the provisioning output logs to navigate to the new Azure resource group. :::image type=""content"" loc-scope=""azure"" source=""media/azure-pipeline-resource-group.png"" lightbox=""media/azure-pipeline-resource-group.png"" alt-text=""A screenshot showing the deployed Azure resources.""::: [!NOTE] You can also navigate directly to your new resource group by searching for it in the Azure Portal. Your resource group name will be the environment name you provided to azd prefixed with rg-. Select the webfrontend container app, which hosts the public facing portion of your site. On the webfrontend details page, select the Application Url link to open your site in the browser. [!IMPORTANT] If you encounter a 403 Forbidden error when viewing your site in the browser, make sure the ingress settings are configured correctly. On the webfrontend app page in the Azure Portal, navigate to Ingress on the left navigation. Make sure Ingress traffic is set to Accepting traffic from anywhere and save your changes. Congratulations! You successfully deployed a .NET Aspire project using the Azure Developer CLI and Azure Pipelines. :::zone-end [!INCLUDE clean-up-resources]']","The Azure Developer CLI (azd) facilitates the deployment of a .NET Aspire project by enabling the creation and configuration of CI/CD pipelines using either GitHub Actions or Azure DevOps. For GitHub Actions, azd can automatically create a GitHub repository and configure it with the necessary secrets to authenticate to Azure, allowing for the deployment of resources to Azure Container Apps. Similarly, for Azure DevOps, azd can create an Azure Pipelines repository and configure it with the required permissions and secrets. This includes setting up a Personal Access Token (PAT) and selecting the appropriate Azure subscription and location for resource deployment. In both cases, azd streamlines the process by automating the setup of the pipeline configurations and securely connecting them to Azure, thus enhancing developer productivity and service observability.",multi_hop_abstract_query_synthesizer
64,Why might a Cloud Solutions Architect choose .NET Aspire over Docker Compose for orchestration in Kubernetes environments?,"[""<1-hop>\n\nWhy use .NET Aspire service discovery over Docker Compose with Kubernetes? answer: | .NET Aspire service discovery APIs are an abstraction that works with various providers (like Kubernetes and Consul). One of the big advantages is that it works locally and is backed by .NET's `IConfiguration` abstraction. This means you can implement service discovery across your compute fabric in a way that doesn't result in code changes. If you have multiple Kubernetes clusters or services on Azure App Service or Azure Functions, you don't have to fundamentally change your application code to make it work locally, either in a single cluster or across multiple clusters. That's the benefit of the abstraction. question: | Why use .NET Aspire if OpenTelemetry is available in .NET? answer: | .NET Aspire takes a big bet on .NET's integration with OpenTelemetry. The .NET Aspire dashboard is a standard OTLP server that visualizes various telemetry data. Leaning on these open standards makes it easy to build these things without breaking compatibility with the broader ecosystem. question: | Why use .NET Aspire if Grafana, Jaeger, and Prometheus work with .NET? answer: | .NET Aspire isn't a replacement for these tools, but rather a complementary technology. .NET Aspire is a set of libraries and tools that make it easy to build applications that are observable. For more information, see the [Metrics example in the .NET Aspire sample repository](https://github.com/dotnet/aspire samples/tree/main/samples/Metrics) that shows Grafana and Prometheus. question: | Why create another framework when existing ones work well? answer: | .NET Aspire isn't a framework, it's an [opinionated stack](../get started/aspire overview.md). Perhaps the most controversial parts of it are the `DistributedApplication` APIs that you can use to build up the orchestration model in any .NET based language. While everything is possible today, it's not easy. Using the Unix philosophy, the entire cloud native ecosystem is built around tying various pieces of CNCF software together to build a stack. .NET Aspire tries to do the same thing using learnings from the cloud native space and picks some opinions (in ways that use the same building blocks). One novel thing about how .NET Aspire builds various pieces of the stack is that it doesn't restrict the access or compatibility of other applications, frameworks, or services. As people play with it more, they realize how composable and extensible it is. question: | How does .NET Aspire differ from Microsoft Orleans? answer: | Microsoft Orleans and .NET Aspire are complementary technologies. [Orleans](/dotnet/orleans) is a distributed actor-based framework. .NET Aspire is a cloud-ready stack for building observable, production-ready, distributed applications. It includes local orchestration capabilities to simplify the developer inner loop and reusable opinionated components for integrating with commonly used application dependencies. An Orleans-based solution will still have external dependencies such as data stores and caches for which .NET Aspire can be used for orchestration purposes. For more information, see [Use Orleans with .NET Aspire](../frameworks/orleans.md) and the corresponding [Orleans voting app sample](/samples/dotnet/aspire-samples/orleans-voting-sample-app-on-aspire/). question: | How does .NET Aspire differ from Dapr? answer: | Dapr and .NET Aspire are complementary technologies. Where Dapr abstracts some of the underlying cloud platform, .NET Aspire provides opinionated configuration around the underlying cloud technologies without abstracting them. A .NET-based application that uses Dapr can use .NET Aspire to orchestrate the local developer inner loop and streamline deployment. .NET Aspire includes extensions that support the launching of Dapr side-car processes during the inner loop. For more information, see [Use Dapr with .NET Aspire](../frameworks/dapr.md) and the corresponding [Dapr sample app](https://github.com/dotnet/aspire-samples/tree/main/samples/AspireWithDapr) in the .NET Aspire sample repository. question: | How does .NET Aspire differ from Project Tye? answer: | Project Tye was an experiment which explored the launching and orchestration of micro services and support deployment into orchestrators such as Kubernetes. .NET Aspire is a superset of Tye which includes the orchestration and deployment capabilities along with opinionated components for integrating common cloud native dependencies. .NET Aspire can be considered the evolution of the Project Tye experiment. question: | How are .NET Aspire and Azure SDK for .NET related? answer: | .NET Aspire provides components that rely on the [Azure SDK for .NET](/dotnet/azure/intro), to expose common functionality for storage ([Azure Blob Storage](../storage/azure storage blobs component.md), [Azure Storage Queues](../storage/azure storage queues component.md), and [Azure Table Storage](../storage/azure storage tables component.md)), databases ([Azure Cosmos DB](../database/azure cosmos db component.md) and [Azure Cosmos DB with Entity Framework Core](../database/azure cosmos db entity framework component.md)), [messaging](../messaging/azure service bus component.md), and [security](../security/azure security key vault component.md). question: | How are .NET Aspire and Kubernetes related? answer: | .NET Aspire makes it easy to develop distributed applications that can be orchestrated on your local development environment as executables and containers. Kubernetes is a technology that orchestrates and manages containers across multiple machines. .NET Aspire projects can produce a [manifest](../deployment/manifest format.md) that tool authors can use to produce artifacts for deployment to Kubernetes. In essence, Kubernetes is a deployment target for .NET Aspire projects. question: | Are worker services supported in .NET Aspire? answer: | Yes, worker services are fully supported and there are docs and samples available to help you get started. Worker services are a great way to run background tasks, scheduled tasks, or long running tasks in .NET Aspire. For more information, see [Database migrations with Entity Framework Core sample app](/samples/dotnet/aspire samples/aspire efcore migrations/). question: | Are Azure Functions supported in .NET Aspire? answer: | Yes, .NET Aspire has [preview support for integrating Azure Functions into your app](../serverless/functions.md). question: | Does .NET Aspire support running web apps locally on IIS or IIS Express? answer: | No. .NET Aspire doesn't support running web apps on IIS or IIS Express. question: | Does .NET Aspire support deploying apps to IIS? answer: | No. .NET Aspire doesn't support deploying apps to IIS. However, it doesn't prevent you from deploying your apps to IIS in the same way that you always have. question: | How to fix integrations and Service Discovery issues when deploying .NET Aspire apps to IIS? answer: | .NET Aspire integrations require specific configuration that must be provided manually. The same is"", '<2-hop>\n\n### YamlMime:FAQ metadata: title: Frequently asked questions about .NET Aspire description: Answers to some of the most common questions and scenarios for .NET Aspire. ms.topic: faq ms.date: 11/18/2024 title: Frequently asked questions about .NET Aspire summary: | This article lists frequently asked questions about .NET Aspire. For a more comprehensive overview, see [.NET Aspire overview](../get-started/aspire-overview.md). sections: - name: Frequently asked questions questions: - question: | Why choose .NET Aspire over Docker Compose for orchestration? answer: | Docker Compose is excellent but is unproductive when all you want to do is run several projects or executables. Docker Compose requires developers to build container images and to run apps inside of containers. That\'s a barrier when you just want to run your front end, back end, workers, and a database. With .NET Aspire, you don\'t need to learn anything beyond what you already know. Configuration through declarative code is better than through YAML. Docker Compose gets complex once you attempt to do any form of abstraction or composition (for example, see the old [eshopOnContainers app](https://github.com/dotnet-architecture/eShopOnContainers/tree/dev/src)). In addition, there are environment variable replacements (and includes) and no types or IntelliSense, and it\'s hard to reason about what exactly is running. Debugging is also difficult. .NET Aspire produces a better experience that\'s easy to get started and scales up to an orchestrator like Compose using a real programming language. question: | How to add projects to .NET Aspire? answer: | You can manually add projects to your .NET Aspire solution by using the `builder.AddProject(""<name>"", ""<path/to/project.csproj>"")` API. question: | How to deploy .NET Aspire without target cloud provider tooling? answer: | .NET Aspire doesn\'t constrain deployment of any existing project or solution. .NET Aspire exposes a [deployment manifest](../deployment/manifest format.md) that\'s used by tool authors to produce artifacts for deployment to any cloud provider. However, unfortunately, not all cloud providers offer tooling for deployments based on this manifest. The manifest is a simple JSON file that describes the resources of your app and the dependencies between them. The manifest is used by the Azure Developer CLI to deploy to Azure. Likewise, Aspir8 uses the manifest to deploy to Kubernetes. You can use the manifest to deploy to any cloud provider that supports the resources you\'re using. question: | Can .NET Aspire apps be built without Azure dependencies and deployed elsewhere? answer: | Yes, you can build .NET Aspire apps without using any Azure proprietary dependencies. While .NET Aspire does offer a first party solution to deploying to Azure, it\'s not a requirement. .NET Aspire is a cloud native stack that can be used to build applications that run anywhere. All Azure specific offerings are explicitly called out as such. question: | true for [Service Discovery](../service discovery/overview.md), ideally, you should deploy to something other than IIS. question: | What is the purpose of the Community Toolkit project? answer: | The goal of the project is to be a centralized home for extensions and integrations for [.NET Aspire](/dotnet/aspire), helping to provide consistency in the way that integrations are built and maintained, as well as easier discoverability for users. question: | How is the Community Toolkit project different from the official .NET Aspire project? answer: | The .NET Aspire Community Toolkit is a community driven project that\'s maintained by the community and isn\'t officially supported by the .NET Aspire team. The toolkit is a collection of integrations and extensions that are built on top of the .NET Aspire project. question: | How can I contribute to the Community Toolkit project? answer: | Anyone can contribute to the .NET Aspire Community Toolkit and before you get started, be sure to read the [Contributing Guide](https://github.com/CommunityToolkit/Aspire/blob/main/CONTRIBUTING.md) to learn how to contribute to the project. question: | Should I propose a new integration on the Community Toolkit or the `dotnet/aspire` repo? answer: | If you have an idea for a new integration, you should propose it on the [.NET Aspire Community Toolkit repository](https://github.com/CommunityToolkit/Aspire), rather than [`dotnet/aspire`](https://github.com/dotnet/aspire), as the official .NET Aspire project is focused on the core functionality of the .NET Aspire project. If you\'ve proposed an integration on the `dotnet/aspire` repository, you can still propose it in the Community Toolkit, but link to the existing issue on the `dotnet/aspire` repository to provide context. question: | How can I find Community Toolkit integrations? answer: | Integrations from the .NET Aspire Community Toolkit appear in the **Add Aspire Integration ** dialog in Visual Studio under the namespace `CommunityToolkit.Aspire. `. additionalContent: | ## Next steps To learn more about networking and functions: [.NET Aspire overview](../get started/aspire overview.md) [Build your first .NET Aspire project](../get started/build your first aspire app.md) [.NET Aspire components](../fundamentals/components overview.md)']",".NET Aspire offers several advantages over Docker Compose for orchestration in Kubernetes environments. While Docker Compose is excellent for running several projects or executables, it requires developers to build container images and run apps inside containers, which can be a barrier when you just want to run your front end, back end, workers, and a database. .NET Aspire simplifies this process by allowing configuration through declarative code, which is more straightforward than using YAML. Additionally, .NET Aspire provides a better experience for abstraction and composition, making it easier to get started and scale up to an orchestrator like Kubernetes using a real programming language. This makes it particularly appealing for a Cloud Solutions Architect who is focused on enhancing productivity and observability in cloud-native applications.",multi_hop_abstract_query_synthesizer
65,"How can .NET Aspire be used to integrate Python applications with telemetry support, and what role does Application Insights play in enhancing observability?","['<1-hop>\n\ntitle: Orchestrate Python apps in .NET Aspire description: Learn how to integrate Python apps into a .NET Aspire app host project. ms.date: 11/11/2024 Orchestrate Python apps in .NET Aspire In this article, you learn how to use Python apps in a .NET Aspire app host. The sample app in this article demonstrates launching a Python application. The Python extension for .NET Aspire requires the use of virtual environments. [!INCLUDE aspire-prereqs] Additionally, you need to install Python on your machine. The sample app in this article was built with Python version 3.12.4 and pip version 24.1.2. To verify your Python and pip versions, run the following commands: python python --version python pip --version To download Python (including pip), see the Python download page. Create a .NET Aspire project using the template To get started launching a Python project in .NET Aspire first use the starter template to create a .NET Aspire application host: dotnetcli dotnet new aspire -o PythonSample In the same terminal session, change directories into the newly created project: dotnetcli cd PythonSample Once the template has been created launch the app host with the following command to ensure that the app host and the .NET Aspire dashboard launches successfully: dotnetcli dotnet run --project PythonSample.AppHost/PythonSample.AppHost.csproj Once the app host starts it should be possible to click on the dashboard link in the console output. At this point the dashboard will not show any resources. Stop the app host by pressing Ctrl + C in the terminal. Prepare a Python app From your previous terminal session where you created the .NET Aspire solution, create a new directory to contain the Python source code. Console mkdir hello-python Change directories into the newly created hello-python directory: Console cd hello-python Initialize the Python virtual environment To work with Python apps, they need to be within a virtual environment. To create a virtual environment, run the following command: python python -m venv .venv For more information on virtual environments, see the Python: Install packages in a virtual environment using pip and venv. To activate the virtual environment, enabling installation and usage of packages, run the following command: Unix/macOS bash source .venv/bin/activate Windows powershell .venv\\Scripts\\Activate.ps1 Ensure that pip within the virtual environment is up-to-date by running the following command: python python -m pip install --upgrade pip Install Python packages Install the Flask package by creating a requirements.txt file in the hello-python directory and adding the following line: python Flask==3.0.3 Then, install the Flask package by running the following command: python python -m pip install -r requirements.txt After Flask is installed, create a new file named main.py in the hello-python directory and add the following code: ```python import os import flask app = flask.Flask(name) @app.route(\'/\', methods=[\'GET\']) def hello_world(): return \'Hello, World!\' if name == \'main\': port = int(os.environ.get(\'PORT\', 8111)) app.run(host=\'0.0.0.0\', port=port) ``` The preceding code creates a simple Flask app that listens on port 8111 and returns the message ""Hello, World!"" when the root endpoint is accessed. Update the app host project Install the Python hosting package by running the following command: dotnetcli dotnet add ../PythonSample.AppHost/PythonSample.AppHost.csproj package Aspire.Hosting.Python --version 9.0.0 After the package is installed, the project XML should have a new package reference similar to the following: :::code language=""xml"" source=""snippets/PythonSample/PythonSample.AppHost/PythonSample.AppHost.csproj""::: Update the app host Program.cs file to include the Python project, by calling the AddPythonApp API and specifying the project name, project path, and the entry point file: :::code source=""snippets/PythonSample/PythonSample.AppHost/Program.cs""::: [!IMPORTANT] The AddPythonApp API is experimental and may change in future releases. For more information, see ASPIREHOSTINGPYTHON001. Run the app Now that you\'ve added the Python hosting package, updated the app host Program.cs file, and created a Python project, you can run the app host: dotnetcli dotnet run --project ../PythonSample.AppHost/PythonSample.AppHost.csproj Launch the dashboard by clicking the link in the console output. The dashboard should display the Python project as a resource. :::image source=""media/python-dashboard.png"" lightbox=""media/python-dashboard.png"" alt-text="".NET Aspire dashboard: Python sample app.""::: Select the Endpoints link to open the hello-python endpoint in a new browser tab. The browser should display the message ""Hello, World!"": :::image source=""media/python-hello-world.png"" lightbox=""media/python-hello-world.png"" alt-text="".NET Aspire dashboard: Python sample app endpoint.""::: Stop the app host by pressing Ctrl + C in the terminal.', '<2-hop>\n\nAdd telemetry support. To add a bit of observability, add telemetry to help monitor the dependant Python app. In the Python project, add the following OpenTelemetry package as a dependency in the requirements.txt file: :::code language=""python"" source=""snippets/PythonSample/hello-python/requirements.txt"" highlight=""2-5""::: The preceding requirement update, adds the OpenTelemetry package and the OTLP exporter. Next, re-install the Python app requirements into the virtual environment by running the following command: python python -m pip install -r requirements.txt The preceding command installs the OpenTelemetry package and the OTLP exporter, in the virtual environment. Update the Python app to include the OpenTelemetry code, by replacing the existing main.py code with the following: :::code language=""python"" source=""snippets/PythonSample/hello-python/main.py""::: Update the app host project\'s launchSettings.json file to include the ASPIRE_ALLOW_UNSECURED_TRANSPORT environment variable: :::code language=""json"" source=""snippets/PythonSample/PythonSample.AppHost/Properties/launchSettings.json""::: The ASPIRE_ALLOW_UNSECURED_TRANSPORT variable is required because when running locally the OpenTelemetry client in Python rejects the local development certificate. Launch the app host again: dotnetcli dotnet run --project ../PythonSample.AppHost/PythonSample.AppHost.csproj Once the app host has launched navigate to the dashboard and note that in addition to console log output, structured logging is also being routed through to the dashboard. :::image source=""media/python-telemetry-in-dashboard.png"" lightbox=""media/python-telemetry-in-dashboard.png"" alt-text="".NET Aspire dashboard: Structured logging from Python process.""::: Summary While there are several considerations that are beyond the scope of this article, you learned how to build .NET Aspire solution that integrates with Python. You also learned how to use the AddPythonApp API to host Python apps. See also GitHub: .NET Aspire Samplesâ€”Python hosting integration', '<3-hop>\n\ntitle: Use .NET Aspire with Application Insights description: Learn how to send .NET Aspire telemetry to Application Insights. ms.date: 04/12/2024 ms.topic: how-to Use Application Insights for .NET Aspire telemetry Azure Application Insights, a feature of Azure Monitor, excels in Application Performance Management (APM) for live web applications. .NET Aspire projects are designed to use OpenTelemetry for application telemetry. OpenTelemetry supports an extension model to support sending data to different APMs. .NET Aspire uses OTLP by default for telemetry export, which is used by the dashboard during development. Azure Monitor doesn\'t (yet) support OTLP, so the applications need to be modified to use the Azure Monitor exporter, and configured with the connection string. To use Application insights, you specify its configuration in the app host project and use the Azure Monitor distro in the service defaults project. Choosing how Application Insights is provisioned .NET Aspire has the capability to provision cloud resources as part of cloud deployment, including Application Insights. In your .NET Aspire project, you can decide if you want .NET Aspire to provision an Application Insights resource when deploying to Azure. You can also select to use an existing Application Insights resource by providing its connection string. The connection information is managed by the resource configuration in the app host project. Provisioning Application insights during Azure deployment With this option, an instance of Application Insights will be created for you when the application is deployed using the Azure Developer CLI (azd). To use automatic provisioning, you specify a dependency in the app host project, and reference it in each project/resource that needs to send telemetry to Application Insights. The steps include: Add a Nuget package reference to Aspire.Hosting.Azure.ApplicationInsights in the app host project. Update the app host code to use the Application Insights resource, and reference it from each project: ```csharp var builder = DistributedApplication.CreateBuilder(args); // Automatically provision an Application Insights resource var insights = builder.AddAzureApplicationInsights(""MyApplicationInsights""); // Reference the resource from each project var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` Follow the steps in Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide) to deploy the application to Azure Container Apps. azd will create an Application Insights resource as part of the same resource group, and configure the connection string for each container. Manual provisioning of Application Insights resource Application Insights uses a connection string to tell the OpenTelemetry exporter where to send the telemetry data. The connection string is specific to the instance of Application Insights you want to send the telemetry to. It can be found in the Overview page for the application insights instance. :::image type=""content"" loc-scope=""azure"" source=""../media/app-insights-connection-string.png"" lightbox=""../media/app-insights-connection-string.png"" alt-text=""Connection string placement in the Azure Application Insights portal UI.""::: If you wish to use an instance of Application Insights that you have provisioned manually, then you should use the AddConnectionString API in the app host project to tell the projects/containers where to send the telemetry data. The Azure Monitor distro expects the environment variable to be APPLICATIONINSIGHTS_CONNECTION_STRING, so that needs to be explicitly set when defining the connection string. ```csharp var builder = DistributedApplication.CreateBuilder(args); var insights = builder.AddConnectionString( ""myInsightsResource"", ""APPLICATIONINSIGHTS_CONNECTION_STRING""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ```']","To integrate Python applications with .NET Aspire, you start by creating a .NET Aspire app host project and incorporating a Python app using the AddPythonApp API. This involves setting up a Python virtual environment and installing necessary packages like Flask. For telemetry support, you add the OpenTelemetry package to the Python app, which allows for monitoring and observability. The OpenTelemetry package is installed as a dependency in the Python project's requirements.txt file, and the app is updated to include OpenTelemetry code. The .NET Aspire dashboard then displays structured logging from the Python process. Application Insights, a feature of Azure Monitor, can further enhance observability by providing Application Performance Management (APM) for live web applications. Although .NET Aspire uses OTLP by default for telemetry export, it can be configured to send telemetry data to Application Insights by using the Azure Monitor exporter. This involves specifying a connection string in the app host project and potentially provisioning an Application Insights resource during Azure deployment. This setup allows for comprehensive monitoring and performance management of applications integrated with .NET Aspire.",multi_hop_abstract_query_synthesizer
66,How to use .NET Aspire with Azure Key Vault and what are the configuration options?,"['<1-hop>\n\ntitle: .NET Aspire Azure Key Vault integration description: Lean about the .NET Aspire Azure Key Vault integration. ms.topic: how-to ms.date: 08/12/2024 .NET Aspire Azure Key Vault integration In this article, you learn how to use the .NET Aspire Azure Key Vault integration. The Aspire.Azure.Key.Vault integration library is used to register a Get started To get started with the .NET Aspire Azure Key Vault integration, install the ðŸ“¦ Aspire.Azure.Security.KeyVault NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Key Vault client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Security.KeyVault PackageReference xml <PackageReference Include=""Aspire.Azure.Security.KeyVault"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Example usage THe following sections describe various example usages. Add secrets to configuration In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.Configuration.AddAzureKeyVaultSecrets(""secrets""); You can then retrieve a secret through normal csharp public class ExampleService(IConfiguration configuration) { string secretValue = configuration[""secretKey""]; // Use secretValue ... } Use SecretClient Alternatively, you can use a SecretClient to retrieve the secrets on demand. In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureKeyVaultClient(""secrets""); You can then retrieve the csharp public class ExampleService(SecretClient client) { // Use client... } ', '<2-hop>\n\nConfiguration.AddAzureKeyVaultSecrets(""secrets""); You can then retrieve a secret through normal csharp public class ExampleService(IConfiguration configuration) { string secretValue = configuration[""secretKey""]; // Use secretValue ... } Use SecretClient Alternatively, you can use a SecretClient to retrieve the secrets on demand. In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureKeyVaultClient(""secrets""); You can then retrieve the csharp public class ExampleService(SecretClient client) { // Use client... } App host usage To add Azure Key Vault hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.KeyVault PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.KeyVault"" Version=""*"" /> In your app host project, register the Azure Key Vault integration and consume the service using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var secrets = builder.ExecutionContext.IsPublishMode ? builder.AddAzureKeyVault(""secrets"") : builder.AddConnectionString(""secrets""); builder.AddProject The preceding code conditionally adds the Azure Key Vault resource to the project based on the execution context. If the app host is executing in publish mode, the resource is added otherwise the connection string to an existing resource is added. Configuration The .NET Aspire Azure Key Vault integration provides multiple options to configure the SecretClient based on the requirements and conventions of your project. Use configuration providers The .NET Aspire Azure Key Vault integration supports json { ""Aspire"": { ""Azure"": { ""Security"": { ""KeyVault"": { ""VaultUri"": ""YOUR_VAULT_URI"", ""DisableHealthChecks"": false, ""DisableTracing"": true, ""ClientOptions"": { ""DisableChallengeResourceVerification"": true } } } } } } If you have set up your configurations in the Aspire:Azure:Security:KeyVault section of your :::no-loc text=""appsettings.json""::: file you can just call the method AddAzureKeyVaultSecrets without passing any parameters. Use inline delegates You can also pass the Action<AzureSecurityKeyVaultSettings> delegate to set up some or all the options inline, for example to set the VaultUri: csharp builder.AddAzureKeyVaultSecrets( ""secrets"", static settings => settings.VaultUri = new Uri(""YOUR_VAULTURI"")); [!TIP] The AddAzureKeyVaultSecrets API name has caused a bit of confusion. The method is used to configure the SecretClient and not to add secrets to the configuration. You can also set up the csharp builder.AddAzureKeyVaultSecrets( ""secrets"", static clientBuilder => clientBuilder.ConfigureOptions( static options => options.DisableChallengeResourceVerification = true)) Configuration options The following configurable options are exposed through the Name Description VaultUri A URI to the vault on which the client operates. Appears as ""DNS Name"" in the Azure portal. Credential The credential used to authenticate to the Azure Key Vault. DisableHealthChecks A boolean value that indicates whether the Key Vault health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. [!INCLUDE integration-health-checks] The .NET Aspire Azure Key Vault integration includes the following health checks: Adds the AzureKeyVaultSecretsHealthCheck health check, which attempts to connect to and query the Key Vault Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Azure Key Vault integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Key Vault integration will emit the following tracing activities using OpenTelemetry: ""Azure.Security.KeyVault.Secrets.SecretClient"" Metrics The .NET Aspire Azure Key Vault integration currently does not support metrics by default due to limitations with the Azure SDK. See also Azure Key Vault docs .NET Aspire integrations .NET Aspire GitHub repo', '<3-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","To use .NET Aspire with Azure Key Vault, you need to install the Aspire.Azure.Security.KeyVault NuGet package in your client-consuming project. You can add secrets to your configuration by calling builder.Configuration.AddAzureKeyVaultSecrets(""secrets"") in your Program.cs file. Alternatively, you can use a SecretClient to retrieve secrets on demand by calling builder.AddAzureKeyVaultClient(""secrets""). Configuration options for the .NET Aspire Azure Key Vault integration include setting the VaultUri, disabling health checks, and disabling tracing. These can be configured in the appsettings.json file or inline using delegates. The integration also supports health checks and observability through logging and tracing activities using OpenTelemetry.",multi_hop_abstract_query_synthesizer
67,How do you create custom resource commands in .NET Aspire and ensure secure communication between hosting and client integrations?,"['<1-hop>\n\ntitle: Custom resource commands in .NET Aspire description: Learn how to create custom resource commands in .NET Aspire. ms.date: 11/07/2024 ms.topic: how-to Custom resource commands in .NET Aspire Each resource in the .NET Aspire app model is represented as an [!IMPORTANT] These .NET Aspire dashboard commands are only available when running the dashboard locally. They\'re not available when running the dashboard in Azure Container Apps. Add custom commands to a resource Start by creating a new .NET Aspire Starter App from the available templates. To create the solution from this template, follow the Quickstart: Build your first .NET Aspire solution. After creating this solution, add a new class named RedisResourceBuilderExtensions.cs to the app host project. Replace the contents of the file with the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/RedisResourceBuilderExtensions.cs""::: The preceding code: Shares the Is a static class so that it can contain extension methods. It defines a single extension method named WithClearCommand, extending the IResourceBuilder<RedisResource> interface. The WithClearCommand method registers a command named clear-cache that clears the cache of the Redis resource. The WithClearCommand method returns the IResourceBuilder<RedisResource> instance to allow chaining. The WithCommand API adds the appropriate annotations to the resource, which are consumed in the .NET Aspire dashboard. The dashboard uses these annotations to render the command in the UI. Before getting too far into those details, let\'s ensure that you first understand the parameters of the WithCommand method: name: The name of the command to invoke. displayName: The name of the command to display in the dashboard. executeCommand: The Func<ExecuteCommandContext, Task<ExecuteCommandResult>> to run when the command is invoked, which is where the command logic is implemented. updateState: The Func<UpdateCommandStateContext, ResourceCommandState> callback is invoked to determine the ""enabled"" state of the command, which is used to enable or disable the command in the dashboard. iconName: The name of the icon to display in the dashboard. The icon is optional, but when you do provide it, it should be a valid Fluent UI Blazor icon name. iconVariant: The variant of the icon to display in the dashboard, valid options are Regular (default) or Filled. Execute command logic The executeCommand delegate is where the command logic is implemented. This parameter is defined as a Func<ExecuteCommandContext, Task<ExecuteCommandResult>>. The ExecuteCommandContext provides the following properties: ExecuteCommandContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. ExecuteCommandContext.ResourceName: The name of the resource instance that the command is being executed on. ExecuteCommandContext.CancellationToken: The In the preceding example, the executeCommand delegate is implemented as an async method that clears the cache of the Redis resource. It delegates out to a private class-scoped function named OnRunClearCacheCommandAsync to perform the actual cache clearing. Consider the following code: ```csharp private static async Task await using var connection = ConnectionMultiplexer.Connect(connectionString); var database = connection.GetDatabase(); await database.ExecuteAsync(""FLUSHALL""); return CommandResults.Success(); } ``` The preceding code: Retrieves the connection string from the Redis resource. Connects to the Redis instance. Gets the database instance. Executes the FLUSHALL command to clear the cache. Returns a CommandResults.Success() instance to indicate that the command was successful. Update command state logic The updateState delegate is where the command state is determined. This parameter is defined as a Func<UpdateCommandStateContext, ResourceCommandState>. The UpdateCommandStateContext provides the following properties: UpdateCommandStateContext.ServiceProvider: The IServiceProvider instance that\'s used to resolve services. UpdateCommandStateContext.ResourceSnapshot: The snapshot of the resource instance that the command is being executed on. The immutable snapshot is an instance of CustomResourceSnapshot, which exposes all sorts of valuable details about the resource instance. Consider the following code: ```csharp private static ResourceCommandState OnUpdateResourceState( UpdateCommandStateContext context) { var logger = context.ServiceProvider.GetRequiredService if (logger.IsEnabled(LogLevel.Information)) { logger.LogInformation( ""Updating resource state: {ResourceSnapshot}"", context.ResourceSnapshot); } return context.ResourceSnapshot.HealthStatus is HealthStatus.Healthy ? ResourceCommandState.Enabled : ResourceCommandState.Disabled; } ``` The preceding code: Retrieves the logger instance from the service provider. Logs the resource snapshot details. Returns ResourceCommandState.Enabled if the resource is healthy; otherwise, it returns ResourceCommandState.Disabled.', '<2-hop>\n\nTest the custom command To test the custom command, update your app host project\'s Program.cs file to include the following code: :::code source=""snippets/custom-commands/AspireApp/AspireApp.AppHost/Program.cs"" highlight=""4""::: The preceding code calls the WithClearCommand extension method to add the custom command to the Redis resource. Run the app and navigate to the .NET Aspire dashboard. You should see the custom command listed under the Redis resource. On the Resources page of the dashboard, select the ellipsis button under the Actions column: :::image source=""media/custom-clear-cache-command.png"" lightbox=""media/custom-clear-cache-command.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command displayed.""::: The preceding image shows the Clear cache command that was added to the Redis resource. The icon displays as a rabbit crosses out to indicate that the speed of the dependant resource is being cleared. Select the Clear cache command to clear the cache of the Redis resource. The command should execute successfully, and the cache should be cleared: :::image source=""media/custom-clear-cache-command-succeeded.png"" lightbox=""media/custom-clear-cache-command-succeeded.png"" alt-text="".NET Aspire dashboard: Redis cache resource with custom command executed.""::: See also .NET Aspire orchestration overview .NET Aspire dashboard: Resource submenu actions', '<3-hop>\n\ntitle: Secure communication between hosting and client integrations description: Learn how to Secure communication between hosting and client integrations. ms.date: 09/12/2024 ms.topic: how-to Secure communication between hosting and client integrations This article is a continuation of two previous articles demonstrating the creation of custom hosting integrations and custom client integrations. One of the primary benefits to .NET Aspire is how it simplifies the configurability of resources and consuming clients (or integrations). This article demonstrates how to share authentication credentials from a custom resource in a hosting integration, to the consuming client in a custom client integration. The custom resource is a MailDev container that allows for either incoming or outgoing credentials. The custom client integration is a MailKit client that sends emails. Prerequisites Since this article continues from previous content, you should have already created the resulting solution as a starting point for this article. If you haven\'t already, complete the following articles: Create custom .NET Aspire hosting integrations Create custom .NET Aspire client integrations The resulting solution from these previous articles contains the following projects: MailDev.Hosting: Contains the custom resource type for the MailDev container. MailDevResource.AppHost: The app host that uses the custom resource and defines it as a dependency for a Newsletter service. MailDevResource.NewsletterService: An ASP.NET Core Web API project that sends emails using the MailDev container. MailDevResource.ServiceDefaults: Contains the default service configurations intended for sharing. MailKit.Client: Contains the custom client integration that exposes the MailKit SmtpClient through a factory. Update the MailDev resource To flow authentication credentials from the MailDev resource to the MailKit integration, you need to update the MailDev resource to include the username and password parameters. The MailDev container supports basic authentication for both incoming and outgoing simple mail transfer protocol (SMTP). To configure the credentials for incoming, you need to set the MAILDEV_INCOMING_USER and MAILDEV_INCOMING_PASS environment variables. For more information, see MailDev: Usage. Update the MailDevResource.cs file in the MailDev.Hosting project, by replacing its contents with the following C# code: :::code source=""snippets/MailDevResourceWithCredentials/MailDev.Hosting/MailDevResource.cs"" highlight=""9-10""::: These updates add a UsernameParameter and PasswordParameter property. These properties are used to store the parameters for the MailDev username and password. The ConnectionStringExpression property is updated to include the username and password parameters in the connection string. Next, update the MailDevResourceBuilderExtensions.cs file in the MailDev.Hosting project with the following C# code: :::code source=""snippets/MailDevResourceWithCredentials/MailDev.Hosting/MailDevResourceBuilderExtensions.cs"" highlight=""9-10,29-30,32-34,40-41,55-59""::: The preceding code updates the AddMailDev extension method to include the userName and password parameters. The WithEnvironment method is updated to include the UserEnvVarName and PasswordEnvVarName environment variables. These environment variables are used to set the MailDev username and password. Update the app host Now that the resource is updated to include the username and password parameters, you need to update the app host to include these parameters. Update the :::no-loc text=""Program.cs""::: file in the MailDevResource.AppHost project with the following C# code: :::code source=""snippets/MailDevResourceWithCredentials/MailDevResource.AppHost/Program.cs"" highlight=""3-4,6-9""::: The preceding code adds two parameters for the MailDev username and password. It assigns these parameters to the MAILDEV_INCOMING_USER and MAILDEV_INCOMING_PASS environment variables. The AddMailDev method has two chained calls to WithEnvironment which includes these environment variables. For more information on parameters, see External parameters. Next, configure the secrets for these parameters. Right-click on the MailDevResource.AppHost project and select Manage User Secrets. Add the following JSON to the secrets.json file: json { ""Parameters:maildev-username"": ""@admin"", ""Parameters:maildev-password"": ""t3st1ng"" } [!WARNING] These credentials are for demonstration purposes only and MailDev is intended for local development. These credentials are fictitious and shouldn\'t be used in a production environment.']","To create custom resource commands in .NET Aspire, you start by creating a new .NET Aspire Starter App from the available templates. After setting up the solution, you add a new class named RedisResourceBuilderExtensions.cs to the app host project. This class contains a static method, WithClearCommand, which registers a command named clear-cache to clear the cache of the Redis resource. The command logic is implemented in the executeCommand delegate, which connects to the Redis instance and executes the FLUSHALL command to clear the cache. To ensure secure communication between hosting and client integrations, you update the MailDev resource to include username and password parameters. These parameters are configured in the MailDevResource.cs file and are used to set environment variables for authentication. The MailDevResourceBuilderExtensions.cs file is also updated to include these parameters, ensuring that the MailDev container supports basic authentication for SMTP. This setup allows for secure sharing of authentication credentials between the hosting integration and the consuming client.",multi_hop_abstract_query_synthesizer
68,How does the .NET Aspire Azure Blob Storage integration utilize logging and tracing to enhance service observability?,"['<1-hop>\n\ntitle: .NET Aspire Azure Blob Storage integration description: Learn how to use the .NET Aspire Azure Blob Storage integration, which includes both hosting and client integrations. ms.date: 12/09/2024 uid: storage/azure-blob-storage-integration .NET Aspire Azure Blob Storage integration [!INCLUDE includes-hosting-and-client] Azure Blob Storage is a service for storing large amounts of unstructured data. The .NET Aspire Azure Blob Storage integration enables you to connect to existing Azure Blob Storage instances or create new instances from .NET applications. Hosting integration [!INCLUDE storage-app-host] Add Azure Blob Storage resource In your app host project, register the Azure Blob Storage integration by chaining a call to ```csharp var builder = DistributedApplication.CreateBuilder(args); var blobs = builder.AddAzureStorage(""storage"") .RunAsEmulator(); .AddBlobs(""blobs""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Adds an Azure Storage resource named storage. Chains a call to Adds a blob container named blobs to the storage resource. Adds the blobs resource to the ExampleProject and waits for it to be ready before starting the project. [!INCLUDE storage-hosting-health-checks] Client integration To get started with the .NET Aspire Azure Blob Storage client integration, install the ðŸ“¦ Aspire.Azure.Storage.Blobs NuGet package in the client-consuming project, that is, the project for the application that uses the Azure Blob Storage client. The Azure Blob Storage client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Azure.Storage.Blobs PackageReference xml <PackageReference Include=""Aspire.Azure.Storage.Blobs"" Version=""*"" /> Add Azure Blob Storage client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureBlobClient(""blobs""); You can then retrieve the BlobServiceClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(BlobServiceClient client) { // Use client... } Configuration The .NET Aspire Azure Blob Storage integration provides multiple options to configure the BlobServiceClient based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddAzureBlobClient(""blobs""); Then the connection string is retrieved from the ConnectionStrings configuration section, and two connection formats are supported: Service URI The recommended approach is to use a ServiceUri, which works with the json { ""ConnectionStrings"": { ""blobs"": ""https://{account_name}.blob.core.windows.net/"" } } Connection string Alternatively, an Azure Storage connection string can be used. json { ""ConnectionStrings"": { ""blobs"": ""AccountName=myaccount;AccountKey=myaccountkey"" } } For more information, see Configure Azure Storage connection strings. Use configuration providers The .NET Aspire Azure Blob Storage integration supports json { ""Aspire"": { ""Azure"": { ""Storage"": { ""Blobs"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Diagnostics"": { ""ApplicationId"": ""myapp"" } } } } } } } For the complete Azure Blob Storage client integration JSON schema, see Aspire.Azure.Storage.Blobs/ConfigurationSchema.json. Use inline delegates You can also pass the Action<AzureStorageBlobsSettings> configureSettings delegate to set up some or all the options inline, for example to configure health checks: csharp builder.AddAzureBlobClient( ""blobs"", settings => settings.DisableHealthChecks = true); You can also set up the csharp builder.AddAzureBlobClient( ""blobs"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Diagnostics.ApplicationId = ""myapp"")); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Blob Storage integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', ""<2-hop>\n\nLogging The .NET Aspire Azure Blob Storage integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Blob Storage integration emits the following tracing activities using OpenTelemetry: Azure.Storage.Blobs.BlobContainerClient Metrics The .NET Aspire Azure Blob Storage integration currently doesn't support metrics by default due to limitations with the Azure SDK. See also Azure Blob Storage docs .NET Aspire integrations .NET Aspire GitHub repo""]","The .NET Aspire Azure Blob Storage integration enhances service observability by utilizing specific log categories and tracing activities. It uses log categories such as Azure.Core and Azure.Identity to capture relevant logging information. For tracing, it emits activities using OpenTelemetry, specifically focusing on Azure.Storage.Blobs.BlobContainerClient. These features help in monitoring and diagnosing the behavior of applications using Azure Blob Storage.",multi_hop_specific_query_synthesizer
69,How can .NET Aspire integrate Azure Blob Storage for both hosting and client applications?,"['<1-hop>\n\ntitle: .NET Aspire Azure Blob Storage integration description: Learn how to use the .NET Aspire Azure Blob Storage integration, which includes both hosting and client integrations. ms.date: 12/09/2024 uid: storage/azure-blob-storage-integration .NET Aspire Azure Blob Storage integration [!INCLUDE includes-hosting-and-client] Azure Blob Storage is a service for storing large amounts of unstructured data. The .NET Aspire Azure Blob Storage integration enables you to connect to existing Azure Blob Storage instances or create new instances from .NET applications. Hosting integration [!INCLUDE storage-app-host] Add Azure Blob Storage resource In your app host project, register the Azure Blob Storage integration by chaining a call to ```csharp var builder = DistributedApplication.CreateBuilder(args); var blobs = builder.AddAzureStorage(""storage"") .RunAsEmulator(); .AddBlobs(""blobs""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Adds an Azure Storage resource named storage. Chains a call to Adds a blob container named blobs to the storage resource. Adds the blobs resource to the ExampleProject and waits for it to be ready before starting the project. [!INCLUDE storage-hosting-health-checks] Client integration To get started with the .NET Aspire Azure Blob Storage client integration, install the ðŸ“¦ Aspire.Azure.Storage.Blobs NuGet package in the client-consuming project, that is, the project for the application that uses the Azure Blob Storage client. The Azure Blob Storage client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Azure.Storage.Blobs PackageReference xml <PackageReference Include=""Aspire.Azure.Storage.Blobs"" Version=""*"" /> Add Azure Blob Storage client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureBlobClient(""blobs""); You can then retrieve the BlobServiceClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(BlobServiceClient client) { // Use client... } Configuration The .NET Aspire Azure Blob Storage integration provides multiple options to configure the BlobServiceClient based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddAzureBlobClient(""blobs""); Then the connection string is retrieved from the ConnectionStrings configuration section, and two connection formats are supported: Service URI The recommended approach is to use a ServiceUri, which works with the json { ""ConnectionStrings"": { ""blobs"": ""https://{account_name}.blob.core.windows.net/"" } } Connection string Alternatively, an Azure Storage connection string can be used. json { ""ConnectionStrings"": { ""blobs"": ""AccountName=myaccount;AccountKey=myaccountkey"" } } For more information, see Configure Azure Storage connection strings. Use configuration providers The .NET Aspire Azure Blob Storage integration supports json { ""Aspire"": { ""Azure"": { ""Storage"": { ""Blobs"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Diagnostics"": { ""ApplicationId"": ""myapp"" } } } } } } } For the complete Azure Blob Storage client integration JSON schema, see Aspire.Azure.Storage.Blobs/ConfigurationSchema.json. Use inline delegates You can also pass the Action<AzureStorageBlobsSettings> configureSettings delegate to set up some or all the options inline, for example to configure health checks: csharp builder.AddAzureBlobClient( ""blobs"", settings => settings.DisableHealthChecks = true); You can also set up the csharp builder.AddAzureBlobClient( ""blobs"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Diagnostics.ApplicationId = ""myapp"")); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Blob Storage integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nms.topic: include The .NET Aspire Azure Storage hosting integration models the various storage resources as the following types: To access these types and APIs for expressing them, add the ðŸ“¦ Aspire.Hosting.Azure.Storage NuGet package in the app host project. .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Storage PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Storage"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Azure Storage resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage""); // An Azure Storage resource is required to add any of the following: // // - Azure Blob storage resource. // - Azure Queue storage resource. // - Azure Table storage resource. // After adding all resources, run the app... ``` When you add an AzureStorageResource to the app host, it exposes other useful APIs to add Azure Blob, Queue, and Table storage resources. In other words, you must add an AzureStorageResource before adding any of the other storage resources. [!IMPORTANT] When you call Generated provisioning Bicep If you\'re new to Bicep, it\'s a domain-specific language for defining Azure resources. With .NET Aspire, you don\'t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Storage resource, the following Bicep is generated: The preceding Bicep is a module that provisions an Azure Storage account with the following defaults: kind: The kind of storage account. The default is StorageV2. sku: The SKU of the storage account. The default is Standard_GRS. properties: The properties of the storage account: accessTier: The access tier of the storage account. The default is Hot. allowSharedKeyAccess: A boolean value that indicates whether the storage account permits requests to be authorized with the account access key. The default is false. minimumTlsVersion: The minimum supported TLS version for the storage account. The default is TLS1_2. networkAcls: The network ACLs for the storage account. The default is { defaultAction: \'Allow\' }. In addition to the storage account, it also provisions a blob container. The following role assignments are added to the storage account to grant your application access. See the built-in Azure role-based access control (Azure RBAC) roles for more information: Role / ID Description Storage Blob Data Contributor ba92f5b4-2d11-453d-a403-e96b0029c9fe Read, write, and delete Azure Storage containers and blobs. Storage Table Data Contributor 0a9a7e1f-b9d0-4cc4-a60d-0319b160aaa3 Read, write, and delete Azure Storage tables and entities. Storage Queue Data Contributor 974c5e8b-45b9-4653-ba55-5f855dd0fb88 Read, write, and delete Azure Storage queues and queue messages. The generated Bicep is a starting point and can be customized to meet your specific requirements. Customize provisioning infrastructure All .NET Aspire Azure resources are subclasses of the :::code language=""csharp"" source=""../../snippets/azure/AppHost/Program.ConfigureStorageInfra.cs"" id=""configure""::: The preceding code: Chains a call to the The infra parameter is an instance of the The provisionable resources are retrieved by calling the The single The The A tag is added to the storage account with a key of ExampleKey and a value of Example value. There are many more configuration options available to customize the Azure Storage resource. For more information, see']","The .NET Aspire Azure Blob Storage integration allows for both hosting and client applications to connect to Azure Blob Storage. For hosting integration, you can register the Azure Blob Storage in your app host project by adding an Azure Storage resource and a blob container using the DistributedApplication.CreateBuilder method. This setup includes adding the Aspire.Hosting.Azure.Storage NuGet package to access APIs for storage resources. For client integration, you need to install the Aspire.Azure.Storage.Blobs NuGet package in the client-consuming project and use the builder.AddAzureBlobClient method to retrieve the BlobServiceClient instance via dependency injection. This integration supports various configuration options, including using connection strings and inline delegates for setting up health checks and diagnostics.",multi_hop_specific_query_synthesizer
70,How do you upgrade a project to use Aspire.Hosting.AppHost in .NET Aspire 9.0?,"['<1-hop>\n\nResource types Each resource has a type field. When a deployment tool reads the manifest, it should read the type to verify whether it can correctly process the manifest. During the .NET Aspire preview period, all resource types have a v0 suffix to indicate that they\'re subject to change. As .NET Aspire approaches release a v1 suffix will be used to signify that the structure of the manifest for that resource type should be considered stable (subsequent updates increment the version number accordingly). Common resource fields The type field is the only field that is common across all resource types, however, the project.v0, container.v0, and executable.v0 resource types also share the env and bindings fields. [!NOTE] The executable.v0 resource type isn\'t fully implemented in the manifest due to its lack of utility in deployment scenarios. For more information on containerizing executables, see Dockerfile resource types. The env field type is a basic key/value mapping where the values might contain placeholder strings. Bindings are specified in the bindings field with each binding contained within its own field under the bindings JSON object. The fields omitted by the .NET Aspire manifest in the bindings node include: scheme: One of the following values tcp, udp, http, or https. protocol: One of the following values tcp or udp transport: Same as scheme, but used to disambiguate between http and http2. containerPort: Optional, if omitted defaults to port 80. The inputs field Some resources generate an inputs field. This field is used to specify input parameters for the resource. The inputs field is a JSON object where each property is an input parameter that\'s used in placeholder structure resolution. Resources that have a connectionString, for example, might use the inputs field to specify a password for the connection string: json ""connectionString"": ""Host={<resourceName>.bindings.tcp.host};Port={<resourceName>.bindings.tcp.port};Username=admin;Password={<resourceName>.inputs.password};"" The connection string placeholder references the password input parameter from the inputs field: json ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } The preceding JSON snippet shows the inputs field for a resource that has a connectionString field. The password input parameter is a string type and is marked as a secret. The default field is used to specify a default value for the input parameter. In this case, the default value is generated using the generate field, with random string of a minimum length. Built-in resources The following table is a list of resource types that are explicitly generated by .NET Aspire and extensions developed by the .NET Aspire team: Cloud-agnostic resource types These resources are available in the ðŸ“¦ Aspire.Hosting NuGet package. App model usage Manifest resource type Heading link container.v0 Container resource type PublishAsDockerFile dockerfile.v0 Dockerfile resource types value.v0 MongoDB Server resource types container.v0 MongoDB resource types value.v0 MySQL Server resource types container.v0 MySQL resource types value.v0 Postgres resource types container.v0 Postgres resource types project.v0 Project resource type container.v0 RabbitMQ resource types container.v0 Redis resource type value.v0 SQL Server resource types container.v0 SQL Server resource types Project resource type Example code: csharp var builder = DistributedApplication.CreateBuilder(args); var apiservice = builder.AddProject<Projects.AspireApp_ApiService>(""apiservice""); Example manifest: json ""apiservice"": { ""type"": ""project.v0"", ""path"": ""../AspireApp.ApiService/AspireApp.ApiService.csproj"", ""env"": { ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES"": ""true"", ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES"": ""true"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"" }, ""https"": { ""scheme"": ""https"", ""protocol"": ""tcp"", ""transport"": ""http"" } } } Container resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddContainer(""mycontainer"", ""myimage"") .WithEnvironment(""LOG_LEVEL"", ""WARN"") .WithHttpEndpoint(3000); ``` Example manifest: json { ""resources"": { ""mycontainer"": { ""type"": ""container.v0"", ""image"": ""myimage:latest"", ""env"": { ""LOG_LEVEL"": ""WARN"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 3000 } } } } } Dockerfile resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddNodeApp(""nodeapp"", ""../nodeapp/app.js"") .WithHttpEndpoint(hostPort: 5031, env: ""PORT"") .PublishAsDockerFile(); ``` [!TIP] The PublishAsDockerFile call is required to generate the Dockerfile resource type in the manifest, and this extension method is only available on the Example manifest: json { ""resources"": { ""nodeapp"": { ""type"": ""dockerfile.v0"", ""path"": ""../nodeapp/Dockerfile"", ""context"": ""../nodeapp"", ""env"": { ""NODE_ENV"": ""development"", ""PORT"": ""{nodeapp.bindings.http.port}"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 5031 } } } } } Postgres resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddPostgres(""postgres1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""postgres1"": { ""type"": ""container.v0"", ""connectionString"": ""Host={postgres1.bindings.tcp.host};Port={postgres1.bindings.tcp.port};Username=postgres;Password={postgres1.inputs.password}"", ""image"": ""postgres:16.2"", ""env"": { ""POSTGRES_HOST_AUTH_METHOD"": ""scram-sha-256"", ""POSTGRES_INITDB_ARGS"": ""--auth-host=scram-sha-256 --auth-local=scram-sha-256"", ""POSTGRES_PASSWORD"": ""{postgres1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5432 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{postgres1.connectionString};Database=shipping"" } } } RabbitMQ resource types RabbitMQ is modeled as a container resource container.v0. The following sample shows how they\'re added to the app model. ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRabbitMQ(""rabbitmq1""); ``` The previous code produces the following manifest: json { ""resources"": { ""rabbitmq1"": { ""type"": ""container.v0"", ""connectionString"": ""amqp://guest:{rabbitmq1.inputs.password}@{rabbitmq1.bindings.tcp.host}:{rabbitmq1.bindings.tcp.port}"", ""image"": ""rabbitmq:3"", ""env"": { ""RABBITMQ_DEFAULT_USER"": ""guest"", ""RABBITMQ_DEFAULT_PASS"": ""{rabbitmq1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5672 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } } } } Redis resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRedis(""redis1""); ``` Example manifest: json { ""resources"": { ""redis1"": { ""type"": ""container.v0"", ""connectionString"": ""{redis1.bindings.tcp.host}:{redis1.bindings.tcp.port}"", ""image"": ""redis:7.2.4"", ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 6379 } } } } } SQL Server resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddSqlServer(""sql1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""sql1"": { ""type"": ""container.v0"", ""connectionString"": ""Server={sql1.bindings.tcp.host},{sql1.bindings.tcp.port};User ID=sa;Password={sql1.inputs.password};TrustServerCertificate=true"", ""image"": ""mcr.microsoft.com/mssql/server:2022-latest"", ""env"": { ""ACCEPT_EULA"": ""Y"", ""MSSQL_SA_PASSWORD"": ""{sql1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 1433 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{sql1.connectionString};Database=shipping"" } } } MongoDB resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddMongoDB(""mongodb1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""mongodb1"": { ""type"": ""container.v0"", ""connectionString"": ""mongodb://{mongodb1.bindings.tcp.host}:{mongodb1.bindings.tcp.port}"", ""image"": ""mongo:7.0.5"", ""bindings"": { ""tcp"": { ""scheme"":', '<2-hop>\n\nUse the Upgrade Assistant to upgrade your projects to .NET Aspire 9.0. [!TIP] If you\'re new to .NET Aspire, there\'s no reason to upgrade anything. For more information, see .NET Aspire setup and tooling. Prerequisites Before you upgrade your projects to .NET Aspire 9.0, ensure that you have the following prerequisites: Install the latest tooling. Use the .NET Aspire SDK. [!NOTE] Feel free to uninstall the .NET Aspire workload as you\'ll no longer need it. dotnetcli dotnet workload uninstall aspire For more information, see dotnet workload uninstall. If you don\'t uninstall the .NET Aspire workload, and you\'re using the new .NET Aspire SDK and templates, you see both .NET Aspire 8.0 and .NET Aspire 9.0 templates. Manually upgrade to .NET Aspire 9.0 To upgrade your projects to .NET Aspire 9.0, you need to update your project files. The following steps guide you through the process: Edit your app host project file to use the new .NET Aspire 9.0 SDK (Aspire.AppHost.Sdk). Update the NuGet packages in your project files to the latest versions. Adjust your Program.cs file to use the new APIs and remove any obsolete APIs. Edit your app host project file To upgrade your app host project to .NET Aspire 9.0, you need to update your project file to use the new ðŸ“¦ Aspire.AppHost.Sdk: ```diff ``` Optionally upgrade the target framework moniker (TFM) .NET Aspire 9.0 runs on .NET 9.0, but you can also run it on .NET 8.0. In other words, just because you\'re using the .NET Aspire SDK, and pointing to version 9.0 packages, you can still target .NET 8.0. If you want to run your .NET Aspire 9.0 project on .NET 9.0, you need to update the TargetFramework property in your project file: ```diff ``` For more information on TFMs, see Target frameworks in SDK-style projects: Latest versions. Overall app host project differences If you followed all of the preceding steps, your app host project file should look like this: ```diff ``` The changes include the addition of the Aspire.AppHost.Sdk, the update of the TargetFramework property to net9.0, and the update of the Aspire.Hosting.AppHost package to version 9.0.0. Adjust your Program.cs file With the introduction of .NET Aspire 9.0, there are some breaking changes. Some APIs were originally marked as experimental (with the For the complete list of breaking changes in .NET Aspire 9.0, see Breaking changes in .NET Aspire 9.0. Use the Upgrade Assistant The Upgrade Assistant is a tool that helps upgrade targeted projects to the latest version. If you\'re new to the Upgrade Assistant, there\'s two modalities to choose from: The Visual Studio extension version. The .NET CLI global tool version. Regardless of how you install the Upgrade Assistant, you can use it to upgrade your .NET Aspire 8.x projects to .NET Aspire 9.0. :::zone pivot=""visual-studio"" To upgrade the .NET Aspire app host project to .NET Aspire 9.0 with Visual Studio, right-click the project in Solution Explorer and select Upgrade. [!IMPORTANT] If the Upgrade Assistant isn\'t already installed, you\'ll be prompted to install it. The Upgrade Assistant displays a welcome package. Select the Aspire upgrades option: :::image type=""content"" source=""media/upgrade-assistant-welcome-aspire.png"" lightbox=""media/upgrade-assistant-welcome-aspire.png"" alt-text=""Visual Studio: Upgrade Assistant welcome page with .NET Aspire app host project.""::: With the Aspire upgrades option selected, the Upgrade Assistant displays the selectable upgrade target components. Leave all the options checked and select Upgrade selection: :::image type=""content"" source=""media/upgrade-assistant-aspire-app-host-comps.png"" lightbox=""media/upgrade-assistant-aspire-app-host-comps.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire selectable components to upgrade.""::: Finally, after selecting the components to upgrade, the Upgrade Assistant displays the results of the upgrade process. If everything was successful, you see green check marks next to each component: :::image type=""content"" source=""media/upgrade-assistant-aspire-upgraded.png"" lightbox=""media/upgrade-assistant-aspire-upgraded.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire app host project upgraded successfully.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To upgrade the .NET Aspire app host project, ensure that you installed the Upgrade Assistant CLI. Open a terminal session at the root directory of the .NET Aspire app host project file, and run the following command: dotnetcli upgrade-assistant upgrade The output is interactive, expecting you to select the upgrade type. Choose the Aspire upgrades option: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ How do you want to upgrade project AspireSample.AppHost? Aspire upgrades Upgrade to latest .NET Aspire version (aspire.latest) Upgrade project to a newer .NET version In-place project upgrade (framework.inplace) NuGet upgrades NuGet central package management (CPM) (nuget.cpm) Navigation Back Exit ``` Use your keyboard to navigate up â†‘ or down â†“, and select the Aspire upgrades option. The Upgrade Assistant prompts for final confirmation. Enter Y to continue with the upgrade: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Upgrade type aspire.latest Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type / Upgrade â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ We have gathered all required options and are ready to do the upgrade. Do you want to continue? [y/n] (y): ``` Finally, after the upgrade process is complete, the Upgrade Assistant displays the results of the upgrade process: dotnetcli Finalizing operation... Complete: 3 succeeded, 0 failed, 7 skipped. :::zone-end Update the NuGet packages To take advantage of the latest updates in your .NET Aspire solution, update all NuGet packages to version 9.0.0. :::zone pivot=""visual-studio"" :::image type=""content"" source=""media/visual-studio-update-nuget.png"" lightbox=""media/visual-studio-update-nuget.png"" alt-text=""Visual Studio: Update all NuGet packages for the .NET Aspire solution.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To update your app host project, use the following .NET CLI command to update the Aspire.Hosting.AppHost package to version 9.0.0: dotnetcli dotnet add package Aspire.Hosting.AppHost --version 9.0.0 When a package reference already exists, the dotnet add package command updates the reference to the specified version. For more information, see dotnet add package. :::zone-end With the app host project updated, your project file should look like this: ```diff ``` [!TIP] You\'ll want to also update the NuGet packages in your other projects to the latest versions.']","To upgrade a project to use Aspire.Hosting.AppHost in .NET Aspire 9.0, you need to follow several steps. First, ensure you have the latest tooling and the .NET Aspire SDK installed. Then, edit your app host project file to use the new Aspire.AppHost.Sdk and update the NuGet packages to the latest versions, specifically updating the Aspire.Hosting.AppHost package to version 9.0.0. You can use the Upgrade Assistant tool, either as a Visual Studio extension or a .NET CLI global tool, to assist with the upgrade process. This involves selecting the Aspire upgrades option and confirming the upgrade. Additionally, you may need to adjust your Program.cs file to accommodate any breaking changes introduced in .NET Aspire 9.0.",multi_hop_specific_query_synthesizer
71,How can the ExampleService utilize both SQL Server Entity Framework Core and Qdrant client integrations in a .NET Aspire application?,"['<1-hop>\n\ntitle: .NET Aspire SQL Server Entity Framework Core integration description: Learn how to use the .NET Aspire SQL Server Entity Framework integration, which includes both hosting and client integrations. ms.date: 12/02/2024 uid: database/sql-server-ef-core-integration .NET Aspire SQL Server Entity Framework Core integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server Entity Framework Core integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server Entity Framework Core integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server Entity Framework Core client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.SqlServer"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add SQL Server database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerDbContext. For more information, see Add SQL Server resource and database resource. To retrieve ExampleDbContext object from a service: csharp public class ExampleService(ExampleDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add SQL Server database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichSqlServerDbContext<ExampleDbContext>( connectionName: ""database"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the', '<2-hop>\n\nClient integration To get started with the .NET Aspire Qdrant client integration, install the ðŸ“¦ Aspire.Qdrant.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Qdrant client. The Qdrant client integration registers a Qdrant.Client.QdrantClient instance that you can use to interact with Qdrant vector data. .NET CLI dotnetcli dotnet add package Aspire.Qdrant.Client PackageReference xml <PackageReference Include=""Aspire.Qdrant.Client"" Version=""*"" /> Add a Qdrant client In the Program.cs file of your client-consuming project, call the csharp builder.AddQdrantClient(""qdrant""); [!TIP] The connectionName parameter must match the name used when adding the Qdrant resource in the app host project. In other words, when you call AddQdrant and provide a name of qdrant that same name should be used when calling AddQdrantClient. For more information, see Add Qdrant resource. You can then retrieve the QdrantClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(QdrantClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Qdrant client There might be situations where you want to register multiple QdrantClient instances with different connection names. To register keyed Qdrant clients, call the csharp builder.AddKeyedQdrantClient(name: ""mainQdrant""); builder.AddKeyedQdrantClient(name: ""loggingQdrant""); Then you can retrieve the QdrantClient instances using dependency injection. For example, to retrieve the connections from an example service: csharp public class ExampleService( [FromKeyedServices(""mainQdrant"")] QdrantClient mainQdrantClient, [FromKeyedServices(""loggingQdrant"")] QdrantClient loggingQdrantClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Qdrant client integration provides multiple options to configure the connection to Qdrant based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddQdrantClient(): csharp builder.AddQdrantClient(""qdrant""); Then .NET Aspire retrieves the connection string from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""qdrant"": ""Endpoint=http://localhost:6334;Key=123456!@#$%"" } } By default the QdrantClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Qdrant client integration supports json { ""Aspire"": { ""Qdrant"": { ""Client"": { ""Endpoint"": ""http://localhost:6334/"", ""Key"": ""123456!@#$%"" } } } } For the complete Qdrant client integration JSON schema, see Aspire.Qdrant.Client/ConfigurationSchema.json. Use inline delegates You can also pass the Action<QdrantClientSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddQdrantClient( ""qdrant"", settings => settings.Key = ""12345!@#$%""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Qdrant integration uses standard .NET logging, and you\'ll see log entries from the following category: Qdrant.Client Tracing The .NET Aspire Qdrant integration doesn\'t currently emit tracing activities because they are not supported by the Qdrant.Client library. Metrics The .NET Aspire Qdrant integration doesn\'t currently emit metrics because they are not supported by the Qdrant.Client library. See also Qdrant Qdrant documentation Qdrant GitHub repo Qdrant .NET SDK .NET Aspire integrations .NET Aspire GitHub repo']","In a .NET Aspire application, the ExampleService can utilize both SQL Server Entity Framework Core and Qdrant client integrations by setting up the respective client and hosting integrations. For SQL Server Entity Framework Core, you need to install the Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package and configure the SQL Server database context in the Program.cs file using builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: ""database""). This allows the ExampleService to retrieve the ExampleDbContext object through dependency injection. For the Qdrant client integration, you need to install the Aspire.Qdrant.Client NuGet package and add a Qdrant client in the Program.cs file using builder.AddQdrantClient(""qdrant""). The ExampleService can then retrieve the QdrantClient instance using dependency injection. By configuring both integrations, the ExampleService can effectively interact with SQL Server and Qdrant vector data within the same application.",multi_hop_specific_query_synthesizer
72,"How does the .NET Aspire Redis integration utilize IConnectionMultiplexer and IConnection for client integration, and what are the configuration options available for these connections?","['<1-hop>\n\ntitle: .NET Aspire Redis integration description: Learn how to use the .NET Aspire Redis integration, which includes both hosting and client integrations. ms.date: 11/05/2024 zone_pivot_groups: resp-host .NET Aspire RedisÂ®* integration [!INCLUDE includes-hosting-and-client] :::zone pivot=""redis"" Redis is the world\'s fastest data platform for caching, vector search, and NoSQL databases. The .NET Aspire Redis integration enables you to connect to existing Redis instances, or create new instances from .NET with the docker.io/library/redis container image. :::zone-end :::zone pivot=""garnet"" Garnet is a a high-performance cache-store from Microsoft Research and complies with the Redis serialization protocol (RESP). The .NET Aspire Redis integration enables you to connect to existing Garnet instances, or create new instances from .NET with the ghcr.io/microsoft/garnet container image. :::zone-end :::zone pivot=""valkey"" Valkey is a Redis fork and complies with the Redis serialization protocol (RESP). It\'s a high-performance key/value datastore that supports a variety of workloads such as caching, message queues, and can act as a primary database. The .NET Aspire Redis integration enables you to connect to existing Valkey instances, or create new instances from .NET with the docker.io/valkey/valkey container image. :::zone-end Hosting integration :::zone pivot=""redis"" [!INCLUDE redis-app-host] :::zone-end :::zone pivot=""garnet"" [!INCLUDE garnet-app-host] :::zone-end :::zone pivot=""valkey"" [!INCLUDE valkey-app-host] :::zone-end Hosting integration health checks [!INCLUDE redis-hosting-health-checks] Client integration To get started with the .NET Aspire Stack Exchange Redis client integration, install the ðŸ“¦ Aspire.StackExchange.Redis NuGet package in the client-consuming project, that is, the project for the application that uses the Redis client. The Redis client integration registers an an IConnectionMultiplexer instance that you can use to interact with Redis. .NET CLI dotnetcli dotnet add package Aspire.StackExchange.Redis PackageReference xml <PackageReference Include=""Aspire.StackExchange.Redis"" Version=""*"" /> Add Redis client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddRedisClient(connectionName: ""cache""); :::zone pivot=""redis"" [!TIP] The connectionName parameter must match the name used when adding the Redis resource in the app host project. For more information, see Add Redis resource. :::zone-end :::zone pivot=""garnet"" [!TIP] The connectionName parameter must match the name used when adding the Garnet resource in the app host project. For more information, see Add Garnet resource. :::zone-end :::zone pivot=""valkey"" [!TIP] The connectionName parameter must match the name used when adding the Valkey resource in the app host project. For more information, see Add Valkey resource. :::zone-end You can then retrieve the IConnection instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(IConnectionMultiplexer connectionMux) { // Use connection multiplexer... } For more information on dependency injection, see .NET dependency injection. Add keyed Redis client There might be situations where you want to register multiple IConnectionMultiplexer instances with different connection names. To register keyed Redis clients, call the csharp builder.AddKeyedRedisClient(name: ""chat""); builder.AddKeyedRedisClient(name: ""queue""); Then you can retrieve the IConnectionMultiplexer instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] IConnectionMultiplexer chatConnectionMux, [FromKeyedServices(""queue"")] IConnectionMultiplexer queueConnectionMux) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Stack Exchange Redis client integration provides multiple options to configure the Redis connection based on the requirements and conventions of your project. Use a connection string :::zone pivot=""redis"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddRedis(""cache""); :::zone-end :::zone pivot=""garnet"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddGarnet(""cache""); :::zone-end :::zone pivot=""valkey"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddValkey(""cache""); :::zone-end Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } For more information on how to format this connection string, see the Stack Exchange Redis configuration docs. Use configuration providers [!INCLUDE redis-client-json-settings] Use inline delegates You can also pass the Action<StackExchangeRedisSettings> delegate to set up some or all the options inline, for example to configure DisableTracing: csharp builder.AddRedisClient( ""cache"", static settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Stack Exchange Redis integration handles the following: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.', '<2-hop>\n\nClient integration To get started with the .NET Aspire NATS client integration, install the ðŸ“¦ Aspire.NATS.Net NuGet package in the client-consuming project, that is, the project for the application that uses the NATS client. The NATS client integration registers an INatsConnection instance that you can use to interact with NATS. .NET CLI dotnetcli dotnet add package Aspire.NATS.Net PackageReference xml <PackageReference Include=""Aspire.NATS.Net"" Version=""*"" /> Add NATS client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNatsClient(connectionName: ""nats""); [!TIP] The connectionName parameter must match the name used when adding the NATS server resource in the app host project. For more information, see Add NATS server resource. You can then retrieve the INatsConnection instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(INatsConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed NATS client There might be situations where you want to register multiple INatsConnection instances with different connection names. To register keyed NATS clients, call the csharp builder.AddKeyedNatsClient(name: ""chat""); builder.AddKeyedNatsClient(name: ""queue""); Then you can retrieve the IConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] INatsConnection chatConnection, [FromKeyedServices(""queue"")] INatsConnection queueConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire NATS integration provides multiple options to configure the NATS connection based on the requirements and conventions of your project. Use a connection string Provide the name of the connection string when you call builder.AddNatsClient: csharp builder.AddNatsClient(connectionName: ""nats""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""nats"": ""nats://nats:4222"" } } See the ConnectionString documentation for more information on how to format this connection string. Use configuration providers The .NET Aspire NATS integration supports json { ""Aspire"": { ""Nats"": { ""Client"": { ""ConnectionString"": ""nats://nats:4222"", ""DisableHealthChecks"": true, ""DisableTracing"": true } } } } For the complete NATS client integration JSON schema, see Aspire.NATS.Net/ConfigurationSchema.json. Use inline delegates Pass the Action<NatsClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddNatsClient( ""nats"", static settings => settings.DisableHealthChecks = true); NATS in the .NET Aspire manifest NATS isn\'t part of the .NET Aspire deployment manifest. It\'s recommended you set up a secure production NATS server outside of .NET Aspire. Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire NATS integration handles the following: Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. Observability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire NATS integration uses the following log categories: NATS Tracing The .NET Aspire NATS integration emits the following tracing activities: NATS.Net See also NATS.Net quickstart .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire Redis integration utilizes the IConnectionMultiplexer interface to facilitate client integration. To get started, developers need to install the Aspire.StackExchange.Redis NuGet package in their client-consuming project. This integration registers an IConnectionMultiplexer instance, which can be used to interact with Redis. Developers can retrieve the IConnection instance using dependency injection, allowing for seamless integration within services. Configuration options for the Redis connection include using a connection string from the ConnectionStrings configuration section, inline delegates to set options like DisableTracing, and configuration providers. These options provide flexibility in setting up the Redis client according to project requirements. Additionally, the integration supports registering multiple IConnectionMultiplexer instances with different connection names, known as keyed Redis clients, which can also be retrieved using dependency injection.",multi_hop_specific_query_synthesizer
73,"How can a .NET Aspire project utilize Azure Monitor for application performance management during both local development and deployment to Azure, and what are the necessary steps to configure Application Insights for telemetry data export?","['<1-hop>\n\ntitle: Use .NET Aspire with Application Insights description: Learn how to send .NET Aspire telemetry to Application Insights. ms.date: 04/12/2024 ms.topic: how-to Use Application Insights for .NET Aspire telemetry Azure Application Insights, a feature of Azure Monitor, excels in Application Performance Management (APM) for live web applications. .NET Aspire projects are designed to use OpenTelemetry for application telemetry. OpenTelemetry supports an extension model to support sending data to different APMs. .NET Aspire uses OTLP by default for telemetry export, which is used by the dashboard during development. Azure Monitor doesn\'t (yet) support OTLP, so the applications need to be modified to use the Azure Monitor exporter, and configured with the connection string. To use Application insights, you specify its configuration in the app host project and use the Azure Monitor distro in the service defaults project. Choosing how Application Insights is provisioned .NET Aspire has the capability to provision cloud resources as part of cloud deployment, including Application Insights. In your .NET Aspire project, you can decide if you want .NET Aspire to provision an Application Insights resource when deploying to Azure. You can also select to use an existing Application Insights resource by providing its connection string. The connection information is managed by the resource configuration in the app host project. Provisioning Application insights during Azure deployment With this option, an instance of Application Insights will be created for you when the application is deployed using the Azure Developer CLI (azd). To use automatic provisioning, you specify a dependency in the app host project, and reference it in each project/resource that needs to send telemetry to Application Insights. The steps include: Add a Nuget package reference to Aspire.Hosting.Azure.ApplicationInsights in the app host project. Update the app host code to use the Application Insights resource, and reference it from each project: ```csharp var builder = DistributedApplication.CreateBuilder(args); // Automatically provision an Application Insights resource var insights = builder.AddAzureApplicationInsights(""MyApplicationInsights""); // Reference the resource from each project var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` Follow the steps in Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide) to deploy the application to Azure Container Apps. azd will create an Application Insights resource as part of the same resource group, and configure the connection string for each container. Manual provisioning of Application Insights resource Application Insights uses a connection string to tell the OpenTelemetry exporter where to send the telemetry data. The connection string is specific to the instance of Application Insights you want to send the telemetry to. It can be found in the Overview page for the application insights instance. :::image type=""content"" loc-scope=""azure"" source=""../media/app-insights-connection-string.png"" lightbox=""../media/app-insights-connection-string.png"" alt-text=""Connection string placement in the Azure Application Insights portal UI.""::: If you wish to use an instance of Application Insights that you have provisioned manually, then you should use the AddConnectionString API in the app host project to tell the projects/containers where to send the telemetry data. The Azure Monitor distro expects the environment variable to be APPLICATIONINSIGHTS_CONNECTION_STRING, so that needs to be explicitly set when defining the connection string. ```csharp var builder = DistributedApplication.CreateBuilder(args); var insights = builder.AddConnectionString( ""myInsightsResource"", ""APPLICATIONINSIGHTS_CONNECTION_STRING""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ```', '<2-hop>\n\nResource usage during development When running the .NET Aspire project locally, the preceding code reads the connection string from configuration. As this is a secret, you should store the value in app secrets. Right click on the app host project and choose Manage Secrets from the context menu to open the secrets file for the app host project. In the file add the key and your specific connection string, the example below is for illustration purposes. json { ""ConnectionStrings"": { ""myInsightsResource"": ""InstrumentationKey=12345678-abcd-1234-abcd-1234abcd5678;IngestionEndpoint=https://westus3-1.in.applicationinsights.azure.com"" } } [!NOTE] The name specified in the app host code needs to match a key inside the ConnectionStrings section in the settings file. Resource usage during deployment When deploying an Aspire application with Azure Developer CLI (azd), it will recognize the connection string resource and prompt for a value. This enables a different resource to be used for the deployment from the value used for local development. Mixed deployment If you wish to use a different deployment mechanism per execution context, use the appropriate API conditionally. For example, the following code uses a pre-supplied connection at development time, and an automatically provisioned resource at deployment time. ``` csharp var builder = DistributedApplication.CreateBuilder(args); var insights = builder.ExecutionContext.IsPublishMode ? builder.AddAzureApplicationInsights(""myInsightsResource"") : builder.AddConnectionString(""myInsightsResource"", ""APPLICATIONINSIGHTS_CONNECTION_STRING""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` [!TIP] The preceding code requires you to supply the connection string information in app secrets for development time usage, and will be prompted for the connection string by azd at deployment time. Use the Azure Monitor distro To make exporting to Azure Monitor simpler, this example uses the Azure Monitor Exporter Repo. This is a wrapper package around the Azure Monitor OpenTelemetry Exporter package that makes it easier to export to Azure Monitor with a set of common defaults. Add the following package to the ServiceDefaults project, so that it will be included in each of the .NET Aspire services. For more information, see .NET Aspire service defaults. xml <PackageReference Include=""Azure.Monitor.OpenTelemetry.AspNetCore"" Version=""*"" /> Add a using statement to the top of the project. csharp using Azure.Monitor.OpenTelemetry.AspNetCore; Uncomment the line in AddOpenTelemetryExporters to use the Azure Monitor exporter: ```csharp private static IHostApplicationBuilder AddOpenTelemetryExporters( this IHostApplicationBuilder builder) { // Omitted for brevity... // Uncomment the following lines to enable the Azure Monitor exporter // (requires the Azure.Monitor.OpenTelemetry.AspNetCore package) if (!string.IsNullOrEmpty(builder.Configuration[""APPLICATIONINSIGHTS_CONNECTION_STRING""])) { builder.Services.AddOpenTelemetry().UseAzureMonitor(); } return builder; } ``` It\'s possible to further customize the Azure Monitor exporter, including customizing the resource name and changing the sampling. For more information, see Customize the Azure Monitor exporter. Using the parameterless version of UseAzureMonitor(), will pickup the connection string from the APPLICATIONINSIGHTS_CONNECTION_STRING environment variable, we configured via the app host project.']","A .NET Aspire project can utilize Azure Monitor for application performance management by integrating Application Insights, a feature of Azure Monitor, to handle telemetry data. During local development, the connection string for Application Insights should be stored securely in app secrets. This involves managing secrets in the app host project and ensuring the connection string matches the key in the settings file. For deployment to Azure, the Azure Developer CLI (azd) can automatically provision an Application Insights resource, or a pre-existing resource can be used by providing its connection string. The connection string is crucial for directing telemetry data to the correct Application Insights instance. The Azure Monitor exporter can be configured in the app host project to use the connection string stored in the APPLICATIONINSIGHTS_CONNECTION_STRING environment variable. This setup allows the project to switch between a pre-supplied connection during development and an automatically provisioned resource during deployment, ensuring seamless telemetry data export to Azure Monitor.",multi_hop_specific_query_synthesizer
74,How do you integrate MicrosoftDocs .NET Aspire with Cosmos DB using Entity Framework Core and what are the steps to add it to an existing .NET app?,"['<1-hop>\n\ntitle: .NET Aspire Cosmos DB Entity Framework Core integration description: Learn how to install and configure the .NET Aspire Cosmos DB Entity Framework Core integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-entity-framework-integration .NET Aspire Cosmos DB Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.Cosmos"" Version=""*"" /> Add Cosmos DB context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmosdb that same name should be used when calling AddCosmosDbContext. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(MyDbContext context) { // Use context... } For more information on using Entity Framework Core with Azure Cosmos DB, see the Examples for Azure Cosmos DB for NoSQL SDK for .NET. Configuration The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddCosmosDbContext: csharp builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information, see the ConnectionString documentation. Use configuration providers The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""Cosmos"": { ""DisableTracing"": true } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json. Use inline delegates You can also pass the Action<EntityFrameworkCoreCosmosSettings> configureSettings delegate to set up some or all the csharp builder.AddCosmosDbContext<MyDbContext>( ""cosmosdb"", settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn\'t implement health checks, though this may change in future releases. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: Add .NET Aspire to an existing .NET app description: Learn how to add .NET Aspire integrations, orchestration, and tooling to a microservices app that already exists. ms.date: 11/08/2024 ms.topic: how-to zone_pivot_groups: dev-environment Tutorial: Add .NET Aspire to an existing .NET app If you have existing microservices and .NET web app, you can add .NET Aspire to it and get all the included features and benefits. In this article, you add .NET Aspire orchestration to a simple, preexisting .NET 9 project. You learn how to: [!div class=""checklist""] Understand the structure of the existing microservices app. Enroll existing projects in .NET Aspire orchestration. Understand the changes enrollment makes in the projects. Start the .NET Aspire project. [!INCLUDE aspire-prereqs] Get started Let\'s start by obtaining the code for the solution: Open a command prompt and change directories to where you want to store the code. To clone to .NET 9 example solution, use the following git clone command: bash git clone https://github.com/MicrosoftDocs/mslearn-dotnet-cloudnative-devops.git eShopLite']","To integrate MicrosoftDocs .NET Aspire with Cosmos DB using Entity Framework Core, you need to install the Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in your client-consuming project. In the Program.cs file, you call builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); ensuring the connectionName matches the name used when adding the Cosmos DB resource in the app host project. Configuration can be done using a connection string from the ConnectionStrings configuration section or by using configuration providers. To add .NET Aspire to an existing .NET app, you can clone the example solution from the MicrosoftDocs GitHub repository using the command: git clone https://github.com/MicrosoftDocs/mslearn-dotnet-cloudnative-devops.git eShopLite. This process involves understanding the structure of the existing microservices app, enrolling existing projects in .NET Aspire orchestration, and starting the .NET Aspire project.",multi_hop_specific_query_synthesizer
75,How do the AspireRedis.AppHost and AspireSample.AppHost projects facilitate service orchestration and communication in .NET Aspire solutions?,"['<1-hop>\n\ntitle: Implement caching with .NET Aspire integrations description: Learn how to connect to Redis and cache data using .NET Aspire integrations. ms.date: 11/08/2024 ms.topic: tutorial Tutorial: Implement caching with .NET Aspire integrations Cloud-native apps often require various types of scalable caching solutions to improve performance. .NET Aspire integrations simplify the process of connecting to popular caching services such as Redis. In this article, you\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET core app that is set up to use .NET Aspire. Add .NET Aspire integrations to connect to Redis and implement caching. Configure the .NET Aspire integrations to meet specific requirements. This article explores how to use two different types of ASP.NET Core caching using .NET Aspire and Redis: Output caching: A configurable, extensible caching method for storing entire HTTP responses for future requests. Distributed caching: A cache shared by multiple app servers that allows you to cache specific pieces of data. A distributed cache is typically maintained as an external service to the app servers that access it and can improve the performance and scalability of an ASP.NET Core app. [!INCLUDE aspire-prereqs] Create the project At the top of Visual Studio, navigate to File > New > Project.... In the dialog window, enter .NET Aspire into the project template search box and select .NET Aspire Starter Application. Choose Next. On the Configure your new project screen: Enter a Project name of AspireRedis. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Uncheck Use Redis for caching. You will implement your own caching setup. Select Create. Visual Studio creates a new .NET Aspire solution that consists of the following projects: AspireRedis.Web - A Blazor UI project with default .NET Aspire configurations. AspireRedis.ApiService - A Minimal API with default .NET Aspire configurations that provides the frontend with data. AspireRedis.AppHost - An orchestrator project designed to connect and configure the different projects and services of your app. AspireRedis.ServiceDefaults - A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. Configure the App Host project Add the ðŸ“¦ Aspire.Hosting.Redis NuGet package to the AspireRedis.AppHost project: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Redis PackageReference xml <PackageReference Include=""Aspire.Hosting.Redis"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Update the :::no-loc text=""Program.cs""::: file of the AspireRedis.AppHost project to match the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var redis = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code creates a local Redis container instance and configures the UI and API to use the instance automatically for both output and distributed caching. The code also configures communication between the frontend UI and the backend API using service discovery. With .NET Aspire\'s implicit service discovery, setting up and managing service connections is streamlined for developer productivity. In the context of this tutorial, the feature simplifies how you connect to Redis. Traditionally, you\'d manually specify the Redis connection string in each project\'s :::no-loc text=""appsettings.json""::: file: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } Configuring connection string with this method, while functional, requires duplicating the connection string across multiple projects, which can be cumbersome and error-prone.', '<2-hop>\n\nUnderstand the .NET Aspire solution structure The solution consists of the following projects: AspireSample.ApiService: An ASP.NET Core Minimal API project is used to provide data to the front end. This project depends on the shared AspireSample.ServiceDefaults project. AspireSample.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the Startup project, and it depends on the AspireSample.ApiService and AspireSample.Web projects. AspireSample.ServiceDefaults: A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. AspireSample.Web: An ASP.NET Core Blazor App project with default .NET Aspire service configurations, this project depends on the AspireSample.ServiceDefaults project. For more information, see .NET Aspire service defaults. Your AspireSample directory should resemble the following structure: [!INCLUDE template-directory-structure] Explore the starter projects Each project in an .NET Aspire solution plays a role in the composition of your app. The .Web_ project is a standard ASP.NET Core Blazor App that provides a front end UI. For more information, see What\'s new in ASP.NET Core 9.0: Blazor. The _.ApiService project is a standard ASP.NET Core Minimal API template project. Both of these projects depend on the *.ServiceDefaults project, which is a shared project that\'s used to manage configurations that are reused across projects in your solution. The two projects of interest in this quickstart are the .AppHost_ and _.ServiceDefaults projects detailed in the following sections. .NET Aspire host project The *.AppHost project is responsible for acting as the orchestrator, and sets the IsAspireHost property of the project file to true: :::code language=""xml"" source=""snippets/quickstart/AspireSample/AspireSample.AppHost/AspireSample.AppHost.csproj"" highlight=""10""::: For more information, see .NET Aspire orchestration overview and .NET Aspire SDK. Consider the :::no-loc text=""Program.cs""::: file of the AspireSample.AppHost project: :::code source=""snippets/quickstart/AspireSample/AspireSample.AppHost/Program.cs""::: If you\'ve used either the .NET Generic Host or the ASP.NET Core Web Host before, the app host programming model and builder pattern should be familiar to you. The preceding code: Creates an Calls Calls Calls AddProject again, this time adding the AspireSample.Web project to the application model. It also chains multiple calls to Finally, the app is built and run. The [!TIP] The call to .NET Aspire service defaults project The *.ServiceDefaults project is a shared project that\'s used to manage configurations that are reused across the projects in your solution. This project ensures that all dependent services share the same resilience, service discovery, and OpenTelemetry configuration. A shared .NET Aspire project file contains the IsAspireSharedProject property set as true: :::code language=""xml"" source=""snippets/quickstart/AspireSample/AspireSample.ServiceDefaults/AspireSample.ServiceDefaults.csproj"" highlight=""7""::: The service defaults project exposes an extension method on the Orchestrate service communication .NET Aspire provides orchestration features to assist with configuring connections and communication between the different parts of your app. The AspireSample.AppHost project added the AspireSample.ApiService and AspireSample.Web projects to the application model. It also declared their names as ""webfrontend"" for Blazor front end, ""apiservice"" for the API project reference. Additionally, a Redis server resource labeled ""cache"" was added. These names are used to configure service discovery and communication between the projects in your app. The front end app defines a typed :::code source=""snippets/quickstart/AspireSample/AspireSample.Web/WeatherApiClient.cs""::: The HttpClient is configured to use service discovery. Consider the following code from the :::no-loc text=""Program.cs""::: file of the AspireSample.Web project: :::code source=""snippets/quickstart/AspireSample/AspireSample.Web/Program.cs"" highlight=""7-8,14-19""::: The preceding code: Calls AddServiceDefaults, configuring the shared defaults for the app. Calls Calls For more information, see Make HTTP requests with the HttpClient class. See also .NET Aspire integrations overview Service discovery in .NET Aspire .NET Aspire service defaults Health checks in .NET Aspire .NET Aspire telemetry Troubleshoot untrusted localhost certificate in .NET Aspire Next steps [!div class=""nextstepaction""] Tutorial: Add .NET Aspire to an existing .NET app']","The AspireRedis.AppHost and AspireSample.AppHost projects both serve as orchestrators in their respective .NET Aspire solutions. The AspireRedis.AppHost project connects and configures different projects and services, such as the UI and API, to use a local Redis container instance for caching. It simplifies service connections through implicit service discovery, enhancing developer productivity. Similarly, the AspireSample.AppHost project acts as an orchestrator by connecting the AspireSample.ApiService and AspireSample.Web projects, using service discovery to manage communication between them. It also configures a Redis server resource labeled 'cache' for service discovery and communication, ensuring that all dependent services share the same resilience, service discovery, and OpenTelemetry configuration.",multi_hop_specific_query_synthesizer
76,How does the .NET Aspire framework facilitate the integration of RabbitMQ and Azure Queue Storage in the ExampleProject?,"['<1-hop>\n\nHosting integration The RabbitMQ hosting integration models a RabbitMQ server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.RabbitMQ PackageReference xml <PackageReference Include=""Aspire.Hosting.RabbitMQ"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add RabbitMQ server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/rabbitmq image, it creates a new RabbitMQ server instance on your local machine. A reference to your RabbitMQ server (the rabbitmq variable) is added to the ExampleProject. The RabbitMQ server resource includes default credentials with a username of ""guest"" and randomly generated password using the The [!TIP] If you\'d rather connect to an existing RabbitMQ server, call Add RabbitMQ server resource with management plugin To add the RabbitMQ management plugin to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithManagementPlugin(); builder.AddProject // After adding all resources, run the app... ``` The RabbitMQ management plugin provides an HTTP-based API for management and monitoring of your RabbitMQ server. .NET Aspire adds another container image docker.io/library/rabbitmq-management to the app host that runs the management plugin. Add RabbitMQ server resource with data volume To add a data volume to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the RabbitMQ server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/rabbitmq path in the RabbitMQ server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add RabbitMQ server resource with data bind mount To add a data bind mount to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataBindMount( source: @""C:\\RabbitMQ\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the RabbitMQ server data across container restarts. The data bind mount is mounted at the C:\\RabbitMQ\\Data on Windows (or /RabbitMQ/Data on Unix) path on the host machine in the RabbitMQ server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add RabbitMQ server resource with parameters When you want to explicitly provide the username and password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username"", secret: true); var password = builder.AddParameter(""password"", secret: true); var rabbitmq = builder.AddRabbitMQ(""messaging"", username, password); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Hosting integration health checks The RabbitMQ hosting integration automatically adds a health check for the RabbitMQ server resource. The health check verifies that the RabbitMQ server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Rabbitmq NuGet package.', '<2-hop>\n\ntitle: .NET Aspire Azure Queue Storage integration description: This article describes the .NET Aspire Azure Queue Storage integration features and capabilities. ms.date: 12/09/2024 uid: storage/azure-queue-storage-integration .NET Aspire Azure Queue Storage integration [!INCLUDE includes-hosting-and-client] Azure Queue Storage is a service for storing large numbers of messages that can be accessed from anywhere in the world via authenticated calls. The .NET Aspire Azure Queue Storage integration enables you to connect to existing Azure Queue Storage instances or create new instances from .NET applications. Hosting integration [!INCLUDE storage-app-host] Add Azure Queue Storage resource In your app host project, register the Azure Queue Storage integration by chaining a call to ```csharp var builder = DistributedApplication.CreateBuilder(args); var queues = builder.AddAzureStorage(""storage"") .AddQueues(""queues""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Adds an Azure Storage resource named storage. Adds a queue named queues to the storage resource. Adds the storage resource to the ExampleProject and waits for it to be ready before starting the project. [!INCLUDE storage-hosting-health-checks] Client integration To get started with the .NET Aspire Azure Queue Storage client integration, install the ðŸ“¦ Aspire.Azure.Storage.Queues NuGet package in the client-consuming project, that is, the project for the application that uses the Azure Queue Storage client. The Azure Queue Storage client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Azure.Storage.Queues PackageReference xml <PackageReference Include=""Aspire.Azure.Storage.Queues"" Version=""*"" /> Add Azure Queue Storage client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureQueueClient(""queue""); You can then retrieve the QueueServiceClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(QueueServiceClient client) { // Use client... } Configuration The .NET Aspire Azure Queue Storage integration provides multiple options to configure the QueueServiceClient based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddAzureQueueClient(""queue""); Then the connection string is retrieved from the ConnectionStrings configuration section, and two connection formats are supported: Service URI The recommended approach is to use a ServiceUri, which works with the json { ""ConnectionStrings"": { ""queue"": ""https://{account_name}.queue.core.windows.net/"" } } Connection string Alternatively, an Azure Storage connection string can be used. json { ""ConnectionStrings"": { ""queue"": ""AccountName=myaccount;AccountKey=myaccountkey"" } } For more information, see Configure Azure Storage connection strings. Use configuration providers The .NET Aspire Azure Queue Storage integration supports json { ""Aspire"": { ""Azure"": { ""Storage"": { ""Queues"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Diagnostics"": { ""ApplicationId"": ""myapp"" } } } } } } } For the complete Azure Storage Queues client integration JSON schema, see Aspire.Azure.Data.Queues/ConfigurationSchema.json. Use inline delegates You can also pass the Action<AzureStorageQueuesSettings> configureSettings delegate to set up some or all the options inline, for example to configure health checks: csharp builder.AddAzureQueueClient( ""queue"", settings => settings.DisableHealthChecks = true); You can also set up the csharp builder.AddAzureQueueClient( ""queue"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Diagnostics.ApplicationId = ""myapp"")); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Queue Storage integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","The .NET Aspire framework facilitates the integration of RabbitMQ and Azure Queue Storage in the ExampleProject by providing specific hosting integrations for each service. For RabbitMQ, it allows the addition of a RabbitMQ server resource to the app host project using the `AddRabbitMQ` method, which can include features like a management plugin, data volume, and data bind mount. This integration also includes automatic health checks to ensure the RabbitMQ server is running properly. For Azure Queue Storage, the framework enables the registration of Azure Queue Storage resources and queues through the `AddAzureStorage` and `AddQueues` methods. It also supports client integration by allowing the addition of an Azure Queue Storage client in the client-consuming project, with options for configuration using connection strings or inline delegates. Both integrations are added to the ExampleProject, enhancing its messaging and storage capabilities.",multi_hop_specific_query_synthesizer
77,"How can a cloud application developer leverage Azure Event Hubs and Azure Service Bus for orchestrating distributed applications, and what are the specific integration features provided by .NET Aspire for Azure Service Bus?","['<1-hop>\n\nlibrary for interacting with Azure App Configuration . - Learn more : ðŸ“„ Azure Application Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ApplicationInsights - Client : N/A A library for interacting with Azure Application Insights . - Learn more : ðŸ“„ Azure Cosmos DB - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos A library for accessing Azure Cosmos DB databases with Entity Framework Core . - Learn more : ðŸ“„ Azure Cosmos DB - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.Azure.Cosmos A library for accessing Azure Cosmos DB databases. - Learn more : ðŸ“„ Azure Event Hubs - Hosting : ðŸ“¦ Aspire.Hosting.Azure.EventHubs - Client : ðŸ“¦ Aspire.Azure.Messaging.EventHubs A library for accessing Azure Event Hubs . - Learn more : ðŸ“„ Azure Functions - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Functions - Client : N/A A library for integrating with Azure Functions . - Learn more : ðŸ“„ Azure Key Vault - Hosting : ðŸ“¦ Aspire.Hosting.Azure.KeyVault - Client : ðŸ“¦ Aspire.Azure.Security.KeyVault A library for accessing Azure Key Vault . - Learn more : ðŸ“„ Azure Operational Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.OperationalInsights - Client : N/A A library for interacting with Azure Operational Insights . - Learn more : ðŸ“„ Azure AI OpenAI - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CognitiveServices - Client : ðŸ“¦ Aspire.Azure.AI.OpenAI A library for accessing Azure AI OpenAI or OpenAI functionality. - Learn more : ðŸ“„ Azure PostgreSQL - Hosting : ðŸ“¦ Aspire.Hosting.Azure.PostgreSQL - Client : N/A A library for interacting with Azure Database for PostgreSQL . - Learn more : ðŸ“„ Azure AI Search - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Search - Client : ðŸ“¦ Aspire.Azure.Search.Documents A library for accessing Azure AI Search functionality. - Learn more : ðŸ“„ Azure Service Bus - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ServiceBus - Client : ðŸ“¦ Aspire.Azure.Messaging.ServiceBus A library for accessing Azure Service Bus . - Learn more : ðŸ“„ Azure SignalR Service - Hosting : ðŸ“¦ Aspire.Hosting.Azure.SignalR - Client : Microsoft.Azure.SignalR A library for accessing Azure SignalR Service . - Learn more : ðŸ“„ Azure Blob Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Blobs A library for accessing Azure Blob Storage . - Learn more : ðŸ“„ Azure Storage Queues - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Queues A library for accessing Azure Storage Queues . - Learn more : ðŸ“„ Azure Table Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Data.Tables A library for accessing the Azure Table service. - Learn more : ðŸ“„ Azure Web PubSub - Hosting : ðŸ“¦ Aspire.Hosting.Azure.WebPubSub - Client : ðŸ“¦ Aspire.Azure.Messaging.WebPubSub A library for accessing the Azure Web PubSub service. Amazon Web Services (AWS) hosting integrations Integration docs and NuGet packages Description - Learn more : ðŸ“„ AWS Hosting - Hosting : ðŸ“¦ Aspire.Hosting.AWS - Client : N/A A library for modeling AWS resources . For more information, see GitHub: Aspire.Hosting.AWS library. Community Toolkit integrations [!NOTE] The Community Toolkit integrations are community-driven and maintained by the .NET Aspire community. These integrations are not officially supported by the .NET Aspire team. Integration docs and NuGet packages Description - Learn More : ðŸ“„ Azure Static Web Apps emulator - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps - Client : N/A A hosting integration for the Azure Static Web Apps emulator (Note: this does not support deployment of a project to Azure Static Web Apps). - Learn More : ðŸ“„ Bun hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Bun - Client : N/A A hosting integration for Bun apps. - Learn More : ðŸ“„ Deno hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Deno - Client : N/A A hosting integration for Deno apps. - Learn More : ðŸ“„ Go hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Golang - Client : N/A A hosting integration for Go apps. - Learn More : ðŸ“„ Java/Spring hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Java - Client : N/A A integration for running Java code in .NET Aspire either using the local JDK or using a container. - Learn More : ðŸ“„ Node.js hosting extensions - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.NodeJs.Extensions - Client : N/A An integration that contains some additional extensions for running Node.js applications - Learn More : ðŸ“„ Ollama - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Ollama - Client : ðŸ“¦ Aspire.CommunitToolkit.OllamaSharp An Aspire component leveraging the Ollama container with support for downloading a model on startup. - Learn More : ðŸ“„ Meilisearch hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Meilisearch - Client : ðŸ“¦ Aspire.CommunitToolkit.Meilisearch An Aspire component leveraging the Meilisearch container. - Learn More : ðŸ“„ Rust hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Rust - Client : N/A A hosting integration for Rust apps. - Learn More : ðŸ“„ SQL Database projects hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects - Client : N/A An Aspire hosting integration for SQL Database Projects. For more information, see .NET Aspire Community Toolkit.', '<2-hop>\n\ntitle: .NET Aspire Azure Service Bus integration description: This article describes the .NET Aspire Azure Service Bus integration features and capabilities ms.topic: how-to ms.date: 08/12/2024 .NET Aspire Azure Service Bus integration Cloud-native apps often require communication with messaging services such as Azure Service Bus. Messaging services help decouple applications and enable scenarios that rely on features such as queues, topics and subscriptions, atomic transactions, load balancing, and more. The .NET Aspire Service Bus integration handles the following concerns to connect your app to Azure Service Bus: A Applies ServiceBusClient configurations either inline through code or through configuration file settings. Prerequisites Azure subscription - create one for free Azure Service Bus namespace, learn more about how to add a Service Bus namespace. Alternatively, you can use a connection string, which is not recommended in production environments. Get started To get started with the .NET Aspire Azure Service Bus integration, install the ðŸ“¦ Aspire.Azure.Messaging.ServiceBus NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Service Bus client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.ServiceBus"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Example usage In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureServiceBusClient(""messaging""); To retrieve the configured csharp public class ExampleService(ServiceBusClient client) { // ... } App host usage To add Azure Service Bus hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.ServiceBus"" Version=""*"" /> In your app host project, register the Service Bus integration and consume the service using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var serviceBus = builder.ExecutionContext.IsPublishMode ? builder.AddAzureServiceBus(""messaging"") : builder.AddConnectionString(""messaging""); builder.AddProject Configuration The .NET Aspire Service Bus integration provides multiple options to configure the ServiceBusClient based on the requirements and conventions of your project. Use configuration providers The Service Bus integration supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""ServiceBus"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Identifier"": ""CLIENT_ID"" } } } } } } If you have set up your configurations in the Aspire:Azure:Messaging:ServiceBus section of your :::no-loc text=""appsettings.json""::: file you can just call the method AddAzureServiceBusClient without passing any parameters. Use inline delegates You can also pass the Action<AzureMessagingServiceBusSettings> delegate to set up some or all the options inline, for example to set the FullyQualifiedNamespace: csharp builder.AddAzureServiceBusClient( ""messaging"", static settings => settings.FullyQualifiedNamespace = ""YOUR_SERVICE_BUS_NAMESPACE""); You can also set up the ServiceBusClientOptions using Action<IAzureClientBuilder<ServiceBusClient, ServiceBusClientOptions>> delegate, the second parameter of the AddAzureServiceBus method. For example to set the ServiceBusClient ID to identify the client: csharp builder.AddAzureServiceBusClient( ""messaging"", static clientBuilder => clientBuilder.ConfigureOptions( static options => options.Identifier = ""CLIENT_ID"")); Configuration options The following configurable options are exposed through the Name Description ConnectionString The connection string used to connect to the Service Bus namespace. Credential The credential used to authenticate to the Service Bus namespace. FullyQualifiedNamespace The fully qualified Service Bus namespace. DisableTracing Disables tracing for the Service Bus client. â€  HealthCheckQueueName The name of the queue used for health checks. â€  HealthCheckTopicName The name of the topic used for health checks. â€  At least one of the name options are mandatory when enabling health checks. [!INCLUDE integration-observability-and-telemetry]']","A cloud application developer can leverage Azure Event Hubs and Azure Service Bus to orchestrate distributed applications by utilizing the libraries provided for accessing these services. Azure Event Hubs can be accessed using the Aspire.Azure.Messaging.EventHubs library, which facilitates the integration of event streaming capabilities into applications. For Azure Service Bus, the .NET Aspire integration provides a comprehensive set of features to connect applications with messaging services. This includes handling configurations for the ServiceBusClient either inline through code or via configuration file settings, supporting communication through queues, topics, and subscriptions, and enabling atomic transactions and load balancing. Developers can install the Aspire.Azure.Messaging.ServiceBus NuGet package to integrate Azure Service Bus into their applications, allowing them to decouple components and enhance scalability and reliability. The integration also supports various configuration options, such as setting the FullyQualifiedNamespace and configuring client options, which can be done through the appsettings.json file or inline delegates.",multi_hop_specific_query_synthesizer
78,"How can a cloud application developer leverage the .NET Aspire NATS and RabbitMQ integrations to enhance distributed application deployment, and what are the benefits of using data volumes and bind mounts in these integrations?","['<1-hop>\n\ntitle: .NET Aspire NATS integration description: Learn how to use the .NET Aspire NATS integration to send logs and traces to a NATS Server. ms.date: 10/11/2024 uid: messaging/nats-integration .NET Aspire NATS integration [!INCLUDE includes-hosting-and-client] NATS is a high-performance, secure, distributed messaging system. The .NET Aspire NATS integration enables you to connect to existing NATS instances, or create new instances from .NET with the docker.io/library/nats container image. Hosting integration NATS hosting integration for .NET Aspire models a NATS server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Nats PackageReference xml <PackageReference Include=""Aspire.Hosting.Nats"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add NATS server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/nats image, it creates a new NATS server instance on your local machine. A reference to your NATS server (the nats variable) is added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing NATS server, call Add NATS server resource with JetStream To add the NATS JetStream to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithJetStream(); builder.AddProject // After adding all resources, run the app... ``` The NATS JetStream functionality provides a built-in persistence engine called JetStream which enables messages to be stored and replayed at a later time. You can optionally provide a srcMountPath parameter to specify the path to the JetStream data directory on the host machine (the provided mount path maps to the container\'s -sd argument). Add NATS server resource with data volume To add a data volume to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the NATS server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/nats path in the NATS server container. A name is generated at random unless you provide a set the name parameter. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add NATS server resource with data bind mount To add a data bind mount to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataBindMount( source: @""C:\\NATS\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the NATS server data across container restarts. The data bind mount is mounted at the C:\\NATS\\Data on Windows (or /NATS/Data on Unix) path on the host machine in the NATS server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The NATS hosting integration automatically adds a health check for the NATS server resource. The health check verifies that the NATS server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Nats NuGet package.', '<2-hop>\n\nHosting integration The RabbitMQ hosting integration models a RabbitMQ server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.RabbitMQ PackageReference xml <PackageReference Include=""Aspire.Hosting.RabbitMQ"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add RabbitMQ server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/rabbitmq image, it creates a new RabbitMQ server instance on your local machine. A reference to your RabbitMQ server (the rabbitmq variable) is added to the ExampleProject. The RabbitMQ server resource includes default credentials with a username of ""guest"" and randomly generated password using the The [!TIP] If you\'d rather connect to an existing RabbitMQ server, call Add RabbitMQ server resource with management plugin To add the RabbitMQ management plugin to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithManagementPlugin(); builder.AddProject // After adding all resources, run the app... ``` The RabbitMQ management plugin provides an HTTP-based API for management and monitoring of your RabbitMQ server. .NET Aspire adds another container image docker.io/library/rabbitmq-management to the app host that runs the management plugin. Add RabbitMQ server resource with data volume To add a data volume to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the RabbitMQ server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/rabbitmq path in the RabbitMQ server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add RabbitMQ server resource with data bind mount To add a data bind mount to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataBindMount( source: @""C:\\RabbitMQ\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the RabbitMQ server data across container restarts. The data bind mount is mounted at the C:\\RabbitMQ\\Data on Windows (or /RabbitMQ/Data on Unix) path on the host machine in the RabbitMQ server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add RabbitMQ server resource with parameters When you want to explicitly provide the username and password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username"", secret: true); var password = builder.AddParameter(""password"", secret: true); var rabbitmq = builder.AddRabbitMQ(""messaging"", username, password); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Hosting integration health checks The RabbitMQ hosting integration automatically adds a health check for the RabbitMQ server resource. The health check verifies that the RabbitMQ server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Rabbitmq NuGet package.']","A cloud application developer can leverage the .NET Aspire NATS and RabbitMQ integrations to enhance distributed application deployment by using the provided hosting integrations to model NATS and RabbitMQ servers as .NET CLI packages. For NATS, the developer can use the .NET Aspire NATS integration to connect to existing NATS instances or create new ones using the docker.io/library/nats container image. This integration allows for the addition of JetStream for message persistence and data volumes or bind mounts for data persistence across container restarts. Similarly, the RabbitMQ integration allows the creation of a RabbitMQ server instance using the docker.io/library/rabbitmq image, with options to add a management plugin for monitoring and management, and to use data volumes or bind mounts for data persistence. The benefits of using data volumes and bind mounts include the ability to persist server data outside the lifecycle of the container, ensuring data is retained across restarts. Data volumes are preferred for their ease of use and management, while bind mounts offer flexibility by relying on the host machine's filesystem.",multi_hop_specific_query_synthesizer
79,"How do you upgrade a .NET Aspire app host project to version 9.0 using the Aspire.Hosting.AppHost package, and what are the built-in resource types available in this package?","['<1-hop>\n\nUse the Upgrade Assistant to upgrade your projects to .NET Aspire 9.0. [!TIP] If you\'re new to .NET Aspire, there\'s no reason to upgrade anything. For more information, see .NET Aspire setup and tooling. Prerequisites Before you upgrade your projects to .NET Aspire 9.0, ensure that you have the following prerequisites: Install the latest tooling. Use the .NET Aspire SDK. [!NOTE] Feel free to uninstall the .NET Aspire workload as you\'ll no longer need it. dotnetcli dotnet workload uninstall aspire For more information, see dotnet workload uninstall. If you don\'t uninstall the .NET Aspire workload, and you\'re using the new .NET Aspire SDK and templates, you see both .NET Aspire 8.0 and .NET Aspire 9.0 templates. Manually upgrade to .NET Aspire 9.0 To upgrade your projects to .NET Aspire 9.0, you need to update your project files. The following steps guide you through the process: Edit your app host project file to use the new .NET Aspire 9.0 SDK (Aspire.AppHost.Sdk). Update the NuGet packages in your project files to the latest versions. Adjust your Program.cs file to use the new APIs and remove any obsolete APIs. Edit your app host project file To upgrade your app host project to .NET Aspire 9.0, you need to update your project file to use the new ðŸ“¦ Aspire.AppHost.Sdk: ```diff ``` Optionally upgrade the target framework moniker (TFM) .NET Aspire 9.0 runs on .NET 9.0, but you can also run it on .NET 8.0. In other words, just because you\'re using the .NET Aspire SDK, and pointing to version 9.0 packages, you can still target .NET 8.0. If you want to run your .NET Aspire 9.0 project on .NET 9.0, you need to update the TargetFramework property in your project file: ```diff ``` For more information on TFMs, see Target frameworks in SDK-style projects: Latest versions. Overall app host project differences If you followed all of the preceding steps, your app host project file should look like this: ```diff ``` The changes include the addition of the Aspire.AppHost.Sdk, the update of the TargetFramework property to net9.0, and the update of the Aspire.Hosting.AppHost package to version 9.0.0. Adjust your Program.cs file With the introduction of .NET Aspire 9.0, there are some breaking changes. Some APIs were originally marked as experimental (with the For the complete list of breaking changes in .NET Aspire 9.0, see Breaking changes in .NET Aspire 9.0. Use the Upgrade Assistant The Upgrade Assistant is a tool that helps upgrade targeted projects to the latest version. If you\'re new to the Upgrade Assistant, there\'s two modalities to choose from: The Visual Studio extension version. The .NET CLI global tool version. Regardless of how you install the Upgrade Assistant, you can use it to upgrade your .NET Aspire 8.x projects to .NET Aspire 9.0. :::zone pivot=""visual-studio"" To upgrade the .NET Aspire app host project to .NET Aspire 9.0 with Visual Studio, right-click the project in Solution Explorer and select Upgrade. [!IMPORTANT] If the Upgrade Assistant isn\'t already installed, you\'ll be prompted to install it. The Upgrade Assistant displays a welcome package. Select the Aspire upgrades option: :::image type=""content"" source=""media/upgrade-assistant-welcome-aspire.png"" lightbox=""media/upgrade-assistant-welcome-aspire.png"" alt-text=""Visual Studio: Upgrade Assistant welcome page with .NET Aspire app host project.""::: With the Aspire upgrades option selected, the Upgrade Assistant displays the selectable upgrade target components. Leave all the options checked and select Upgrade selection: :::image type=""content"" source=""media/upgrade-assistant-aspire-app-host-comps.png"" lightbox=""media/upgrade-assistant-aspire-app-host-comps.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire selectable components to upgrade.""::: Finally, after selecting the components to upgrade, the Upgrade Assistant displays the results of the upgrade process. If everything was successful, you see green check marks next to each component: :::image type=""content"" source=""media/upgrade-assistant-aspire-upgraded.png"" lightbox=""media/upgrade-assistant-aspire-upgraded.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire app host project upgraded successfully.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To upgrade the .NET Aspire app host project, ensure that you installed the Upgrade Assistant CLI. Open a terminal session at the root directory of the .NET Aspire app host project file, and run the following command: dotnetcli upgrade-assistant upgrade The output is interactive, expecting you to select the upgrade type. Choose the Aspire upgrades option: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ How do you want to upgrade project AspireSample.AppHost? Aspire upgrades Upgrade to latest .NET Aspire version (aspire.latest) Upgrade project to a newer .NET version In-place project upgrade (framework.inplace) NuGet upgrades NuGet central package management (CPM) (nuget.cpm) Navigation Back Exit ``` Use your keyboard to navigate up â†‘ or down â†“, and select the Aspire upgrades option. The Upgrade Assistant prompts for final confirmation. Enter Y to continue with the upgrade: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Upgrade type aspire.latest Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type / Upgrade â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ We have gathered all required options and are ready to do the upgrade. Do you want to continue? [y/n] (y): ``` Finally, after the upgrade process is complete, the Upgrade Assistant displays the results of the upgrade process: dotnetcli Finalizing operation... Complete: 3 succeeded, 0 failed, 7 skipped. :::zone-end Update the NuGet packages To take advantage of the latest updates in your .NET Aspire solution, update all NuGet packages to version 9.0.0. :::zone pivot=""visual-studio"" :::image type=""content"" source=""media/visual-studio-update-nuget.png"" lightbox=""media/visual-studio-update-nuget.png"" alt-text=""Visual Studio: Update all NuGet packages for the .NET Aspire solution.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To update your app host project, use the following .NET CLI command to update the Aspire.Hosting.AppHost package to version 9.0.0: dotnetcli dotnet add package Aspire.Hosting.AppHost --version 9.0.0 When a package reference already exists, the dotnet add package command updates the reference to the specified version. For more information, see dotnet add package. :::zone-end With the app host project updated, your project file should look like this: ```diff ``` [!TIP] You\'ll want to also update the NuGet packages in your other projects to the latest versions.', '<2-hop>\n\nBuilt-in resource types .NET Aspire projects are made up of a set of resources. The primary base resource types in the ðŸ“¦ Aspire.Hosting.AppHost NuGet package are described in the following table: Method Resource type Description A .NET project, for example, an ASP.NET Core web app. A container image, such as a Docker image. An executable file, such as a Node.js app . A parameter resource that can be used to express external parameters . Project resources represent .NET projects that are part of the app model. When you add a project reference to the app host project, the .NET Aspire SDK generates a type in the Projects namespace for each referenced project. For more information, see .NET Aspire SDK: Project references. To add a project to the app model, use the ```csharp var builder = DistributedApplication.CreateBuilder(args); // Adds the project ""apiservice"" of type ""Projects.AspireApp_ApiService"". var apiservice = builder.AddProject Projects can be replicated and scaled out by adding multiple instances of the same project to the app model. To configure replicas, use the ```csharp var builder = DistributedApplication.CreateBuilder(args); // Adds the project ""apiservice"" of type ""Projects.AspireApp_ApiService"". var apiservice = builder.AddProject The preceding code adds three replicas of the ""apiservice"" project resource to the app model. For more information, see .NET Aspire dashboard: Resource replicas. Reference resources A reference represents a dependency between resources. For example, you can probably imagine a scenario where you a web frontend depends on a Redis cache. Consider the following example app host Program C# code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); builder.AddProject The ""webfrontend"" project resource uses Waiting for resources In some cases, you might want to wait for a resource to be ready before starting another resource. For example, you might want to wait for a database to be ready before starting an API that depends on it. To express this dependency, use the ```csharp var builder = DistributedApplication.CreateBuilder(args); var postgres = builder.AddPostgres(""postgres""); var postgresdb = postgres.AddDatabase(""postgresdb""); builder.AddProject In the preceding code, the ""apiservice"" project resource waits for the ""postgresdb"" database resource to enter the Other cases might warrant waiting for a resource to run to completion, either ```csharp var builder = DistributedApplication.CreateBuilder(args); var postgres = builder.AddPostgres(""postgres""); var postgresdb = postgres.AddDatabase(""postgresdb""); var migration = builder.AddProject builder.AddProject In the preceding code, the ""apiservice"" project resource waits for the ""migration"" project resource to run to completion before starting. The ""migration"" project resource waits for the ""postgresdb"" database resource to enter the']","To upgrade a .NET Aspire app host project to version 9.0, you need to use the Upgrade Assistant tool. This involves updating your project files to use the new .NET Aspire 9.0 SDK (Aspire.AppHost.Sdk), updating the NuGet packages to the latest versions, and adjusting your Program.cs file to accommodate new APIs and remove obsolete ones. Specifically, you should update the Aspire.Hosting.AppHost package to version 9.0.0 using the .NET CLI command: `dotnet add package Aspire.Hosting.AppHost --version 9.0.0`. The built-in resource types available in the Aspire.Hosting.AppHost NuGet package include .NET projects (such as ASP.NET Core web apps), container images (like Docker images), executable files (such as Node.js apps), and parameter resources for external parameters. These resources can be added to the app model and configured for replication and scaling, allowing for complex application architectures.",multi_hop_specific_query_synthesizer
80,How does the integration of Aspire.Hosting.Redis in .NET Aspire enhance caching capabilities in cloud-native applications?,"['<1-hop>\n\nResource types Each resource has a type field. When a deployment tool reads the manifest, it should read the type to verify whether it can correctly process the manifest. During the .NET Aspire preview period, all resource types have a v0 suffix to indicate that they\'re subject to change. As .NET Aspire approaches release a v1 suffix will be used to signify that the structure of the manifest for that resource type should be considered stable (subsequent updates increment the version number accordingly). Common resource fields The type field is the only field that is common across all resource types, however, the project.v0, container.v0, and executable.v0 resource types also share the env and bindings fields. [!NOTE] The executable.v0 resource type isn\'t fully implemented in the manifest due to its lack of utility in deployment scenarios. For more information on containerizing executables, see Dockerfile resource types. The env field type is a basic key/value mapping where the values might contain placeholder strings. Bindings are specified in the bindings field with each binding contained within its own field under the bindings JSON object. The fields omitted by the .NET Aspire manifest in the bindings node include: scheme: One of the following values tcp, udp, http, or https. protocol: One of the following values tcp or udp transport: Same as scheme, but used to disambiguate between http and http2. containerPort: Optional, if omitted defaults to port 80. The inputs field Some resources generate an inputs field. This field is used to specify input parameters for the resource. The inputs field is a JSON object where each property is an input parameter that\'s used in placeholder structure resolution. Resources that have a connectionString, for example, might use the inputs field to specify a password for the connection string: json ""connectionString"": ""Host={<resourceName>.bindings.tcp.host};Port={<resourceName>.bindings.tcp.port};Username=admin;Password={<resourceName>.inputs.password};"" The connection string placeholder references the password input parameter from the inputs field: json ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } The preceding JSON snippet shows the inputs field for a resource that has a connectionString field. The password input parameter is a string type and is marked as a secret. The default field is used to specify a default value for the input parameter. In this case, the default value is generated using the generate field, with random string of a minimum length. Built-in resources The following table is a list of resource types that are explicitly generated by .NET Aspire and extensions developed by the .NET Aspire team: Cloud-agnostic resource types These resources are available in the ðŸ“¦ Aspire.Hosting NuGet package. App model usage Manifest resource type Heading link container.v0 Container resource type PublishAsDockerFile dockerfile.v0 Dockerfile resource types value.v0 MongoDB Server resource types container.v0 MongoDB resource types value.v0 MySQL Server resource types container.v0 MySQL resource types value.v0 Postgres resource types container.v0 Postgres resource types project.v0 Project resource type container.v0 RabbitMQ resource types container.v0 Redis resource type value.v0 SQL Server resource types container.v0 SQL Server resource types Project resource type Example code: csharp var builder = DistributedApplication.CreateBuilder(args); var apiservice = builder.AddProject<Projects.AspireApp_ApiService>(""apiservice""); Example manifest: json ""apiservice"": { ""type"": ""project.v0"", ""path"": ""../AspireApp.ApiService/AspireApp.ApiService.csproj"", ""env"": { ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES"": ""true"", ""OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES"": ""true"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"" }, ""https"": { ""scheme"": ""https"", ""protocol"": ""tcp"", ""transport"": ""http"" } } } Container resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddContainer(""mycontainer"", ""myimage"") .WithEnvironment(""LOG_LEVEL"", ""WARN"") .WithHttpEndpoint(3000); ``` Example manifest: json { ""resources"": { ""mycontainer"": { ""type"": ""container.v0"", ""image"": ""myimage:latest"", ""env"": { ""LOG_LEVEL"": ""WARN"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 3000 } } } } } Dockerfile resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddNodeApp(""nodeapp"", ""../nodeapp/app.js"") .WithHttpEndpoint(hostPort: 5031, env: ""PORT"") .PublishAsDockerFile(); ``` [!TIP] The PublishAsDockerFile call is required to generate the Dockerfile resource type in the manifest, and this extension method is only available on the Example manifest: json { ""resources"": { ""nodeapp"": { ""type"": ""dockerfile.v0"", ""path"": ""../nodeapp/Dockerfile"", ""context"": ""../nodeapp"", ""env"": { ""NODE_ENV"": ""development"", ""PORT"": ""{nodeapp.bindings.http.port}"" }, ""bindings"": { ""http"": { ""scheme"": ""http"", ""protocol"": ""tcp"", ""transport"": ""http"", ""containerPort"": 5031 } } } } } Postgres resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddPostgres(""postgres1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""postgres1"": { ""type"": ""container.v0"", ""connectionString"": ""Host={postgres1.bindings.tcp.host};Port={postgres1.bindings.tcp.port};Username=postgres;Password={postgres1.inputs.password}"", ""image"": ""postgres:16.2"", ""env"": { ""POSTGRES_HOST_AUTH_METHOD"": ""scram-sha-256"", ""POSTGRES_INITDB_ARGS"": ""--auth-host=scram-sha-256 --auth-local=scram-sha-256"", ""POSTGRES_PASSWORD"": ""{postgres1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5432 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{postgres1.connectionString};Database=shipping"" } } } RabbitMQ resource types RabbitMQ is modeled as a container resource container.v0. The following sample shows how they\'re added to the app model. ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRabbitMQ(""rabbitmq1""); ``` The previous code produces the following manifest: json { ""resources"": { ""rabbitmq1"": { ""type"": ""container.v0"", ""connectionString"": ""amqp://guest:{rabbitmq1.inputs.password}@{rabbitmq1.bindings.tcp.host}:{rabbitmq1.bindings.tcp.port}"", ""image"": ""rabbitmq:3"", ""env"": { ""RABBITMQ_DEFAULT_USER"": ""guest"", ""RABBITMQ_DEFAULT_PASS"": ""{rabbitmq1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 5672 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } } } } Redis resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRedis(""redis1""); ``` Example manifest: json { ""resources"": { ""redis1"": { ""type"": ""container.v0"", ""connectionString"": ""{redis1.bindings.tcp.host}:{redis1.bindings.tcp.port}"", ""image"": ""redis:7.2.4"", ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 6379 } } } } } SQL Server resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddSqlServer(""sql1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""sql1"": { ""type"": ""container.v0"", ""connectionString"": ""Server={sql1.bindings.tcp.host},{sql1.bindings.tcp.port};User ID=sa;Password={sql1.inputs.password};TrustServerCertificate=true"", ""image"": ""mcr.microsoft.com/mssql/server:2022-latest"", ""env"": { ""ACCEPT_EULA"": ""Y"", ""MSSQL_SA_PASSWORD"": ""{sql1.inputs.password}"" }, ""bindings"": { ""tcp"": { ""scheme"": ""tcp"", ""protocol"": ""tcp"", ""transport"": ""tcp"", ""containerPort"": 1433 } }, ""inputs"": { ""password"": { ""type"": ""string"", ""secret"": true, ""default"": { ""generate"": { ""minLength"": 10 } } } } }, ""shipping"": { ""type"": ""value.v0"", ""connectionString"": ""{sql1.connectionString};Database=shipping"" } } } MongoDB resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddMongoDB(""mongodb1"") .AddDatabase(""shipping""); ``` Example manifest: json { ""resources"": { ""mongodb1"": { ""type"": ""container.v0"", ""connectionString"": ""mongodb://{mongodb1.bindings.tcp.host}:{mongodb1.bindings.tcp.port}"", ""image"": ""mongo:7.0.5"", ""bindings"": { ""tcp"": { ""scheme"":', '<2-hop>\n\ntitle: Implement caching with .NET Aspire integrations description: Learn how to connect to Redis and cache data using .NET Aspire integrations. ms.date: 11/08/2024 ms.topic: tutorial Tutorial: Implement caching with .NET Aspire integrations Cloud-native apps often require various types of scalable caching solutions to improve performance. .NET Aspire integrations simplify the process of connecting to popular caching services such as Redis. In this article, you\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET core app that is set up to use .NET Aspire. Add .NET Aspire integrations to connect to Redis and implement caching. Configure the .NET Aspire integrations to meet specific requirements. This article explores how to use two different types of ASP.NET Core caching using .NET Aspire and Redis: Output caching: A configurable, extensible caching method for storing entire HTTP responses for future requests. Distributed caching: A cache shared by multiple app servers that allows you to cache specific pieces of data. A distributed cache is typically maintained as an external service to the app servers that access it and can improve the performance and scalability of an ASP.NET Core app. [!INCLUDE aspire-prereqs] Create the project At the top of Visual Studio, navigate to File > New > Project.... In the dialog window, enter .NET Aspire into the project template search box and select .NET Aspire Starter Application. Choose Next. On the Configure your new project screen: Enter a Project name of AspireRedis. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Uncheck Use Redis for caching. You will implement your own caching setup. Select Create. Visual Studio creates a new .NET Aspire solution that consists of the following projects: AspireRedis.Web - A Blazor UI project with default .NET Aspire configurations. AspireRedis.ApiService - A Minimal API with default .NET Aspire configurations that provides the frontend with data. AspireRedis.AppHost - An orchestrator project designed to connect and configure the different projects and services of your app. AspireRedis.ServiceDefaults - A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. Configure the App Host project Add the ðŸ“¦ Aspire.Hosting.Redis NuGet package to the AspireRedis.AppHost project: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Redis PackageReference xml <PackageReference Include=""Aspire.Hosting.Redis"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Update the :::no-loc text=""Program.cs""::: file of the AspireRedis.AppHost project to match the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var redis = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code creates a local Redis container instance and configures the UI and API to use the instance automatically for both output and distributed caching. The code also configures communication between the frontend UI and the backend API using service discovery. With .NET Aspire\'s implicit service discovery, setting up and managing service connections is streamlined for developer productivity. In the context of this tutorial, the feature simplifies how you connect to Redis. Traditionally, you\'d manually specify the Redis connection string in each project\'s :::no-loc text=""appsettings.json""::: file: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } Configuring connection string with this method, while functional, requires duplicating the connection string across multiple projects, which can be cumbersome and error-prone.']","The integration of Aspire.Hosting.Redis in .NET Aspire enhances caching capabilities in cloud-native applications by simplifying the process of connecting to Redis, a popular caching service. This integration allows developers to implement both output caching and distributed caching, which are essential for improving performance and scalability. Output caching stores entire HTTP responses for future requests, while distributed caching shares specific pieces of data across multiple app servers. By adding the Aspire.Hosting.Redis NuGet package to the AspireRedis.AppHost project, developers can create a local Redis container instance that is automatically configured for both output and distributed caching. This setup streamlines service connections through .NET Aspire's implicit service discovery, enhancing developer productivity by reducing the need for manual configuration of connection strings across multiple projects.",multi_hop_specific_query_synthesizer
81,How does the Azure Developer CLI (azd) facilitate the deployment of .NET Aspire projects using Bicep?,"['<1-hop>\n\nms.topic: include The .NET Aspire Azure Storage hosting integration models the various storage resources as the following types: To access these types and APIs for expressing them, add the ðŸ“¦ Aspire.Hosting.Azure.Storage NuGet package in the app host project. .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.Storage PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.Storage"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Azure Storage resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""storage""); // An Azure Storage resource is required to add any of the following: // // - Azure Blob storage resource. // - Azure Queue storage resource. // - Azure Table storage resource. // After adding all resources, run the app... ``` When you add an AzureStorageResource to the app host, it exposes other useful APIs to add Azure Blob, Queue, and Table storage resources. In other words, you must add an AzureStorageResource before adding any of the other storage resources. [!IMPORTANT] When you call Generated provisioning Bicep If you\'re new to Bicep, it\'s a domain-specific language for defining Azure resources. With .NET Aspire, you don\'t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Storage resource, the following Bicep is generated: The preceding Bicep is a module that provisions an Azure Storage account with the following defaults: kind: The kind of storage account. The default is StorageV2. sku: The SKU of the storage account. The default is Standard_GRS. properties: The properties of the storage account: accessTier: The access tier of the storage account. The default is Hot. allowSharedKeyAccess: A boolean value that indicates whether the storage account permits requests to be authorized with the account access key. The default is false. minimumTlsVersion: The minimum supported TLS version for the storage account. The default is TLS1_2. networkAcls: The network ACLs for the storage account. The default is { defaultAction: \'Allow\' }. In addition to the storage account, it also provisions a blob container. The following role assignments are added to the storage account to grant your application access. See the built-in Azure role-based access control (Azure RBAC) roles for more information: Role / ID Description Storage Blob Data Contributor ba92f5b4-2d11-453d-a403-e96b0029c9fe Read, write, and delete Azure Storage containers and blobs. Storage Table Data Contributor 0a9a7e1f-b9d0-4cc4-a60d-0319b160aaa3 Read, write, and delete Azure Storage tables and entities. Storage Queue Data Contributor 974c5e8b-45b9-4653-ba55-5f855dd0fb88 Read, write, and delete Azure Storage queues and queue messages. The generated Bicep is a starting point and can be customized to meet your specific requirements. Customize provisioning infrastructure All .NET Aspire Azure resources are subclasses of the :::code language=""csharp"" source=""../../snippets/azure/AppHost/Program.ConfigureStorageInfra.cs"" id=""configure""::: The preceding code: Chains a call to the The infra parameter is an instance of the The provisionable resources are retrieved by calling the The single The The A tag is added to the storage account with a key of ExampleKey and a value of Example value. There are many more configuration options available to customize the Azure Storage resource. For more information, see', '<2-hop>\n\ntitle: Deploy a .NET Aspire project to Azure Container Apps using azd (in-depth guide) description: Learn how to use azd to deploy .NET Aspire projects to Azure Container Apps. ms.date: 06/14/2024 ms.custom: devx-track-extended-azdevcli Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide) The Azure Developer CLI (azd) has been extended to support deploying .NET Aspire projects. Use this guide to walk through the process of creating and deploying a .NET Aspire project to Azure Container Apps using the Azure Developer CLI. In this tutorial, you\'ll learn the following concepts: [!div class=""checklist""] Explore how azd integration works with .NET Aspire projects Provision and deploy resources on Azure for a .NET Aspire project using azd Generate Bicep infrastructure and other template files using azd [!INCLUDE aspire-prereqs] You will also need to have the Azure Developer CLI installed locally. Common install options include the following: Windows powershell winget install microsoft.azd macOS bash brew tap azure/azd && brew install azd Linux bash curl -fsSL https://aka.ms/install-azd.sh | bash How Azure Developer CLI integration works The azd init workflow provides customized support for .NET Aspire projects. The following diagram illustrates how this flow works conceptually and how azd and .NET Aspire are integrated: :::image type=""content"" source=""media/azd-internals.png"" alt-text=""Illustration of internal processing of azd when deploying .NET Aspire project.""::: When azd targets a .NET Aspire project it starts the AppHost with a special command (dotnet run --project AppHost.csproj --output-path manifest.json --publisher manifest), which produces the Aspire manifest file. The manifest file is interrogated by the azd provision sub-command logic to generate Bicep files in-memory only (by default). After generating the Bicep files, a deployment is triggered using Azure\'s ARM APIs targeting the subscription and resource group provided earlier. Once the underlying Azure resources are configured, the azd deploy sub-command logic is executed which uses the same Aspire manifest file. As part of deployment azd makes a call to dotnet publish using .NET\'s built in container publishing support to generate container images. Once azd has built the container images it pushes them to the ACR registry that was created during the provisioning phase. Finally, once the container image is in ACR, azd updates the resource using ARM to start using the new version of the container image. [!NOTE] azd also enables you to output the generated Bicep to an infra folder in your project, which you can read more about in the Generating Bicep from .NET Aspire app model section. Provision and deploy a .NET Aspire starter app The steps in this section demonstrate how to create a .NET Aspire start app and handle provisioning and deploying the app resources to Azure using azd. Create the .NET Aspire starter app Create a new .NET Aspire project using the dotnet new command. You can also create the project using Visual Studio. dotnetcli dotnet new aspire-starter --use-redis-cache -o AspireSample cd AspireSample dotnet run --project AspireSample.AppHost\\AspireSample.AppHost.csproj The previous commands create a new .NET Aspire project based on the aspire-starter template which includes a dependency on Redis cache. It runs the .NET Aspire project which verifies that everything is working correctly. [!INCLUDE init workflow] The azure.yaml file has the following contents: ```yml yaml-language-server: $schema=https://raw.githubusercontent.com/Azure/azure-dev/main/schemas/v1.0/azure.yaml.json name: AspireSample services: app: language: dotnet project: .\\AspireSample.AppHost\\AspireSample.AppHost.csproj host: containerapp ``` Resource naming [!INCLUDE azure-container-app-naming] Initial deployment In order to deploy the .NET Aspire project, authenticate to Azure AD to call the Azure resource management APIs. azdeveloper azd auth login The previous command will launch a browser to authenticate the command-line session. Once authenticated, run the following command from the AppHost project directory to provision and deploy the application. azdeveloper azd up [!IMPORTANT] To push container images to the Azure Container Registry (ACR), you need to have Microsoft.Authorization/roleAssignments/write access. This can be achieved by enabling an Admin user on the registry. Open the Azure Portal, navigate to the ACR resource / Settings / Access keys, and then select the Admin user checkbox. For more information, see Enable admin user. When prompted, select the subscription and location the resources should be deployed to. Once these options are selected the .NET Aspire project will be deployed. [!INCLUDE azd-up-output] The final line of output from the azd command is a link to the Azure Portal that shows all of the Azure resources that were deployed: :::image type=""content"" loc-scope=""azure"" source=""media/azd-azure-portal-deployed-resources.png"" lightbox=""media/azd-azure-portal-deployed-resources.png"" alt-text=""Screenshot of Azure Portal showing deployed resources.""::: Three containers are deployed within this application: webfrontend: Contains code from the web project in the starter template. apiservice: Contains code from the API service project in the starter template. cache: A Redis container image to supply a cache to the front-end. Just like in local development, the configuration of connection strings has been handled automatically. In this case, azd was responsible for interpreting the application model and translating it to the appropriate deployment steps. As an example, consider the connection string and service discovery variables that are injected into the webfrontend container so that it knows how to connect to the Redis cache and apiservice. :::image type=""content"" loc-scope=""azure"" source=""media/azd-aca-variables.png"" lightbox=""media/azd-aca-variables.png"" alt-text=""A screenshot of environment variables in the webfrontend container app.""::: For more information on how .NET Aspire projects handle connection strings and service discovery, see .NET Aspire orchestration overview.']","The Azure Developer CLI (azd) facilitates the deployment of .NET Aspire projects by generating Bicep infrastructure and other template files in-memory. When azd targets a .NET Aspire project, it starts the AppHost with a special command to produce the Aspire manifest file. This manifest file is used by the azd provision sub-command logic to generate Bicep files, which are then used to configure the underlying Azure resources. The generated Bicep is output alongside the manifest file, and azd also allows for the output of the generated Bicep to an infra folder in the project. This process streamlines the provisioning and deployment of resources on Azure for .NET Aspire projects.",multi_hop_specific_query_synthesizer
82,How can ExampleService utilize both Azure Cosmos DB and RabbitMQ integrations in a .NET Aspire application?,"['<1-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nClient integration To get started with the .NET Aspire RabbitMQ client integration, install the ðŸ“¦ Aspire.RabbitMQ.Client NuGet package in the client-consuming project, that is, the project for the application that uses the RabbitMQ client. The RabbitMQ client integration registers an IConnection instance that you can use to interact with RabbitMQ. .NET CLI dotnetcli dotnet add package Aspire.RabbitMQ.Client PackageReference xml <PackageReference Include=""Aspire.RabbitMQ.Client"" Version=""*"" /> Add RabbitMQ client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddRabbitMQClient(connectionName: ""messaging""); [!TIP] The connectionName parameter must match the name used when adding the RabbitMQ server resource in the app host project. For more information, see Add RabbitMQ server resource. You can then retrieve the IConnection instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(IConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed RabbitMQ client There might be situations where you want to register multiple IConnection instances with different connection names. To register keyed RabbitMQ clients, call the csharp builder.AddKeyedRabbitMQClient(name: ""chat""); builder.AddKeyedRabbitMQClient(name: ""queue""); Then you can retrieve the IConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] IConnection chatConnection, [FromKeyedServices(""queue"")] IConnection queueConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire RabbitMQ integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddRabbitMQClient(connectionName: ""messaging""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""messaging"": ""amqp://username:password@localhost:5672"" } } For more information on how to format this connection string, see the RabbitMQ URI specification docs. Use configuration providers The .NET Aspire RabbitMQ integration supports json { ""Aspire"": { ""RabbitMQ"": { ""Client"": { ""ConnectionString"": ""amqp://username:password@localhost:5672"", ""DisableHealthChecks"": true, ""DisableTracing"": true, ""MaxConnectRetryCount"": 2 } } } } For the complete RabbitMQ client integration JSON schema, see Aspire.RabbitMQ.Client/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<RabbitMQClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddRabbitMQClient( ""messaging"", static settings => settings.DisableHealthChecks = true); You can also set up the IConnectionFactory using the Action<IConnectionFactory> configureConnectionFactory delegate parameter of the AddRabbitMQClient method. For example to set the client provided name for connections: csharp builder.AddRabbitMQClient( ""messaging"", configureConnectionFactory: static factory => factory.ClientProvidedName = ""MyApp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire RabbitMQ integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. Observability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations might only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire RabbitMQ integration uses the following log categories: RabbitMQ.Client Tracing The .NET Aspire RabbitMQ integration emits the following tracing activities using OpenTelemetry: Aspire.RabbitMQ.Client Metrics The .NET Aspire RabbitMQ integration currently doesn\'t support metrics by default. See also Send messages with RabbitMQ in .NET Aspire RabbitMQ .NET Client docs .NET Aspire integrations .NET Aspire GitHub repo']","In a .NET Aspire application, ExampleService can utilize both Azure Cosmos DB and RabbitMQ integrations by leveraging dependency injection to retrieve the necessary client instances. For Azure Cosmos DB, the service can retrieve CosmosClient instances by registering them with specific connection names using the builder.AddAzureCosmosClient method. Similarly, for RabbitMQ, the service can retrieve IConnection instances by registering them with specific connection names using the builder.AddRabbitMQClient method. Both integrations support the use of keyed services, allowing ExampleService to access multiple instances with different connection names, such as 'mainDb' and 'loggingDb' for Cosmos DB, and 'chat' and 'queue' for RabbitMQ. This setup enables ExampleService to interact with both databases and messaging services efficiently within the application.",multi_hop_specific_query_synthesizer
83,"What are the necessary tools and environments required to work with .NET Aspire, and how do .NET 8.0 and .NET 9.0 fit into this setup?","['<1-hop>\n\n.NET Aspire dashboard Install .NET Aspire To work with .NET Aspire, you need the following installed locally: .NET 8.0 or .NET 9.0. An OCI compliant container runtime, such as: Docker Desktop or Podman. For more information, see Container runtime. An Integrated Developer Environment (IDE) or code editor, such as: Visual Studio 2022 version 17.9 or higher (Optional) Visual Studio Code (Optional) C# Dev Kit: Extension (Optional) JetBrains Rider with .NET Aspire plugin (Optional) :::zone pivot=""visual-studio"" Visual Studio 2022 17.9 or higher includes the latest .NET Aspire SDK by default when you install the Web & Cloud workload. If you have an earlier version of Visual Studio 2022, you can either upgrade to Visual Studio 2022 17.9 or you can install the .NET Aspire SDK using the following steps: To install the .NET Aspire workload in Visual Studio 2022, use the Visual Studio installer. Open the Visual Studio Installer. Select Modify next to Visual Studio 2022. Select the ASP.NET and web development workload. On the Installation details panel, select .NET Aspire SDK. Select Modify to install the .NET Aspire integration. :::image type=""content"" loc-scope=""visual-studio"" source=""media/setup-tooling/web-workload-with-aspire.png"" lightbox=""media/setup-tooling/web-workload-with-aspire.png"" alt-text=""A screenshot showing how to install the .NET Aspire workload with the Visual Studio installer.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" :::zone-end Container runtime .NET Aspire projects are designed to run in containers. You can use either Docker Desktop or Podman as your container runtime. Docker Desktop is the most common container runtime. Podman is an open-source daemonless alternative to Docker, that can build and run Open Container Initiative (OCI) containers. If your host environment has both Docker and Podman installed, .NET Aspire defaults to using Docker. You can instruct .NET Aspire to use Podman instead, by setting the DOTNET_ASPIRE_CONTAINER_RUNTIME environment variable to podman: Linux bash export DOTNET_ASPIRE_CONTAINER_RUNTIME=podman For more information, see Install Podman on Linux. Windows ```powershell ``` For more information, see Install Podman on Windows. .NET Aspire templates .NET Aspire provides a set of solution and project templates. These templates are available in your favorite .NET developer integrated environment. You can use these templates to create full .NET Aspire solutions, or add individual projects to existing .NET Aspire solutions. For more information, see .NET Aspire templates. .NET Aspire dashboard .NET Aspire templates that expose the app host project also include a useful developer dashboard that\'s used to monitor and inspect various aspects of your app, such as logs, traces, and environment configurations. This dashboard is designed to improve the local development experience and provides an overview of the overall state and structure of your app. The .NET Aspire dashboard is only visible while the app is running and starts automatically when you start the *.AppHost project. Visual Studio and Visual Studio Code launch both your app and the .NET Aspire dashboard for you automatically in your browser. If you start the app using the .NET CLI, copy and paste the dashboard URL from the output into your browser, or hold Ctrl and select the link (if your terminal supports hyperlinks). :::image type=""content"" source=""dashboard/media/explore/dotnet-run-login-url.png"" lightbox=""dashboard/media/explore/dotnet-run-login-url.png"" alt-text=""A screenshot showing how to launch the dashboard using the CLI.""::: The left navigation provides links to the different parts of the dashboard, each of which you explore in the following sections. :::image type=""content"" source=""../get-started/media/aspire-dashboard.png"" lightbox=""../get-started/media/aspire-dashboard.png"" alt-text=""A screenshot of the .NET Aspire dashboard Projects page.""::: The .NET Aspire dashboard is also available in a standalone mode. For more information, see Standalone .NET Aspire dashboard. :::zone pivot=""visual-studio"" Visual Studio tooling Visual Studio provides additional features for working with .NET Aspire integrations and the App Host orchestrator project. Not all of these features are currently available in Visual Studio Code or through the CLI. Add an integration package You add .NET Aspire integrations to your app like any other NuGet package using Visual Studio. However, Visual Studio also provides UI options to add .NET Aspire integrations directly. In Visual Studio, right select on the project you want to add an .NET Aspire integration to and select Add > .NET Aspire package.... :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-package.png"" lightbox=""../media/visual-studio-add-aspire-package.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire Component option.""::: The package manager opens with search results preconfigured (populating filter criteria) for .NET Aspire integrations, allowing you to easily browse and select the desired integration. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-comp-nuget.png"" lightbox=""../media/visual-studio-add-aspire-comp-nuget.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire integration options.""::: For more information on .NET Aspire integrations, see .NET Aspire integrations overview. Add hosting packages .NET Aspire hosting packages are used to configure various resources and dependencies an app may depend on or consume. Hosting packages are differentiated from other integration packages in that they\'re added to the *.AppHost project. To add a hosting package to your app, follow these steps: In Visual Studio, right select on the _.AppHost_ project and select Add > .NET Aspire package...*. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-hosting-package.png"" lightbox=""../media/visual-studio-add-aspire-hosting-package.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire Hosting Resource option.""::: The package manager opens with search results preconfigured (populating filter criteria) for .NET Aspire hosting packages, allowing you to easily browse and select the desired package. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-hosting-nuget.png"" lightbox=""../media/visual-studio-add-aspire-hosting-nuget.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire resource options.""::: Add orchestration projects You can add .NET Aspire orchestration projects to an existing app using the following steps: In Visual Studio, right select on an existing project and select Add > .NET Aspire Orchestrator Support... :::image type=""content"" loc-scope=""visual-studio"" source=""../media/visual-studio-add-aspire-orchestrator.png"" lightbox=""../media/visual-studio-add-aspire-orchestrator.png"" alt-text=""The Visual Studio context menu displaying the Add .NET Aspire Orchestrator Support option.""::: A dialog window opens with a summary of the .AppHost_ and _.ServiceDefaults projects that are added to your solution. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/add-orchestrator-app.png"" alt-text=""A screenshot showing the Visual Studio add .NET Aspire orchestration summary.""::: Select OK and the following changes are applied: The .AppHost_ and _.ServiceDefaults orchestration projects are added to your solution. A call to builder.AddServiceDefaults will be added to the :::no-loc text=""Program.cs""::: file of your original project. A reference to your original project will be added to the :::no-loc text=""Program.cs""::: file of the *.AppHost project. For more information on .NET Aspire orchestration,', '<2-hop>\n\ntitle: .NET Aspire tooling description: Learn about essential tooling concepts for .NET Aspire. ms.date: 01/17/2025 zone_pivot_groups: dev-environment uid: dotnet/aspire/setup-tooling .NET Aspire setup and tooling .NET Aspire includes tooling to help you create and configure cloud-native apps. The tooling includes useful starter project templates and other features to streamline getting started with .NET Aspire for Visual Studio, Visual Studio Code, and CLI workflows. In the sections ahead, you learn how to work with .NET Aspire tooling and explore the following tasks: [!div class=""checklist""] Install .NET Aspire and its dependencies Create starter project templates using Visual Studio, Visual Studio Code, or the .NET CLI Install .NET Aspire integrations Work with the .NET Aspire dashboard Install .NET Aspire To work with .NET Aspire, you need the following installed locally: .NET 8.0 or .NET 9.0. An OCI compliant container runtime, such as: Docker Desktop or Podman. For more information, see Container runtime. An Integrated Developer Environment (IDE) or code editor, such as: Visual Studio 2022 version 17.9 or higher (Optional) Visual Studio Code (Optional) C# Dev Kit: Extension (Optional) JetBrains Rider with .NET Aspire plugin (Optional) :::zone pivot=""visual-studio"" Visual Studio 2022 17.9 or higher includes the latest .NET Aspire SDK by default when you install the Web & Cloud workload. If you have an earlier version of Visual Studio 2022, you can either upgrade to Visual Studio 2022 17.9 or you can install the .NET Aspire SDK using the following steps: To install the .NET Aspire workload in Visual Studio 2022, use the Visual Studio installer. Open the Visual Studio Installer. Select Modify next to Visual Studio 2022. Select the ASP.NET and web development workload. On the Installation details panel, select .NET Aspire SDK. Select Modify to install the .NET Aspire integration. :::image type=""content"" loc-scope=""visual-studio"" source=""media/setup-tooling/web-workload-with-aspire.png"" lightbox=""media/setup-tooling/web-workload-with-aspire.png"" alt-text=""A screenshot showing how to install the .NET Aspire workload with the Visual Studio installer.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" :::zone-end Container runtime .NET Aspire projects are designed to run in containers. You can use either Docker Desktop or Podman as your container runtime. Docker Desktop is the most common container runtime. Podman is an open-source daemonless alternative to Docker, that can build and run Open Container Initiative (OCI) containers. If your host environment has both Docker and Podman installed, .NET Aspire defaults to using Docker. You can instruct .NET Aspire to use Podman instead, by setting the DOTNET_ASPIRE_CONTAINER_RUNTIME environment variable to podman: Linux bash export DOTNET_ASPIRE_CONTAINER_RUNTIME=podman For more information, see Install Podman on Linux. Windows ```powershell ``` For more information, see Install Podman on Windows.  see .NET Aspire orchestration overview. Enlist in orchestration Visual Studio provides the option to Enlist in Aspire orchestration during the new project workflow. Select this option to have Visual Studio create .AppHost_ and _.ServiceDefaults projects alongside your selected project template. :::image type=""content"" loc-scope=""visual-studio"" source=""../media/aspire-enlist-orchestration.png"" lightbox=""../media/aspire-enlist-orchestration.png"" alt-text=""A screenshot showing how to enlist in .NET Aspire orchestration.""::: Create test project When you\'re using Visual Studio, and you select the .NET Aspire Start Application template, you have the option to include a test project. This test project is an xUnit project that includes a sample test that you can use as a starting point for your tests. :::image type=""content"" source=""media/setup-tooling/create-test-projects-template.png"" lightbox=""media/setup-tooling/create-test-projects-template.png"" alt-text=""A screenshot of Visual Studio displaying the option to create a test project.""::: For more information, see Write your first .NET Aspire test. :::zone-end :::zone pivot=""vscode"" Visual Studio Code tooling You can use Visual Studio Code, with the C# Dev Kit extension, to create and develop .NET Aspire projects. To create a new .NET Aspire project in Visual Studio Code, select the Create .NET Project button in the Explorer view, then select one of the .NET Aspire templates: :::image type=""content"" source=""media/vscode-create-dotnet-aspire-proj.png"" lightbox=""media/vscode-create-dotnet-aspire-proj.png"" alt-text=""A screenshot showing how to create a new .NET Aspire project in Visual Studio Code.""::: Once you create a new .NET Aspire project, you run and debug the app, stepping through breakpoints, and inspecting variables using the Visual Studio Code debugger: :::image type=""content"" source=""media/setup-tooling/vscode-debugging.png"" lightbox=""media/setup-tooling/vscode-debugging.png"" alt-text=""A screenshot showing how to debug a .NET Aspire project in Visual Studio Code.""::: :::zone-end See also Unable to install .NET Aspire workload Use Dev Proxy with .NET Aspire project']","To work with .NET Aspire, you need to have either .NET 8.0 or .NET 9.0 installed locally. Additionally, an OCI compliant container runtime such as Docker Desktop or Podman is required, as .NET Aspire projects are designed to run in containers. For development, an Integrated Developer Environment (IDE) or code editor like Visual Studio 2022 version 17.9 or higher, Visual Studio Code, or JetBrains Rider with the .NET Aspire plugin is necessary. Visual Studio 2022 version 17.9 or higher includes the latest .NET Aspire SDK by default when you install the Web & Cloud workload. If using an earlier version, you can upgrade or install the .NET Aspire SDK separately. These tools and environments are essential for creating and configuring cloud-native applications using .NET Aspire.",multi_hop_specific_query_synthesizer
84,How do the AspNetCore.HealthChecks.CosmosDb package and the .NET Aspire Azure Cosmos DB integration work together to ensure the health of Cosmos DB instances?,"['<1-hop>\n\ntitle: .NET Aspire Cosmos DB Entity Framework Core integration description: Learn how to install and configure the .NET Aspire Cosmos DB Entity Framework Core integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-entity-framework-integration .NET Aspire Cosmos DB Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.Cosmos"" Version=""*"" /> Add Cosmos DB context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmosdb that same name should be used when calling AddCosmosDbContext. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(MyDbContext context) { // Use context... } For more information on using Entity Framework Core with Azure Cosmos DB, see the Examples for Azure Cosmos DB for NoSQL SDK for .NET. Configuration The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddCosmosDbContext: csharp builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information, see the ConnectionString documentation. Use configuration providers The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""Cosmos"": { ""DisableTracing"": true } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json. Use inline delegates You can also pass the Action<EntityFrameworkCoreCosmosSettings> configureSettings delegate to set up some or all the csharp builder.AddCosmosDbContext<MyDbContext>( ""cosmosdb"", settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn\'t implement health checks, though this may change in future releases. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","The AspNetCore.HealthChecks.CosmosDb package is used in both the .NET Aspire Cosmos DB Entity Framework Core integration and the .NET Aspire Azure Cosmos DB integration to automatically add health checks for Cosmos DB resources. These health checks verify that the Cosmos DB is running and that a connection can be established to it. This integration ensures that the application can monitor the health of Cosmos DB instances, providing observability and enhancing the reliability of cloud-native applications.",multi_hop_specific_query_synthesizer
85,How do you integrate Azure Cosmos DB with .NET Aspire and provision resources locally using the app host model?,"['<1-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: Local Azure provisioning description: Learn how to use Azure resources in your local development environment. ms.date: 12/13/2024 uid: dotnet/aspire/local-azure-provisioning Local Azure provisioning .NET Aspire simplifies local cloud-native app development with its compelling app host model. This model allows you to run your app locally with the same configuration and services as in Azure. In this article you learn how to provision Azure resources from your local development environment through the .NET Aspire app host. [!NOTE] To be clear, resources are provisioned in Azure, but the provisioning process is initiated from your local development environment. To optimize your local development experience, consider using emulator or containers when available. For more information, see Typical developer experience. Requirements This article assumes that you have an Azure account and subscription. If you don\'t have an Azure account, you can create a free one at Azure Free Account. For provisioning functionality to work correctly, you\'ll need to be authenticated with Azure. Ensure that you have the Azure Developer CLI installed. Additionally, you\'ll need to provide some configuration values so that the provisioning logic can create resources on your behalf. App host provisioning APIs The app host provides a set of APIs to express Azure resources. These APIs are available as extension methods in .NET Aspire Azure hosting libraries, extending the When the app host starts, the following provisioning logic is executed: The Azure configuration section is validated. When invalid the dashboard and app host output provides hints as to what\'s missing. For more information, see Missing configuration value hints. When valid Azure resources are conditionally provisioned: If an Azure deployment for a given resource doesn\'t exist, it\'s created and configured as a deployment. The configuration of said deployment is stamped with a checksum as a means to support only provisioning resources as necessary. Use existing Azure resources The app host automatically manages provisioning of Azure resources. The first time the app host runs, it provisions the resources specified in the app host. Subsequent runs don\'t provision the resources again unless the app host configuration changes. If you\'ve already provisioned Azure resources outside of the app host and want to use them, you can provide the connection string with the ```csharp // Service registration var secrets = builder.ExecutionContext.IsPublishMode ? builder.AddAzureKeyVault(""secrets"") : builder.AddConnectionString(""secrets""); // Service consumption builder.AddProject The preceding code snippet shows how to add an Azure Key Vault to the app host. The Alternatively, for some Azure resources, you can opt-in to running them as an emulator with the RunAsEmulator API. This API is available for Azure Cosmos DB and Azure Storage integrations. For example, to run Azure Cosmos DB as an emulator, you can use the following code snippet: csharp var cosmos = builder.AddAzureCosmosDB(""cosmos"") .RunAsEmulator(); The']","To integrate Azure Cosmos DB with .NET Aspire, you need to install the Aspire.Microsoft.Azure.Cosmos NuGet package in your client-consuming project. This integration allows you to connect to existing Cosmos DB instances or create new ones using the Azure Cosmos DB emulator. You can configure the connection using a connection string or inline delegates to set options like disabling tracing. Health checks are automatically added to ensure the Cosmos DB resource is running. For local provisioning of Azure resources, including Cosmos DB, the .NET Aspire app host model allows you to initiate the provisioning process from your local development environment. This model uses APIs available in .NET Aspire Azure hosting libraries to manage and provision resources, ensuring they are only created when necessary. You can also use the RunAsEmulator API to run Azure Cosmos DB as an emulator locally.",multi_hop_specific_query_synthesizer
86,"How do you use Azure CLI to set up Azure SQL and Azure Service Bus for a .NET Aspire project, and what are the benefits of using these integrations?","['<1-hop>\n\nAzure-specific resource types The following resources are available in the ðŸ“¦ Aspire.Hosting.Azure NuGet package. App Model usage Manifest resource type Heading link azure.bicep.v0 Azure App Configuration resource types azure.bicep.v0 Azure Key Vault resource type AddAzureRedis azure.bicep.v0 Azure Redis resource types azure.bicep.v0 Azure Service Bus resource type AddAzureSqlServer(...) azure.bicep.v0 Azure SQL resource types AddAzureSqlServer(...).AddDatabase(...) value.v0 Azure SQL resource types AddAzurePostgresFlexibleServer(...) azure.bicep.v0 Azure Postgres resource types AddAzurePostgresFlexibleServer(...).AddDatabase(...) value.v0 Azure Postgres resource types azure.storage.v0 Azure Storage resource types value.v0 Azure Storage resource types value.v0 Azure Storage resource types value.v0 Azure Storage resource types Azure Key Vault resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureKeyVault(""keyvault1""); ``` Example manifest: json { ""resources"": { ""keyvault1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{keyvault1.outputs.vaultUri}"", ""path"": ""aspire.hosting.azure.bicep.keyvault.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""vaultName"": ""keyvault1"" } } } } Azure Service Bus resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureServiceBus(""sb1"") .AddTopic(""topic1"", []) .AddTopic(""topic2"", []) .AddQueue(""queue1"") .AddQueue(""queue2""); ``` Example manifest: json { ""resources"": { ""sb1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{sb1.outputs.serviceBusEndpoint}"", ""path"": ""aspire.hosting.azure.bicep.servicebus.bicep"", ""params"": { ""serviceBusNamespaceName"": ""sb1"", ""principalId"": """", ""principalType"": """", ""queues"": [ ""queue1"", ""queue2"" ], ""topics"": [ { ""name"": ""topic1"", ""subscriptions"": [] }, { ""name"": ""topic2"", ""subscriptions"": [] } ] } } } } Azure Storage resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.AddAzureStorage(""images""); storage.AddBlobs(""blobs""); storage.AddQueues(""queues""); storage.AddTables(""tables""); ``` Example manifest: json { ""resources"": { ""images"": { ""type"": ""azure.bicep.v0"", ""path"": ""aspire.hosting.azure.bicep.storage.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""storageName"": ""images"" } }, ""blobs"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.blobEndpoint}"" }, ""queues"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.queueEndpoint}"" }, ""tables"": { ""type"": ""value.v0"", ""connectionString"": ""{images.outputs.tableEndpoint}"" } } } Azure Redis resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureRedis(""azredis1""); ``` Example manifest: json { ""resources"": { ""azredis"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{azredis.outputs.connectionString}"", ""path"": ""azredis.module.bicep"", ""params"": { ""principalId"": """", ""principalName"": """" } } } } Azure App Configuration resource type Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureAppConfiguration(""appconfig1""); ``` Example manifest: json { ""resources"": { ""appconfig1"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{appconfig1.outputs.appConfigEndpoint}"", ""path"": ""aspire.hosting.azure.bicep.appconfig.bicep"", ""params"": { ""configName"": ""appconfig1"", ""principalId"": """", ""principalType"": """" } } } } Azure SQL resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureSqlServer(""sql"") .AddDatabase(""inventory""); ``` Example manifest: json { ""resources"": { ""sql"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""Server=tcp:{sql.outputs.sqlServerFqdn},1433;Encrypt=True;Authentication=\\u0022Active Directory Default\\u0022"", ""path"": ""sql.module.bicep"", ""params"": { ""principalId"": """", ""principalName"": """" } }, ""inventory"": { ""type"": ""value.v0"", ""connectionString"": ""{sql.connectionString};Database=inventory"" } } } Azure Postgres resource types Example code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzurePostgresFlexibleServer(""postgres"") .AddDatabase(""db""); ``` Example manifest: json { ""resources"": { ""postgres"": { ""type"": ""azure.bicep.v0"", ""connectionString"": ""{postgres.outputs.connectionString}"", ""path"": ""postgres.module.bicep"", ""params"": { ""principalId"": """", ""principalType"": """", ""principalName"": """" } }, ""db"": { ""type"": ""value.v0"", ""connectionString"": ""{postgres.connectionString};Database=db"" } } } Resource types supported in the Azure Developer CLI The Azure Developer CLI (azd) is a tool that can be used to deploy .NET Aspire projects to Azure Container Apps. With the azure.bicep.v0 resource type, cloud-agnostic resource container types can be mapped to Azure-specific resources. The following table lists the resource types that are supported in the Azure Developer CLI: Name Cloud-agnostic API Azure API Redis AddAzureRedis Postgres AddAzurePostgresFlexibleServer SQL Server AddAzureSqlServer When resources as configured as Azure resources, the azure.bicep.v0 resource type is generated in the manifest. For more information, see Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide). See also .NET Aspire overview .NET Aspire orchestration overview .NET Aspire integrations overview Service discovery in .NET Aspire', '<2-hop>\n\ntitle: Use .NET Aspire messaging integrations in ASP.NET Core description: Learn how to connect an ASP.NET Core app to messaging services using .NET Aspire integrations. ms.date: 08/12/2024 ms.topic: tutorial zone_pivot_groups: dev-environment Tutorial: Use .NET Aspire messaging integrations in ASP.NET Core Cloud-native apps often require scalable messaging solutions that provide capabilities such as messaging queues and topics and subscriptions. .NET Aspire integrations simplify the process of connecting to various messaging providers, such as Azure Service Bus. In this tutorial, you\'ll create an ASP.NET Core app that uses .NET Aspire integrations to connect to Azure Service Bus to create a notification system. Submitted messages will be sent to a Service Bus topic for consumption by subscribers. You\'ll learn how to: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire integrations Add an .NET Aspire integration to connect to Azure Service Bus Configure and use .NET Aspire integration features to send and receive data [!INCLUDE aspire-prereqs] In addition to the preceding prerequisites, you also need to install the Azure CLI. To install the Azure CLI, follow the instructions in the Azure CLI installation guide. Set up the Azure Service Bus account For this tutorial, you\'ll need access to an Azure Service Bus namespace with a topic and subscription configured. Use one of the following options to set up the require resources: Azure portal: Create a service bus account with a topic and subscription. Alternatively: Azure CLI: Run the following commands in the Azure CLI or CloudShell to set up the required Azure Service Bus resources: azurecli-interactive az group create -n <your-resource-group-name> --location eastus az servicebus namespace create -g <your-resource-group-name> --name <your-namespace-name> --location eastus az servicebus topic create -g <your-resource-group-name> --namespace-name <your-namespace-name> --name notifications az servicebus topic subscription create -g <your-resource-group-name> --namespace-name <your-namespace-name> --topic-name notifications --name mobile [!NOTE] Replace the your-resource-group-name and your-namespace-name placeholders with your own values. Service Bus namespace names must be globally unique across Azure. Azure authentication This quickstart can be completed using either passwordless authentication or a connection string. Passwordless connections use Azure Active Directory and role-based access control (RBAC) to connect to a Service Bus namespace. You don\'t need to worry about having hard-coded connection string in your code, a configuration file, or in secure storage such as Azure Key Vault. You can also use a connection string to connect to a Service Bus namespace, but the passwordless approach is recommended for real-world applications and production environments. For more information, read about Authentication and authorization or visit the passwordless overview page. Passwordless (Recommended) On your Service Bus namespace, assign the following role to the user account you logged into Visual Studio or the Azure CLI with: Service Bus Data Owner: Assign an Azure RBAC role Connection string Retrieve the connection string for your Service Bus namespace from the Shared access policies menu in the Azure portal. Keep it somewhere safe for use during the quickstart. :::image type=""content"" source=""../media/aspire-service-bus.png"" alt-text=""Screenshot of Aspire service bus connection string menu."":::']","To set up Azure SQL and Azure Service Bus for a .NET Aspire project using Azure CLI, you can follow these steps: For Azure SQL, you can use the command `AddAzureSqlServer(...)` to add an Azure SQL Server and then use `.AddDatabase(...)` to add a database, as shown in the example code: `builder.AddAzureSqlServer(""sql"").AddDatabase(""inventory"");`. For Azure Service Bus, you can create a Service Bus namespace, topic, and subscription using Azure CLI commands such as `az servicebus namespace create`, `az servicebus topic create`, and `az servicebus topic subscription create`. The benefits of using these integrations include the ability to connect an ASP.NET Core app to scalable messaging solutions like Azure Service Bus, which provides capabilities such as messaging queues, topics, and subscriptions. This setup allows for the creation of a notification system where messages are sent to a Service Bus topic for consumption by subscribers. Additionally, using passwordless authentication with Azure Active Directory and role-based access control (RBAC) enhances security by avoiding hard-coded connection strings.",multi_hop_specific_query_synthesizer
87,"How does the Aspire.Hosting.AppHost facilitate orchestration in .NET Aspire projects, and what role does Aspire.Hosting.NodeJS play in integrating Node.js applications?","[""<1-hop>\n\ntitle: Orchestrate Node.js apps in .NET Aspire description: Learn how to integrate Node.js and npm apps into a .NET Aspire App Host project. ms.date: 11/20/2024 Orchestrate Node.js apps in .NET Aspire In this article, you learn how to use Node.js and Node Package Manager (npm) apps in a .NET Aspire project. The sample app in this article demonstrates Angular, React, and Vue client experiences. The following .NET Aspire APIs exist to support these scenariosâ€”and they're part of the Aspire.Hosting.NodeJS NuGet package: Node.js: npm apps: The difference between these two APIs is that the former is used to host Node.js apps, while the latter is used to host apps that execute from a package.json file's scripts sectionâ€”and the corresponding npm run <script-name> command. [!TIP] The sample source code for this article is available on GitHub, and there are details available on the Code Samples: .NET Aspire with Angular, React and Vue page. [!IMPORTANT] While this article is focused on Single-Page App (SPA) frontend bits, there's an additional Node.js sample available on the Code Samples: .NET Aspire Node.js sample page, that demonstrates how to use Node.js as a server app with express. [!INCLUDE aspire-prereqs] Additionally, you need to install Node.js on your machine. The sample app in this article was built with Node.js version 20.12.2 and npm version 10.5.1. To verify your Node.js and npm versions, run the following commands: nodejs node --version nodejs npm --version To download Node.js (including npm), see the Node.js download page. Clone sample source code To clone the sample source code from GitHub, run the following command: bash git clone https://github.com/dotnet/aspire-samples.git After cloning the repository, navigate to the samples/AspireWithJavaScript folder: bash cd samples/AspireWithJavaScript From this directory, there are six child directories described in the following list: AspireJavaScript.Angular: An Angular app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.AppHost: A .NET Aspire project that orchestrates the other apps in this sample. For more information, see .NET Aspire orchestration overview. AspireJavaScript.MinimalApi: An HTTP API that returns randomly generated weather forecast data. AspireJavaScript.React: A React app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.ServiceDefaults: The default shared project for .NET Aspire projects. For more information, see .NET Aspire service defaults. AspireJavaScript.Vue: A Vue app that consumes the weather forecast API and displays the data in a table. Install client dependencies The sample app demonstrates how to use JavaScript client apps that are built on top of Node.js. Each client app was written either using a npm create template command or manually. The following table lists the template commands used to create each client app, along with the default port: App type Create template command Default port Angular npm create @angular@latest 4200 React Didn't use a template. PORT env var Vue npm create vue@latest 5173 [!TIP] You don't need to run any of these commands, since the sample app already includes the clients. Instead, this is a point of reference from which the clients were created. For more information, see npm-init. To run the app, you first need to install the dependencies for each client. To do so, navigate to each client folder and run npm install (or the install alias npm i) commands. Install Angular dependencies nodejs npm i ./AspireJavaScript.Angular/ For more information on the Angular app, see explore the Angular client. Install React dependencies nodejs npm i ./AspireJavaScript.React/ For more information on the React app, see explore the React client. Install Vue dependencies nodejs npm i ./AspireJavaScript.Vue/ For more information on the Vue app, see explore the Vue client."", '<2-hop>\n\ntitle: .NET Aspire orchestration overview description: Learn the fundamental concepts of .NET Aspire orchestration and explore the various APIs for adding resources and expressing dependencies. ms.date: 12/13/2024 ms.topic: overview uid: dotnet/aspire/app-host .NET Aspire orchestration overview .NET Aspire provides APIs for expressing resources and dependencies within your distributed application. In addition to these APIs, there\'s tooling that enables several compelling scenarios. The orchestrator is intended for local development purposes and isn\'t supported in production environments. Before continuing, consider some common terminology used in .NET Aspire: App model: A collection of resources that make up your distributed application ( App host/Orchestrator project: The .NET project that orchestrates the app model, named with the *.AppHost suffix (by convention). Resource: A resource is a dependent part of an application, such as a .NET project, container, executable, database, cache, or cloud service. It represents any part of the application that can be managed or referenced. Integration: An integration is a NuGet package for either the app host that models a resource or a package that configures a client for use in a consuming app. For more information, see .NET Aspire integrations overview. Reference: A reference defines a connection between resources, expressed as a dependency using the [!NOTE] .NET Aspire\'s orchestration is designed to enhance your local development experience by simplifying the management of your cloud-native app\'s configuration and interconnections. While it\'s an invaluable tool for development, it\'s not intended to replace production environment systems like Kubernetes, which are specifically designed to excel in that context. Define the app model .NET Aspire empowers you to seamlessly build, provision, deploy, configure, test, run, and observe your distributed applications. All of these capabilities are achieved through the utilization of an app model that outlines the resources in your .NET Aspire solution and their relationships. These resources encompass projects, executables, containers, and external services and cloud resources that your app depends on. Within every .NET Aspire solution, there\'s a designated App host project, where the app model is precisely defined using methods available on the ```csharp // Create a new app model builder var builder = DistributedApplication.CreateBuilder(args); // TODO: // Add resources to the app model // Express dependencies between resources builder.Build().Run(); ``` App host project The app host project handles running all of the projects that are part of the .NET Aspire project. In other words, it\'s responsible for orchestrating all apps within the app model. The project itself is a .NET executable project that references the ðŸ“¦ Aspire.Hosting.AppHost NuGet package, sets the IsAspireHost property to true, and references the .NET Aspire SDK: ```xml <Sdk Name=""Aspire.AppHost.Sdk"" Version=""9.0.0"" /> <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net9.0</TargetFramework> <IsAspireHost>true</IsAspireHost> <!-- Omitted for brevity --> </PropertyGroup> <ItemGroup> <PackageReference Include=""Aspire.Hosting.AppHost"" Version=""9.0.0"" /> </ItemGroup> <!-- Omitted for brevity --> ``` The following code describes an app host Program with two project references and a Redis cache: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code: Creates a new app model builder using the Adds a Redis cache resource named ""cache"" using the Adds a project resource named ""apiservice"" using the Adds a project resource named ""webfrontend"" using the Specifies that the project has external HTTP endpoints using the Adds a reference to the cache resource and waits for it to be ready using the Adds a reference to the apiservice resource and waits for it to be ready using the Builds and runs the app model using the The example code uses the .NET Aspire Redis hosting integration. To help visualize the relationship between the app host project and the resources it describes, consider the following diagram: :::image type=""content"" source=""../media/app-host-resource-diagram.png"" lightbox=""../media/app-host-resource-diagram.png"" alt-text=""The relationship between the projects in the .NET Aspire Starter Application template.""::: Each resource must be uniquely named. This diagram shows each resource and the relationships between them. The container resource is named ""cache"" and the project resources are named ""apiservice"" and ""webfrontend"". The web frontend project references the cache and API service projects. When you\'re expressing references in this way, the web frontend project is saying that it depends on these two resources, the ""cache"" and ""apiservice"" respectively.']","The Aspire.Hosting.AppHost facilitates orchestration in .NET Aspire projects by serving as the app host project that orchestrates all apps within the app model. It is a .NET executable project that references the Aspire.Hosting.AppHost NuGet package and sets the IsAspireHost property to true, allowing it to manage resources such as projects, containers, and external services. This orchestration is designed to enhance local development by simplifying the management of cloud-native app configurations and interconnections. On the other hand, Aspire.Hosting.NodeJS plays a role in integrating Node.js applications by providing APIs that support hosting Node.js apps and executing npm scripts within a .NET Aspire project. This integration allows for the orchestration of Node.js apps alongside other resources in the .NET Aspire environment, enabling seamless development of distributed applications that include both .NET and Node.js components.",multi_hop_specific_query_synthesizer
88,How does the .NET Aspire platform facilitate the integration of NodeJS and MongoDB for cloud-native applications?,"['<1-hop>\n\ntitle: .NET Aspire MongoDB database integration description: Learn how to use the .NET Aspire MongoDB database integration, which includes both hosting and client integrations. ms.date: 12/03/2024 uid: database/mongodb-integration .NET Aspire MongoDB database integration [!INCLUDE includes-hosting-and-client] MongoDB is a NoSQL database that provides high performance, high availability, and easy scalability. The .NET Aspire MongoDB integration enables you to connect to existing MongoDB instances (including MongoDB Atlas) or create new instances from .NET with the docker.io/library/mongo container image Hosting integration The MongoDB server hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.MongoDB PackageReference xml <PackageReference Include=""Aspire.Hosting.MongoDB"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications.', '<2-hop>\n\nExplore the Angular client There are several key modifications from the original Angular template. The first is the addition of a proxy.conf.js file. This file is used to proxy requests from the Angular client to the ""weatherapi"" service. :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/proxy.conf.js""::: The .NET Aspire app host sets the services__weatherapi__http__0 environment variable, which is used to resolve the ""weatherapi"" service endpoint. The preceding configuration proxies HTTP requests that start with /api to the target URL specified in the environment variable. The second update is to the package.json file. This file is used to configure the Angular client to run on a different port than the default port. This is achieved by using the PORT environment variable, and the run-script-os npm package to set the port. :::code language=""json"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/package.json""::: The scripts section of the package.json file is used to define the start script. This script is used by the npm start command to start the Angular client app. The start script is configured to use the run-script-os package to set the port, which delegates to the ng serve command passing the appropriate --port switch based on the OS-appropriate syntax. In order to make HTTP calls to the ""weatherapi"" service, the Angular client app needs to be configured to provide the Angular HttpClient for dependency injection. This is achieved by using the provideHttpClient helper function while configuring the application in the app.config.ts file. :::code language=""typescript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/src/app/app.config.ts""::: Finally, the Angular client app needs to call the /api/WeatherForecast endpoint to retrieve the weather forecast data. There are several HTML, CSS, and TypeScript updates, all of which are made to the following files: app.component.css: Update the CSS to style the table. app.component.html: Update the HTML to display the weather forecast data in a table. app.component.ts: Update the TypeScript to call the /api/WeatherForecast endpoint and display the data in the table. :::code language=""typescript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/src/app/app.component.ts""::: Angular app running To visualize the Angular client app, navigate to the ""angular"" endpoint in the .NET Aspire dashboard. The following image depicts the Angular client app: :::image type=""content"" source=""media/angular-app.png"" lightbox=""media/angular-app.png"" alt-text=""Angular client app with fake forecast weather data displayed as a table.""::: Explore the React client The React app wasn\'t written using a template, and instead was written manually. The complete source code can be found in the dotnet/aspire-samples repository. Some of the key points of interest are found in the src/App.js file: :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.React/src/components/App.js""::: The App function is the entry point for the React client app. It uses the useState and useEffect hooks to manage the state of the weather forecast data. The fetch API is used to make an HTTP request to the /api/WeatherForecast endpoint. The response is then converted to JSON and set as the state of the weather forecast data. :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.React/webpack.config.js""::: The preceding code defines the module.exports as follows: The entry property is set to the src/index.js file. The devServer relies on a proxy to forward requests to the ""weatherapi"" service, sets the port to the PORT environment variable, and allows all hosts. The output results in a dist folder with a bundle.js file. The plugins set the src/index.html file as the template, and expose the favicon.ico file. The final updates are to the following files: App.css: Update the CSS to style the table. App.js: Update the JavaScript to call the /api/WeatherForecast endpoint and display the data in the table. React app running To visualize the React client app, navigate to the ""react"" endpoint in the .NET Aspire dashboard. The following image depicts the React client app: :::image type=""content"" source=""media/react-app.png"" lightbox=""media/react-app.png"" alt-text=""React client app with fake forecast weather data displayed as a table.""::: Explore the Vue client There are several key modifications from the original Vue template. The primary updates were the addition of the fetch call in the TheWelcome.vue file to retrieve the weather forecast data from the /api/WeatherForecast endpoint. The following code snippet demonstrates the fetch call: :::code language=""html"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Vue/src/components/TheWelcome.vue""::: As the TheWelcome integration is mounted, it calls the /api/weatherforecast endpoint to retrieve the weather forecast data. The response is then set as the forecasts data property. To set the server port, the Vue client app uses the PORT environment variable. This is achieved by updating the vite.config.ts file: :::code language=""typescript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Vue/vite.config.ts""::: Additionally, the Vite config specifies the server.proxy property to forward requests to the ""weatherapi"" service. This is achieved by using the services__weatherapi__http__0 environment variable, which is set by the .NET Aspire app host. The final update from the template is made to the TheWelcome.vue file. This file calls the /api/WeatherForecast endpoint to retrieve the weather forecast data, and displays the data in a table. It includes CSS, HTML, and TypeScript updates. Vue app running To visualize the Vue client app, navigate to the ""vue"" endpoint in the .NET Aspire dashboard. The following image depicts the Vue client app: :::image type=""content"" source=""media/vue-app.png"" lightbox=""media/vue-app.png"" alt-text=""Vue client app with fake forecast weather data displayed as a table.""::: Deployment considerations The sample source code for this article is designed to run locally. Each client app deploys as a container image. The Dockerfile for each client app is used to build the container image. Each Dockerfile is identical, using a multistage build to create a production-ready container image. :::code language=""dockerfile"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/Dockerfile""::: The client apps are currently configured to run as true SPA apps, and aren\'t configured to run in a server-side rendered (SSR) mode. They sit behind nginx, which is used to serve the static files. They use a default.conf.template file to configure nginx to proxy requests to the client app. :::code language=""nginx"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/default.conf.template""::: Node.js server app considerations While this article focuses on client apps, you might have scenarios where you need to host a Node.js server app. The same semantics are required to host a Node.js server app as a SPA client app. The .NET Aspire app host requires a package reference to the Aspire.Hosting.NodeJS NuGet package and the code needs to call either AddNodeApp or AddNpmApp. These APIs are useful for adding existing JavaScript apps to the .NET Aspire app host. When configuring secrets']","The .NET Aspire platform facilitates the integration of NodeJS and MongoDB for cloud-native applications by providing specific hosting packages and integration tools. For MongoDB, the platform offers the Aspire.Hosting.MongoDB package, which allows developers to connect to existing MongoDB instances or create new ones using the docker.io/library/mongo container image. This integration supports high performance, availability, and scalability. For NodeJS, the platform provides the Aspire.Hosting.NodeJS NuGet package, which enables the hosting of Node.js server applications. Developers can use APIs like AddNodeApp or AddNpmApp to add existing JavaScript apps to the .NET Aspire app host, ensuring seamless orchestration and deployment of distributed applications.",multi_hop_specific_query_synthesizer
89,How does the .NET Aspire Cosmos DB Entity Framework Core integration utilize MicrosoftDocs resources to enhance productivity and observability in cloud-native applications?,"['<1-hop>\n\ntitle: .NET Aspire Cosmos DB Entity Framework Core integration description: Learn how to install and configure the .NET Aspire Cosmos DB Entity Framework Core integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-entity-framework-integration .NET Aspire Cosmos DB Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.Cosmos"" Version=""*"" /> Add Cosmos DB context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmosdb that same name should be used when calling AddCosmosDbContext. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(MyDbContext context) { // Use context... } For more information on using Entity Framework Core with Azure Cosmos DB, see the Examples for Azure Cosmos DB for NoSQL SDK for .NET. Configuration The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddCosmosDbContext: csharp builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information, see the ConnectionString documentation. Use configuration providers The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""Cosmos"": { ""DisableTracing"": true } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json. Use inline delegates You can also pass the Action<EntityFrameworkCoreCosmosSettings> configureSettings delegate to set up some or all the csharp builder.AddCosmosDbContext<MyDbContext>( ""cosmosdb"", settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn\'t implement health checks, though this may change in future releases. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: Apply EF Core migrations in .NET Aspire description: Learn about how to to apply Entity Framework Core migrations in .NET Aspire ms.date: 07/31/2024 ms.topic: how-to Apply Entity Framework Core migrations in .NET Aspire Since .NET Aspire projects use a containerized architecture, databases are ephemeral and can be recreated at any time. Entity Framework Core (EF Core) uses a feature called migrations to create and update database schemas. Since databases are recreated when the app starts, you need to apply migrations to initialize the database schema each time your app starts. This is accomplished by registering a migration service project in your app that runs migrations during startup. In this tutorial, you learn how to configure .NET Aspire projects to run EF Core migrations during app startup. [!INCLUDE aspire-prereqs] Obtain the starter app This tutorial uses a sample app that demonstrates how to apply EF Core migrations in .NET Aspire. Use Visual Studio to clone the sample app from GitHub or use the following command: bash git clone https://github.com/MicrosoftDocs/aspire-docs-samples/ The sample app is in the SupportTicketApi folder. Open the solution in Visual Studio or VS Code and take a moment to review the sample app and make sure it runs before proceeding. The sample app is a rudimentary support ticket API, and it contains the following projects: SupportTicketApi.Api: The ASP.NET Core project that hosts the API. SupportTicketApi.Data: Contains the EF Core contexts and models. SupportTicketApi.AppHost: Contains the .NET Aspire app host and configuration. SupportTicketApi.ServiceDefaults: Contains the default service configurations. Run the app to ensure it works as expected. From the .NET Aspire dashboard, select the https Swagger endpoint and test the API\'s GET /api/SupportTickets endpoint by expanding the operation and selecting Try it out. Select Execute to send the request and view the response: json [ { ""id"": 1, ""title"": ""Initial Ticket"", ""description"": ""Test ticket, please ignore."" } ] Create migrations Start by creating some migrations to apply. Open a terminal (Ctrl+` in Visual Studio). Set :::no-loc text=""SupportTicketApi\\SupportTicketApi.Api""::: as the current directory. Use the dotnet ef command-line tool to create a new migration to capture the initial state of the database schema: dotnetcli dotnet ef migrations add InitialCreate --project ..\\SupportTicketApi.Data\\SupportTicketApi.Data.csproj The proceeding command: Runs EF Core migration command-line tool in the SupportTicketApi.Api directory. dotnet ef is run in this location because the API service is where the DB context is used. Creates a migration named InitialCreate. Creates the migration in the in the Migrations folder in the SupportTicketApi.Data project. Modify the model so that it includes a new property. Open :::no-loc text=""SupportTicketApi.Data\\Models\\SupportTicket.cs""::: and add a new property to the SupportTicket class: :::code source=""~/aspire-docs-samples-solution/SupportTicketApi/SupportTicketApi.Data/Models/SupportTicket.cs"" range=""5-13"" highlight=""8"" ::: Create another new migration to capture the changes to the model: dotnetcli dotnet ef migrations add AddCompleted --project ..\\SupportTicketApi.Data\\SupportTicketApi.Data.csproj Now you\'ve got some migrations to apply. Next, you\'ll create a migration service that applies these migrations during app startup. Create the migration service To run the migrations at startup, you need to create a service that applies the migrations. Add a new Worker Service project to the solution. If using Visual Studio, right-click the solution in Solution Explorer and select :::no-loc text=""Add""::: > :::no-loc text=""New Project"":::. Select :::no-loc text=""Worker Service""::: and name the project :::no-loc text=""SupportTicketApi.MigrationService"":::. If using the command line, use the following commands from the solution directory: dotnetcli dotnet new worker -n SupportTicketApi.MigrationService dotnet sln add SupportTicketApi.MigrationService Add the :::no-loc text=""SupportTicketApi.Data""::: and :::no-loc text=""SupportTicketApi.ServiceDefaults""::: project references to the :::no-loc text=""SupportTicketApi.MigrationService""::: project using Visual Studio or the command line: dotnetcli dotnet add SupportTicketApi.MigrationService reference SupportTicketApi.Data dotnet add SupportTicketApi.MigrationService reference SupportTicketApi.ServiceDefaults Add the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package reference to the :::no-loc text=""SupportTicketApi.MigrationService""::: project using Visual Studio or the command line: dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer Add the highlighted lines to the :::no-loc text=""Program.cs""::: file in the :::no-loc text=""SupportTicketApi.MigrationService""::: project: :::code source=""~/aspire-docs-samples-solution/SupportTicketApi/SupportTicketApi.MigrationService/Program.cs"" highlight=""1,6,9-12"" ::: In the preceding code: The AddServiceDefaults extension method adds service defaults functionality. The AddOpenTelemetry extension method configures OpenTelemetry functionality. The AddSqlServerDbContext extension method adds the TicketContext service to the service collection. This service is used to run migrations and seed the database. Replace the contents of the :::no-loc text=""Worker.cs""::: file in the :::no-loc text=""SupportTicketApi.MigrationService""::: project with the following code: :::code source=""~/aspire-docs-samples-solution/SupportTicketApi/SupportTicketApi.MigrationService/Worker.cs"" ::: In the preceding code: The ExecuteAsync method is called when the worker starts. It in turn performs the following steps: Gets a reference to the TicketContext service from the service provider. Calls EnsureDatabaseAsync to create the database if it doesn\'t exist. Calls RunMigrationAsync to apply any pending migrations. Calls SeedDataAsync to seed the database with initial data. Stops the worker with StopApplication. The EnsureDatabaseAsync, RunMigrationAsync, and SeedDataAsync methods all encapsulate their respective database operations using execution strategies to handle transient errors that may occur when interacting with the database. To learn more about execution strategies, see Connection Resiliency. Add the migration service to the orchestrator The migration service is created, but it needs to be added to the .NET Aspire app host so that it runs when the app starts. In the :::no-loc text=""SupportTicketApi.AppHost""::: project, open the :::no-loc text=""Program.cs""::: file. Add the following highlighted code to the ConfigureServices method: :::code source=""~/aspire-docs-samples-solution/SupportTicketApi/SupportTicketApi.AppHost/Program.cs"" highlight=""9-10"" ::: This enlists the :::no-loc text=""SupportTicketApi.MigrationService""::: project as a service in the .NET Aspire app host. [!IMPORTANT] If you are using Visual Studio, and you selected the :::no-loc text=""Enlist in Aspire orchestration""::: option when creating the Worker Service project, similar code is added automatically with the service name supportticketapi-migrationservice. Replace that code with the preceding code. Remove existing seeding code Since the migration service seeds the database, you should remove the existing data seeding code from the API project. In the :::no-loc text=""SupportTicketApi.Api""::: project, open the :::no-loc text=""Program.cs""::: file. Delete the highlighted lines. :::code source=""~/aspire-docs-samples-main/SupportTicketApi/SupportTicketApi.Api/Program.cs"" range=""20-36"" highlight=""6-16"" :::']","The .NET Aspire Cosmos DB Entity Framework Core integration utilizes MicrosoftDocs resources by providing detailed documentation and tutorials on how to install and configure the integration to connect to existing Cosmos DB instances or create new ones using the Azure Cosmos DB emulator. This integration enhances productivity by enabling developers to easily set up and manage their database connections within .NET applications. Additionally, the integration supports health checks and observability features, such as the use of the AspNetCore.HealthChecks.CosmosDb NuGet package, which automatically adds a health check for the Cosmos DB resource to ensure it is running and a connection can be established. Furthermore, the integration supports configuration options like using connection strings and configuration providers, which are well-documented in MicrosoftDocs, to tailor the setup according to project requirements. These resources collectively contribute to improved productivity and observability in cloud-native applications.",multi_hop_specific_query_synthesizer
90,How can .NET Aspire be used to orchestrate Node.js applications and deploy an ASP.NET Core app with SQL Server to Azure?,"[""<1-hop>\n\ntitle: Orchestrate Node.js apps in .NET Aspire description: Learn how to integrate Node.js and npm apps into a .NET Aspire App Host project. ms.date: 11/20/2024 Orchestrate Node.js apps in .NET Aspire In this article, you learn how to use Node.js and Node Package Manager (npm) apps in a .NET Aspire project. The sample app in this article demonstrates Angular, React, and Vue client experiences. The following .NET Aspire APIs exist to support these scenariosâ€”and they're part of the Aspire.Hosting.NodeJS NuGet package: Node.js: npm apps: The difference between these two APIs is that the former is used to host Node.js apps, while the latter is used to host apps that execute from a package.json file's scripts sectionâ€”and the corresponding npm run <script-name> command. [!TIP] The sample source code for this article is available on GitHub, and there are details available on the Code Samples: .NET Aspire with Angular, React and Vue page. [!IMPORTANT] While this article is focused on Single-Page App (SPA) frontend bits, there's an additional Node.js sample available on the Code Samples: .NET Aspire Node.js sample page, that demonstrates how to use Node.js as a server app with express. [!INCLUDE aspire-prereqs] Additionally, you need to install Node.js on your machine. The sample app in this article was built with Node.js version 20.12.2 and npm version 10.5.1. To verify your Node.js and npm versions, run the following commands: nodejs node --version nodejs npm --version To download Node.js (including npm), see the Node.js download page. Clone sample source code To clone the sample source code from GitHub, run the following command: bash git clone https://github.com/dotnet/aspire-samples.git After cloning the repository, navigate to the samples/AspireWithJavaScript folder: bash cd samples/AspireWithJavaScript From this directory, there are six child directories described in the following list: AspireJavaScript.Angular: An Angular app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.AppHost: A .NET Aspire project that orchestrates the other apps in this sample. For more information, see .NET Aspire orchestration overview. AspireJavaScript.MinimalApi: An HTTP API that returns randomly generated weather forecast data. AspireJavaScript.React: A React app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.ServiceDefaults: The default shared project for .NET Aspire projects. For more information, see .NET Aspire service defaults. AspireJavaScript.Vue: A Vue app that consumes the weather forecast API and displays the data in a table. Install client dependencies The sample app demonstrates how to use JavaScript client apps that are built on top of Node.js. Each client app was written either using a npm create template command or manually. The following table lists the template commands used to create each client app, along with the default port: App type Create template command Default port Angular npm create @angular@latest 4200 React Didn't use a template. PORT env var Vue npm create vue@latest 5173 [!TIP] You don't need to run any of these commands, since the sample app already includes the clients. Instead, this is a point of reference from which the clients were created. For more information, see npm-init. To run the app, you first need to install the dependencies for each client. To do so, navigate to each client folder and run npm install (or the install alias npm i) commands. Install Angular dependencies nodejs npm i ./AspireJavaScript.Angular/ For more information on the Angular app, see explore the Angular client. Install React dependencies nodejs npm i ./AspireJavaScript.React/ For more information on the React app, see explore the React client. Install Vue dependencies nodejs npm i ./AspireJavaScript.Vue/ For more information on the Vue app, see explore the Vue client."", '<2-hop>\n\ntitle: Deploy a ASP.NET Core app that connects to SQL Server to Azure description: Learn how to deploy a ASP.NET Core app that connects to SQL Server to Azure ms.date: 11/08/2024 ms.topic: how-to Tutorial: Deploy a .NET Aspire project with a SQL Server Database to Azure In this tutorial, you learn to configure an ASP.NET Core app with a SQL Server Database for deployment to Azure. .NET Aspire provides multiple SQL Server integration configurations that provision different database services in Azure. You\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET Core app that is configured to use the .NET Aspire SQL Server integration Configure the app to provision an Azure SQL Database Configure the app to provision a containerized SQL Server database [!NOTE] This document focuses specifically on .NET Aspire configurations to provision and deploy SQL Server resources in Azure. Visit the Azure Container Apps deployment tutorial to learn more about the full .NET Aspire deployment process. [!INCLUDE aspire-prereqs] Create the sample solution Visual Studio At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Aspire and select .NET Aspire - Starter Application. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQL. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Verify that .NET 9.0 is selected and choose Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. .NET CLI In an empty directory, run the following command to create a new .NET Aspire project: dotnetcli dotnet new aspire-starter --output AspireSQL The .NET CLI creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Configure the app for SQL Server deployment .NET Aspire provides two built-in configuration options to streamline SQL Server deployment on Azure: Provision a containerized SQL Server database using Azure Container Apps Provision an Azure SQL Database instance Add the .NET Aspire integration to the app Add the appropriate .NET Aspire integration to the AspireSQL.AppHost project for your desired hosting service. Azure SQL Database Add the ðŸ“¦ Aspire.Hosting.Azure.Sql NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.Azure.Sql SQL Server Container Add the ðŸ“¦ Aspire.Hosting.SqlServer NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Configure the AppHost project Configure the AspireSQL.AppHost project for your desired SQL database service. Azure SQL Database Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeployazure/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The PublishAsAzureSqlDatabase method ensures that tools such as the Azure Developer CLI or Visual Studio create an Azure SQL Database resource during the deployment process. SQL Server Container Replace the contents of the Program.cs file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeploycontainer/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. This configuration also ensures that tools such as the Azure Developer CLI or Visual Studio create a containerized SQL Server instance during the deployment process.']","In .NET Aspire, Node.js applications can be orchestrated by integrating Node.js and npm apps into a .NET Aspire App Host project. This is supported by the Aspire.Hosting.NodeJS NuGet package, which allows hosting of Node.js apps and execution of npm scripts. For deploying an ASP.NET Core app with SQL Server to Azure, .NET Aspire provides configurations to provision Azure SQL Database or a containerized SQL Server database. This involves adding the Aspire.Hosting.Azure.Sql NuGet package to the AspireSQL.AppHost project and configuring the app for SQL Server deployment using Azure services.",multi_hop_specific_query_synthesizer
91,"How does the Azure Developer CLI (azd) facilitate the deployment of .NET Aspire projects using GitHub Actions and Azure DevOps pipelines, and what are the key steps involved in configuring these deployments?","['<1-hop>\n\nDeploy the app Tools such as the Azure Developer CLI (azd) support .NET Aspire SQL Server integration configurations to streamline deployments. azd consumes these settings and provisions properly configured resources for you. [!INCLUDE init-workflow] [!INCLUDE azd-up-workflow] Azure SQL Database The deployment process provisioned an Azure SQL Database resource due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-database.png"" alt-text=""A screenshot showing the deployed Azure SQL Database.""::: SQL Server Container The deployment process created a SQL Server app container due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-container.png"" alt-text=""A screenshot showing the containerized SQL Database.""::: [!INCLUDE clean-up-resources] See also .NET Aspire deployment via Azure Container Apps .NET Aspire Azure Container Apps deployment deep dive Deploy a .NET Aspire project using GitHub Actions', '<2-hop>\n\ntitle: Deploy a .NET Aspire project using the Azure Developer CLI description: Learn how to use azd to deploy .NET Aspire projects. ms.date: 01/08/2025 zone_pivot_groups: deployment-platform ms.custom: devx-track-extended-azdevcli Tutorial: Deploy a .NET Aspire project using the Azure Developer CLI The Azure Developer CLI (azd) enables you to deploy .NET Aspire projects using GitHub Actions or Azure Devops pipelines by automatically configuring the required authentication and environment settings. This article walks you through the process of creating and deploying a .NET Aspire project on Azure Container Apps using azd. You learn the following concepts: [!div class=""checklist""] Explore how azd integration works with .NET Aspire projects Create and configure a GitHub or Azure DevOps repository for a .NET Aspire project using azd Monitor and explore GitHub Actions workflow or Azure DevOps pipeline executions and Azure deployments [!INCLUDE aspire-prereqs] :::zone pivot=""azure-pipelines"" Create an Azure DevOps organization or choose an existing organization Create an Azure DevOps Personal Access Token (PAT) and save it for later use. Configure the token with the following permissions: Agent Pools (read, manage) Build (read and execute) Code (full) Project and team (read, write and manage) Release (read, write, execute and manage) Service Connections (read, query and manage) :::zone-end You also need to have the Azure Developer CLI installed locally (version 1.5.1 or higher). Common install options include the following: Windows powershell winget install microsoft.azd macOS bash brew tap azure/azd && brew install azd Linux bash curl -fsSL https://aka.ms/install-azd.sh | bash Create a .NET Aspire solution As a starting point, this article assumes that you\'ve created a .NET Aspire solution from the .NET Aspire Starter Application template. For more information, see Quickstart: Build your first .NET Aspire app. [!INCLUDE init workflow] :::zone pivot=""github-actions"" Create the GitHub repository and pipeline The Azure Developer CLI enables you to automatically create CI/CD pipelines with the correct configurations and permissions to provision and deploy resources to Azure. azd can also create a GitHub repository for your app if it doesn\'t exist already. Run the azd pipeline config command to configure your deployment pipeline and securely connect it to Azure: azdeveloper azd pipeline config Select the subscription to provision and deploy the app resources to. Select the Azure location to use for the resources. When prompted whether to create a new Git repository in the directory, enter y and press Enter. [!NOTE] Creating a GitHub repository required you being logged into GitHub. There are a few selections that vary based on your preferences. After logging in, you will be prompted to create a new repository in the current directory. Select Create a new private GitHub repository to configure the git remote. Enter a name of your choice for the new GitHub repository or press enter to use the default name. azd creates a new repository in GitHub and configures it with the necessary secrets required to authenticate to Azure. :::image type=""content"" loc-scope=""other"" source=""media/pipeline-configuration.png"" alt-text=""A screenshot showing the pipeline configuration steps.""::: Enter y to proceed when azd prompts you to commit and push your local changes to start the configured pipeline. Explore the GitHub Actions workflow and deployment Navigate to your new GitHub repository using the link output by azd. Select the Actions tab to view the repository workflows. You should see the new workflow either running or already completed. Select the workflow to view the job steps and details in the logs of the run. For example, you can expand steps such as Install .NET Aspire Workload or Deploy application to see the details of the completed action. :::image type=""content"" loc-scope=""github"" source=""media/github-action.png"" alt-text=""A screenshot showing the GitHub Action workflow steps.""::: Select Deploy Application to expand the logs for that step. You should see two endpoint urls printed out for the apiservice and webfrontend. Select either of these links to open them in another browser tab and explore the deployed application. :::image type=""content"" loc-scope=""github"" source=""media/deployment-links.png"" alt-text=""A screenshot showing the deployed app links.""::: Congratulations! You successfully deployed a .NET Aspire project using the Azure Developer CLI and GitHub Actions. :::zone-end :::zone pivot=""azure-pipelines""']","The Azure Developer CLI (azd) facilitates the deployment of .NET Aspire projects by automating the configuration of authentication and environment settings necessary for deployment through GitHub Actions or Azure DevOps pipelines. Key steps involved in configuring these deployments include creating and configuring a GitHub or Azure DevOps repository for the .NET Aspire project, setting up CI/CD pipelines with the correct configurations and permissions, and securely connecting the deployment pipeline to Azure. The process involves using the 'azd pipeline config' command to configure the deployment pipeline, selecting the Azure subscription and location for resource deployment, and creating a new GitHub repository if needed. Once configured, azd manages the deployment process, including provisioning resources like Azure SQL Database and SQL Server containers, and allows monitoring of the GitHub Actions workflow or Azure DevOps pipeline executions to ensure successful deployment.",multi_hop_specific_query_synthesizer
92,How does the .NET Aspire Azure Blob Storage integration facilitate data persistence across app launches using volume mounts?,"['<1-hop>\n\ntitle: .NET Aspire Azure Blob Storage integration description: Learn how to use the .NET Aspire Azure Blob Storage integration, which includes both hosting and client integrations. ms.date: 12/09/2024 uid: storage/azure-blob-storage-integration .NET Aspire Azure Blob Storage integration [!INCLUDE includes-hosting-and-client] Azure Blob Storage is a service for storing large amounts of unstructured data. The .NET Aspire Azure Blob Storage integration enables you to connect to existing Azure Blob Storage instances or create new instances from .NET applications. Hosting integration [!INCLUDE storage-app-host] Add Azure Blob Storage resource In your app host project, register the Azure Blob Storage integration by chaining a call to ```csharp var builder = DistributedApplication.CreateBuilder(args); var blobs = builder.AddAzureStorage(""storage"") .RunAsEmulator(); .AddBlobs(""blobs""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Adds an Azure Storage resource named storage. Chains a call to Adds a blob container named blobs to the storage resource. Adds the blobs resource to the ExampleProject and waits for it to be ready before starting the project. [!INCLUDE storage-hosting-health-checks] Client integration To get started with the .NET Aspire Azure Blob Storage client integration, install the ðŸ“¦ Aspire.Azure.Storage.Blobs NuGet package in the client-consuming project, that is, the project for the application that uses the Azure Blob Storage client. The Azure Blob Storage client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Azure.Storage.Blobs PackageReference xml <PackageReference Include=""Aspire.Azure.Storage.Blobs"" Version=""*"" /> Add Azure Blob Storage client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureBlobClient(""blobs""); You can then retrieve the BlobServiceClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(BlobServiceClient client) { // Use client... } Configuration The .NET Aspire Azure Blob Storage integration provides multiple options to configure the BlobServiceClient based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddAzureBlobClient(""blobs""); Then the connection string is retrieved from the ConnectionStrings configuration section, and two connection formats are supported: Service URI The recommended approach is to use a ServiceUri, which works with the json { ""ConnectionStrings"": { ""blobs"": ""https://{account_name}.blob.core.windows.net/"" } } Connection string Alternatively, an Azure Storage connection string can be used. json { ""ConnectionStrings"": { ""blobs"": ""AccountName=myaccount;AccountKey=myaccountkey"" } } For more information, see Configure Azure Storage connection strings. Use configuration providers The .NET Aspire Azure Blob Storage integration supports json { ""Aspire"": { ""Azure"": { ""Storage"": { ""Blobs"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Diagnostics"": { ""ApplicationId"": ""myapp"" } } } } } } } For the complete Azure Blob Storage client integration JSON schema, see Aspire.Azure.Storage.Blobs/ConfigurationSchema.json. Use inline delegates You can also pass the Action<AzureStorageBlobsSettings> configureSettings delegate to set up some or all the options inline, for example to configure health checks: csharp builder.AddAzureBlobClient( ""blobs"", settings => settings.DisableHealthChecks = true); You can also set up the csharp builder.AddAzureBlobClient( ""blobs"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Diagnostics.ApplicationId = ""myapp"")); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Blob Storage integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: Persist data with .NET Aspire using volume mounts description: Learn about .NET Aspire volume configurations. ms.date: 04/26/2024 ms.topic: how-to Persist .NET Aspire project data using volumes In this article, you learn how to configure .NET Aspire projects to persist data across app launches using volumes. A continuous set of data during local development is useful in many scenarios. Various .NET Aspire resource container types are able to leverage volume storage, such as PostgreSQL, Redis and Azure Storage. When to use volumes By default, every time you start and stop a .NET Aspire project, the app also creates and destroys the app resource containers. This setup creates problems when you want to persist data in a database or storage services between app launches for testing or debugging. For example, you may want to handle the following scenarios: Work with a continuous set of data in a database during an extended development session. Test or debug a changing set of files in an Azure Blob Storage emulator. Maintain cached data or messages in a Redis instance across app launches. These goals can all be accomplished using volumes. With volumes, you decide which services retain data between launches of your .NET Aspire project. Understand volumes Volumes are the recommended way to persist data generated by containers and supported on both Windows and Linux. Volumes can store data from multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume, which is the physical location on the host. Target: The target path in the container of the data you want to persist. For the remainder of this article, imagine that your exploring a Program class in a .NET Aspire app host project that\'s already defined the distributed app builder bits: ```csharp var builder = DistributedApplication.CreateBuilder(args); // TODO: // Consider various code snippets for configuring // volumes here and persistent passwords. builder.Build().Run(); ``` The first code snippet to consider uses the WithBindMount API to configure a volume for a SQL Server resource. The following code demonstrates how to configure a volume for a SQL Server resource in a .NET Aspire app host project: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.WithBindMount.cs"" id=""mount""::: In this example: VolumeMount.AppHost-sql-data sets where the volume will be stored on the host. /var/opt/mssql sets the path to the database files in the container. All .NET Aspire container resources can utilize volume mounts, and some provide convenient APIs for adding named volumes derived from resources. Using the WithDataVolume as an example, the following code is functionally equivalent to the previous example but more succinct: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.Implicit.cs"" id=""implicit""::: With the app host project being named VolumeMount.AppHost, the WithDataVolume method automatically creates a named volume as VolumeMount.AppHost-sql-data and is mounted to the /var/opt/mssql path in the SQL Server container. The naming convention is as follows: {appHostProjectName}-{resourceName}-data: The volume name is derived from the app host project name and the resource name. Create a persistent password Named volumes require a consistent password between app launches. .NET Aspire conveniently provides random password generation functionality. Consider the previous example once more, where a password is generated automatically: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.Implicit.cs"" id=""implicit""::: Since the password parameter isn\'t provided when calling AddSqlServer, .NET Aspire automatically generates a password for the SQL Server resource. [!IMPORTANT] This isn\'t a persistent password! Instead, it changes every time the app host runs. To create a persistent password, you must override the generated password. To do this, run the following command in your app host project directory to set a local password in your .NET user secrets: dotnetcli dotnet user-secrets set Parameters:sql-password <password> The naming convention for these secrets is important to understand. The password is stored in configuration with the Parameters:sql-password key. The naming convention follows this pattern: Parameters:{resourceName}-password: In the case of the SQL Server resource (which was named ""sql""), the password is stored in the configuration with the key Parameters:sql-password. The same pattern applies to the other server-based resource types, such as those shown in the following table: | Resource type | Hosting package | Example resource name | Override key | |--|--|--| | MySQL | ðŸ“¦ Aspire.Hosting.MySql | mysql | Parameters:mysql-password | | Oracle | ðŸ“¦ Aspire.Hosting.Oracle | oracle | Parameters:oracle-password | | PostgreSQL | ðŸ“¦ Aspire.Hosting.PostgreSQL | postgresql | Parameters:postgresql-password | | RabbitMQ | ðŸ“¦ Aspire.Hosting.RabbitMq | rabbitmq | Parameters:rabbitmq-password | | SQL Server | ðŸ“¦ Aspire.Hosting.SqlServer | sql | Parameters:sql-password | By overriding the generated password, you can ensure that the password remains consistent between app launches, thus creating a persistent password. An alternative approach is to use the AddParameter method to create a parameter that can be used as a password. The following code demonstrates how to create a persistent password for a SQL Server resource: :::code language=""csharp"" source=""snippets/volumes/VolumeMounts.AppHost/Program.ExplicitStable.cs"" id=""explicit""::: The preceding code snippet demonstrates how to create a persistent password for a SQL Server resource. The AddParameter method is used to create a parameter named sql-password that\'s considered a secret. The AddSqlServer method is then called with the password parameter to set the password for the SQL Server resource. For more information, see External parameters.']","The .NET Aspire Azure Blob Storage integration facilitates data persistence across app launches by leveraging volume mounts. This approach allows for the storage of data from multiple containers, ensuring that data such as files in an Azure Blob Storage emulator can be retained between app launches. By configuring volumes, developers can maintain a continuous set of data during local development, which is particularly useful for testing or debugging purposes. The integration supports the use of volumes to persist data, which is crucial for scenarios where data needs to be retained across multiple sessions.",multi_hop_specific_query_synthesizer
93,How does Microsoft Research's Garnet integration with .NET Aspire enhance Redis capabilities in cloud-native applications?,"['<1-hop>\n\ntitle: .NET Aspire Redis integration description: Learn how to use the .NET Aspire Redis integration, which includes both hosting and client integrations. ms.date: 11/05/2024 zone_pivot_groups: resp-host .NET Aspire RedisÂ®* integration [!INCLUDE includes-hosting-and-client] :::zone pivot=""redis"" Redis is the world\'s fastest data platform for caching, vector search, and NoSQL databases. The .NET Aspire Redis integration enables you to connect to existing Redis instances, or create new instances from .NET with the docker.io/library/redis container image. :::zone-end :::zone pivot=""garnet"" Garnet is a a high-performance cache-store from Microsoft Research and complies with the Redis serialization protocol (RESP). The .NET Aspire Redis integration enables you to connect to existing Garnet instances, or create new instances from .NET with the ghcr.io/microsoft/garnet container image. :::zone-end :::zone pivot=""valkey"" Valkey is a Redis fork and complies with the Redis serialization protocol (RESP). It\'s a high-performance key/value datastore that supports a variety of workloads such as caching, message queues, and can act as a primary database. The .NET Aspire Redis integration enables you to connect to existing Valkey instances, or create new instances from .NET with the docker.io/valkey/valkey container image. :::zone-end Hosting integration :::zone pivot=""redis"" [!INCLUDE redis-app-host] :::zone-end :::zone pivot=""garnet"" [!INCLUDE garnet-app-host] :::zone-end :::zone pivot=""valkey"" [!INCLUDE valkey-app-host] :::zone-end Hosting integration health checks [!INCLUDE redis-hosting-health-checks] Client integration To get started with the .NET Aspire Stack Exchange Redis client integration, install the ðŸ“¦ Aspire.StackExchange.Redis NuGet package in the client-consuming project, that is, the project for the application that uses the Redis client. The Redis client integration registers an an IConnectionMultiplexer instance that you can use to interact with Redis. .NET CLI dotnetcli dotnet add package Aspire.StackExchange.Redis PackageReference xml <PackageReference Include=""Aspire.StackExchange.Redis"" Version=""*"" /> Add Redis client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddRedisClient(connectionName: ""cache""); :::zone pivot=""redis"" [!TIP] The connectionName parameter must match the name used when adding the Redis resource in the app host project. For more information, see Add Redis resource. :::zone-end :::zone pivot=""garnet"" [!TIP] The connectionName parameter must match the name used when adding the Garnet resource in the app host project. For more information, see Add Garnet resource. :::zone-end :::zone pivot=""valkey"" [!TIP] The connectionName parameter must match the name used when adding the Valkey resource in the app host project. For more information, see Add Valkey resource. :::zone-end You can then retrieve the IConnection instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(IConnectionMultiplexer connectionMux) { // Use connection multiplexer... } For more information on dependency injection, see .NET dependency injection. Add keyed Redis client There might be situations where you want to register multiple IConnectionMultiplexer instances with different connection names. To register keyed Redis clients, call the csharp builder.AddKeyedRedisClient(name: ""chat""); builder.AddKeyedRedisClient(name: ""queue""); Then you can retrieve the IConnectionMultiplexer instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] IConnectionMultiplexer chatConnectionMux, [FromKeyedServices(""queue"")] IConnectionMultiplexer queueConnectionMux) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Stack Exchange Redis client integration provides multiple options to configure the Redis connection based on the requirements and conventions of your project. Use a connection string :::zone pivot=""redis"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddRedis(""cache""); :::zone-end :::zone pivot=""garnet"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddGarnet(""cache""); :::zone-end :::zone pivot=""valkey"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddValkey(""cache""); :::zone-end Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } For more information on how to format this connection string, see the Stack Exchange Redis configuration docs. Use configuration providers [!INCLUDE redis-client-json-settings] Use inline delegates You can also pass the Action<StackExchangeRedisSettings> delegate to set up some or all the options inline, for example to configure DisableTracing: csharp builder.AddRedisClient( ""cache"", static settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Stack Exchange Redis integration handles the following: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.', '<2-hop>\n\nCreate an Orleans client project In the Orleans client project, add the same NuGet packages: .NET CLI dotnetcli dotnet add package Aspire.Azure.Data.Tables dotnet add package Aspire.Azure.Storage.Blobs dotnet add package Microsoft.Orleans.Client dotnet add package Microsoft.Orleans.Persistence.AzureStorage dotnet add package Microsoft.Orleans.Clustering.AzureStorage PackageReference ```xml ``` Next, in the :::no-loc text=""Program.cs""::: file of your Orleans client project, add the Azure table storage client and then call :::code language=""csharp"" source=""snippets/Orleans/OrleansClient/Program.cs"" range=""6-7"" ::: The following code is a complete example of an Orleans client project. It calls the CounterGrain grain defined in the Orleans server example above: :::code language=""csharp"" source=""snippets/Orleans/OrleansClient/Program.cs"" ::: Enabling OpenTelemetry By convention, .NET Aspire solutions include a project for defining default configuration and behavior for your service. This project is called the service defaults project and templates create it with a name ending in ServiceDefaults. To configure Orleans for OpenTelemetry in .NET Aspire, apply configuration to your service defaults project following the Orleans observability guide. Modify the ConfigureOpenTelemetry method to add the Orleans meters and tracing instruments. The following code snippet shows the modified Extensions.cs file from a service defaults project that includes metrics and traces from Orleans. :::code language=""csharp"" source=""snippets/Orleans/OrleansServiceDefaults/Extensions.cs"" range=""40-68"" highlight=""15,19-20""::: Supported providers The Orleans Aspire integration supports a limited subset of Orleans providers today: Clustering: Redis Azure Storage Tables Persistence: Redis Azure Storage Tables Azure Storage Blobs Reminders: Redis Azure Storage Tables Grain directory: Redis Azure Storage Tables Streaming providers aren\'t supported as of Orleans version 8.1.0. Next steps [!div class=""nextstepaction""] Microsoft Orleans documentation Explore the Orleans voting sample app']","Microsoft Research's Garnet integration with .NET Aspire enhances Redis capabilities by providing a high-performance cache-store that complies with the Redis serialization protocol (RESP). This integration allows developers to connect to existing Garnet instances or create new ones using the ghcr.io/microsoft/garnet container image. It supports various workloads such as caching and message queues, similar to Redis, and can be seamlessly integrated into cloud-native applications using .NET Aspire, thereby enhancing productivity and observability.",multi_hop_specific_query_synthesizer
94,"How does the AppHost project in .NET Aspire facilitate the deployment and seeding of databases using containerized environments, and what are the specific steps involved in updating infrastructure and seeding data?","['<1-hop>\n\nDeploy application updates When the azd up command is executed the underlying Azure resources are provisioned and a container image is built and deployed to the container apps hosting the .NET Aspire project. Typically once development is underway and Azure resources are deployed it won\'t be necessary to provision Azure resources every time code is updatedâ€”this is especially true for the developer inner loop. To speed up deployment of code changes, azd supports deploying code updates in the container image. This is done using the azd deploy command: azdeveloper azd deploy [!INCLUDE azd-deploy-output] It\'s not necessary to deploy all services each time. azd understands the .NET Aspire project model, it\'s possible to deploy just one of the services specified using the following command: azdeveloper azd deploy webfrontend For more information, see Azure Developer CLI reference: azd deploy. Deploy infrastructure updates Whenever the dependency structure within a .NET Aspire project changes, azd must re-provision the underlying Azure resources. The azd provision command is used to apply these changes to the infrastructure. To see this in action, update the :::no-loc text=""Program.cs""::: file in the AppHost project to the following: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); // Add the locations database. var locationsdb = builder.AddPostgres(""db"").AddDatabase(""locations""); // Add the locations database reference to the API service. var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` Save the file and issue the following command: azdeveloper azd provision The azd provision command updates the infrastructure by creating a container app to host the Postgres database. The azd provision command didn\'t update the connection strings for the apiservice container. In order to have connection strings updated to point to the newly provisioned Postgres database the azd deploy command needs to be invoked again. When in doubt, use azd up to both provision and deploy. Clean up resources Remember to clean up the Azure resources that you\'ve created during this walkthrough. Because `azd knows the resource group in which it created the resources it can be used to spin down the environment using the following command: azdeveloper azd down The previous command may take some time to execute, but when completed the resource group and all its resources should be deleted. [!INCLUDE azd-down-output]', '<2-hop>\n\ntitle: Seed data in a database using .NET Aspire description: Learn about how to seed database data in .NET Aspire ms.date: 08/12/2024 ms.topic: how-to Seed data in a database using .NET Aspire In this article, you learn how to configure .NET Aspire projects to seed data in a database during app startup. .NET Aspire enables you to seed data using database scripts or Entity Framework Core for common platforms such as SQL Server, PostgreSQL and MySQL. When to seed data Seeding data pre-populates database tables with rows of data so they\'re ready for testing via your app. You may want to seed data for the following scenarios: Manually develop and test different features of your app against a meaningful set of data, such as a product catalog or list of customers. Run test suites to verify that features behave a specific way with a given set of data. Manually seeding data is tedious and time consuming, so you should automate the process when possible. Use volumes to run database scripts for .NET Aspire projects during startup. You can also seed your database using tools like Entity Framework Core, which handles many underlying concerns for you. Understand containerized databases By default, .NET Aspire database integrations rely on containerized databases, which create the following challenges when trying to seed data: .NET Aspire destroys and recreates containers every time the app restarts, which means by default you have to re-seed your database every time the app restarts. Depending on your selected database technology, the new container instance may or may not create a default database, which means you might also have to create the database itself. Even if a default database exists, it most likely will not have the desired name or schema for your specific app. .NET Aspire enables you to resolve these challenges using volumes and a few configurations to seed data effectively. Seed data using volumes and SQL scripts Volumes are the recommended way to automatically seed containerized databases when using SQL scripts. Volumes can store data for multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume mount, which is the physical location on your host. Target: The target path in the container of the data you want to persist. Consider the following volume configuration code from a :::no-loc text=""Program.cs""::: file in a sample AppHost project: csharp var todosDbName = ""Todos""; var todosDb = builder.AddPostgres(""postgres"") .WithEnvironment(""POSTGRES_DB"", todosDbName) .WithBindMount( ""../DatabaseContainers.ApiService/data/postgres"", ""/docker-entrypoint-initdb.d"") .AddDatabase(todosDbName); In this example, the .WithBindMount method parameters configure the following: ../DatabaseContainers.ApiService/data/postgres sets a path to the SQL script in your local project that you want to run in the container to seed data. /docker-entrypoint-initdb.d sets the path to an entry point in the container so your script will be run during container startup. The referenced SQL script located at ../DatabaseContainers.ApiService/data/postgres creates and seeds a Todos table: ```sql -- Postgres init script -- Create the Todos table CREATE TABLE IF NOT EXISTS Todos ( Id SERIAL PRIMARY KEY, Title text UNIQUE NOT NULL, IsComplete boolean NOT NULL DEFAULT false ); -- Insert some sample data into the Todos table INSERT INTO Todos (Title, IsComplete) VALUES (\'Give the dog a bath\', false), (\'Wash the dishes\', false), (\'Do the groceries\', false) ON CONFLICT DO NOTHING; ``` The script runs during startup every time a new container instance is created. Database seeding examples The following examples demonstrate how to seed data using SQL scripts and configurations applied using the .WithBindMount method for different database technologies: [!NOTE] Visit the Database Container Sample App to view the full project and file structure for each database option. SQL Server The configuration code in the .AppHost :::no-loc text=""Program.cs""::: file mounts the required database files and folders and configures an entrypoint so that they run during startup. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""37-49"" ::: The entrypoint.sh script lives in the mounted ./sqlserverconfig project folder and runs when the container starts. The script launches SQL Server and checks that it\'s running. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/sqlserverconfig/entrypoint.sh"" ::: The init.sql SQL script that lives in the mounted ../DatabaseContainers.ApiService/data/sqlserver project folder creates the database and tables. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/sqlserver/init.sql"" ::: PostgreSQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""3-15"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/postgres/init.sql"" ::: MySQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""20-32"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/mysql/init.sql"" :::']","The AppHost project in .NET Aspire facilitates the deployment and seeding of databases using containerized environments by leveraging the azd CLI commands and volume configurations. To update infrastructure, the azd provision command is used, which applies changes to the infrastructure, such as creating a container app to host a Postgres database. This command does not update connection strings, so the azd deploy command must be invoked again to ensure connection strings point to the newly provisioned database. For seeding databases, .NET Aspire uses volumes and SQL scripts. The .WithBindMount method is configured in the Program.cs file to specify the source path of the SQL script and the target path in the container. This setup ensures that the SQL script runs during container startup, creating and seeding tables like the Todos table in a Postgres database. The script is executed every time a new container instance is created, ensuring the database is seeded with the necessary data.",multi_hop_specific_query_synthesizer
95,How does .NET Aspire utilize the app host configuration and database seeding to enhance application startup and testing?,"['<1-hop>\n\nInternal settings that .NET Aspire uses to run the app host. These are set internally but can be accessed by integrations that extend .NET Aspire. App host configuration is provided by the app host launch profile. The app host has a launch settings file call launchSettings.json which has a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } } } } The preceding launch settings file: Has one launch profile named https. Configures an .NET Aspire app host project: The applicationUrl property configures the dashboard launch address (ASPNETCORE_URLS). Environment variables such as DOTNET_DASHBOARD_OTLP_ENDPOINT_URL and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL are set on the app host. For more information, see .NET Aspire and launch profiles. [!NOTE] Configuration described on this page is for .NET Aspire app host project. To configure the standalone dashboard, see dashboard configuration. Common configuration Option Default value Description ASPIRE_ALLOW_UNSECURED_TRANSPORT false Allows communication with the app host without https. ASPNETCORE_URLS (dashboard address) and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL (app host resource service address) must be secured with HTTPS unless true. DOTNET_ASPIRE_CONTAINER_RUNTIME docker Allows the user of alternative container runtimes for resources backed by containers. Possible values are docker (default) or podman . See Setup and tooling overview for more details . Resource service A resource service is hosted by the app host. The resource service is used by the dashboard to fetch information about resources which are being orchestrated by .NET Aspire. Option Default value Description DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null Configures the address of the resource service hosted by the app host. Automatically generated with launchSettings.json to have a random port on localhost. For example, https://localhost:17037 . DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key is required if the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . Dashboard By default, the dashboard is automatically started by the app host. The dashboard supports its own set of configuration, and some settings can be configured from the app host. Option Default value Description ASPNETCORE_URLS null Dashboard address. Must be https unless ASPIRE_ALLOW_UNSECURED_TRANSPORT or DistributedApplicationOptions.AllowUnsecuredTransport is true. Automatically generated with launchSettings.json to have a random port on localhost. The value in launch settings is set on the applicationUrls property. ASPNETCORE_ENVIRONMENT Production Configures the environment the dashboard runs as. For more information, see Use multiple environments in ASP.NET Core . DOTNET_DASHBOARD_OTLP_ENDPOINT_URL http://localhost:18889 if no gRPC endpoint is configured. Configures the dashboard OTLP gRPC address. Used by the dashboard to receive telemetry over OTLP. Set on resources as the OTEL_EXPORTER_OTLP_ENDPOINT env var. The OTEL_EXPORTER_OTLP_PROTOCOL env var is grpc . Automatically generated with launchSettings.json to have a random port on localhost. DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL null Configures the dashboard OTLP HTTP address. Used by the dashboard to receive telemetry over OTLP. If only DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL is configured then it is set on resources as the OTEL_EXPORTER_OTLP_ENDPOINT env var. The OTEL_EXPORTER_OTLP_PROTOCOL env var is http/protobuf . DOTNET_DASHBOARD_FRONTEND_BROWSERTOKEN Automatically generated 128-bit entropy token. Configures the frontend browser token. This is the value that must be entered to access the dashboard when the auth mode is BrowserToken. If no browser token is specified then a new token is generated each time the app host is launched. Internal Internal settings are used by the app host and integrations. Internal settings aren\'t designed to be configured directly. Option Default value Description AppHost:Directory The content root if there\'s no project. Directory of the project where the app host is located. Accessible from the . AppHost:Path The directory combined with the application name. The path to the app host. It combines the directory with the application name. AppHost:Sha256 It is created from the app host name when the app host is in publish mode. Otherwise it is created from the app host path. Hex encoded hash for the current application. The hash is based on the location of the app on the current machine so it is stable between launches of the app host. AppHost:OtlpApiKey Automatically generated 128-bit entropy token. The API key used to authenticate requests sent to the dashboard OTLP service. The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . AppHost:BrowserToken Automatically generated 128-bit entropy token. The browser token used to authenticate browsing to the dashboard when it is launched by the app host. The browser token can be set by DOTNET_DASHBOARD_FRONTEND_BROWSERTOKEN . The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . AppHost:ResourceService:AuthMode ApiKey . If DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS is true then the value is Unsecured . The authentication mode used to access the resource service. The value is present if needed: the app host is in run mode and the dashboard isn\'t disabled. AppHost:ResourceService:ApiKey Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key can be set by DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY . The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS .', '<2-hop>\n\ntitle: Seed data in a database using .NET Aspire description: Learn about how to seed database data in .NET Aspire ms.date: 08/12/2024 ms.topic: how-to Seed data in a database using .NET Aspire In this article, you learn how to configure .NET Aspire projects to seed data in a database during app startup. .NET Aspire enables you to seed data using database scripts or Entity Framework Core for common platforms such as SQL Server, PostgreSQL and MySQL. When to seed data Seeding data pre-populates database tables with rows of data so they\'re ready for testing via your app. You may want to seed data for the following scenarios: Manually develop and test different features of your app against a meaningful set of data, such as a product catalog or list of customers. Run test suites to verify that features behave a specific way with a given set of data. Manually seeding data is tedious and time consuming, so you should automate the process when possible. Use volumes to run database scripts for .NET Aspire projects during startup. You can also seed your database using tools like Entity Framework Core, which handles many underlying concerns for you. Understand containerized databases By default, .NET Aspire database integrations rely on containerized databases, which create the following challenges when trying to seed data: .NET Aspire destroys and recreates containers every time the app restarts, which means by default you have to re-seed your database every time the app restarts. Depending on your selected database technology, the new container instance may or may not create a default database, which means you might also have to create the database itself. Even if a default database exists, it most likely will not have the desired name or schema for your specific app. .NET Aspire enables you to resolve these challenges using volumes and a few configurations to seed data effectively. Seed data using volumes and SQL scripts Volumes are the recommended way to automatically seed containerized databases when using SQL scripts. Volumes can store data for multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume mount, which is the physical location on your host. Target: The target path in the container of the data you want to persist. Consider the following volume configuration code from a :::no-loc text=""Program.cs""::: file in a sample AppHost project: csharp var todosDbName = ""Todos""; var todosDb = builder.AddPostgres(""postgres"") .WithEnvironment(""POSTGRES_DB"", todosDbName) .WithBindMount( ""../DatabaseContainers.ApiService/data/postgres"", ""/docker-entrypoint-initdb.d"") .AddDatabase(todosDbName); In this example, the .WithBindMount method parameters configure the following: ../DatabaseContainers.ApiService/data/postgres sets a path to the SQL script in your local project that you want to run in the container to seed data. /docker-entrypoint-initdb.d sets the path to an entry point in the container so your script will be run during container startup. The referenced SQL script located at ../DatabaseContainers.ApiService/data/postgres creates and seeds a Todos table: ```sql -- Postgres init script -- Create the Todos table CREATE TABLE IF NOT EXISTS Todos ( Id SERIAL PRIMARY KEY, Title text UNIQUE NOT NULL, IsComplete boolean NOT NULL DEFAULT false ); -- Insert some sample data into the Todos table INSERT INTO Todos (Title, IsComplete) VALUES (\'Give the dog a bath\', false), (\'Wash the dishes\', false), (\'Do the groceries\', false) ON CONFLICT DO NOTHING; ``` The script runs during startup every time a new container instance is created. Database seeding examples The following examples demonstrate how to seed data using SQL scripts and configurations applied using the .WithBindMount method for different database technologies: [!NOTE] Visit the Database Container Sample App to view the full project and file structure for each database option. SQL Server The configuration code in the .AppHost :::no-loc text=""Program.cs""::: file mounts the required database files and folders and configures an entrypoint so that they run during startup. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""37-49"" ::: The entrypoint.sh script lives in the mounted ./sqlserverconfig project folder and runs when the container starts. The script launches SQL Server and checks that it\'s running. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/sqlserverconfig/entrypoint.sh"" ::: The init.sql SQL script that lives in the mounted ../DatabaseContainers.ApiService/data/sqlserver project folder creates the database and tables. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/sqlserver/init.sql"" ::: PostgreSQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""3-15"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/postgres/init.sql"" ::: MySQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""20-32"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/mysql/init.sql"" :::']",".NET Aspire utilizes the app host configuration through the launchSettings.json file, which defines launch profiles and environment variables necessary for running the app host. This configuration includes setting application URLs, environment variables, and securing communication with HTTPS. Additionally, .NET Aspire enhances application startup and testing by enabling database seeding. This is achieved by using volumes and SQL scripts to automatically seed containerized databases during app startup. The seeding process pre-populates database tables with data, facilitating testing and development by ensuring that meaningful data is available for application features. This approach addresses challenges such as the recreation of containers and the need for consistent database states across application restarts.",multi_hop_specific_query_synthesizer
96,How does the .NET Aspire SQL Server Entity Framework Core integration enhance developer productivity and service observability using Microsoft technologies?,"['<1-hop>\n\ntitle: .NET Aspire SQL Server Entity Framework Core integration description: Learn how to use the .NET Aspire SQL Server Entity Framework integration, which includes both hosting and client integrations. ms.date: 12/02/2024 uid: database/sql-server-ef-core-integration .NET Aspire SQL Server Entity Framework Core integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server Entity Framework Core integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server Entity Framework Core integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server Entity Framework Core client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.SqlServer"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add SQL Server database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerDbContext. For more information, see Add SQL Server resource and database resource. To retrieve ExampleDbContext object from a service: csharp public class ExampleService(ExampleDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add SQL Server database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichSqlServerDbContext<ExampleDbContext>( connectionName: ""database"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the', '<2-hop>\n\nFramework Specific Instrumentation This instrumentation has only focused on adding OpenTelemetry to our code. For more detailed instrumentation, you can use the OpenTelemetry Instrumentation packages for the specific frameworks that you are using. Flask Install the Flask instrumentation package: console pip install opentelemetry-instrumentation-flask Add the following code to your application: ```python from opentelemetry.instrumentation.flask import FlaskInstrumentor add this line after configure_otel_otlp() call FlaskInstrumentor().instrument() ``` FastAPI Install the FastAPI instrumentation package: console pip install opentelemetry-instrumentation-fastapi Add the following code to your application: ```python from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor add this line after configure_otel_otlp() call FastAPIInstrumentor.instrument_app(app) ``` Start the Aspire dashboard To start the Aspire dashboard in standalone mode, run the following Docker command: bash docker run --rm -it -p 18888:18888 -p 4317:18889 --name aspire-dashboard \\ mcr.microsoft.com/dotnet/aspire-dashboard:9.0 In the Docker logs, the endpoint and key for the dashboard are displayed. Copy the key and navigate to http://localhost:18888 in a web browser. Enter the key to log in to the dashboard. View Structured Logs Navigate around the Python application, and you\'ll see structured logs in the Aspire dashboard. The structured logs page displays logs from your application, and you can filter and search the logs. :::image type=""content"" source=""./media/standalone/aspire-dashboard-python-logs.png"" alt-text=""Screenshot of the Aspire dashboard showing the Python application logs""::: Next steps You have successfully used the .NET Aspire dashboard with a Python application. To learn more about the .NET Aspire dashboard, see the Aspire dashboard overview and how to orchestrate a Python application with the .NET Aspire app host.']","The .NET Aspire SQL Server Entity Framework Core integration enhances developer productivity by providing a seamless way to connect to SQL Server instances using the mcr.microsoft.com/mssql/server container image. It includes hosting and client integrations, with automatic health checks for SQL Server resources using the AspNetCore.HealthChecks.SqlServer NuGet package. For service observability, the integration can be enriched with additional services such as automatic retries, health checks, logging, and telemetry. This is achieved by configuring the DbContext with settings like command timeout and retry policies. Additionally, the integration with the Aspire dashboard allows developers to view structured logs and monitor applications, further enhancing observability.",multi_hop_specific_query_synthesizer
97,How does the Azure SDK impact the ability to run Azure services locally in containers and provision infrastructure using .NET Aspire?,"[""<1-hop>\n\nLogging The .NET Aspire Azure Queue Storage integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Queue Storage integration emits the following tracing activities using OpenTelemetry: Azure.Storage.Queues.QueueClient Metrics The .NET Aspire Azure Queue Storage integration currently doesn't support metrics by default due to limitations with the Azure SDK. See also Azure Queue Storage docs .NET Aspire integrations .NET Aspire GitHub repo"", '<2-hop>\n\nLocal containers Some Azure services can be run locally in containers. To run an Azure service locally in a container, chain a call to the RunAsContainer method on the Azure resource builder. This method configures the Azure resource to run locally in a container instead of the actual Azure service. Currently, .NET Aspire supports the following Azure services as containers: Hosting integration Details Azure Cache for Redis Call on the IResourceBuilder<AzureRedisCacheResource> to configure it to run locally in a container, based on the docker.io/library/redis image. Azure PostgreSQL Flexible Server Call on the IResourceBuilder<AzurePostgresFlexibleServerResource> to configure it to run locally in a container, based on the docker.io/library/postgres image. Azure SQL Server Call on the IResourceBuilder<AzureSqlServerResource> to configure it to run locally in a container, based on the mcr.microsoft.com/mssql/server image. [!NOTE] Like emulators, calling RunAsContainer on an Azure resource builder doesn\'t impact the publishing manifest. When you publish your app, the generated Bicep file reflects the actual Azure service, not the local container. Understand Azure integration APIs .NET Aspire\'s strength lies in its ability to provide an amazing developer inner-loop. The Azure integrations are no different. They provide a set of common APIs and patterns that are shared across all Azure resources. These APIs and patterns are designed to make it easy to work with Azure resources in a consistent manner. In the preceding containers section, you saw how to run Azure services locally in containers. If you\'re familiar with .NET Aspire, you might wonder how calling AddAzureRedis(""redis"").RunAsContainer() to get a local docker.io/library/redis container differs from AddRedis(""redis"")â€”as they both result in the same local container. The answer is that there\'s no difference when running locally. However, when they\'re published you get different resources: API Run mode Publish mode AddAzureRedis(""redis"").RunAsContainer() Local Redis container Azure Cache for Redis AddRedis(""redis"") Local Redis container Azure Container App with Redis image The same is true for SQL and PostgreSQL services: API Run mode Publish mode AddAzurePostgresFlexibleServer(""postgres"").RunAsContainer() Local PostgreSQL container Azure PostgreSQL Flexible Server AddPostgres(""postgres"") Local PostgreSQL container Azure Container App with PostgreSQL image AddAzureSqlServer(""sql"").RunAsContainer() Local SQL Server container Azure SQL Server AddSqlServer(""sql"") Local SQL Server container Azure Container App with SQL Server image For more information on the difference between run and publish modes, see .NET Aspire app host: Execution context. Infrastructure as code The Azure SDK for .NET provides the ðŸ“¦ Azure.Provisioning NuGet package and a suite of service-specific Azure provisioning packages. These Azure provisioning libraries make it easy to declaratively specify Azure infrastructure natively in .NET. Their APIs enable you to write object-oriented infrastructure in C#, resulting in Bicep. Bicep is a domain-specific language (DSL) for deploying Azure resources declaratively. While it\'s possible to provision Azure resources manually, .NET Aspire simplifies the process by providing a set of APIs to express Azure resources. These APIs are available as extension methods in .NET Aspire Azure hosting libraries, extending the Since .NET Aspire models Azure resources within Azure hosting integrations, the Azure SDK is used to provision these resources. Bicep files are generated that define the Azure resources you need. The generated Bicep files are output alongside the manifest file when you publish your app. There are several ways to influence the generated Bicep files: Azure.Provisioning customization: Configure infrastructure: Customize Azure resource infrastructure. Add Azure infrastructure: Manually add Azure infrastructure to your app host. Use custom Bicep templates: Reference Bicep files: Add a reference to a Bicep file on disk. Reference Bicep inline: Add an inline Bicep template. Local provisioning and Azure.Provisioning To avoid conflating terms and to help disambiguate ""provisioning,"" it\'s important to understand the distinction between local provisioning and Azure provisioning: Local provisioning: By default, when you call any of the Azure hosting integration APIs to add Azure resources, the Azure.Provisioning: Azure.Provisioning refers to the NuGet package, and is a set of libraries that lets you use C# to generate Bicep. The Azure hosting integrations in .NET Aspire use these libraries under the covers to generate Bicep files that define the Azure resources you need. For more information, see Azure.Provisioning customization. Azure.Provisioning customization All .NET Aspire Azure hosting integrations expose various Azure resources, and they\'re all subclasses of the Configure infrastructure Regardless of the Azure resource you\'re working with, to configure its underlying infrastructure, you chain a call to the Consider the following example: :::code language=""csharp"" source=""../snippets/azure/AppHost/Program.ConfigureInfrastructure.cs"" id=""infra""::: The preceding code: Adds a parameter named storage-sku. Adds Azure Storage with the Chains a call to ConfigureInfrastructure to customize the Azure Storage infrastructure: Gets the provisionable resources. Filters to a single Assigns the storage-sku parameter to the This exemplifies flowing an external parameter into the Azure Storage infrastructure, resulting in the generated Bicep file reflecting the desired configuration. Add Azure infrastructure Not all Azure services are exposed as .NET Aspire integrations. While they might be at a later time, you can still provision services that are available in Azure.Provisioning.* libraries. Imagine a scenario where you have worker service that\'s responsible for managing an Azure Container Registry. Now imagine that an app host project takes a dependency on the ðŸ“¦ Azure.Provisioning.ContainerRegistry NuGet package. You can use the AddAzureInfrastructure API to add the Azure Container Registry infrastructure to your app host: :::code language=""csharp"" source=""../snippets/azure/AppHost/Program.AddAzureInfra.cs"" id=""add""::: The preceding code: Calls Provides a configureInfrastructure delegate to customize the Azure Container Registry infrastructure: Instantiates a Adds the Azure Container Registry service to the infra variable. Instantiates a Adds the output to the infra variable. Adds a project named worker to the builder. Chains a call to The functionality demonstrates how to add Azure infrastructure to your app host project, even if the Azure service isn\'t directly exposed as a .NET Aspire integration. It further shows how to flow the output of the Azure Container Registry into the environment of a dependent project. Consider the resulting Bicep file: :::code language=""bicep"" source=""../snippets/azure/AppHost/acr.module.bicep""::: The Bicep file reflects the desired configuration of the Azure Container Registry, as defined by the AddAzureInfrastructure API. Use custom Bicep templates When you\'re targeting Azure as your desired cloud provider, you can use Bicep to define your infrastructure as code.']","The Azure SDK impacts the ability to run Azure services locally in containers by providing APIs that allow developers to configure Azure resources to run locally using the RunAsContainer method. This method is part of the .NET Aspire framework, which supports running services like Azure Cache for Redis, Azure PostgreSQL Flexible Server, and Azure SQL Server in local containers. Additionally, the Azure SDK facilitates infrastructure provisioning through the Azure.Provisioning NuGet package, which allows developers to declaratively specify Azure infrastructure using C# to generate Bicep files. These Bicep files define the necessary Azure resources, enabling a seamless transition from local development to cloud deployment.",multi_hop_specific_query_synthesizer
98,How does the .NET Aspire Azure Functions integration enhance productivity and what are the supported deployment options?,"['<1-hop>\n\ntitle: .NET Aspire Azure Functions integration (Preview) description: Learn how to integrate Azure Functions with .NET Aspire. ms.date: 11/13/2024 zone_pivot_groups: dev-environment .NET Aspire Azure Functions integration (Preview) [!INCLUDE includes-hosting] [!IMPORTANT] The .NET Aspire Azure Functions integration is currently in preview and is subject to change. Azure Functions is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. The .NET Aspire Azure Functions integration enables you to develop, debug, and orchestrate an Azure Functions .NET project as part of the app host. It\'s expected that you\'ve installed the required Azure tooling: :::zone pivot=""visual-studio"" Configure Visual Studio for Azure development with .NET :::zone-end :::zone pivot=""vscode"" Configure Visual Studio Code for Azure development with .NET :::zone-end :::zone pivot=""dotnet-cli"" Install the Azure Functions Core Tools :::zone-end Supported scenarios The .NET Aspire Azure Functions integration has several key supported scenarios. This section outlines the scenarios and provides details related to the implementation of each approach. Supported triggers The following table lists the supported triggers for Azure Functions in the .NET Aspire integration: Trigger Attribute Details Azure Event Hubs trigger EventHubTrigger ðŸ“¦ Aspire.Hosting.Azure.EventHubs Azure Service Bus trigger ServiceBusTrigger ðŸ“¦ Aspire.Hosting.Azure.ServiceBus Azure Storage Blobs trigger BlobTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage Azure Storage Queues trigger QueueTrigger ðŸ“¦ Aspire.Hosting.Azure.Storage HTTP trigger HttpTrigger Supported without any additional resource dependencies. Timer trigger TimerTrigger Supported without any additional resource dependenciesâ€”relies on implicit host storage. [!IMPORTANT] Other Azure Functions triggers and bindings aren\'t currently supported in the .NET Aspire Azure Functions integration. Deployment Currently, deployment is supported only to containers on Azure Container Apps (ACA) using the SDK container publish function in Microsoft.Azure.Functions.Worker.Sdk. This deployment methodology doesn\'t currently support KEDA-based autoscaling. Configure external HTTP endpoints To make HTTP triggers publicly accessible, call the', '<2-hop>\n\nclient integration registers the OpenAIClient as a singleton service in the service collection. The client can be used to interact with the OpenAI REST API. ðŸ“¦ Aspire.OpenAI (Preview) Moreover, the already available .NET Aspire Azure OpenAI integration was improved to provide a flexible way to configure an OpenAIClient for either an Azure AI OpenAI service or a dedicated OpenAI REST API one with the new csharp builder.AddOpenAIClientFromConfiguration(""openai""); For instance, if the openai connection looked like Endpoint=https://{account}.azure.com;Key={key}; it would guess it can register an Azure AI OpenAI client because of the domain name. Otherwise a common OpenAIClient would be used. Read Azure-agnostic client resolution for more details. MongoDB Added support for specifying the MongoDB username and password when using the ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""mongousername""); var password = builder.AddParameter(""mongopassword"", secret: true); var db = builder.AddMongo(""db"", username, password); ``` Important Azure improvements The following sections describe Azure improvements added in .NET Aspire 9. For a complete listing of all the breaking changes, see Breaking changes in .NET Aspire 9. Azure resource customization In .NET Aspire 8, customizing Azure resources were marked experimental because the underlying Azure.Provisioning libraries were new and gathering feedback before they could be marked stable. In .NET Aspire 9 these APIs were updated and removes the experimental attribute. Azure Resource naming breaking change As part of the update to the ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.Services.Configure Azure SQL, PostgreSQL, and Redis Update Azure SQL, PostgreSQL, and Redis resources are different than other Azure resources because there are local container resources for these technologies. In .NET Aspire 8, in order to create these Azure resources you needed to start with a local container resource and then either ""As"" or ""PublishAs"" it to an Azure resource. This design introduced problems and didn\'t fit with other APIs. For example, you might have this code in .NET Aspire 8: ```csharp var builder = DistributedApplication.CreateBuilder(args); var sql = builder.AddSqlServer(""sql"") .PublishAsAzureSqlDatabase(); var pgsql = builder.AddPostgres(""pgsql"") .PublishAsAzurePostgresFlexibleServer(); var cache = builder.AddRedis(""cache"") .PublishAsAzureSqlDatabase(); ``` In .NET Aspire 9 these APIs were marked as obsolete and a new API pattern implemented: ```csharp var builder = DistributedApplication.CreateBuilder(args); var sql = builder.AddAzureSqlServer(""sql"") .RunAsContainer(); var pgsql = builder.AddAzurePostgresFlexibleServer(""pgsql"") .RunAsContainer(); var cache = builder.AddAzureRedis(""cache"") .RunAsContainer(); ``` Microsoft Entra ID by default In order to make .NET Aspire applications more secure, Azure Database for PostgreSQL and Azure Cache for Redis resources were updated to use Microsoft Entra ID by default. This requires changes to applications that need to connect to these resources. See the following for updating applications to use Microsoft Entra ID to connect to these resources: Azure Database for PostgreSQL Azure Cache for Redis The following examples demonstrate how to configure your application to connect to the Azure resources using Microsoft Entra ID: .NET Aspire: Azure PostgreSQL hosting integration. .NET Aspire: Azure Redis hosting integration. If you need to use password or access key authentication (not recommended), you can opt-in with the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var pgsql = builder.AddAzurePostgresFlexibleServer(""pgsql"") .WithPasswordAuthentication(); var cache = builder.AddAzureRedis(""cache"") .WithAccessKeyAuthentication(); ``` Support for Azure Functions (Preview) Support for Azure Functions is one of the most widely requested features on the .NET Aspire issue tracker and we\'re excited to introduce preview support for it in this release. To demonstrate this support, let\'s use .NET Aspire to create and deploy a webhook. To get started, create a new Azure Functions project using the Visual Studio New Project dialog. When prompted, select the Enlist in Aspire orchestration checkbox when creating the project. :::image type=""content"" source=""media/functions-step-1.gif"" lightbox=""media/functions-step-1.gif"" alt-text=""Create new .NET Aspire Azure Functions project.""::: In the app host project, observe that there\'s a PackageReference to the new ðŸ“¦ Aspire.Hosting.Azure.Functions NuGet package: xml <ItemGroup> <PackageReference Include=""Aspire.Hosting.AppHost"" Version=""9.0.0"" /> <PackageReference Include=""Aspire.Hosting.Azure.Functions"" Version=""9.0.0"" /> </ItemGroup> This package provides an ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddAzureFunctionsProject builder.Build().Run(); ``` In this example, the webhook is responsible for translating an input string into Pig Latin. Update the contents of our trigger with the following code: ```csharp using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; using Microsoft.Azure.Functions.Worker; using Microsoft.Extensions.Logging; using System.Text; using FromBodyAttribute = Microsoft.Azure.Functions.Worker.Http.FromBodyAttribute; namespace PigLatinApp; public class Function1(ILogger [Function(""Function1"")] public IActionResult Run( [HttpTrigger(AuthorizationLevel.Anonymous, ""post"")] HttpRequest req, [FromBody] InputText inputText) { logger.LogInformation(""C# HTTP trigger function processed a request.""); var result = TranslateToPigLatin(inputText.Value); return new OkObjectResult(new PigLatinText(result)); } private static string TranslateToPigLatin(string input) { if (string.IsNullOrEmpty(input)) { return input; } var words = input.Split(\' \'); StringBuilder pigLatin = new(); foreach (string word in words) { if (IsVowel(word[0])) { pigLatin.Append(word + ""yay ""); } else { int vowelIndex = FindFirstVowelIndex(word); if (vowelIndex is -1) { pigLatin.Append(word + ""ay ""); } else { pigLatin.Append( word.Substring(vowelIndex) + word.Substring(0, vowelIndex) + ""ay ""); } } } return pigLatin.ToString().Trim(); } private static int FindFirstVowelIndex(string word) { for (var i = 0; i < word.Length; i++) { if (IsVowel(word[i])) { return i; } } return -1; } private static bool IsVowel(char c) => char.ToLower(c) is \'a\' or \'e\' or \'i\' or \'o\' or \'u\'; } ``` Set a breakpoint on the first logger.LogInformation line of the Run method and press F5 to start the Functions host. Once the .NET Aspire dashboard launches, you observe the following: :::image type=""content"" source=""media/functions-dashboard-screenshot.png"" lightbox=""media/functions-dashboard-screenshot.png"" alt-text=""Screenshot of the .NET Aspire running with an Azure Function app.""::: .NET Aspire has: Configured an emulated Azure Storage resource to be used for bookkeeping by the host. Launched the Functions host locally with the target as the Functions project registered. Wired the port defined in launchSettings.json of the functions project for listening. Use your favorite HTTP client of choice to send a request to the trigger and observe the inputs bound from the request body in the debugger. Unix bash curl --request POST \\ --url http://localhost:7282/api/Function1 \\ --header \'Content-Type: application/json\' \\ --data \'{ ""value"": ""Welcome to Azure Functions"" }\' Windows powershell curl --request POST ` --url http://localhost:7282/api/Function1 ` --header \'Content-Type: application/json\' ` --data \'{ ""value"": ""Welcome to Azure Functions"" }\' :::image type=""content"" source=""media/functions-debug-screenshot.png"" lightbox=""media/functions-debug-screenshot.png"" alt-text=""Screenshot of the .NET Aspire dashboard: Debugging an Azure Function app.""::: Now you\'re ready to deploy our application to Azure Container Apps (ACA). Deployment']","The .NET Aspire Azure Functions integration enhances productivity by allowing developers to write less code, maintain less infrastructure, and save on costs through a serverless solution. It enables the development, debugging, and orchestration of an Azure Functions .NET project as part of the app host. Supported deployment options include deploying to containers on Azure Container Apps (ACA) using the SDK container publish function in Microsoft.Azure.Functions.Worker.Sdk, although it currently does not support KEDA-based autoscaling.",multi_hop_specific_query_synthesizer
99,How do you test the app locally using Azure Blob Storage and what logging and tracing activities are involved in the .NET Aspire integration?,"['<1-hop>\n\nRun and test the app locally The sample app is now ready for testing. Verify that the submitted form data is sent to Azure Blob Storage and Azure Queue Storage by completing the following steps: Visual Studio Press the run button at the top of Visual Studio to launch your .NET Aspire project dashboard in the browser. On the resources page, in the aspirestorage.web row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: .NET CLI In a terminal window at the root of your project, use the dotnet run command to start the app: dotnetcli dotnet run --project AspireStorage.AppHost On the resources page, in the aspirestorage row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/support-app.png"" lightbox=""media/support-app.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields and select a simple file to upload. Select the Submit button, and the form submits the support ticket for processing â€” and clears the form. In a separate browser tab, use the Azure portal to navigate to the Storage browser in your Azure Storage Account. Select Containers and then navigate into the Documents container to see the uploaded file. You can verify the message on the queue was processed by looking at the Project logs of the .NET Aspire dashboard, and selecting the aspirestorage.workerservice from the dropdown. :::image type=""content"" source=""media/queue-output.png"" lightbox=""media/queue-output.png"" alt-text=""A screenshot showing the console output of the Worker app.""::: Summary The example app that you built demonstrates persisting blobs from an ASP.NET Core Blazor Web App and processing queues in a .NET Worker Service. Your app connects to Azure Storage using .NET Aspire integrations. The app sends the support tickets to a queue for processing and uploads an attachment to storage. :::zone pivot=""azurite"" Since you choose to use Azurite, there\'s no need to clean up these resources when you\'re done testing them, as you created them locally in the context of an emulator. The emulator enabled you to test your app locally without incurring any costs, as no Azure resources were provisioned or created. :::zone-end :::zone pivot=""azure-portal,azure-cli"" [!INCLUDE clean-up-resources] :::zone-end', ""<2-hop>\n\nLogging The .NET Aspire Azure Blob Storage integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Blob Storage integration emits the following tracing activities using OpenTelemetry: Azure.Storage.Blobs.BlobContainerClient Metrics The .NET Aspire Azure Blob Storage integration currently doesn't support metrics by default due to limitations with the Azure SDK. See also Azure Blob Storage docs .NET Aspire integrations .NET Aspire GitHub repo""]","To test the app locally using Azure Blob Storage, you can run the sample app and verify that the submitted form data is sent to Azure Blob Storage and Azure Queue Storage. This involves launching your .NET Aspire project dashboard in the browser, entering sample data into the form fields, and submitting the form. You can then use the Azure portal to navigate to the Storage browser in your Azure Storage Account to see the uploaded file in the Documents container. The message on the queue can be verified by checking the Project logs of the .NET Aspire dashboard. The .NET Aspire Azure Blob Storage integration uses logging categories such as Azure.Core and Azure.Identity, and emits tracing activities using OpenTelemetry, specifically Azure.Storage.Blobs.BlobContainerClient.",multi_hop_specific_query_synthesizer
100,"How does the Azure Developer CLI (azd) facilitate the use of Bicep templates in deploying .NET Aspire projects, and what role does the Aspire.Hosting.Azure package play in customizing these deployments?","['<1-hop>\n\nGenerate Bicep from .NET Aspire project model Although development teams are free to use azd up (or azd provision and azd deploy) commands for their deployments both for development and production purposes, some teams may choose to generate Bicep files that they can review and manage as part of version control (this also allows these Bicep files to be referenced as part of a larger more complex Azure deployment). azd includes the ability to output the Bicep it uses for provisioning via following command: azdeveloper azd config set alpha.infraSynth on azd infra synth After this command is executed in the starter template example used in this guide, the following files are created in the AppHost project directory: infra/main.bicep: Represents the main entry point for the deployment. infra/main.parameters.json: Used as the parameters for main Bicep (maps to environment variables defined in .azure folder). infra/resources.bicep: Defines the Azure resources required to support the .NET Aspire project model. AspireSample.Web/manifests/containerApp.tmpl.yaml: The container app definition for webfrontend. AspireSample.ApiService/manifests/containerApp.tmpl.yaml: The container app definition for apiservice. The infra\\resources.bicep file doesn\'t contain any definition of the container apps themselves (with the exception of container apps which are dependencies such as Redis and Postgres): ```bicep @description(\'The location used for all deployed resources\') param location string = resourceGroup().location @description(\'Tags that will be applied to all resources\') param tags object = {} var resourceToken = uniqueString(resourceGroup().id) resource managedIdentity \'Microsoft.ManagedIdentity/userAssignedIdentities@2023-01-31\' = { name: \'mi-${resourceToken}\' location: location tags: tags } resource containerRegistry \'Microsoft.ContainerRegistry/registries@2023-07-01\' = { name: replace(\'acr-${resourceToken}\', \'-\', \'\') location: location sku: { name: \'Basic\' } tags: tags } resource caeMiRoleAssignment \'Microsoft.Authorization/roleAssignments@2022-04-01\' = { name: guid(containerRegistry.id, managedIdentity.id, subscriptionResourceId(\'Microsoft.Authorization/roleDefinitions\', \'7f951dda-4ed3-4680-a7ca-43fe172d538d\')) scope: containerRegistry properties: { principalId: managedIdentity.properties.principalId principalType: \'ServicePrincipal\' roleDefinitionId: subscriptionResourceId(\'Microsoft.Authorization/roleDefinitions\', \'7f951dda-4ed3-4680-a7ca-43fe172d538d\') } } resource logAnalyticsWorkspace \'Microsoft.OperationalInsights/workspaces@2022-10-01\' = { name: \'law-${resourceToken}\' location: location properties: { sku: { name: \'PerGB2018\' } } tags: tags } resource containerAppEnvironment \'Microsoft.App/managedEnvironments@2023-05-01\' = { name: \'cae-${resourceToken}\' location: location properties: { appLogsConfiguration: { destination: \'log-analytics\' logAnalyticsConfiguration: { customerId: logAnalyticsWorkspace.properties.customerId sharedKey: logAnalyticsWorkspace.listKeys().primarySharedKey } } } tags: tags } resource cache \'Microsoft.App/containerApps@2023-05-02-preview\' = { name: \'cache\' location: location properties: { environmentId: containerAppEnvironment.id configuration: { service: { type: \'redis\' } } template: { containers: [ { image: \'redis\' name: \'redis\' } ] } } tags: union(tags, {\'aspire-resource-name\': \'cache\'}) } resource locations \'Microsoft.App/containerApps@2023-05-02-preview\' = { name: \'locations\' location: location properties: { environmentId: containerAppEnvironment.id configuration: { service: { type: \'postgres\' } } template: { containers: [ { image: \'postgres\' name: \'postgres\' } ] } } tags: union(tags, {\'aspire-resource-name\': \'locations\'}) } output MANAGED_IDENTITY_CLIENT_ID string = managedIdentity.properties.clientId output AZURE_CONTAINER_REGISTRY_ENDPOINT string = containerRegistry.properties.loginServer output AZURE_CONTAINER_REGISTRY_MANAGED_IDENTITY_ID string = managedIdentity.id output AZURE_CONTAINER_APPS_ENVIRONMENT_ID string = containerAppEnvironment.id output AZURE_CONTAINER_APPS_ENVIRONMENT_DEFAULT_DOMAIN string = containerAppEnvironment.properties.defaultDomain ``` For more information on using Bicep to automate deployments to Azure see, What is Bicep? The definition of the container apps from the .NET service projects is contained within the containerApp/tmpl.yaml files in the manifests directory in each project respectively. Here is an example from the webfrontend project: yml location: {{ .Env.AZURE_LOCATION }} identity: type: UserAssigned userAssignedIdentities: ? ""{{ .Env.AZURE_CONTAINER_REGISTRY_MANAGED_IDENTITY_ID }}"" : {} properties: environmentId: {{ .Env.AZURE_CONTAINER_APPS_ENVIRONMENT_ID }} configuration: activeRevisionsMode: single ingress: external: true targetPort: 8080 transport: http allowInsecure: false registries: - server: {{ .Env.AZURE_CONTAINER_REGISTRY_ENDPOINT }} identity: {{ .Env.AZURE_CONTAINER_REGISTRY_MANAGED_IDENTITY_ID }} template: containers: - image: {{ .Env.SERVICE_WEBFRONTEND_IMAGE_NAME }} name: webfrontend env: - name: AZURE_CLIENT_ID value: {{ .Env.MANAGED_IDENTITY_CLIENT_ID }} - name: ConnectionStrings__cache value: {{ connectionString ""cache"" }} - name: OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES value: ""true"" - name: OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES value: ""true"" - name: services__apiservice__0 value: http://apiservice.internal.{{ .Env.AZURE_CONTAINER_APPS_ENVIRONMENT_DEFAULT_DOMAIN }} - name: services__apiservice__1 value: https://apiservice.internal.{{ .Env.AZURE_CONTAINER_APPS_ENVIRONMENT_DEFAULT_DOMAIN }} tags: azd-service-name: webfrontend aspire-resource-name: webfrontend After executing the azd infra synth command, when azd provision and azd deploy are called they use the Bicep and supporting generated files. [!IMPORTANT] If azd infra synth is called again, it replaces any modified files with freshly generated ones and prompts you for confirmation before doing so. Isolated environments for debugging Because azd makes it easy to provision new environments, it\'s possible for each team member to have an isolated cloud-hosted environment for debugging code in a setting that closely matches production. When doing this each team member should create their own environment using the following command: azdeveloper azd env new This will prompt the user for subscription and resource group information again and subsequent azd up, azd provision, and azd deploy invocations will use this new environment by default. The --environment switch can be applied to these commands to switch between environments. [!INCLUDE clean-up-resources]', '<2-hop>\n\nIt aims to drastically simplify the authoring experience with a cleaner syntax and better support for modularity and code reuse. While .NET Aspire provides a set of prebuilt Bicep templates, there might be times when you either want to customize the templates or create your own. This section explains the concepts and corresponding APIs that you can use to customize the Bicep templates. [!IMPORTANT] This section isn\'t intended to teach you Bicep, but rather to provide guidance on how to create custom Bicep templates for use with .NET Aspire. As part of the Azure deployment story for .NET Aspire, the Azure Developer CLI (azd) provides an understanding of your .NET Aspire project and the ability to deploy it to Azure. The azd CLI uses the Bicep templates to deploy the application to Azure. Install Aspire.Hosting.Azure package When you want to reference Bicep files, it\'s possible that you\'re not using any of the Azure hosting integrations. In this case, you can still reference Bicep files by installing the Aspire.Hosting.Azure package. This package provides the necessary APIs to reference Bicep files and customize the Azure resources. [!TIP] If you\'re using any of the Azure hosting integrations, you don\'t need to install the Aspire.Hosting.Azure package, as it\'s a transitive dependency. To use any of this functionality, the ðŸ“¦ Aspire.Hosting.Azure NuGet package must be installed: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. What to expect from the examples All the examples in this section assume that you\'re using the ```csharp using Aspire.Hosting.Azure; var builder = DistributedApplication.CreateBuilder(args); // Examples go here... builder.Build().Run(); ``` By default, when you call any of the Bicep-related APIs, a call is also made to Reference Bicep files Imagine that you have a Bicep template in a file named storage.bicep that provisions an Azure Storage Account: :::code language=""bicep"" source=""snippets/AppHost.Bicep/storage.bicep""::: To add a reference to the Bicep file on disk, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.ReferenceBicep.cs"" id=""addfile""::: The preceding code adds a reference to a Bicep file located at ../infra/storage.bicep. The file paths should be relative to the app host project. This reference results in an Reference Bicep inline While having a Bicep file on disk is the most common scenario, you can also add Bicep templates inline. Inline templates can be useful when you want to define a template in code or when you want to generate the template dynamically. To add an inline Bicep template, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.InlineBicep.cs"" id=""addinline""::: In this example, the Bicep template is defined as an inline string and added to the application\'s resources collection with the name ""ai"". This example provisions an Azure AI resource. Pass parameters to Bicep templates Bicep supports accepting parameters, which can be used to customize the behavior of the template. To pass parameters to a Bicep template from .NET Aspire, chain calls to the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.PassParameter.cs"" id=""addparameter""::: The preceding code: Adds a parameter named ""region"" to the builder instance. Adds a reference to a Bicep file located at ../infra/storage.bicep. Passes the ""region"" parameter to the Bicep template, which is resolved using the standard parameter resolution. Passes the ""storageName"" parameter to the Bicep template with a hardcoded value. Passes the ""tags"" parameter to the Bicep template with an array of strings. For more information, see External parameters. Well-known parameters .NET Aspire provides a set of well-known parameters that can be passed to Bicep templates. These parameters are used to provide information about the application and the environment to the Bicep templates. The following well-known parameters are available: Field Description Value The name of the key vault resource used to store secret outputs. ""keyVaultName"" The location of the resource. This is required for all resources. ""location"" The resource ID of the log analytics workspace. ""logAnalyticsWorkspaceId"" The principal ID of the current user or managed identity. ""principalId"" The principal name of the current user or managed identity. ""principalName"" The principal type of the current user or managed identity. Either User or ServicePrincipal . ""principalType"" To use a well-known parameter, pass the parameter name to the Consider an example where you want to set up an Azure Event Grid webhook. You might define the Bicep template as follows: :::code language=""bicep"" source=""snippets/AppHost.Bicep/event-grid-webhook.bicep"" highlight=""3-4,27-35""::: This Bicep template defines several parameters, including the topicName, webHookEndpoint, principalId, principalType, and the optional location. To pass these parameters to the Bicep template, you can use the following code snippet: :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.PassParameter.cs"" id=""addwellknownparams""::: The webHookApi project is added as a reference to the builder. The topicName parameter is passed a hardcoded name value. The webHookEndpoint parameter is passed as an expression that resolves to the URL from the api project references\' ""https"" endpoint with the /hook route. The principalId and principalType parameters are passed as well-known parameters. The well-known parameters are convention-based and shouldn\'t be accompanied with a corresponding value when passed using the WithParameter API. Well-known parameters simplify some common functionality, such as role assignments, when added to the Bicep templates, as shown in the preceding example. Role assignments are required for the Event Grid webhook to send events to the specified endpoint. For more information, see Event Grid Data Sender role assignment. Get outputs from Bicep references In addition to passing parameters to Bicep templates, you can also get outputs from the Bicep templates. Consider the following Bicep template, as it defines an output named endpoint: :::code language=""bicep"" source=""snippets/AppHost.Bicep/storage-out.bicep""::: The Bicep defines an output named endpoint. To get the output from the Bicep template, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.GetOutputReference.cs"" id=""getoutput""::: In this example, the output from the Bicep template is retrieved and stored in an endpoint variable. Typically, you would pass this output as an environment variable to another resource that relies on it. For instance, if you had an ASP.NET Core Minimal API project that depended on this endpoint, you could pass the output as an environment variable to the project using the following code snippet: ```csharp var storage = builder.AddBicepTemplate( name: ""storage"", bicepFile: ""../infra/storage.bicep"" );']","The Azure Developer CLI (azd) facilitates the use of Bicep templates in deploying .NET Aspire projects by providing an understanding of the project and the ability to deploy it to Azure using Bicep templates. The azd CLI includes commands such as 'azd infra synth' to generate Bicep files, which are then used in the 'azd provision' and 'azd deploy' commands to manage deployments. These Bicep files can be reviewed and managed as part of version control, allowing for complex Azure deployments. The Aspire.Hosting.Azure package plays a role in customizing these deployments by providing the necessary APIs to reference and customize Bicep files. This package allows developers to add references to Bicep files, pass parameters, and retrieve outputs, enabling a more modular and reusable approach to defining Azure resources. It also supports inline Bicep templates and well-known parameters, which simplify common functionalities such as role assignments.",multi_hop_specific_query_synthesizer
101,How does the .NET Aspire integration enhance developer productivity and observability when using Azure Cosmos DB?,"['<1-hop>\n\nlibrary for interacting with Azure App Configuration . - Learn more : ðŸ“„ Azure Application Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ApplicationInsights - Client : N/A A library for interacting with Azure Application Insights . - Learn more : ðŸ“„ Azure Cosmos DB - EF Core - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos A library for accessing Azure Cosmos DB databases with Entity Framework Core . - Learn more : ðŸ“„ Azure Cosmos DB - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CosmosDB - Client : ðŸ“¦ Aspire.Microsoft.Azure.Cosmos A library for accessing Azure Cosmos DB databases. - Learn more : ðŸ“„ Azure Event Hubs - Hosting : ðŸ“¦ Aspire.Hosting.Azure.EventHubs - Client : ðŸ“¦ Aspire.Azure.Messaging.EventHubs A library for accessing Azure Event Hubs . - Learn more : ðŸ“„ Azure Functions - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Functions - Client : N/A A library for integrating with Azure Functions . - Learn more : ðŸ“„ Azure Key Vault - Hosting : ðŸ“¦ Aspire.Hosting.Azure.KeyVault - Client : ðŸ“¦ Aspire.Azure.Security.KeyVault A library for accessing Azure Key Vault . - Learn more : ðŸ“„ Azure Operational Insights - Hosting : ðŸ“¦ Aspire.Hosting.Azure.OperationalInsights - Client : N/A A library for interacting with Azure Operational Insights . - Learn more : ðŸ“„ Azure AI OpenAI - Hosting : ðŸ“¦ Aspire.Hosting.Azure.CognitiveServices - Client : ðŸ“¦ Aspire.Azure.AI.OpenAI A library for accessing Azure AI OpenAI or OpenAI functionality. - Learn more : ðŸ“„ Azure PostgreSQL - Hosting : ðŸ“¦ Aspire.Hosting.Azure.PostgreSQL - Client : N/A A library for interacting with Azure Database for PostgreSQL . - Learn more : ðŸ“„ Azure AI Search - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Search - Client : ðŸ“¦ Aspire.Azure.Search.Documents A library for accessing Azure AI Search functionality. - Learn more : ðŸ“„ Azure Service Bus - Hosting : ðŸ“¦ Aspire.Hosting.Azure.ServiceBus - Client : ðŸ“¦ Aspire.Azure.Messaging.ServiceBus A library for accessing Azure Service Bus . - Learn more : ðŸ“„ Azure SignalR Service - Hosting : ðŸ“¦ Aspire.Hosting.Azure.SignalR - Client : Microsoft.Azure.SignalR A library for accessing Azure SignalR Service . - Learn more : ðŸ“„ Azure Blob Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Blobs A library for accessing Azure Blob Storage . - Learn more : ðŸ“„ Azure Storage Queues - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Storage.Queues A library for accessing Azure Storage Queues . - Learn more : ðŸ“„ Azure Table Storage - Hosting : ðŸ“¦ Aspire.Hosting.Azure.Storage - Client : ðŸ“¦ Aspire.Azure.Data.Tables A library for accessing the Azure Table service. - Learn more : ðŸ“„ Azure Web PubSub - Hosting : ðŸ“¦ Aspire.Hosting.Azure.WebPubSub - Client : ðŸ“¦ Aspire.Azure.Messaging.WebPubSub A library for accessing the Azure Web PubSub service. Amazon Web Services (AWS) hosting integrations Integration docs and NuGet packages Description - Learn more : ðŸ“„ AWS Hosting - Hosting : ðŸ“¦ Aspire.Hosting.AWS - Client : N/A A library for modeling AWS resources . For more information, see GitHub: Aspire.Hosting.AWS library. Community Toolkit integrations [!NOTE] The Community Toolkit integrations are community-driven and maintained by the .NET Aspire community. These integrations are not officially supported by the .NET Aspire team. Integration docs and NuGet packages Description - Learn More : ðŸ“„ Azure Static Web Apps emulator - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps - Client : N/A A hosting integration for the Azure Static Web Apps emulator (Note: this does not support deployment of a project to Azure Static Web Apps). - Learn More : ðŸ“„ Bun hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Bun - Client : N/A A hosting integration for Bun apps. - Learn More : ðŸ“„ Deno hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Deno - Client : N/A A hosting integration for Deno apps. - Learn More : ðŸ“„ Go hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Golang - Client : N/A A hosting integration for Go apps. - Learn More : ðŸ“„ Java/Spring hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Java - Client : N/A A integration for running Java code in .NET Aspire either using the local JDK or using a container. - Learn More : ðŸ“„ Node.js hosting extensions - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.NodeJs.Extensions - Client : N/A An integration that contains some additional extensions for running Node.js applications - Learn More : ðŸ“„ Ollama - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Ollama - Client : ðŸ“¦ Aspire.CommunitToolkit.OllamaSharp An Aspire component leveraging the Ollama container with support for downloading a model on startup. - Learn More : ðŸ“„ Meilisearch hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Meilisearch - Client : ðŸ“¦ Aspire.CommunitToolkit.Meilisearch An Aspire component leveraging the Meilisearch container. - Learn More : ðŸ“„ Rust hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.Rust - Client : N/A A hosting integration for Rust apps. - Learn More : ðŸ“„ SQL Database projects hosting - Hosting : ðŸ“¦ CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects - Client : N/A An Aspire hosting integration for SQL Database Projects. For more information, see .NET Aspire Community Toolkit.', '<2-hop>\n\nLogging The .NET Aspire Azure Cosmos DB integration uses the following log categories: Azure-Cosmos-Operation-Request-Diagnostics In addition to getting Azure Cosmos DB request diagnostics for failed requests, you can configure latency thresholds to determine which successful Azure Cosmos DB request diagnostics will be logged. The default values are 100 ms for point operations and 500 ms for non point operations. csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => { clientOptions.CosmosClientTelemetryOptions = new() { CosmosThresholdOptions = new() { PointOperationLatencyThreshold = TimeSpan.FromMilliseconds(50), NonPointOperationLatencyThreshold = TimeSpan.FromMilliseconds(300) } }; }); Tracing The .NET Aspire Azure Cosmos DB integration will emit the following tracing activities using OpenTelemetry: Azure.Cosmos.Operation Azure Cosmos DB tracing is currently in preview, so you must set the experimental switch to ensure traces are emitted. csharp AppContext.SetSwitch(""Azure.Experimental.EnableActivitySource"", true); For more information, see Azure Cosmos DB SDK observability: Trace attributes. Metrics The .NET Aspire Azure Cosmos DB integration currently doesn\'t support metrics by default due to limitations with the Azure SDK. See also Azure Cosmos DB .NET Aspire integrations overview .NET Aspire Azure integrations overview .NET Aspire GitHub repo']","The .NET Aspire integration enhances developer productivity and observability when using Azure Cosmos DB by providing libraries for accessing Azure Cosmos DB databases with Entity Framework Core and direct client access. It supports logging through categories like Azure-Cosmos-Operation-Request-Diagnostics, allowing configuration of latency thresholds for logging successful and failed requests. Additionally, it offers tracing capabilities using OpenTelemetry, although tracing is currently in preview and requires setting an experimental switch. These features collectively improve the ability to monitor and optimize Azure Cosmos DB operations within cloud-native applications.",multi_hop_specific_query_synthesizer
