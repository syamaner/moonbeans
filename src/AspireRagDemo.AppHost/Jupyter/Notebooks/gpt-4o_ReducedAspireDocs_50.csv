,user_input,reference_contexts,reference,synthesizer_name
0,Cud yu pleese explane wut the NpgSqlHealthCheck duz in the .NET Aspire PostgreSQL integrashun?,"['title: .NET Aspire PostgreSQL integration description: Learn how to integrate PostgreSQL with .NET Aspire applications, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-integration .NET Aspire PostgreSQL integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL client integration, install the ðŸ“¦ Aspire.Npgsql NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The PostgreSQL client integration registers an NpgsqlDataSource instance that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql PackageReference xml <PackageReference Include=""Aspire.Npgsql"" Version=""*"" /> Add Npgsql client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDataSource(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding NpgsqlDataSource to the builder, you can get the NpgsqlDataSource instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(NpgsqlDataSource dataSource) { // Use dataSource... } For more information on dependency injection, see .NET dependency injection. Add keyed Npgsql client There might be situations where you want to register multiple NpgsqlDataSource instances with different connection names. To register keyed Npgsql clients, call the csharp builder.AddKeyedNpgsqlDataSource(name: ""chat""); builder.AddKeyedNpgsqlDataSource(name: ""queue""); Then you can retrieve the NpgsqlDataSource instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] NpgsqlDataSource chatDataSource, [FromKeyedServices(""queue"")] NpgsqlDataSource queueDataSource) { // Use data sources... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire PostgreSQL integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddNpgsqlDataSource(""postgresdb""); Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""postgresdb"": ""Host=myserver;Database=postgresdb"" } } For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DisableHealthChecks"": false, ""DisableTracing"": true, ""DisableMetrics"": false } } } For the complete PostgreSQL client integration JSON schema, see Aspire.Npgsql/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks: csharp builder.AddNpgsqlDataSource( ""postgresdb"", static settings => settings.DisableHealthChecks = true); [!INCLUDE integration-health-checks] Adds the NpgSqlHealthCheck, which verifies that commands can be successfully executed against the underlying Postgres Database. Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]']","The NpgSqlHealthCheck verifies that commands can be successfully executed against the underlying Postgres Database. It integrates with the /health HTTP endpoint, which specifies that all registered health checks must pass for the app to be considered ready to accept traffic.",single_hop_specifc_query_synthesizer
1,"Could you elaborate on the logging, tracing, and metrics capabilities provided by the .NET Aspire PostgreSQL integration, particularly in the context of cloud-native application development?",['Logging The .NET Aspire PostgreSQL integration uses the following log categories: Npgsql.Connection Npgsql.Command Npgsql.Transaction Npgsql.Copy Npgsql.Replication Npgsql.Exception Tracing The .NET Aspire PostgreSQL integration will emit the following Tracing activities using OpenTelemetry: Npgsql Metrics The .NET Aspire PostgreSQL integration will emit the following metrics using OpenTelemetry: Npgsql: ec_Npgsql_bytes_written_per_second ec_Npgsql_bytes_read_per_second ec_Npgsql_commands_per_second ec_Npgsql_total_commands ec_Npgsql_current_commands ec_Npgsql_failed_commands ec_Npgsql_prepared_commands_ratio ec_Npgsql_connection_pools ec_Npgsql_multiplexing_average_commands_per_batch ec_Npgsql_multiplexing_average_write_time_per_batch [!INCLUDE postgresql-flexible-server] [!INCLUDE azure-postgresql-client] See also PostgreSQL docs .NET Aspire integrations .NET Aspire GitHub repo'],"The .NET Aspire PostgreSQL integration provides logging capabilities through various log categories such as Npgsql.Connection, Npgsql.Command, Npgsql.Transaction, Npgsql.Copy, Npgsql.Replication, and Npgsql.Exception. For tracing, it emits activities using OpenTelemetry. The integration also offers metrics using OpenTelemetry, including ec_Npgsql_bytes_written_per_second, ec_Npgsql_bytes_read_per_second, ec_Npgsql_commands_per_second, ec_Npgsql_total_commands, ec_Npgsql_current_commands, ec_Npgsql_failed_commands, ec_Npgsql_prepared_commands_ratio, ec_Npgsql_connection_pools, ec_Npgsql_multiplexing_average_commands_per_batch, and ec_Npgsql_multiplexing_average_write_time_per_batch.",single_hop_specifc_query_synthesizer
2,How can I configure MicrosoftDataSqlClientSettings to disable health checks in a .NET Aspire SQL Server integration?,"['title: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","To disable health checks in a .NET Aspire SQL Server integration, you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate inline. For example, you can use the following code: builder.AddSqlServerClient(""database"", static settings => settings.DisableHealthChecks = true);",single_hop_specifc_query_synthesizer
3,how does .NET Aspire work with SQL Server for logging and metrics and tracing?,"[""Logging The .NET Aspire SQL Server integration currently doesn't enable logging by default due to limitations of the Tracing The .NET Aspire SQL Server integration emits the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.SqlClient Metrics The .NET Aspire SQL Server integration will emit the following metrics using OpenTelemetry: Microsoft.Data.SqlClient.EventSource active-hard-connections hard-connects hard-disconnects active-soft-connects soft-connects soft-disconnects number-of-non-pooled-connections number-of-pooled-connections number-of-active-connection-pool-groups number-of-inactive-connection-pool-groups number-of-active-connection-pools number-of-inactive-connection-pools number-of-active-connections number-of-free-connections number-of-stasis-connections number-of-reclaimed-connections See also Azure SQL Database SQL Server .NET Aspire database containers sample .NET Aspire integrations .NET Aspire GitHub repo""]","The .NET Aspire SQL Server integration does not enable logging by default due to limitations. However, it emits tracing activities using OpenTelemetry, specifically OpenTelemetry.Instrumentation.SqlClient. For metrics, it uses OpenTelemetry to emit various metrics such as active-hard-connections, hard-connects, hard-disconnects, active-soft-connects, soft-connects, soft-disconnects, number-of-non-pooled-connections, number-of-pooled-connections, number-of-active-connection-pool-groups, number-of-inactive-connection-pool-groups, number-of-active-connection-pools, number-of-inactive-connection-pools, number-of-active-connections, number-of-free-connections, number-of-stasis-connections, and number-of-reclaimed-connections.",single_hop_specifc_query_synthesizer
4,How can a Cloud Native Application Developer integrate Oracle servers using .NET technologies?,"['title: .NET Aspire Oracle Entity Framework Core integration description: Learn how to use the .NET Aspire Oracle Entity Framework Core integration, which includes both hosting and client integrations. ms.date: 01/21/2025 uid: database/oracle-entity-framework-integration .NET Aspire Oracle Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Oracle Database is a widely-used relational database management system owned and developed by Oracle. The .NET Aspire Oracle Entity Framework Core integration enables you to connect to existing Oracle servers or create new servers from .NET with the container-registry.orcale.com/databse/free container image. Hosting integration The .NET Aspire Oracle hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Oracle PackageReference xml <PackageReference Include=""Aspire.Hosting.Oracle"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications.']",The .NET Aspire Oracle Entity Framework Core integration allows a Cloud Native Application Developer to connect to existing Oracle servers or create new servers from .NET using the container-registry.oracle.com/database/free container image. The hosting integration models the server as the .NET CLI with the package Aspire.Hosting.Oracle.,single_hop_specifc_query_synthesizer
5,What role does the AspNetCore.HealthChecks.Oracle package play in Oracle hosting integration?,"['Add Oracle server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Oracle database container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the container-registry.oracle.com/database/free image, it creates a new Oracle server on your local machine. A reference to your Oracle resource builder (the oracle variable) is used to add a database. The database is named oracledb and then added to the ExampleProject. The Oracle resource includes a random password generated using the The [!TIP] If you\'d rather connect to an existing Oracle server, call Add Oracle resource with password parameter The Oracle resource includes default credentials with a random password. Oracle supports configuration-based default passwords by using the environment variable ORACLE_PWD. When you want to provide a password explicitly, you can provide it as a parameter: ```csharp var password = builder.AddParameter(""password"", secret: true); var oracle = builder.AddOracle(""oracle"", password) .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddOracle API, and internally assigns the parameter to the ORACLE_PWD environment variable of the Oracle container. The password parameter is usually specified as a user secret: json { ""Parameters"": { ""password"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Oracle resource with data volume To add a data volume to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataVolume() .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracle""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Oracle data outside the lifecycle of its container. The data volume is mounted at the /opt/oracle/oradata path in the Oracle container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add Oracle resource with data bind mount To add a data bind mount to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataBindMount(source: @""C:\\Oracle\\Data""); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Oracle data across container restarts. The data bind mount is mounted at the C:\\Oracle\\Data on Windows (or /Oracle/Data on Unix) path on the host machine in the Oracle container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Oracle hosting integration automatically adds a health check for the Oracle resource. The health check verifies that the Oracle server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Oracle NuGet package.']","The AspNetCore.HealthChecks.Oracle package is used in Oracle hosting integration to automatically add a health check for the Oracle resource, verifying that the Oracle server is running and that a connection can be established to it.",single_hop_specifc_query_synthesizer
6,Wht iz the .NET Aspire Oracle Entity Framework Core integration on GitHub?,"['Client integration You need an Oracle database and connection string for accessing the database. To get started with the .NET Aspire Oracle client integration, install the ðŸ“¦ Aspire.Oracle.EntityFrameworkCore NuGet package in the client-consuming project, that is, the project for the application that uses the Oracle client. The Oracle client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Oracle.EntityFrameworkCore PackageReference xml <PackageReference Include=""Aspire.Oracle.EntityFrameworkCore"" Version=""*"" /> Add Oracle client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(connectionName: ""oracledb""); [!TIP] The connectionName parameter must match the name used when adding the Oracle database resource in the app host project. In other words, when you call AddDatabase and provide a name of oracledb that same name should be used when calling AddOracleDatabaseDbContext. For more information, see Add Oracle server and database resources. You can then retrieve the csharp public class ExampleService(ExampleDbContext context) { // Use database context... } For more information on dependency injection, see .NET dependency injection. Add Oracle database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( connectionName: ""oracledb"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the Configuration The .NET Aspire Oracle Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling builder.AddOracleDatabaseDbContext<TContext>(): csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(""oracleConnection""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""oracleConnection"": ""Data Source=TORCL;User Id=OracleUser;Password=Non-default-P@ssw0rd;"" } } The EnrichOracleDatabaseDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it is called. For more information, see the ODP.NET documentation. Use configuration providers The .NET Aspire Oracle Entity Framework Core integration supports The following is an example of an :::no-loc text=""appsettings.json""::: that configures some of the available options: json { ""Aspire"": { ""Oracle"": { ""EntityFrameworkCore"": { ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableRetry"": false, ""CommandTimeout"": 30 } } } } [!TIP] The CommandTimeout property is in seconds. When set as shown in the preceding example, the timeout is 30 seconds. Use inline delegates You can also pass the Action<OracleEntityFrameworkCoreSettings> delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>( ""oracle"", static settings => settings.DisableHealthChecks = true); or csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( static settings => settings.DisableHealthChecks = true); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the Oracle database to connect to. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. DisableRetry A boolean value that indicates whether command retries should be disabled or not. CommandTimeout The time in seconds to wait for the command to execute. [!INCLUDE integration-health-checks] By default, the .NET Aspire Oracle Entity Framework Core integration handles the following: Checks if the If so, adds the DbContextHealthCheck, which calls EF Core\'s [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Oracle Entity Framework Core integration uses the following log categories: Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Database.Connection Microsoft.EntityFrameworkCore.Database.Transaction Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Migrations Microsoft.EntityFrameworkCore.Model Microsoft.EntityFrameworkCore.Model.Validation Microsoft.EntityFrameworkCore.Query Microsoft.EntityFrameworkCore.Update Tracing The .NET Aspire Oracle Entity Framework Core integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Oracle Entity Framework Core integration currently supports the following metrics: Microsoft.EntityFrameworkCore See also Oracle Database Oracle Database Documentation Entity Framework Core docs .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire Oracle Entity Framework Core integration is mentioned in the context as part of the .NET Aspire integrations, and there is a reference to the .NET Aspire GitHub repo.",single_hop_specifc_query_synthesizer
7,Wht is Qdrant?,"['title: .NET Aspire Qdrant integration description: Learn how to use the .NET Aspire Qdrant integration, which includes both hosting and client integrations. ms.date: 01/13/2025 uid: database/qdrant-integration .NET Aspire Qdrant integration [!INCLUDE includes-hosting-and-client] Qdrant is an open-source vector similarity search engine that efficiently stores, indexes, and searches large-scale vector data. It\'s commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Qdrant integration. The .NET Aspire Qdrant integration enables you to connect to existing Qdrant databases or create new instances with the qdrant/qdrant container image. Hosting integration The Qdrant hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Qdrant PackageReference xml <PackageReference Include=""Aspire.Hosting.Qdrant"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Qdrant resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Qdrant container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the qdrant/qdrant image, it creates a new Qdrant instance on your local machine. The resource is named qdrant and then added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing Qdrant server, call [!TIP] The qdrant/qdrant container image includes a web UI that you can use to explore your vectors and administer the database. To access this tool, start your .NET Aspire solution and then, in the .NET Aspire dashboard, select the endpoint for the Qdrant resource. In your browser\'s address bar, append /dashboard and press Enter. Handling API keys and passing other parameters for the Qdrant resource To connect to Qdrant a client must pass the right API key. In the above code, when .NET Aspire adds a Qdrant resource to your solution, it sets the API key to a random string. If you want to use a specific API key instead, you can pass it as an apiKey parameter: ```csharp var apiKey = builder.AddParameter(""apiKey"", secret: true); var qdrant = builder.AddQdrant(""qdrant"", apiKey); builder.AddProject Qdrant supports configuration-based default API keys by using the environment variable QDRANT__SERVICE__API_KEY. The preceding code gets a parameter to pass to the AddQdrant API, and internally assigns the parameter to the QDRANT__SERVICE__API_KEY environment variable of the Qdrant container. The apiKey parameter is usually specified as a user secret: json { ""Parameters"": { ""apiKey"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Qdrant resource with data volume To add a data volume to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Qdrant data outside the lifecycle of its container. The data volume is mounted at the /qdrant/storage path in the Qdrant container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Qdrant resource with data bind mount To add a data bind mount to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataBindMount(source: @""C:\\Qdrant\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Qdrant data across container restarts. The data bind mount is mounted at the C:\\Qdrant\\Data folder on Windows (or /Qdrant/Data on Unix) on the host machine in the Qdrant container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Qdrant hosting integration automatically adds a health check for the Qdrant resource. The health check verifies that Qdrant is running and that a connection can be established to it.']","Qdrant is an open-source vector similarity search engine that efficiently stores, indexes, and searches large-scale vector data.",single_hop_specifc_query_synthesizer
8,"How can a Cloud Application Developer integrate Qdrant into a .NET project using the Aspire Qdrant client, and what are the key configuration options available?","['Client integration To get started with the .NET Aspire Qdrant client integration, install the ðŸ“¦ Aspire.Qdrant.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Qdrant client. The Qdrant client integration registers a Qdrant.Client.QdrantClient instance that you can use to interact with Qdrant vector data. .NET CLI dotnetcli dotnet add package Aspire.Qdrant.Client PackageReference xml <PackageReference Include=""Aspire.Qdrant.Client"" Version=""*"" /> Add a Qdrant client In the Program.cs file of your client-consuming project, call the csharp builder.AddQdrantClient(""qdrant""); [!TIP] The connectionName parameter must match the name used when adding the Qdrant resource in the app host project. In other words, when you call AddQdrant and provide a name of qdrant that same name should be used when calling AddQdrantClient. For more information, see Add Qdrant resource. You can then retrieve the QdrantClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(QdrantClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Qdrant client There might be situations where you want to register multiple QdrantClient instances with different connection names. To register keyed Qdrant clients, call the csharp builder.AddKeyedQdrantClient(name: ""mainQdrant""); builder.AddKeyedQdrantClient(name: ""loggingQdrant""); Then you can retrieve the QdrantClient instances using dependency injection. For example, to retrieve the connections from an example service: csharp public class ExampleService( [FromKeyedServices(""mainQdrant"")] QdrantClient mainQdrantClient, [FromKeyedServices(""loggingQdrant"")] QdrantClient loggingQdrantClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Qdrant client integration provides multiple options to configure the connection to Qdrant based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddQdrantClient(): csharp builder.AddQdrantClient(""qdrant""); Then .NET Aspire retrieves the connection string from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""qdrant"": ""Endpoint=http://localhost:6334;Key=123456!@#$%"" } } By default the QdrantClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Qdrant client integration supports json { ""Aspire"": { ""Qdrant"": { ""Client"": { ""Endpoint"": ""http://localhost:6334/"", ""Key"": ""123456!@#$%"" } } } } For the complete Qdrant client integration JSON schema, see Aspire.Qdrant.Client/ConfigurationSchema.json. Use inline delegates You can also pass the Action<QdrantClientSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddQdrantClient( ""qdrant"", settings => settings.Key = ""12345!@#$%""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Qdrant integration uses standard .NET logging, and you\'ll see log entries from the following category: Qdrant.Client Tracing The .NET Aspire Qdrant integration doesn\'t currently emit tracing activities because they are not supported by the Qdrant.Client library. Metrics The .NET Aspire Qdrant integration doesn\'t currently emit metrics because they are not supported by the Qdrant.Client library. See also Qdrant Qdrant documentation Qdrant GitHub repo Qdrant .NET SDK .NET Aspire integrations .NET Aspire GitHub repo']","To integrate Qdrant into a .NET project using the Aspire Qdrant client, a Cloud Application Developer should start by installing the Aspire.Qdrant.Client NuGet package in the client-consuming project. This integration registers a Qdrant.Client.QdrantClient instance for interacting with Qdrant vector data. In the Program.cs file, the developer should call builder.AddQdrantClient(""qdrant""); ensuring the connectionName parameter matches the name used when adding the Qdrant resource in the app host project. The QdrantClient instance can be retrieved using dependency injection. For registering multiple QdrantClient instances with different connection names, the developer can use builder.AddKeyedQdrantClient(name: ""mainQdrant""); and builder.AddKeyedQdrantClient(name: ""loggingQdrant"");. Configuration options include using a connection string from the ConnectionStrings configuration section, configuration providers, and inline delegates to set options such as the API key. By default, the QdrantClient uses the gRPC API endpoint, and health checks are enabled for all services. However, the integration does not currently support tracing or metrics.",single_hop_specifc_query_synthesizer
9,How do you seed data in a PostgresQL database using .NET Aspire?,"['title: Seed data in a database using .NET Aspire description: Learn about how to seed database data in .NET Aspire ms.date: 08/12/2024 ms.topic: how-to Seed data in a database using .NET Aspire In this article, you learn how to configure .NET Aspire projects to seed data in a database during app startup. .NET Aspire enables you to seed data using database scripts or Entity Framework Core for common platforms such as SQL Server, PostgreSQL and MySQL. When to seed data Seeding data pre-populates database tables with rows of data so they\'re ready for testing via your app. You may want to seed data for the following scenarios: Manually develop and test different features of your app against a meaningful set of data, such as a product catalog or list of customers. Run test suites to verify that features behave a specific way with a given set of data. Manually seeding data is tedious and time consuming, so you should automate the process when possible. Use volumes to run database scripts for .NET Aspire projects during startup. You can also seed your database using tools like Entity Framework Core, which handles many underlying concerns for you. Understand containerized databases By default, .NET Aspire database integrations rely on containerized databases, which create the following challenges when trying to seed data: .NET Aspire destroys and recreates containers every time the app restarts, which means by default you have to re-seed your database every time the app restarts. Depending on your selected database technology, the new container instance may or may not create a default database, which means you might also have to create the database itself. Even if a default database exists, it most likely will not have the desired name or schema for your specific app. .NET Aspire enables you to resolve these challenges using volumes and a few configurations to seed data effectively. Seed data using volumes and SQL scripts Volumes are the recommended way to automatically seed containerized databases when using SQL scripts. Volumes can store data for multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume mount, which is the physical location on your host. Target: The target path in the container of the data you want to persist. Consider the following volume configuration code from a :::no-loc text=""Program.cs""::: file in a sample AppHost project: csharp var todosDbName = ""Todos""; var todosDb = builder.AddPostgres(""postgres"") .WithEnvironment(""POSTGRES_DB"", todosDbName) .WithBindMount( ""../DatabaseContainers.ApiService/data/postgres"", ""/docker-entrypoint-initdb.d"") .AddDatabase(todosDbName); In this example, the .WithBindMount method parameters configure the following: ../DatabaseContainers.ApiService/data/postgres sets a path to the SQL script in your local project that you want to run in the container to seed data. /docker-entrypoint-initdb.d sets the path to an entry point in the container so your script will be run during container startup. The referenced SQL script located at ../DatabaseContainers.ApiService/data/postgres creates and seeds a Todos table: ```sql -- Postgres init script -- Create the Todos table CREATE TABLE IF NOT EXISTS Todos ( Id SERIAL PRIMARY KEY, Title text UNIQUE NOT NULL, IsComplete boolean NOT NULL DEFAULT false ); -- Insert some sample data into the Todos table INSERT INTO Todos (Title, IsComplete) VALUES (\'Give the dog a bath\', false), (\'Wash the dishes\', false), (\'Do the groceries\', false) ON CONFLICT DO NOTHING; ``` The script runs during startup every time a new container instance is created. Database seeding examples The following examples demonstrate how to seed data using SQL scripts and configurations applied using the .WithBindMount method for different database technologies: [!NOTE] Visit the Database Container Sample App to view the full project and file structure for each database option. SQL Server The configuration code in the .AppHost :::no-loc text=""Program.cs""::: file mounts the required database files and folders and configures an entrypoint so that they run during startup. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""37-49"" ::: The entrypoint.sh script lives in the mounted ./sqlserverconfig project folder and runs when the container starts. The script launches SQL Server and checks that it\'s running. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/sqlserverconfig/entrypoint.sh"" ::: The init.sql SQL script that lives in the mounted ../DatabaseContainers.ApiService/data/sqlserver project folder creates the database and tables. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/sqlserver/init.sql"" ::: PostgreSQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""3-15"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/postgres/init.sql"" ::: MySQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""20-32"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/mysql/init.sql"" :::']",".NET Aspire enables you to seed data in a PostgreSQL database by configuring a volume for each resource container. You use the .WithBindMount method to set the source path to the SQL script in your local project and the target path in the container. The SQL script, located at ../DatabaseContainers.ApiService/data/postgres, creates and seeds a Todos table during container startup.",single_hop_specifc_query_synthesizer
10,How to configure MySQL in a .NET Aspire project?,"['Seed data using Entity Framework Core You can also seed data in .NET Aspire projects using Entity Framework Core by explicitly running migrations during startup. Entity Framework Core handles underlying database connections and schema creation for you, which eliminates the need to use volumes or run SQL scripts during container startup. [!IMPORTANT] These types of configurations should only be done during development, so make sure to add a conditional that checks your current environment context. Add the following code to the :::no-loc text=""Program.cs""::: file of your API Service project. SQL Server ```csharp // Register DbContext class builder.AddSqlServerDbContext var app = builder.Build(); app.MapDefaultEndpoints(); if (app.Environment.IsDevelopment()) { // Retrieve an instance of the DbContext class and manually run migrations during startup using (var scope = app.Services.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService PostgreSQL ```csharp // Register DbContext class builder.AddNpgsqlDbContext var app = builder.Build(); app.MapDefaultEndpoints(); if (app.Environment.IsDevelopment()) { // Retrieve an instance of the DbContext class and manually run migrations during startup using (var scope = app.Services.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService MySQL ```csharp // Register DbContext class builder.AddMySqlDataSource var app = builder.Build(); app.MapDefaultEndpoints(); if (app.Environment.IsDevelopment()) { // Retrieve an instance of the DbContext class and manually run migrations during startup using (var scope = app.Services.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService Next steps Database seeding is useful in a variety of app development scenarios. Try combining these techniques with the resource implementations demonstrated in the following tutorials: Tutorial: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations .NET Aspire orchestration overview']","In a .NET Aspire project, you can configure MySQL by registering the DbContext class using `builder.AddMySqlDataSource`. During development, you can manually run migrations at startup by retrieving an instance of the DbContext class within a development environment check.",single_hop_specifc_query_synthesizer
11,"How can a Cloud Native Application Developer deploy an ASP.NET Core app with a SQL Server database to Azure using .NET Aspire, ensuring perfect integration and configuration?","['title: Deploy a ASP.NET Core app that connects to SQL Server to Azure description: Learn how to deploy a ASP.NET Core app that connects to SQL Server to Azure ms.date: 11/08/2024 ms.topic: how-to Tutorial: Deploy a .NET Aspire project with a SQL Server Database to Azure In this tutorial, you learn to configure an ASP.NET Core app with a SQL Server Database for deployment to Azure. .NET Aspire provides multiple SQL Server integration configurations that provision different database services in Azure. You\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET Core app that is configured to use the .NET Aspire SQL Server integration Configure the app to provision an Azure SQL Database Configure the app to provision a containerized SQL Server database [!NOTE] This document focuses specifically on .NET Aspire configurations to provision and deploy SQL Server resources in Azure. Visit the Azure Container Apps deployment tutorial to learn more about the full .NET Aspire deployment process. [!INCLUDE aspire-prereqs] Create the sample solution Visual Studio At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Aspire and select .NET Aspire - Starter Application. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQL. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Verify that .NET 9.0 is selected and choose Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. .NET CLI In an empty directory, run the following command to create a new .NET Aspire project: dotnetcli dotnet new aspire-starter --output AspireSQL The .NET CLI creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Configure the app for SQL Server deployment .NET Aspire provides two built-in configuration options to streamline SQL Server deployment on Azure: Provision a containerized SQL Server database using Azure Container Apps Provision an Azure SQL Database instance Add the .NET Aspire integration to the app Add the appropriate .NET Aspire integration to the AspireSQL.AppHost project for your desired hosting service. Azure SQL Database Add the ðŸ“¦ Aspire.Hosting.Azure.Sql NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.Azure.Sql SQL Server Container Add the ðŸ“¦ Aspire.Hosting.SqlServer NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Configure the AppHost project Configure the AspireSQL.AppHost project for your desired SQL database service. Azure SQL Database Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeployazure/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The PublishAsAzureSqlDatabase method ensures that tools such as the Azure Developer CLI or Visual Studio create an Azure SQL Database resource during the deployment process. SQL Server Container Replace the contents of the Program.cs file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeploycontainer/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. This configuration also ensures that tools such as the Azure Developer CLI or Visual Studio create a containerized SQL Server instance during the deployment process.']","To deploy an ASP.NET Core app with a SQL Server database to Azure using .NET Aspire, a Cloud Native Application Developer should follow these steps: First, create a basic ASP.NET Core app configured to use the .NET Aspire SQL Server integration. Then, configure the app to provision either an Azure SQL Database or a containerized SQL Server database. For Azure SQL Database, add the Aspire.Hosting.Azure.Sql NuGet package to the AspireSQL.AppHost project and replace the contents of the Program.cs file with the appropriate code to ensure the creation of an Azure SQL Database resource during deployment. For a SQL Server Container, add the Aspire.Hosting.SqlServer NuGet package and replace the Program.cs file contents to configure a containerized SQL Server instance. This setup ensures seamless integration and configuration for deployment on Azure.",single_hop_specifc_query_synthesizer
12,How does the deployment process utilize Azure SQL Database in a .NET Aspire project?,"['Deploy the app Tools such as the Azure Developer CLI (azd) support .NET Aspire SQL Server integration configurations to streamline deployments. azd consumes these settings and provisions properly configured resources for you. [!INCLUDE init-workflow] [!INCLUDE azd-up-workflow] Azure SQL Database The deployment process provisioned an Azure SQL Database resource due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-database.png"" alt-text=""A screenshot showing the deployed Azure SQL Database.""::: SQL Server Container The deployment process created a SQL Server app container due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-container.png"" alt-text=""A screenshot showing the containerized SQL Database.""::: [!INCLUDE clean-up-resources] See also .NET Aspire deployment via Azure Container Apps .NET Aspire Azure Container Apps deployment deep dive Deploy a .NET Aspire project using GitHub Actions']","The deployment process provisions an Azure SQL Database resource due to the .AppHost configuration provided, streamlining the integration with .NET Aspire projects.",single_hop_specifc_query_synthesizer
13,How can I integrate Milvus with .NET Aspire for efficient vector data management?,"[""title: .NET Aspire Milvus database integration description: Learn how to use the .NET Aspire Milvus database integration, which includes both hosting and client integrations. ms.date: 08/22/2024 uid: database/milvus-integration .NET Aspire Milvus database integration [!INCLUDE includes-hosting-and-client] Milvus is an open-source vector database system that efficiently stores, indexes, and searches large-scale vector data. It's commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Milvus database integration. The .NET Aspire Milvus database integration enables you to connect to existing Milvus databases or create new instances with the milvusdb/milvus container image.""]","The .NET Aspire Milvus database integration allows you to connect to existing Milvus databases or create new instances using the milvusdb/milvus container image. Milvus is an open-source vector database system that efficiently stores, indexes, and searches large-scale vector data, commonly used in machine learning, artificial intelligence, and data science applications.",single_hop_specifc_query_synthesizer
14,How is SQL Server integrated with Milvus in .NET applications?,"['Hosting integration The Milvus database hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Milvus PackageReference xml <PackageReference Include=""Aspire.Hosting.Milvus"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Milvus server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithLifetime(ContainerLifetime.Persistent); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Milvus container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the milvusdb/milvus image, it creates a new Milvus instance on your local machine. A reference to your Milvus resource builder (the milvus variable) is used to add a database. The database is named milvusdb and then added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing Milvus server, call Handling credentials and passing other parameters for the Milvus resource The Milvus resource includes default credentials with a username of root and the password Milvus. Milvus supports configuration-based default passwords by using the environment variable COMMON_SECURITY_DEFAULTROOTPASSWORD. To change the default password in the container, pass an apiKey parameter when calling the AddMilvus hosting API: ```csharp var apiKey = builder.AddParameter(""apiKey"", secret: true); var milvus = builder.AddMilvus(""milvus"", apiKey); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddMilvus API, and internally assigns the parameter to the COMMON_SECURITY_DEFAULTROOTPASSWORD environment variable of the Milvus container. The apiKey parameter is usually specified as a user secret: json { ""Parameters"": { ""apiKey"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add a Milvus resource with a data volume To add a data volume to the Milvus service resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithDataVolume(); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Milvus data outside the lifecycle of its container. The data volume is mounted at the /var/lib/milvus path in the SQL Server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add a Milvus resource with a data bind mount To add a data bind mount to the Milvus resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithDataBindMount(source: @""C:\\Milvus\\Data""); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Milvus data across container restarts. The data bind mount is mounted at the C:\\Milvus\\Data on Windows (or /Milvus/Data on Unix) path on the host machine in the Milvus container. For more information on data bind mounts, see Docker docs: Bind mounts. Create an Attu resource Attu is a graphical user interface (GUI) and management tool designed to interact with Milvus and its databases. It includes rich visualization features that can help you investigate and understand your vector data. If you want to use Attu to manage Milvus in your .NET Aspire solution, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithAttu() .WithLifetime(ContainerLifetime.Persistent); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` When you debug the .NET Aspire solution, you\'ll see an Attu container listed in the solution\'s resources. Select the resource\'s endpoint to open the GUI and start managing databases.']","The Milvus data volume is mounted at the /var/lib/milvus path in the SQL Server container, allowing for data persistence outside the container's lifecycle.",single_hop_specifc_query_synthesizer
15,Howw doo I intigrate Milvus with .NET usingg the Aspire Milvus Client?,"['Client integration To get started with the .NET Aspire Milvus client integration, install the ðŸ“¦ Aspire.Milvus.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Milvus database client. The Milvus client integration registers a Milvus.Client.MilvusClient instance that you can use to interact with Milvus databases. .NET CLI dotnetcli dotnet add package Aspire.Milvus.Client PackageReference xml <PackageReference Include=""Aspire.Milvus.Client"" Version=""*"" /> Add a Milvus client In the Program.cs file of your client-consuming project, call the csharp builder.AddMilvusClient(""milvusdb""); [!TIP] The connectionName parameter must match the name used when adding the Milvus database resource in the app host project. In other words, when you call AddDatabase and provide a name of milvusdb that same name should be used when calling AddMilvusClient. For more information, see Add a Milvus server resource and database resource. You can then retrieve the MilvusClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(MilvusClient client) { // Use the Milvus Client... } For more information on dependency injection, see .NET dependency injection. Add a keyed Milvus client There might be situations where you want to register multiple MilvusClient instances with different connection names. To register keyed Milvus clients, call the csharp builder.AddKeyedMilvusClient(name: ""mainDb""); builder.AddKeyedMilvusClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Milvus resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the MilvusClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] MilvusClient mainDbClient, [FromKeyedServices(""loggingDb"")] MilvusClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Milvus client integration provides multiple options to configure the connection to Milvus based on the requirements and conventions of your project. [!TIP] The default use is root and the default password is Milvus. To configure a different password in the Milvus container, see Handling credentials and passing other parameters for the Milvus resource. Use the following techniques to configure consuming client apps in your .NET Aspire solution with the same password or other settings. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddMilvusClient(): csharp builder.AddMilvusClient(""milvus""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""milvus"": ""Endpoint=http://localhost:19530/;Key=root:Non-default-P@ssw0rd"" } } By default the MilvusClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Milvus client integration supports json { ""Aspire"": { ""Milvus"": { ""Client"": { ""Endpoint"": ""http://localhost:19530/"", ""Database"": ""milvusdb"", ""Key"": ""root:Non-default-P@ssw0rd"", ""DisableHealthChecks"": false } } } } For the complete Milvus client integration JSON schema, see Aspire.Milvus.Client/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MilvusSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddMilvusClient( ""milvus"", static settings => settings.Key = ""root:Non-default-P@ssw0rd""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Milvus database integration: Adds the health check when Uses the configured client to perform a HealthAsync. If the result is healthy, the health check is considered healthy, otherwise it\'s unhealthy. Likewise, if there\'s an exception, the health check is considered unhealthy with the error propagating through the health check failure. [!INCLUDE integration-observability-and-telemetry]']","To integrate Milvus with .NET using the Aspire Milvus Client, you need to install the Aspire.Milvus.Client NuGet package in your client-consuming project. Then, in the Program.cs file, call builder.AddMilvusClient(""milvusdb""). Ensure the connectionName parameter matches the name used when adding the Milvus database resource in the app host project. You can retrieve the MilvusClient instance using dependency injection. For multiple instances, use builder.AddKeyedMilvusClient with different connection names. Configuration options include using a connection string from the ConnectionStrings configuration section or passing an Action<MilvusSettings> delegate to set options inline.",single_hop_specifc_query_synthesizer
16,where find Milvus code on GitHub?,"[""Logging The .NET Aspire Milvus database integration uses standard .NET logging, and you'll see log entries from the following category: Milvus.Client Tracing The .NET Aspire Milvus database integration doesn't currently emit tracing activities because they are not supported by the Milvus.Client library. Metrics The .NET Aspire Milvus database integration doesn't currently emit metrics because they are not supported by the Milvus.Client library. See also Milvus Milvus GitHub repo Milvus .NET SDK .NET Aspire integrations .NET Aspire GitHub repo""]",You can find the Milvus code on the Milvus GitHub repo.,single_hop_specifc_query_synthesizer
17,How does .NET Aspire facilitate PostgreSQL integration and deployment on Azure?,"['<1-hop>\n\ntitle: .NET Aspire PostgreSQL integration description: Learn how to integrate PostgreSQL with .NET Aspire applications, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-integration .NET Aspire PostgreSQL integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL client integration, install the ðŸ“¦ Aspire.Npgsql NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The PostgreSQL client integration registers an NpgsqlDataSource instance that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql PackageReference xml <PackageReference Include=""Aspire.Npgsql"" Version=""*"" /> Add Npgsql client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDataSource(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding NpgsqlDataSource to the builder, you can get the NpgsqlDataSource instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(NpgsqlDataSource dataSource) { // Use dataSource... } For more information on dependency injection, see .NET dependency injection. Add keyed Npgsql client There might be situations where you want to register multiple NpgsqlDataSource instances with different connection names. To register keyed Npgsql clients, call the csharp builder.AddKeyedNpgsqlDataSource(name: ""chat""); builder.AddKeyedNpgsqlDataSource(name: ""queue""); Then you can retrieve the NpgsqlDataSource instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] NpgsqlDataSource chatDataSource, [FromKeyedServices(""queue"")] NpgsqlDataSource queueDataSource) { // Use data sources... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire PostgreSQL integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddNpgsqlDataSource(""postgresdb""); Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""postgresdb"": ""Host=myserver;Database=postgresdb"" } } For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DisableHealthChecks"": false, ""DisableTracing"": true, ""DisableMetrics"": false } } } For the complete PostgreSQL client integration JSON schema, see Aspire.Npgsql/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks: csharp builder.AddNpgsqlDataSource( ""postgresdb"", static settings => settings.DisableHealthChecks = true); [!INCLUDE integration-health-checks] Adds the NpgSqlHealthCheck, which verifies that commands can be successfully executed against the underlying Postgres Database. Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nLogging The .NET Aspire PostgreSQL integration uses the following log categories: Npgsql.Connection Npgsql.Command Npgsql.Transaction Npgsql.Copy Npgsql.Replication Npgsql.Exception Tracing The .NET Aspire PostgreSQL integration will emit the following Tracing activities using OpenTelemetry: Npgsql Metrics The .NET Aspire PostgreSQL integration will emit the following metrics using OpenTelemetry: Npgsql: ec_Npgsql_bytes_written_per_second ec_Npgsql_bytes_read_per_second ec_Npgsql_commands_per_second ec_Npgsql_total_commands ec_Npgsql_current_commands ec_Npgsql_failed_commands ec_Npgsql_prepared_commands_ratio ec_Npgsql_connection_pools ec_Npgsql_multiplexing_average_commands_per_batch ec_Npgsql_multiplexing_average_write_time_per_batch [!INCLUDE postgresql-flexible-server] [!INCLUDE azure-postgresql-client] See also PostgreSQL docs .NET Aspire integrations .NET Aspire GitHub repo', '<3-hop>\n\nDeploy the app Tools such as the Azure Developer CLI (azd) support .NET Aspire SQL Server integration configurations to streamline deployments. azd consumes these settings and provisions properly configured resources for you. [!INCLUDE init-workflow] [!INCLUDE azd-up-workflow] Azure SQL Database The deployment process provisioned an Azure SQL Database resource due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-database.png"" alt-text=""A screenshot showing the deployed Azure SQL Database.""::: SQL Server Container The deployment process created a SQL Server app container due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-container.png"" alt-text=""A screenshot showing the containerized SQL Database.""::: [!INCLUDE clean-up-resources] See also .NET Aspire deployment via Azure Container Apps .NET Aspire Azure Container Apps deployment deep dive Deploy a .NET Aspire project using GitHub Actions']",".NET Aspire facilitates PostgreSQL integration by providing hosting and client integration options, allowing developers to connect to existing PostgreSQL databases or create new instances using the docker.io/library/postgres container image. The integration includes health checks and dependency injection for managing NpgsqlDataSource instances. For deployment on Azure, tools like the Azure Developer CLI (azd) support .NET Aspire configurations, streamlining the provisioning of resources such as Azure SQL Databases and SQL Server containers, ensuring that applications are properly configured for cloud environments.",multi_hop_abstract_query_synthesizer
18,"How does the .NET Aspire MongoDB integration facilitate hosting and client integrations, and what role do health checks play in ensuring the reliability of these integrations?","['<1-hop>\n\ntitle: .NET Aspire MongoDB database integration description: Learn how to use the .NET Aspire MongoDB database integration, which includes both hosting and client integrations. ms.date: 12/03/2024 uid: database/mongodb-integration .NET Aspire MongoDB database integration [!INCLUDE includes-hosting-and-client] MongoDB is a NoSQL database that provides high performance, high availability, and easy scalability. The .NET Aspire MongoDB integration enables you to connect to existing MongoDB instances (including MongoDB Atlas) or create new instances from .NET with the docker.io/library/mongo container image Hosting integration The MongoDB server hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.MongoDB PackageReference xml <PackageReference Include=""Aspire.Hosting.MongoDB"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add MongoDB server resource and database resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithLifetime(ContainerLifetime.Persistent); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The MongoDB container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/mongo image, it creates a new MongoDB instance on your local machine. A reference to your MongoDB server resource builder (the mongo variable) is used to add a database. The database is named mongodb and then added to the ExampleProject. The MongoDB server resource includes default credentials: MONGO_INITDB_ROOT_USERNAME: A value of admin. MONGO_INITDB_ROOT_PASSWORD: Random password generated using the When the app host runs, the password is stored in the app host\'s secret store. It\'s added to the Parameters section, for example: json { ""Parameters:mongo-password"": ""<THE_GENERATED_PASSWORD>"" } The name of the parameter is mongo-password, but really it\'s just formatting the resource name with a -password suffix. For more information, see Safe storage of app secrets in development in ASP.NET Core and Add MongoDB server resource with parameters. The [!TIP] If you\'d rather connect to an existing MongoDB server, call', '<2-hop>\n\nAdd MongoDB server resource with data volume To add a data volume to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithDataVolume(); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the MongoDB server data outside the lifecycle of its container. The data volume is mounted at the /data/db path in the MongoDB server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add MongoDB server resource with data bind mount To add a data bind mount to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithDataBindMount(@""C:\\MongoDB\\Data""); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the MongoDB server data across container restarts. The data bind mount is mounted at the C:\\MongoDB\\Data on Windows (or /MongoDB/Data on Unix) path on the host machine in the MongoDB server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add MongoDB server resource with initialization data bind mount To add an initialization folder data bind mount to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithInitBindMount(@""C:\\MongoDB\\Init""); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` The initialization data bind mount is used to initialize the MongoDB server with data. The initialization data bind mount is mounted at the C:\\MongoDB\\Init on Windows (or /MongoDB/Init on Unix) path on the host machine in the MongoDB server container and maps to the /docker-entrypoint-initdb.d path in the MongoDB server container. MongoDB executes the scripts found in this folder, which is useful for loading data into the database. Add MongoDB server resource with parameters When you want to explicitly provide the password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username""); var password = builder.AddParameter(""password"", secret: true); var mongo = builder.AddMongoDB(""mongo"", username, password); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Add MongoDB Express resource MongoDB Express is a web-based MongoDB admin user interface. To add a MongoDB Express resource that corresponds to the docker.io/library/mongo-express container image, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithMongoExpress(); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!TIP] To configure the host port for the The preceding code adds a MongoDB Express resource that is configured to connect to the MongoDB server resource. The default credentials are: ME_CONFIG_MONGODB_SERVER: The name assigned to the parent MongoDBServerResource, in this case it would be mongo. ME_CONFIG_BASICAUTH: A value of false. ME_CONFIG_MONGODB_PORT: Assigned from the primary endpoint\'s target port of the parent MongoDBServerResource. ME_CONFIG_MONGODB_ADMINUSERNAME: The same username as configured in the parent MongoDBServerResource. ME_CONFIG_MONGODB_ADMINPASSWORD: The same password as configured in the parent MongoDBServerResource. Additionally, the WithMongoExpress API exposes an optional configureContainer parameter of type Action<IResourceBuilder<MongoExpressContainerResource>> that you use to configure the MongoDB Express container resource. Hosting integration health checks The MongoDB hosting integration automatically adds a health check for the MongoDB server resource. The health check verifies that the MongoDB server resource is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.MongoDb NuGet package.', '<3-hop>\n\nClient integration To get started with the .NET Aspire MongoDB client integration, install the ðŸ“¦ Aspire.MongoDB.Driver NuGet package in the client-consuming project, that is, the project for the application that uses the MongoDB client. The MongoDB client integration registers a IMongoClient instance that you can use to interact with the MongoDB server resource. If your app host adds MongoDB database resources, the IMongoDatabase instance is also registered. .NET CLI dotnetcli dotnet add package Aspire.MongoDB.Driver PackageReference xml <PackageReference Include=""Aspire.MongoDB.Driver"" Version=""*"" /> Add MongoDB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddMongoDBClient(connectionName: ""mongodb""); [!TIP] The connectionName parameter must match the name used when adding the MongoDB server resource (or the database resource when provided) in the app host project. In other words, when you call AddDatabase and provide a name of mongodb that same name should be used when calling AddMongoDBClient. For more information, see Add MongoDB server resource and database resource. You can then retrieve the IMongoClient instance using dependency injection. For example, to retrieve the client from an example service: csharp public class ExampleService(IMongoClient client) { // Use client... } The IMongoClient is used to interact with the MongoDB server resource. It can be used to create databases that aren\'t already known to the app host project. When you define a MongoDB database resource in your app host, you could instead require that the dependency injection container provides an IMongoDatabase instance. For more information on dependency injection, see .NET dependency injection. Add keyed MongoDB client There might be situations where you want to register multiple IMongoDatabase instances with different connection names. To register keyed MongoDB clients, call the csharp builder.AddKeyedMongoDBClient(name: ""mainDb""); builder.AddKeyedMongoDBClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your MongoDB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the IMongoDatabase instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] IMongoDatabase mainDatabase, [FromKeyedServices(""loggingDb"")] IMongoDatabase loggingDatabase) { // Use databases... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire MongoDB database integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddMongoDBClient(): csharp builder.AddMongoDBClient(""mongo""); The connection string is retrieved from the ConnectionStrings configuration section. Consider the following MongoDB example JSON configuration: json { ""ConnectionStrings"": { ""mongo"": ""mongodb://server:port/test"", } } Alternatively, consider the following MongoDB Atlas example JSON configuration: json { ""ConnectionStrings"": { ""mongo"": ""mongodb+srv://username:password@server.mongodb.net/"", } } For more information on how to format this connection string, see MongoDB: ConnectionString documentation. Use configuration providers The .NET Aspire MongoDB integration supports json { ""Aspire"": { ""MongoDB"": { ""Driver"": { ""ConnectionString"": ""mongodb://server:port/test"", ""DisableHealthChecks"": false, ""HealthCheckTimeout"": 10000, ""DisableTracing"": false }, } } Use inline configurations You can also pass the Action<MongoDBSettings> delegate to set up some or all the options inline: csharp builder.AddMongoDBClient(""mongodb"", static settings => settings.ConnectionString = ""mongodb://server:port/test""); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the MongoDB database database to connect to. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. HealthCheckTimeout An int? value that indicates the MongoDB health check timeout in milliseconds. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. [!INCLUDE integration-health-checks] By default, the .NET Aspire MongoDB client integration handles the following scenarios: Adds a health check when enabled that verifies that a connection can be made commands can be run against the MongoDB database within a certain amount of time. Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire MongoDB database integration uses standard .NET logging, and you see log entries from the following categories: MongoDB[.*]: Any log entries from the MongoDB namespace. Tracing The .NET Aspire MongoDB database integration emits the following Tracing activities using OpenTelemetry: MongoDB.Driver.Core.Extensions.DiagnosticSources Metrics The .NET Aspire MongoDB database integration doesn\'t currently expose any OpenTelemetry metrics. See also MongoDB database .NET Aspire integrations .NET Aspire GitHub repo', ""<4-hop>\n\ntitle: .NET Aspire Milvus database integration description: Learn how to use the .NET Aspire Milvus database integration, which includes both hosting and client integrations. ms.date: 08/22/2024 uid: database/milvus-integration .NET Aspire Milvus database integration [!INCLUDE includes-hosting-and-client] Milvus is an open-source vector database system that efficiently stores, indexes, and searches large-scale vector data. It's commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Milvus database integration. The .NET Aspire Milvus database integration enables you to connect to existing Milvus databases or create new instances with the milvusdb/milvus container image."", '<5-hop>\n\nClient integration To get started with the .NET Aspire Milvus client integration, install the ðŸ“¦ Aspire.Milvus.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Milvus database client. The Milvus client integration registers a Milvus.Client.MilvusClient instance that you can use to interact with Milvus databases. .NET CLI dotnetcli dotnet add package Aspire.Milvus.Client PackageReference xml <PackageReference Include=""Aspire.Milvus.Client"" Version=""*"" /> Add a Milvus client In the Program.cs file of your client-consuming project, call the csharp builder.AddMilvusClient(""milvusdb""); [!TIP] The connectionName parameter must match the name used when adding the Milvus database resource in the app host project. In other words, when you call AddDatabase and provide a name of milvusdb that same name should be used when calling AddMilvusClient. For more information, see Add a Milvus server resource and database resource. You can then retrieve the MilvusClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(MilvusClient client) { // Use the Milvus Client... } For more information on dependency injection, see .NET dependency injection. Add a keyed Milvus client There might be situations where you want to register multiple MilvusClient instances with different connection names. To register keyed Milvus clients, call the csharp builder.AddKeyedMilvusClient(name: ""mainDb""); builder.AddKeyedMilvusClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Milvus resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the MilvusClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] MilvusClient mainDbClient, [FromKeyedServices(""loggingDb"")] MilvusClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Milvus client integration provides multiple options to configure the connection to Milvus based on the requirements and conventions of your project. [!TIP] The default use is root and the default password is Milvus. To configure a different password in the Milvus container, see Handling credentials and passing other parameters for the Milvus resource. Use the following techniques to configure consuming client apps in your .NET Aspire solution with the same password or other settings. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddMilvusClient(): csharp builder.AddMilvusClient(""milvus""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""milvus"": ""Endpoint=http://localhost:19530/;Key=root:Non-default-P@ssw0rd"" } } By default the MilvusClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Milvus client integration supports json { ""Aspire"": { ""Milvus"": { ""Client"": { ""Endpoint"": ""http://localhost:19530/"", ""Database"": ""milvusdb"", ""Key"": ""root:Non-default-P@ssw0rd"", ""DisableHealthChecks"": false } } } } For the complete Milvus client integration JSON schema, see Aspire.Milvus.Client/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MilvusSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddMilvusClient( ""milvus"", static settings => settings.Key = ""root:Non-default-P@ssw0rd""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Milvus database integration: Adds the health check when Uses the configured client to perform a HealthAsync. If the result is healthy, the health check is considered healthy, otherwise it\'s unhealthy. Likewise, if there\'s an exception, the health check is considered unhealthy with the error propagating through the health check failure. [!INCLUDE integration-observability-and-telemetry]', '<6-hop>\n\ntitle: .NET Aspire Azure Service Bus integration description: This article describes the .NET Aspire Azure Service Bus integration features and capabilities ms.topic: how-to ms.date: 08/12/2024 .NET Aspire Azure Service Bus integration Cloud-native apps often require communication with messaging services such as Azure Service Bus. Messaging services help decouple applications and enable scenarios that rely on features such as queues, topics and subscriptions, atomic transactions, load balancing, and more. The .NET Aspire Service Bus integration handles the following concerns to connect your app to Azure Service Bus: A Applies ServiceBusClient configurations either inline through code or through configuration file settings. Prerequisites Azure subscription - create one for free Azure Service Bus namespace, learn more about how to add a Service Bus namespace. Alternatively, you can use a connection string, which is not recommended in production environments. Get started To get started with the .NET Aspire Azure Service Bus integration, install the ðŸ“¦ Aspire.Azure.Messaging.ServiceBus NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Service Bus client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.ServiceBus"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Example usage In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureServiceBusClient(""messaging""); To retrieve the configured csharp public class ExampleService(ServiceBusClient client) { // ... } App host usage To add Azure Service Bus hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.ServiceBus"" Version=""*"" /> In your app host project, register the Service Bus integration and consume the service using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var serviceBus = builder.ExecutionContext.IsPublishMode ? builder.AddAzureServiceBus(""messaging"") : builder.AddConnectionString(""messaging""); builder.AddProject Configuration The .NET Aspire Service Bus integration provides multiple options to configure the ServiceBusClient based on the requirements and conventions of your project. Use configuration providers The Service Bus integration supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""ServiceBus"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Identifier"": ""CLIENT_ID"" } } } } } } If you have set up your configurations in the Aspire:Azure:Messaging:ServiceBus section of your :::no-loc text=""appsettings.json""::: file you can just call the method AddAzureServiceBusClient without passing any parameters. Use inline delegates You can also pass the Action<AzureMessagingServiceBusSettings> delegate to set up some or all the options inline, for example to set the FullyQualifiedNamespace: csharp builder.AddAzureServiceBusClient( ""messaging"", static settings => settings.FullyQualifiedNamespace = ""YOUR_SERVICE_BUS_NAMESPACE""); You can also set up the ServiceBusClientOptions using Action<IAzureClientBuilder<ServiceBusClient, ServiceBusClientOptions>> delegate, the second parameter of the AddAzureServiceBus method. For example to set the ServiceBusClient ID to identify the client: csharp builder.AddAzureServiceBusClient( ""messaging"", static clientBuilder => clientBuilder.ConfigureOptions( static options => options.Identifier = ""CLIENT_ID"")); Configuration options The following configurable options are exposed through the Name Description ConnectionString The connection string used to connect to the Service Bus namespace. Credential The credential used to authenticate to the Service Bus namespace. FullyQualifiedNamespace The fully qualified Service Bus namespace. DisableTracing Disables tracing for the Service Bus client. â€  HealthCheckQueueName The name of the queue used for health checks. â€  HealthCheckTopicName The name of the topic used for health checks. â€  At least one of the name options are mandatory when enabling health checks. [!INCLUDE integration-observability-and-telemetry]']","The .NET Aspire MongoDB integration facilitates hosting and client integrations by allowing developers to connect to existing MongoDB instances or create new ones using the docker.io/library/mongo container image. Hosting integration is achieved by modeling the MongoDB server as a .NET CLI package, enabling the addition of server and database resources to an application host project. Client integration is supported by installing the Aspire.MongoDB.Driver NuGet package, which registers an IMongoClient instance for interacting with the MongoDB server resource. Health checks play a crucial role in ensuring the reliability of these integrations by automatically verifying that the MongoDB server resource is running and that a connection can be established. This is achieved through the AspNetCore.HealthChecks.MongoDb NuGet package, which integrates with the /health HTTP endpoint to ensure all registered health checks pass before the application is considered ready to accept traffic.",multi_hop_abstract_query_synthesizer
19,How can a cloud application developer leverage the .NET Aspire Apache Kafka integration for streaming applications and the .NET Aspire Milvus database integration for managing large-scale vector data in a cloud-native environment?,"['<1-hop>\n\ntitle: .NET Aspire Apache Kafka integration description: Learn how to use the .NET Aspire Apache Kafka client message-broker integration. ms.date: 10/11/2024 uid: messaging/kafka-integration .NET Aspire Apache Kafka integration [!INCLUDE includes-hosting-and-client] Apache Kafka is an open-source distributed event streaming platform. It\'s useful for building real-time data pipelines and streaming applications. The .NET Aspire Apache Kafka integration enables you to connect to existing Kafka instances, or create new instances from .NET with the docker.io/confluentinc/confluent-local container image. Hosting integration The Apache Kafka hosting integration models a Kafka server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Kafka PackageReference xml <PackageReference Include=""Aspire.Hosting.Kafka"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Kafka server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/confluentinc/confluent-local image, it creates a new Kafka server instance on your local machine. A reference to your Kafka server (the kafka variable) is added to the ExampleProject. The Kafka server resource includes default ports The [!TIP] If you\'d rather connect to an existing Kafka server, call Add Kafka UI To add the Kafka UI to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithKafkaUI(); builder.AddProject // After adding all resources, run the app... ``` The Kafka UI is a free, open-source web UI to monitor and manage Apache Kafka clusters. .NET Aspire adds another container image docker.io/provectuslabs/kafka-ui to the app host that runs the Kafka UI. Change the Kafka UI host port To change the Kafka UI host port, chain a call to the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithKafkaUI(kafkaUI => kafkaUI.WithHostPort(9100)); builder.AddProject // After adding all resources, run the app... ``` The Kafka UI is accessible at http://localhost:9100 in the preceding example. Add Kafka server resource with data volume To add a data volume to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Kafka server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/kafka/data path in the Kafka server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Kafka server resource with data bind mount To add a data bind mount to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithDataBindMount( source: @""C:\\Kafka\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Kafka server data across container restarts. The data bind mount is mounted at the C:\\Kafka\\Data on Windows (or /Kafka/Data on Unix) path on the host machine in the Kafka server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Kafka hosting integration automatically adds a health check for the Kafka server resource. The health check verifies that a Kafka producer with the specified connection name is able to connect and persist a topic to the Kafka server. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Kafka NuGet package.', ""<2-hop>\n\ntitle: .NET Aspire Milvus database integration description: Learn how to use the .NET Aspire Milvus database integration, which includes both hosting and client integrations. ms.date: 08/22/2024 uid: database/milvus-integration .NET Aspire Milvus database integration [!INCLUDE includes-hosting-and-client] Milvus is an open-source vector database system that efficiently stores, indexes, and searches large-scale vector data. It's commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Milvus database integration. The .NET Aspire Milvus database integration enables you to connect to existing Milvus databases or create new instances with the milvusdb/milvus container image.""]","A cloud application developer can leverage the .NET Aspire Apache Kafka integration to build streaming applications by connecting to existing Kafka instances or creating new ones using the docker.io/confluentinc/confluent-local container image. This integration allows for the addition of a Kafka server resource to the app host, enabling real-time data pipelines. Additionally, the developer can use the .NET Aspire Milvus database integration to manage large-scale vector data, which is essential for machine learning and AI applications. The Milvus database efficiently stores, indexes, and searches vector data, and can be integrated into the cloud-native environment using the milvusdb/milvus container image. Together, these integrations provide a robust framework for developing applications that require both real-time data streaming and advanced data management capabilities.",multi_hop_abstract_query_synthesizer
20,"How does the .NET Aspire project integrate Angular client modifications to support the weather forecast API, and what role does the Aspire.Hosting.NodeJS NuGet package play in this integration?","[""<1-hop>\n\ntitle: Orchestrate Node.js apps in .NET Aspire description: Learn how to integrate Node.js and npm apps into a .NET Aspire App Host project. ms.date: 11/20/2024 Orchestrate Node.js apps in .NET Aspire In this article, you learn how to use Node.js and Node Package Manager (npm) apps in a .NET Aspire project. The sample app in this article demonstrates Angular, React, and Vue client experiences. The following .NET Aspire APIs exist to support these scenariosâ€”and they're part of the Aspire.Hosting.NodeJS NuGet package: Node.js: npm apps: The difference between these two APIs is that the former is used to host Node.js apps, while the latter is used to host apps that execute from a package.json file's scripts sectionâ€”and the corresponding npm run <script-name> command. [!TIP] The sample source code for this article is available on GitHub, and there are details available on the Code Samples: .NET Aspire with Angular, React and Vue page. [!IMPORTANT] While this article is focused on Single-Page App (SPA) frontend bits, there's an additional Node.js sample available on the Code Samples: .NET Aspire Node.js sample page, that demonstrates how to use Node.js as a server app with express. [!INCLUDE aspire-prereqs] Additionally, you need to install Node.js on your machine. The sample app in this article was built with Node.js version 20.12.2 and npm version 10.5.1. To verify your Node.js and npm versions, run the following commands: nodejs node --version nodejs npm --version To download Node.js (including npm), see the Node.js download page. Clone sample source code To clone the sample source code from GitHub, run the following command: bash git clone https://github.com/dotnet/aspire-samples.git After cloning the repository, navigate to the samples/AspireWithJavaScript folder: bash cd samples/AspireWithJavaScript From this directory, there are six child directories described in the following list: AspireJavaScript.Angular: An Angular app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.AppHost: A .NET Aspire project that orchestrates the other apps in this sample. For more information, see .NET Aspire orchestration overview. AspireJavaScript.MinimalApi: An HTTP API that returns randomly generated weather forecast data. AspireJavaScript.React: A React app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.ServiceDefaults: The default shared project for .NET Aspire projects. For more information, see .NET Aspire service defaults. AspireJavaScript.Vue: A Vue app that consumes the weather forecast API and displays the data in a table. Install client dependencies The sample app demonstrates how to use JavaScript client apps that are built on top of Node.js. Each client app was written either using a npm create template command or manually. The following table lists the template commands used to create each client app, along with the default port: App type Create template command Default port Angular npm create @angular@latest 4200 React Didn't use a template. PORT env var Vue npm create vue@latest 5173 [!TIP] You don't need to run any of these commands, since the sample app already includes the clients. Instead, this is a point of reference from which the clients were created. For more information, see npm-init. To run the app, you first need to install the dependencies for each client. To do so, navigate to each client folder and run npm install (or the install alias npm i) commands. Install Angular dependencies nodejs npm i ./AspireJavaScript.Angular/ For more information on the Angular app, see explore the Angular client. Install React dependencies nodejs npm i ./AspireJavaScript.React/ For more information on the React app, see explore the React client. Install Vue dependencies nodejs npm i ./AspireJavaScript.Vue/ For more information on the Vue app, see explore the Vue client."", '<2-hop>\n\nExplore the Angular client There are several key modifications from the original Angular template. The first is the addition of a proxy.conf.js file. This file is used to proxy requests from the Angular client to the ""weatherapi"" service. :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/proxy.conf.js""::: The .NET Aspire app host sets the services__weatherapi__http__0 environment variable, which is used to resolve the ""weatherapi"" service endpoint. The preceding configuration proxies HTTP requests that start with /api to the target URL specified in the environment variable. The second update is to the package.json file. This file is used to configure the Angular client to run on a different port than the default port. This is achieved by using the PORT environment variable, and the run-script-os npm package to set the port. :::code language=""json"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/package.json""::: The scripts section of the package.json file is used to define the start script. This script is used by the npm start command to start the Angular client app. The start script is configured to use the run-script-os package to set the port, which delegates to the ng serve command passing the appropriate --port switch based on the OS-appropriate syntax. In order to make HTTP calls to the ""weatherapi"" service, the Angular client app needs to be configured to provide the Angular HttpClient for dependency injection. This is achieved by using the provideHttpClient helper function while configuring the application in the app.config.ts file. :::code language=""typescript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/src/app/app.config.ts""::: Finally, the Angular client app needs to call the /api/WeatherForecast endpoint to retrieve the weather forecast data. There are several HTML, CSS, and TypeScript updates, all of which are made to the following files: app.component.css: Update the CSS to style the table. app.component.html: Update the HTML to display the weather forecast data in a table. app.component.ts: Update the TypeScript to call the /api/WeatherForecast endpoint and display the data in the table. :::code language=""typescript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/src/app/app.component.ts""::: Angular app running To visualize the Angular client app, navigate to the ""angular"" endpoint in the .NET Aspire dashboard. The following image depicts the Angular client app: :::image type=""content"" source=""media/angular-app.png"" lightbox=""media/angular-app.png"" alt-text=""Angular client app with fake forecast weather data displayed as a table.""::: Explore the React client The React app wasn\'t written using a template, and instead was written manually. The complete source code can be found in the dotnet/aspire-samples repository. Some of the key points of interest are found in the src/App.js file: :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.React/src/components/App.js""::: The App function is the entry point for the React client app. It uses the useState and useEffect hooks to manage the state of the weather forecast data. The fetch API is used to make an HTTP request to the /api/WeatherForecast endpoint. The response is then converted to JSON and set as the state of the weather forecast data. :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.React/webpack.config.js""::: The preceding code defines the module.exports as follows: The entry property is set to the src/index.js file. The devServer relies on a proxy to forward requests to the ""weatherapi"" service, sets the port to the PORT environment variable, and allows all hosts. The output results in a dist folder with a bundle.js file. The plugins set the src/index.html file as the template, and expose the favicon.ico file. The final updates are to the following files: App.css: Update the CSS to style the table. App.js: Update the JavaScript to call the /api/WeatherForecast endpoint and display the data in the table. React app running To visualize the React client app, navigate to the ""react"" endpoint in the .NET Aspire dashboard. The following image depicts the React client app: :::image type=""content"" source=""media/react-app.png"" lightbox=""media/react-app.png"" alt-text=""React client app with fake forecast weather data displayed as a table.""::: Explore the Vue client There are several key modifications from the original Vue template. The primary updates were the addition of the fetch call in the TheWelcome.vue file to retrieve the weather forecast data from the /api/WeatherForecast endpoint. The following code snippet demonstrates the fetch call: :::code language=""html"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Vue/src/components/TheWelcome.vue""::: As the TheWelcome integration is mounted, it calls the /api/weatherforecast endpoint to retrieve the weather forecast data. The response is then set as the forecasts data property. To set the server port, the Vue client app uses the PORT environment variable. This is achieved by updating the vite.config.ts file: :::code language=""typescript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Vue/vite.config.ts""::: Additionally, the Vite config specifies the server.proxy property to forward requests to the ""weatherapi"" service. This is achieved by using the services__weatherapi__http__0 environment variable, which is set by the .NET Aspire app host. The final update from the template is made to the TheWelcome.vue file. This file calls the /api/WeatherForecast endpoint to retrieve the weather forecast data, and displays the data in a table. It includes CSS, HTML, and TypeScript updates. Vue app running To visualize the Vue client app, navigate to the ""vue"" endpoint in the .NET Aspire dashboard. The following image depicts the Vue client app: :::image type=""content"" source=""media/vue-app.png"" lightbox=""media/vue-app.png"" alt-text=""Vue client app with fake forecast weather data displayed as a table.""::: Deployment considerations The sample source code for this article is designed to run locally. Each client app deploys as a container image. The Dockerfile for each client app is used to build the container image. Each Dockerfile is identical, using a multistage build to create a production-ready container image. :::code language=""dockerfile"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/Dockerfile""::: The client apps are currently configured to run as true SPA apps, and aren\'t configured to run in a server-side rendered (SSR) mode. They sit behind nginx, which is used to serve the static files. They use a default.conf.template file to configure nginx to proxy requests to the client app. :::code language=""nginx"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/default.conf.template""::: Node.js server app considerations While this article focuses on client apps, you might have scenarios where you need to host a Node.js server app. The same semantics are required to host a Node.js server app as a SPA client app. The .NET Aspire app host requires a package reference to the Aspire.Hosting.NodeJS NuGet package and the code needs to call either AddNodeApp or AddNpmApp. These APIs are useful for adding existing JavaScript apps to the .NET Aspire app host. When configuring secrets', '<3-hop>\n\nRun the sample app To run the sample app, call the dotnet run command given the orchestrator app host AspireJavaScript.AppHost.csproj as the --project switch: dotnetcli dotnet run --project ./AspireJavaScript.AppHost/AspireJavaScript.AppHost.csproj The .NET Aspire dashboard launches in your default browser, and each client app endpoint displays under the Endpoints column of the Resources page. The following image depicts the dashboard for this sample app: :::image type=""content"" source=""media/aspire-dashboard-with-nodejs.png"" lightbox=""media/aspire-dashboard-with-nodejs.png"" alt-text="".NET Aspire dashboard with multiple JavaScript client apps.""::: The weatherapi service endpoint resolves to a Swagger UI page that documents the HTTP API. Each client app consumes this service to display the weather forecast data. You can view each client app by navigating to the corresponding endpoint in the .NET Aspire dashboard. Their screenshots and the modifications made from the template starting point are detailed in the following sections. In the same terminal session that you used to run the app, press Ctrl + C to stop the app. Explore the app host To help understand how each client app resource is orchestrated, look to the app host project. The app host requires the Aspire.Hosting.NodeJS NuGet package to host Node.js apps: :::code language=""xml"" highlight=""15,22-30"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.AppHost/AspireJavaScript.AppHost.csproj""::: The project file also defines a build target that ensures that the npm dependencies are installed before the app host is built. The app host code (Program.cs) declares the client app resources using the :::code source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.AppHost/Program.cs""::: The preceding code: Creates a Adds the ""weatherapi"" service as a project to the app host. Marks the HTTP endpoints as external. With a reference to the ""weatherapi"" service, adds the ""angular"", ""react"", and ""vue"" client apps as npm apps. Each client app is configured to run on a different container port, and uses the PORT environment variable to determine the port. All client apps also rely on a Dockerfile to build their container image and are configured to express themselves in the publishing manifest as a container from the For more information on inner-loop networking, see .NET Aspire inner-loop networking overview. For more information on deploying apps, see .NET Aspire manifest format for deployment tool builders. When the app host orchestrates the launch of each client app, it uses the npm run start command. This command is defined in the scripts section of the package.json file for each client app. The start script is used to start the client app on the specified port. Each client app relies on a proxy to request the ""weatherapi"" service. The proxy is configured in: The proxy.conf.js file for the Angular client. The webpack.config.js file for the React client. The vite.config.ts file for the Vue client. and passing environment variables to JavaScript-based apps, whether they are client or server apps, use parameters. For more information, see .NET Aspire: External parametersâ€”secrets. Use the OpenTelemetry JavaScript SDK To export OpenTelemetry logs, traces, and metrics from a Node.js server app, you use the OpenTelemetry JavaScript SDK. For a complete example of a Node.js server app using the OpenTelemetry JavaScript SDK, you can refer to the Code Samples: .NET Aspire Node.js sample page. Consider the sample\'s instrumentation.js file, which demonstrates how to configure the OpenTelemetry JavaScript SDK to export logs, traces, and metrics: :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithNode/NodeFrontend/instrumentation.js""::: [!TIP] To configure the .NET Aspire dashboard OTEL CORS settings, see the .NET Aspire dashboard OTEL CORS settings page. Summary While there are several considerations that are beyond the scope of this article, you learned how to build .NET Aspire projects that use Node.js and Node Package Manager (npm). You also learned how to use the See also Code Samples: .NET Aspire with Angular, React, and Vue Code Samples: .NET Aspire Node.js App']","The .NET Aspire project integrates Angular client modifications to support the weather forecast API by adding a proxy.conf.js file, which proxies requests from the Angular client to the 'weatherapi' service. The .NET Aspire app host sets the services__weatherapi__http__0 environment variable to resolve the 'weatherapi' service endpoint. Additionally, the package.json file is updated to configure the Angular client to run on a different port using the PORT environment variable and the run-script-os npm package. The Angular client app is configured to provide the Angular HttpClient for dependency injection using the provideHttpClient helper function in the app.config.ts file. The Aspire.Hosting.NodeJS NuGet package plays a crucial role by allowing the .NET Aspire app host to orchestrate Node.js apps, including the Angular client, as npm apps. This package is required to host Node.js apps and ensures that npm dependencies are installed before the app host is built, facilitating the integration of JavaScript client apps like Angular into the .NET Aspire project.",multi_hop_abstract_query_synthesizer
21,How does the .NET Aspire Qdrant integration utilize NuGet packages for machine learning applications?,"['<1-hop>\n\ntitle: .NET Aspire Qdrant integration description: Learn how to use the .NET Aspire Qdrant integration, which includes both hosting and client integrations. ms.date: 01/13/2025 uid: database/qdrant-integration .NET Aspire Qdrant integration [!INCLUDE includes-hosting-and-client] Qdrant is an open-source vector similarity search engine that efficiently stores, indexes, and searches large-scale vector data. It\'s commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Qdrant integration. The .NET Aspire Qdrant integration enables you to connect to existing Qdrant databases or create new instances with the qdrant/qdrant container image. Hosting integration The Qdrant hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Qdrant PackageReference xml <PackageReference Include=""Aspire.Hosting.Qdrant"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Qdrant resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Qdrant container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the qdrant/qdrant image, it creates a new Qdrant instance on your local machine. The resource is named qdrant and then added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing Qdrant server, call [!TIP] The qdrant/qdrant container image includes a web UI that you can use to explore your vectors and administer the database. To access this tool, start your .NET Aspire solution and then, in the .NET Aspire dashboard, select the endpoint for the Qdrant resource. In your browser\'s address bar, append /dashboard and press Enter. Handling API keys and passing other parameters for the Qdrant resource To connect to Qdrant a client must pass the right API key. In the above code, when .NET Aspire adds a Qdrant resource to your solution, it sets the API key to a random string. If you want to use a specific API key instead, you can pass it as an apiKey parameter: ```csharp var apiKey = builder.AddParameter(""apiKey"", secret: true); var qdrant = builder.AddQdrant(""qdrant"", apiKey); builder.AddProject Qdrant supports configuration-based default API keys by using the environment variable QDRANT__SERVICE__API_KEY. The preceding code gets a parameter to pass to the AddQdrant API, and internally assigns the parameter to the QDRANT__SERVICE__API_KEY environment variable of the Qdrant container. The apiKey parameter is usually specified as a user secret: json { ""Parameters"": { ""apiKey"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Qdrant resource with data volume To add a data volume to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Qdrant data outside the lifecycle of its container. The data volume is mounted at the /qdrant/storage path in the Qdrant container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Qdrant resource with data bind mount To add a data bind mount to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataBindMount(source: @""C:\\Qdrant\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Qdrant data across container restarts. The data bind mount is mounted at the C:\\Qdrant\\Data folder on Windows (or /Qdrant/Data on Unix) on the host machine in the Qdrant container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Qdrant hosting integration automatically adds a health check for the Qdrant resource. The health check verifies that Qdrant is running and that a connection can be established to it.', '<2-hop>\n\nClient integration To get started with the .NET Aspire Qdrant client integration, install the ðŸ“¦ Aspire.Qdrant.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Qdrant client. The Qdrant client integration registers a Qdrant.Client.QdrantClient instance that you can use to interact with Qdrant vector data. .NET CLI dotnetcli dotnet add package Aspire.Qdrant.Client PackageReference xml <PackageReference Include=""Aspire.Qdrant.Client"" Version=""*"" /> Add a Qdrant client In the Program.cs file of your client-consuming project, call the csharp builder.AddQdrantClient(""qdrant""); [!TIP] The connectionName parameter must match the name used when adding the Qdrant resource in the app host project. In other words, when you call AddQdrant and provide a name of qdrant that same name should be used when calling AddQdrantClient. For more information, see Add Qdrant resource. You can then retrieve the QdrantClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(QdrantClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Qdrant client There might be situations where you want to register multiple QdrantClient instances with different connection names. To register keyed Qdrant clients, call the csharp builder.AddKeyedQdrantClient(name: ""mainQdrant""); builder.AddKeyedQdrantClient(name: ""loggingQdrant""); Then you can retrieve the QdrantClient instances using dependency injection. For example, to retrieve the connections from an example service: csharp public class ExampleService( [FromKeyedServices(""mainQdrant"")] QdrantClient mainQdrantClient, [FromKeyedServices(""loggingQdrant"")] QdrantClient loggingQdrantClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Qdrant client integration provides multiple options to configure the connection to Qdrant based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddQdrantClient(): csharp builder.AddQdrantClient(""qdrant""); Then .NET Aspire retrieves the connection string from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""qdrant"": ""Endpoint=http://localhost:6334;Key=123456!@#$%"" } } By default the QdrantClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Qdrant client integration supports json { ""Aspire"": { ""Qdrant"": { ""Client"": { ""Endpoint"": ""http://localhost:6334/"", ""Key"": ""123456!@#$%"" } } } } For the complete Qdrant client integration JSON schema, see Aspire.Qdrant.Client/ConfigurationSchema.json. Use inline delegates You can also pass the Action<QdrantClientSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddQdrantClient( ""qdrant"", settings => settings.Key = ""12345!@#$%""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Qdrant integration uses standard .NET logging, and you\'ll see log entries from the following category: Qdrant.Client Tracing The .NET Aspire Qdrant integration doesn\'t currently emit tracing activities because they are not supported by the Qdrant.Client library. Metrics The .NET Aspire Qdrant integration doesn\'t currently emit metrics because they are not supported by the Qdrant.Client library. See also Qdrant Qdrant documentation Qdrant GitHub repo Qdrant .NET SDK .NET Aspire integrations .NET Aspire GitHub repo', '<3-hop>\n\ntitle: Deploy a .NET Aspire project that connects to Redis Cache to Azure description: Learn how to deploy a .NET Aspire project that connects to Redis Cache to Azure ms.date: 08/12/2024 ms.topic: how-to Tutorial: Deploy a .NET Aspire project with a Redis Cache to Azure In this tutorial, you learn to configure a .NET Aspire project with a Redis Cache for deployment to Azure. .NET Aspire provides multiple caching integration configurations that provision different Redis services in Azure. You\'ll learn how to: [!div class=""checklist""] Configure the app to provision an Azure Cache for Redis Configure the app to provision a containerized Redis Cache [!NOTE] This document focuses specifically on .NET Aspire configurations to provision and deploy Redis Cache resources in Azure. For more information and to learn more about the full .NET Aspire deployment process, see the Azure Container Apps deployment tutorial. [!INCLUDE aspire-prereqs] Create the sample solution Follow the Tutorial: Implement caching with .NET Aspire integrations to create the sample project. Configure the app for Redis cache deployment .NET Aspire provides two built-in configuration options to streamline Redis Cache deployment on Azure: Provision a containerized Redis Cache using Azure Container Apps Provision an Azure Cache for Redis instance Add the .NET Aspire integration to the app Add the appropriate .NET Aspire integration to the AspireRedis.AppHost project for your desired hosting service. Azure Cache for Redis Add the ðŸ“¦ Aspire.Hosting.Azure.Redis NuGet package to the AspireRedis.AppHost project: dotnetcli dotnet add package Aspire.Hosting.Azure.Redis Redis Container Add the ðŸ“¦ Aspire.Hosting.Redis NuGet package to the AspireRedis.AppHost project: dotnetcli dotnet add package Aspire.Hosting.Redis Configure the AppHost project Configure the AspireRedis.AppHost project for your desired Redis service. Azure Cache for Redis Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireRedis.AppHost project with the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddAzureRedis(""cache""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code adds an Azure Cache for Redis resource to your app and configures a connection called cache. The AddAzureRedis method ensures that tools such as the Azure Developer CLI or Visual Studio create an Azure Cache for Redis resource during the deployment process. Redis Container Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireRedis.AppHost project with the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code adds a Redis Container resource to your app and configures a connection called cache. This configuration also ensures that tools such as the Azure Developer CLI or Visual Studio create a containerized Redis instance during the deployment process. Deploy the app Tools such as the Azure Developer CLI (azd) support .NET Aspire Redis integration configurations to streamline deployments. azd consumes these settings and provisions properly configured resources for you. [!NOTE] You can also use the Azure CLI or Bicep to provision and deploy .NET Aspire project resources. These options require more manual steps, but provide more granular control over your deployments. .NET Aspire projects can also connect to an existing Redis instance through manual configurations. Open a terminal window in the root of your .NET Aspire project. Run the azd init command to initialize the project with azd. azdeveloper azd init When prompted for an environment name, enter docs-aspireredis. Run the azd up command to begin the deployment process: azdeveloper azd up Select the Azure subscription that should host your app resources. Select the Azure location to use. The Azure Developer CLI provisions and deploys your app resources. The process may take a few minutes to complete. When the deployment finishes, click the resource group link in the output to view the created resources in the Azure portal. Azure Cache for Redis The deployment process provisioned an Azure Cache for Redis resource due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-redis.png"" alt-text=""A screenshot showing the deployed Azure Cache for Redis.""::: Redis Container The deployment process created a Redis app container due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-redis-container.png"" alt-text=""A screenshot showing the containerized Redis.""::: [!INCLUDE clean-up-resources]']","The .NET Aspire Qdrant integration utilizes NuGet packages to facilitate both hosting and client integrations for machine learning applications. For hosting integration, the Aspire.Hosting.Qdrant package is used to model the server and manage package dependencies in .NET applications. This allows for the creation of new Qdrant instances or connection to existing databases, which are essential for storing and searching large-scale vector data commonly used in machine learning. For client integration, the Aspire.Qdrant.Client NuGet package is installed in the client-consuming project, enabling interaction with Qdrant vector data through a registered QdrantClient instance. This setup supports machine learning applications by providing efficient vector similarity search capabilities.",multi_hop_abstract_query_synthesizer
22,"How can the .NET Aspire Qdrant integration be utilized for machine learning applications, and what role does the NuGet package play in this process?","['<1-hop>\n\ntitle: .NET Aspire Qdrant integration description: Learn how to use the .NET Aspire Qdrant integration, which includes both hosting and client integrations. ms.date: 01/13/2025 uid: database/qdrant-integration .NET Aspire Qdrant integration [!INCLUDE includes-hosting-and-client] Qdrant is an open-source vector similarity search engine that efficiently stores, indexes, and searches large-scale vector data. It\'s commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Qdrant integration. The .NET Aspire Qdrant integration enables you to connect to existing Qdrant databases or create new instances with the qdrant/qdrant container image. Hosting integration The Qdrant hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Qdrant PackageReference xml <PackageReference Include=""Aspire.Hosting.Qdrant"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Qdrant resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Qdrant container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the qdrant/qdrant image, it creates a new Qdrant instance on your local machine. The resource is named qdrant and then added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing Qdrant server, call [!TIP] The qdrant/qdrant container image includes a web UI that you can use to explore your vectors and administer the database. To access this tool, start your .NET Aspire solution and then, in the .NET Aspire dashboard, select the endpoint for the Qdrant resource. In your browser\'s address bar, append /dashboard and press Enter. Handling API keys and passing other parameters for the Qdrant resource To connect to Qdrant a client must pass the right API key. In the above code, when .NET Aspire adds a Qdrant resource to your solution, it sets the API key to a random string. If you want to use a specific API key instead, you can pass it as an apiKey parameter: ```csharp var apiKey = builder.AddParameter(""apiKey"", secret: true); var qdrant = builder.AddQdrant(""qdrant"", apiKey); builder.AddProject Qdrant supports configuration-based default API keys by using the environment variable QDRANT__SERVICE__API_KEY. The preceding code gets a parameter to pass to the AddQdrant API, and internally assigns the parameter to the QDRANT__SERVICE__API_KEY environment variable of the Qdrant container. The apiKey parameter is usually specified as a user secret: json { ""Parameters"": { ""apiKey"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Qdrant resource with data volume To add a data volume to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Qdrant data outside the lifecycle of its container. The data volume is mounted at the /qdrant/storage path in the Qdrant container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Qdrant resource with data bind mount To add a data bind mount to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataBindMount(source: @""C:\\Qdrant\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Qdrant data across container restarts. The data bind mount is mounted at the C:\\Qdrant\\Data folder on Windows (or /Qdrant/Data on Unix) on the host machine in the Qdrant container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Qdrant hosting integration automatically adds a health check for the Qdrant resource. The health check verifies that Qdrant is running and that a connection can be established to it.', '<2-hop>\n\nClient integration To get started with the .NET Aspire Qdrant client integration, install the ðŸ“¦ Aspire.Qdrant.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Qdrant client. The Qdrant client integration registers a Qdrant.Client.QdrantClient instance that you can use to interact with Qdrant vector data. .NET CLI dotnetcli dotnet add package Aspire.Qdrant.Client PackageReference xml <PackageReference Include=""Aspire.Qdrant.Client"" Version=""*"" /> Add a Qdrant client In the Program.cs file of your client-consuming project, call the csharp builder.AddQdrantClient(""qdrant""); [!TIP] The connectionName parameter must match the name used when adding the Qdrant resource in the app host project. In other words, when you call AddQdrant and provide a name of qdrant that same name should be used when calling AddQdrantClient. For more information, see Add Qdrant resource. You can then retrieve the QdrantClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(QdrantClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Qdrant client There might be situations where you want to register multiple QdrantClient instances with different connection names. To register keyed Qdrant clients, call the csharp builder.AddKeyedQdrantClient(name: ""mainQdrant""); builder.AddKeyedQdrantClient(name: ""loggingQdrant""); Then you can retrieve the QdrantClient instances using dependency injection. For example, to retrieve the connections from an example service: csharp public class ExampleService( [FromKeyedServices(""mainQdrant"")] QdrantClient mainQdrantClient, [FromKeyedServices(""loggingQdrant"")] QdrantClient loggingQdrantClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Qdrant client integration provides multiple options to configure the connection to Qdrant based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddQdrantClient(): csharp builder.AddQdrantClient(""qdrant""); Then .NET Aspire retrieves the connection string from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""qdrant"": ""Endpoint=http://localhost:6334;Key=123456!@#$%"" } } By default the QdrantClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Qdrant client integration supports json { ""Aspire"": { ""Qdrant"": { ""Client"": { ""Endpoint"": ""http://localhost:6334/"", ""Key"": ""123456!@#$%"" } } } } For the complete Qdrant client integration JSON schema, see Aspire.Qdrant.Client/ConfigurationSchema.json. Use inline delegates You can also pass the Action<QdrantClientSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddQdrantClient( ""qdrant"", settings => settings.Key = ""12345!@#$%""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Qdrant integration uses standard .NET logging, and you\'ll see log entries from the following category: Qdrant.Client Tracing The .NET Aspire Qdrant integration doesn\'t currently emit tracing activities because they are not supported by the Qdrant.Client library. Metrics The .NET Aspire Qdrant integration doesn\'t currently emit metrics because they are not supported by the Qdrant.Client library. See also Qdrant Qdrant documentation Qdrant GitHub repo Qdrant .NET SDK .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire Qdrant integration can be utilized for machine learning applications by leveraging Qdrant's capabilities as an open-source vector similarity search engine, which efficiently stores, indexes, and searches large-scale vector data. This is particularly useful in machine learning, artificial intelligence, and data science applications where vector data is used to represent unstructured objects like images, text, audio, or video. The integration allows developers to connect to existing Qdrant databases or create new instances using the qdrant/qdrant container image. The NuGet package, specifically the Aspire.Qdrant.Client package, plays a crucial role in this process by providing the necessary client integration. It registers a Qdrant.Client.QdrantClient instance that can be used to interact with Qdrant vector data, enabling developers to add and manage Qdrant resources within their .NET applications. This setup facilitates the implementation of machine learning models that require efficient vector data handling and similarity searches.",multi_hop_abstract_query_synthesizer
23,"How does the .NET Aspire PostgreSQL Entity Framework Core integration facilitate the connection and configuration of PostgreSQL databases, and how does it compare to the integration process for SQL Server using .NET Aspire?","['<1-hop>\n\ntitle: .NET Aspire PostgreSQL Entity Framework Core integration description: Learn how to integrate PostgreSQL with .NET Aspire applications using Entity Framework Core, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-ef-core-integration .NET Aspire PostgreSQL Entity Framework Core integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL Entity Framework Core integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL Entity Framework Core client integration, install the ðŸ“¦ Aspire.Npgsql.EntityFrameworkCore.PostgreSQL NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The .NET Aspire PostgreSQL Entity Framework Core client integration registers your desired DbContext subclass instances that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql.EntityFrameworkCore.PostgreSQL PackageReference xml <PackageReference Include=""Aspire.Npgsql.EntityFrameworkCore.PostgreSQL"" Version=""*"" /> Add Npgsql database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDbContext<YourDbContext>(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding YourDbContext to the builder, you can get the YourDbContext instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(YourDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add Npgsql database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichNpgsqlDbContext<YourDbContext>( connectionName: ""postgresdb"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30; }); The settings parameter is an instance of the Configuration The .NET Aspire PostgreSQL Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling the csharp builder.AddNpgsqlDbContext<MyDbContext>(""pgdb""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""pgdb"": ""Host=myserver;Database=test"" } } The EnrichNpgsqlDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it\'s called. For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL Entity Framework Core integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""EntityFrameworkCore"": { ""PostgreSQL"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true } } } } } For the complete PostgreSQL Entity Framework Core client integration JSON schema, see Aspire.Npgsql.EntityFrameworkCore.PostgreSQL/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlEntityFrameworkCorePostgreSQLSettings> delegate to set up some or all the options inline, for example to set the ConnectionString: csharp builder.AddNpgsqlDbContext<YourDbContext>( ""pgdb"", static settings => settings.ConnectionString = ""<YOUR CONNECTION STRING>""); Configure multiple DbContext classes If you want to register more than one json { ""Aspire"": { ""Npgsql"": { ""EntityFrameworkCore"": { ""PostgreSQL"": { ""ConnectionString"": ""<YOUR CONNECTION STRING>"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""AnotherDbContext"": { ""ConnectionString"": ""<ANOTHER CONNECTION STRING>"", ""DisableTracing"": false } } } } } } Then calling the csharp builder.AddNpgsqlDbContext<AnotherDbContext>(); [!INCLUDE integration-health-checks] By default, the .NET Aspire PostgreSQL Entity Framework Core integrations handles the following: Adds the DbContextHealthCheck, which calls EF Core\'s Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core description: Learn how to connect an ASP.NET Core app to to SQL Server using .NET Aspire and Entity Framework Core. ms.date: 12/02/2024 ms.topic: tutorial Tutorial: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core In this tutorial, you create an ASP.NET Core app that uses a .NET Aspire Entity Framework Core SQL Server integration to connect to SQL Server to read and write support ticket data. Entity Framework Core is a lightweight, extensible, open source object-relational mapper that enables .NET developers to work with databases using .NET objects. You\'ll learn how to: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire integrations Add a .NET Aspire integration to connect to SQL Server Configure and use .NET Aspire Component features to read and write from the database [!INCLUDE aspire-prereqs] Create the sample solution At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Blazor and select Blazor Web App. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQLEFCore. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Ensure the Interactive render mode is set to None. Check the Enlist in .NET Aspire orchestration option and select Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQLEFCore: A Blazor project that depends on service defaults. AspireSQLEFCore.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQLEFCore.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Create the database model and context classes To represent a user submitted support request, add the following SupportTicket model class at the root of the AspireSQLEFCore project. :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/SupportTicket.cs""::: Add the following TicketDbContext data context class at the root of the AspireSQLEFCore project. The class inherits :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/TicketContext.cs""::: Add the .NET Aspire integration to the Blazor app Add the .NET Aspire Entity Framework Core Sql Server library package to your AspireSQLEFCore project: dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer Your AspireSQLEFCore project is now set up to use .NET Aspire integrations. Here\'s the updated AspireSQLEFCore.csproj file: :::code language=""xml"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/AspireSQLEFCore.csproj"" highlight=""10""::: Configure the .NET Aspire integration In the :::no-loc text=""Program.cs""::: file of the AspireSQLEFCore project, add a call to the :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-14"" highlight=""5""::: This method accomplishes the following tasks: Registers a TicketContext with the DI container for connecting to the containerized Azure SQL Database. Automatically enable corresponding health checks, logging, and telemetry. Create the database While developing locally, you need to create a database inside the SQL Server container. Update the :::no-loc text=""Program.cs""::: file with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-30"" highlight=""16-30""::: The preceding code: Checks if the app is running in a development environment. If it is, it retrieves the TicketContext service from the DI container and calls Database.EnsureCreated() to create the database if it doesn\'t already exist. [!NOTE] Note that EnsureCreated() is not suitable for production environments, and it only creates the database as defined in the context. It doesn\'t apply any migrations. For more information on Entity Framework Core migrations in .NET Aspire, see Apply Entity Framework Core migrations in .NET Aspire. Create the form The app requires a form for the user to be able to submit support ticket information and save the entry to the database. Use the following Razor markup to create a basic form, replacing the contents of the Home.razor file in the AspireSQLEFCore/Components/Pages directory: :::code language=""razor"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Components/Pages/Home.razor""::: For more information about creating forms in Blazor, see ASP.NET Core Blazor forms overview. Configure the AppHost The AspireSQLEFCore.AppHost project is the orchestrator for your app. It\'s responsible for connecting and configuring the different projects and services of your app. The orchestrator should be set as the startup project. Add the .NET Aspire Hosting Sql Server NuGet package to your AspireStorage.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQLEFCore.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The Entity Framework classes you configured earlier will automatically use this connection when migrating and connecting to the database.', '<3-hop>\n\nRun and test the app locally The sample app is now ready for testing. Verify that the submitted form data is persisted to the database by completing the following steps: Select the run button at the top of Visual Studio (or F5) to launch your .NET Aspire project dashboard in the browser. On the projects page, in the AspireSQLEFCore row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/app-home-screen.png"" lightbox=""media/app-home-screen.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields. Select the Submit button, and the form submits the support ticket for processing â€” (then select Clear to clear the form). The data you submitted displays in the table at the bottom of the page when the page reloads. See also .NET Aspire with SQL Database deployment .NET Aspire deployment via Azure Container Apps Deploy a .NET Aspire project using GitHub Actions']","The .NET Aspire PostgreSQL Entity Framework Core integration facilitates the connection and configuration of PostgreSQL databases by providing a way to connect to existing PostgreSQL databases or create new instances using the docker.io/library/postgres container image. It includes hosting and client integrations, where the hosting integration automatically adds a health check for the PostgreSQL server resource using the AspNetCore.HealthChecks.Npgsql NuGet package. The client integration involves installing the Aspire.Npgsql.EntityFrameworkCore.PostgreSQL NuGet package and registering DbContext subclass instances to interact with PostgreSQL. Configuration can be enriched with additional services like automatic retries, health checks, logging, and telemetry. In contrast, the integration process for SQL Server using .NET Aspire involves creating an ASP.NET Core app that uses the .NET Aspire Entity Framework Core SQL Server integration to connect to SQL Server. This process includes setting up a Blazor project, adding the Aspire.Microsoft.EntityFrameworkCore.SqlServer library package, and configuring the app to connect to a containerized Azure SQL Database. Both integrations use Entity Framework Core to manage database interactions, but they differ in the specific packages and configuration steps required for PostgreSQL and SQL Server.",multi_hop_abstract_query_synthesizer
24,How does the .NET Aspire Microsoft Entity Framework Core integration utilize logging and metrics for Cosmos DB?,"['<1-hop>\n\ntitle: .NET Aspire Cosmos DB Entity Framework Core integration description: Learn how to install and configure the .NET Aspire Cosmos DB Entity Framework Core integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-entity-framework-integration .NET Aspire Cosmos DB Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.Cosmos"" Version=""*"" /> Add Cosmos DB context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmosdb that same name should be used when calling AddCosmosDbContext. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(MyDbContext context) { // Use context... } For more information on using Entity Framework Core with Azure Cosmos DB, see the Examples for Azure Cosmos DB for NoSQL SDK for .NET. Configuration The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddCosmosDbContext: csharp builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information, see the ConnectionString documentation. Use configuration providers The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""Cosmos"": { ""DisableTracing"": true } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json. Use inline delegates You can also pass the Action<EntityFrameworkCoreCosmosSettings> configureSettings delegate to set up some or all the csharp builder.AddCosmosDbContext<MyDbContext>( ""cosmosdb"", settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn\'t implement health checks, though this may change in future releases. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nLogging The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration uses the following log categories: Azure-Cosmos-Operation-Request-Diagnostics Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Query Tracing The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration will emit the following tracing activities using OpenTelemetry: Azure.Cosmos.Operation OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently supports the following metrics: Microsoft.EntityFrameworkCore ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second See also Azure Cosmos DB docs .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration utilizes logging through categories such as Azure-Cosmos-Operation-Request-Diagnostics, Microsoft.EntityFrameworkCore.ChangeTracking, Microsoft.EntityFrameworkCore.Database.Command, Microsoft.EntityFrameworkCore.Infrastructure, and Microsoft.EntityFrameworkCore.Query. For tracing, it emits activities using OpenTelemetry, including Azure.Cosmos.Operation and OpenTelemetry.Instrumentation.EntityFrameworkCore. The integration supports metrics like ec_Microsoft_EntityFrameworkCore_active_db_contexts, ec_Microsoft_EntityFrameworkCore_total_queries, ec_Microsoft_EntityFrameworkCore_queries_per_second, ec_Microsoft_EntityFrameworkCore_total_save_changes, ec_Microsoft_EntityFrameworkCore_save_changes_per_second, ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate, ec_Microsoft_Entity_total_execution_strategy_operation_failures, ec_Microsoft_E_execution_strategy_operation_failures_per_second, ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures, and ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second.",multi_hop_abstract_query_synthesizer
25,How does .NET Aspire facilitate Node.js app orchestration and Azure integration?,"['<1-hop>\n\ntitle: "" .NET Aspire docs: What\'s new for October 2024"" description: ""What\'s new in the .NET Aspire docs for October 2024."" ms.custom: October-2024 ms.date: 11/01/2024 .NET Aspire docs: What\'s new for October 2024 Welcome to what\'s new in the .NET Aspire docs for October 2024. This article lists some of the major changes to docs during this period. Get started Updated articles Orchestrate Node.js apps in .NET Aspire - Fix broken links Quickstart: Build your first .NET Aspire solution - Make it easier to onboard with VS Code. Fundamentals New articles Enable browser telemetry Updated articles .NET Aspire dashboard overview Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. .NET Aspire integrations overview Add Meilisearch integeration docs Using nuget.org links for Community Toolkit packages Moving from Aspire.CommunityToolkit to CommunityToolkit.Aspire Moving package links to be Azure Artifacts not GitHub Packages Rewrite the non-Azure messaging integration articles Community Toolkit .NET Aspire orchestration overview - Rewrite the non-Azure messaging integration articles Dashboard configuration Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Enable browser telemetry minor text fixes Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Security considerations for running the .NET Aspire dashboard - Various dashboard and telemetry docs updates Standalone .NET Aspire dashboard - Various dashboard and telemetry docs updates Tutorial: Use the .NET Aspire dashboard with Python apps - Various dashboard and telemetry docs updates', '<2-hop>\n\nStorage Updated articles .NET Aspire Azure Blob Storage integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Data Tables integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Queue Storage integration - Rewrite the non-Azure messaging integration articles Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations - Rewrite the non-Azure messaging integration articles Database Updated articles .NET Aspire Azure Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Microsoft Entity Framework Core Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Milvus database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MongoDB database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MySQL database integration - Rewrite the non-Azure messaging integration articles .NET Aspire Oracle Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire Pomelo MySQL Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL Entity Framework Core integration Rewrite both PostgreSQL integration docs Update postgresql-entity-framework-integration.md Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL integration Rewrite both PostgreSQL integration docs Rewrite the non-Azure messaging integration articles .NET Aspire Qdrant integration - Rewrite the non-Azure messaging integration articles .NET Aspire SQL Server integration - Rewrite the non-Azure messaging integration articles .NET Aspire SqlServer Entity Framework Core integration - Rewrite the non-Azure messaging integration articles Messaging New articles .NET Aspire RabbitMQ integration Updated articles .NET Aspire Apache Kafka integration Fix Kafka integration documentation Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire Azure Event Hubs integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Service Bus integration Rewrite the non-Azure messaging integration articles Use correct method name in ServiceBus .NET Aspire Azure Web PubSub integration - Rewrite the non-Azure messaging integration articles .NET Aspire NATS integration Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire RabbitMQ integration Rewrite both PostgreSQL integration docs Redis rewrite Demote messaging integration headings Rewrite the non-Azure messaging integration articles Caching Updated articles .NET Aspire Redis distributed caching integration Updates to other Redis-protocol docs Rewrite the non-Azure messaging integration articles .NET Aspire Redis integration Updates to other Redis-protocol docs Redis rewrite Rewrite the non-Azure messaging integration articles .NET Aspire Redis output caching integration Updates to other Redis-protocol docs Rewrite the non-Azure messaging integration articles Stack Exchange Redis caching overview - Updates to other Redis-protocol docs Tutorial: Implement caching with .NET Aspire integrations - Rewrite the non-Azure messaging integration articles Security Updated articles .NET Aspire Azure Key Vault integration - Rewrite the non-Azure messaging integration articles Deployment Updated articles Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide) - Fix typo in aca-deployment-azd-in-depth.md Use Application Insights for .NET Aspire telemetry - Rewrite the non-Azure messaging integration articles Use custom Bicep templates - Rewrite the non-Azure messaging integration articles Community contributors The following people contributed to the .NET Aspire docs during this period. Thank you! Learn how to contribute by following the links under ""Get involved"" in the what\'s new landing page. alexravenna - Alex Ravenna Alirexaa - Alireza Baloochi fabiocozzolino - Fabio Cozzolino g7ed6e - Guillaume Delahaye willibrandon - Brandon Williams']",".NET Aspire facilitates Node.js app orchestration by providing updated articles and resources that help fix broken links and make it easier to onboard with tools like VS Code. Additionally, it supports Azure integration through various storage and database services, such as Azure Blob Storage, Azure Data Tables, and Azure Queue Storage, as well as database integrations like Azure Cosmos DB and SQL Server. These integrations are part of the updates and rewrites aimed at enhancing the performance and capabilities of cloud-native applications.",multi_hop_abstract_query_synthesizer
26,How does the .NET Aspire integration facilitate the connection and configuration of Azure Cosmos DB and RabbitMQ for cloud-native applications?,"['<1-hop>\n\ntitle: .NET Aspire RabbitMQ integration description: Learn how to use the .NET Aspire RabbitMQ message-broker integration, which includes both hosting and client integrations. ms.date: 10/11/2024 uid: messaging/rabbitmq-integration .NET Aspire RabbitMQ integration [!INCLUDE includes-hosting-and-client] RabbitMQ is a reliable messaging and streaming broker, which is easy to deploy on cloud environments, on-premises, and on your local machine. The .NET Aspire RabbitMQ integration enables you to connect to existing RabbitMQ instances, or create new instances from .NET with the docker.io/library/rabbitmq container image.', '<2-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<3-hop>\n\ntitle: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core description: Learn how to connect an ASP.NET Core app to to SQL Server using .NET Aspire and Entity Framework Core. ms.date: 12/02/2024 ms.topic: tutorial Tutorial: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core In this tutorial, you create an ASP.NET Core app that uses a .NET Aspire Entity Framework Core SQL Server integration to connect to SQL Server to read and write support ticket data. Entity Framework Core is a lightweight, extensible, open source object-relational mapper that enables .NET developers to work with databases using .NET objects. You\'ll learn how to: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire integrations Add a .NET Aspire integration to connect to SQL Server Configure and use .NET Aspire Component features to read and write from the database [!INCLUDE aspire-prereqs] Create the sample solution At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Blazor and select Blazor Web App. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQLEFCore. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Ensure the Interactive render mode is set to None. Check the Enlist in .NET Aspire orchestration option and select Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQLEFCore: A Blazor project that depends on service defaults. AspireSQLEFCore.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQLEFCore.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Create the database model and context classes To represent a user submitted support request, add the following SupportTicket model class at the root of the AspireSQLEFCore project. :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/SupportTicket.cs""::: Add the following TicketDbContext data context class at the root of the AspireSQLEFCore project. The class inherits :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/TicketContext.cs""::: Add the .NET Aspire integration to the Blazor app Add the .NET Aspire Entity Framework Core Sql Server library package to your AspireSQLEFCore project: dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer Your AspireSQLEFCore project is now set up to use .NET Aspire integrations. Here\'s the updated AspireSQLEFCore.csproj file: :::code language=""xml"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/AspireSQLEFCore.csproj"" highlight=""10""::: Configure the .NET Aspire integration In the :::no-loc text=""Program.cs""::: file of the AspireSQLEFCore project, add a call to the :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-14"" highlight=""5""::: This method accomplishes the following tasks: Registers a TicketContext with the DI container for connecting to the containerized Azure SQL Database. Automatically enable corresponding health checks, logging, and telemetry. Create the database While developing locally, you need to create a database inside the SQL Server container. Update the :::no-loc text=""Program.cs""::: file with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-30"" highlight=""16-30""::: The preceding code: Checks if the app is running in a development environment. If it is, it retrieves the TicketContext service from the DI container and calls Database.EnsureCreated() to create the database if it doesn\'t already exist. [!NOTE] Note that EnsureCreated() is not suitable for production environments, and it only creates the database as defined in the context. It doesn\'t apply any migrations. For more information on Entity Framework Core migrations in .NET Aspire, see Apply Entity Framework Core migrations in .NET Aspire. Create the form The app requires a form for the user to be able to submit support ticket information and save the entry to the database. Use the following Razor markup to create a basic form, replacing the contents of the Home.razor file in the AspireSQLEFCore/Components/Pages directory: :::code language=""razor"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Components/Pages/Home.razor""::: For more information about creating forms in Blazor, see ASP.NET Core Blazor forms overview. Configure the AppHost The AspireSQLEFCore.AppHost project is the orchestrator for your app. It\'s responsible for connecting and configuring the different projects and services of your app. The orchestrator should be set as the startup project. Add the .NET Aspire Hosting Sql Server NuGet package to your AspireStorage.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQLEFCore.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The Entity Framework classes you configured earlier will automatically use this connection when migrating and connecting to the database.', '<4-hop>\n\nRun and test the app locally The sample app is now ready for testing. Verify that the submitted form data is persisted to the database by completing the following steps: Select the run button at the top of Visual Studio (or F5) to launch your .NET Aspire project dashboard in the browser. On the projects page, in the AspireSQLEFCore row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/app-home-screen.png"" lightbox=""media/app-home-screen.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields. Select the Submit button, and the form submits the support ticket for processing â€” (then select Clear to clear the form). The data you submitted displays in the table at the bottom of the page when the page reloads. See also .NET Aspire with SQL Database deployment .NET Aspire deployment via Azure Container Apps Deploy a .NET Aspire project using GitHub Actions']","The .NET Aspire integration facilitates the connection and configuration of Azure Cosmos DB and RabbitMQ for cloud-native applications by providing specific integration packages and tools for each service. For Azure Cosmos DB, the .NET Aspire integration allows developers to connect to existing Cosmos DB instances or create new ones using the Azure Cosmos DB emulator. It includes hosting integration that automatically adds health checks for the Cosmos DB resource, ensuring it is running and a connection can be established. Developers can use the Aspire.Microsoft.Azure.Cosmos NuGet package to set up client integrations, allowing for dependency injection and configuration of multiple CosmosClient instances with different connection names. For RabbitMQ, the .NET Aspire integration enables connection to existing RabbitMQ instances or the creation of new ones using the docker.io/library/rabbitmq container image. This integration supports both hosting and client configurations, making it easy to deploy RabbitMQ in various environments, including cloud and on-premises setups. Together, these integrations streamline the process of setting up and managing these services within .NET applications, enhancing the development of cloud-native solutions.",multi_hop_abstract_query_synthesizer
27,How does the .NET Aspire project facilitate local Azure provisioning and integration with Redis Cache?,"['<1-hop>\n\ntitle: Local Azure provisioning description: Learn how to use Azure resources in your local development environment. ms.date: 12/13/2024 uid: dotnet/aspire/local-azure-provisioning Local Azure provisioning .NET Aspire simplifies local cloud-native app development with its compelling app host model. This model allows you to run your app locally with the same configuration and services as in Azure. In this article you learn how to provision Azure resources from your local development environment through the .NET Aspire app host. [!NOTE] To be clear, resources are provisioned in Azure, but the provisioning process is initiated from your local development environment. To optimize your local development experience, consider using emulator or containers when available. For more information, see Typical developer experience. Requirements This article assumes that you have an Azure account and subscription. If you don\'t have an Azure account, you can create a free one at Azure Free Account. For provisioning functionality to work correctly, you\'ll need to be authenticated with Azure. Ensure that you have the Azure Developer CLI installed. Additionally, you\'ll need to provide some configuration values so that the provisioning logic can create resources on your behalf. App host provisioning APIs The app host provides a set of APIs to express Azure resources. These APIs are available as extension methods in .NET Aspire Azure hosting libraries, extending the When the app host starts, the following provisioning logic is executed: The Azure configuration section is validated. When invalid the dashboard and app host output provides hints as to what\'s missing. For more information, see Missing configuration value hints. When valid Azure resources are conditionally provisioned: If an Azure deployment for a given resource doesn\'t exist, it\'s created and configured as a deployment. The configuration of said deployment is stamped with a checksum as a means to support only provisioning resources as necessary. Use existing Azure resources The app host automatically manages provisioning of Azure resources. The first time the app host runs, it provisions the resources specified in the app host. Subsequent runs don\'t provision the resources again unless the app host configuration changes. If you\'ve already provisioned Azure resources outside of the app host and want to use them, you can provide the connection string with the ```csharp // Service registration var secrets = builder.ExecutionContext.IsPublishMode ? builder.AddAzureKeyVault(""secrets"") : builder.AddConnectionString(""secrets""); // Service consumption builder.AddProject The preceding code snippet shows how to add an Azure Key Vault to the app host. The Alternatively, for some Azure resources, you can opt-in to running them as an emulator with the RunAsEmulator API. This API is available for Azure Cosmos DB and Azure Storage integrations. For example, to run Azure Cosmos DB as an emulator, you can use the following code snippet: csharp var cosmos = builder.AddAzureCosmosDB(""cosmos"") .RunAsEmulator(); The', '<2-hop>\n\ntitle: Deploy a .NET Aspire project that connects to Redis Cache to Azure description: Learn how to deploy a .NET Aspire project that connects to Redis Cache to Azure ms.date: 08/12/2024 ms.topic: how-to Tutorial: Deploy a .NET Aspire project with a Redis Cache to Azure In this tutorial, you learn to configure a .NET Aspire project with a Redis Cache for deployment to Azure. .NET Aspire provides multiple caching integration configurations that provision different Redis services in Azure. You\'ll learn how to: [!div class=""checklist""] Configure the app to provision an Azure Cache for Redis Configure the app to provision a containerized Redis Cache [!NOTE] This document focuses specifically on .NET Aspire configurations to provision and deploy Redis Cache resources in Azure. For more information and to learn more about the full .NET Aspire deployment process, see the Azure Container Apps deployment tutorial. [!INCLUDE aspire-prereqs] Create the sample solution Follow the Tutorial: Implement caching with .NET Aspire integrations to create the sample project. Configure the app for Redis cache deployment .NET Aspire provides two built-in configuration options to streamline Redis Cache deployment on Azure: Provision a containerized Redis Cache using Azure Container Apps Provision an Azure Cache for Redis instance Add the .NET Aspire integration to the app Add the appropriate .NET Aspire integration to the AspireRedis.AppHost project for your desired hosting service. Azure Cache for Redis Add the ðŸ“¦ Aspire.Hosting.Azure.Redis NuGet package to the AspireRedis.AppHost project: dotnetcli dotnet add package Aspire.Hosting.Azure.Redis Redis Container Add the ðŸ“¦ Aspire.Hosting.Redis NuGet package to the AspireRedis.AppHost project: dotnetcli dotnet add package Aspire.Hosting.Redis Configure the AppHost project Configure the AspireRedis.AppHost project for your desired Redis service. Azure Cache for Redis Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireRedis.AppHost project with the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddAzureRedis(""cache""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code adds an Azure Cache for Redis resource to your app and configures a connection called cache. The AddAzureRedis method ensures that tools such as the Azure Developer CLI or Visual Studio create an Azure Cache for Redis resource during the deployment process. Redis Container Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireRedis.AppHost project with the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var cache = builder.AddRedis(""cache""); var apiService = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code adds a Redis Container resource to your app and configures a connection called cache. This configuration also ensures that tools such as the Azure Developer CLI or Visual Studio create a containerized Redis instance during the deployment process. Deploy the app Tools such as the Azure Developer CLI (azd) support .NET Aspire Redis integration configurations to streamline deployments. azd consumes these settings and provisions properly configured resources for you. [!NOTE] You can also use the Azure CLI or Bicep to provision and deploy .NET Aspire project resources. These options require more manual steps, but provide more granular control over your deployments. .NET Aspire projects can also connect to an existing Redis instance through manual configurations. Open a terminal window in the root of your .NET Aspire project. Run the azd init command to initialize the project with azd. azdeveloper azd init When prompted for an environment name, enter docs-aspireredis. Run the azd up command to begin the deployment process: azdeveloper azd up Select the Azure subscription that should host your app resources. Select the Azure location to use. The Azure Developer CLI provisions and deploys your app resources. The process may take a few minutes to complete. When the deployment finishes, click the resource group link in the output to view the created resources in the Azure portal. Azure Cache for Redis The deployment process provisioned an Azure Cache for Redis resource due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-redis.png"" alt-text=""A screenshot showing the deployed Azure Cache for Redis.""::: Redis Container The deployment process created a Redis app container due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-redis-container.png"" alt-text=""A screenshot showing the containerized Redis.""::: [!INCLUDE clean-up-resources]']","The .NET Aspire project facilitates local Azure provisioning by allowing developers to initiate the provisioning of Azure resources from their local development environment using the app host model. This model ensures that the app can run locally with the same configuration and services as in Azure, optimizing the development experience with tools like emulators or containers. For integration with Redis Cache, .NET Aspire provides configurations to deploy a Redis Cache to Azure, either as a containerized Redis Cache using Azure Container Apps or as an Azure Cache for Redis instance. The project uses the Azure Developer CLI to streamline the deployment process, ensuring that the necessary Redis resources are provisioned and configured during deployment.",multi_hop_abstract_query_synthesizer
28,How does the .NET Aspire integration facilitate RabbitMQ message-broker integration and SQL Server connectivity in an ASP.NET Core application?,"['<1-hop>\n\ntitle: .NET Aspire RabbitMQ integration description: Learn how to use the .NET Aspire RabbitMQ message-broker integration, which includes both hosting and client integrations. ms.date: 10/11/2024 uid: messaging/rabbitmq-integration .NET Aspire RabbitMQ integration [!INCLUDE includes-hosting-and-client] RabbitMQ is a reliable messaging and streaming broker, which is easy to deploy on cloud environments, on-premises, and on your local machine. The .NET Aspire RabbitMQ integration enables you to connect to existing RabbitMQ instances, or create new instances from .NET with the docker.io/library/rabbitmq container image.', '<2-hop>\n\ntitle: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core description: Learn how to connect an ASP.NET Core app to to SQL Server using .NET Aspire and Entity Framework Core. ms.date: 12/02/2024 ms.topic: tutorial Tutorial: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core In this tutorial, you create an ASP.NET Core app that uses a .NET Aspire Entity Framework Core SQL Server integration to connect to SQL Server to read and write support ticket data. Entity Framework Core is a lightweight, extensible, open source object-relational mapper that enables .NET developers to work with databases using .NET objects. You\'ll learn how to: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire integrations Add a .NET Aspire integration to connect to SQL Server Configure and use .NET Aspire Component features to read and write from the database [!INCLUDE aspire-prereqs] Create the sample solution At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Blazor and select Blazor Web App. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQLEFCore. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Ensure the Interactive render mode is set to None. Check the Enlist in .NET Aspire orchestration option and select Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQLEFCore: A Blazor project that depends on service defaults. AspireSQLEFCore.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQLEFCore.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Create the database model and context classes To represent a user submitted support request, add the following SupportTicket model class at the root of the AspireSQLEFCore project. :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/SupportTicket.cs""::: Add the following TicketDbContext data context class at the root of the AspireSQLEFCore project. The class inherits :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/TicketContext.cs""::: Add the .NET Aspire integration to the Blazor app Add the .NET Aspire Entity Framework Core Sql Server library package to your AspireSQLEFCore project: dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer Your AspireSQLEFCore project is now set up to use .NET Aspire integrations. Here\'s the updated AspireSQLEFCore.csproj file: :::code language=""xml"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/AspireSQLEFCore.csproj"" highlight=""10""::: Configure the .NET Aspire integration In the :::no-loc text=""Program.cs""::: file of the AspireSQLEFCore project, add a call to the :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-14"" highlight=""5""::: This method accomplishes the following tasks: Registers a TicketContext with the DI container for connecting to the containerized Azure SQL Database. Automatically enable corresponding health checks, logging, and telemetry. Create the database While developing locally, you need to create a database inside the SQL Server container. Update the :::no-loc text=""Program.cs""::: file with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-30"" highlight=""16-30""::: The preceding code: Checks if the app is running in a development environment. If it is, it retrieves the TicketContext service from the DI container and calls Database.EnsureCreated() to create the database if it doesn\'t already exist. [!NOTE] Note that EnsureCreated() is not suitable for production environments, and it only creates the database as defined in the context. It doesn\'t apply any migrations. For more information on Entity Framework Core migrations in .NET Aspire, see Apply Entity Framework Core migrations in .NET Aspire. Create the form The app requires a form for the user to be able to submit support ticket information and save the entry to the database. Use the following Razor markup to create a basic form, replacing the contents of the Home.razor file in the AspireSQLEFCore/Components/Pages directory: :::code language=""razor"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Components/Pages/Home.razor""::: For more information about creating forms in Blazor, see ASP.NET Core Blazor forms overview. Configure the AppHost The AspireSQLEFCore.AppHost project is the orchestrator for your app. It\'s responsible for connecting and configuring the different projects and services of your app. The orchestrator should be set as the startup project. Add the .NET Aspire Hosting Sql Server NuGet package to your AspireStorage.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQLEFCore.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The Entity Framework classes you configured earlier will automatically use this connection when migrating and connecting to the database.', '<3-hop>\n\nRun and test the app locally The sample app is now ready for testing. Verify that the submitted form data is persisted to the database by completing the following steps: Select the run button at the top of Visual Studio (or F5) to launch your .NET Aspire project dashboard in the browser. On the projects page, in the AspireSQLEFCore row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/app-home-screen.png"" lightbox=""media/app-home-screen.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields. Select the Submit button, and the form submits the support ticket for processing â€” (then select Clear to clear the form). The data you submitted displays in the table at the bottom of the page when the page reloads. See also .NET Aspire with SQL Database deployment .NET Aspire deployment via Azure Container Apps Deploy a .NET Aspire project using GitHub Actions']","The .NET Aspire integration facilitates RabbitMQ message-broker integration by allowing developers to connect to existing RabbitMQ instances or create new ones using the docker.io/library/rabbitmq container image. This integration supports hosting and client integrations, making it easy to deploy RabbitMQ in cloud environments, on-premises, or locally. Additionally, .NET Aspire enables SQL Server connectivity in an ASP.NET Core application through the use of Entity Framework Core. Developers can create a basic .NET app that uses .NET Aspire integrations to connect to SQL Server, allowing the app to read and write support ticket data. The integration involves setting up a Blazor project, configuring the database model and context classes, and using the .NET Aspire Entity Framework Core SQL Server library package to manage database interactions.",multi_hop_abstract_query_synthesizer
29,"How does the .NET Aspire Redis integration facilitate telemetry and observability, and what are the specific features related to telemetry introduced in .NET Aspire 9?","['<1-hop>\n\ntitle: .NET Aspire Redis integration description: Learn how to use the .NET Aspire Redis integration, which includes both hosting and client integrations. ms.date: 11/05/2024 zone_pivot_groups: resp-host .NET Aspire RedisÂ®* integration [!INCLUDE includes-hosting-and-client] :::zone pivot=""redis"" Redis is the world\'s fastest data platform for caching, vector search, and NoSQL databases. The .NET Aspire Redis integration enables you to connect to existing Redis instances, or create new instances from .NET with the docker.io/library/redis container image. :::zone-end :::zone pivot=""garnet"" Garnet is a a high-performance cache-store from Microsoft Research and complies with the Redis serialization protocol (RESP). The .NET Aspire Redis integration enables you to connect to existing Garnet instances, or create new instances from .NET with the ghcr.io/microsoft/garnet container image. :::zone-end :::zone pivot=""valkey"" Valkey is a Redis fork and complies with the Redis serialization protocol (RESP). It\'s a high-performance key/value datastore that supports a variety of workloads such as caching, message queues, and can act as a primary database. The .NET Aspire Redis integration enables you to connect to existing Valkey instances, or create new instances from .NET with the docker.io/valkey/valkey container image. :::zone-end Hosting integration :::zone pivot=""redis"" [!INCLUDE redis-app-host] :::zone-end :::zone pivot=""garnet"" [!INCLUDE garnet-app-host] :::zone-end :::zone pivot=""valkey"" [!INCLUDE valkey-app-host] :::zone-end Hosting integration health checks [!INCLUDE redis-hosting-health-checks] Client integration To get started with the .NET Aspire Stack Exchange Redis client integration, install the ðŸ“¦ Aspire.StackExchange.Redis NuGet package in the client-consuming project, that is, the project for the application that uses the Redis client. The Redis client integration registers an an IConnectionMultiplexer instance that you can use to interact with Redis. .NET CLI dotnetcli dotnet add package Aspire.StackExchange.Redis PackageReference xml <PackageReference Include=""Aspire.StackExchange.Redis"" Version=""*"" /> Add Redis client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddRedisClient(connectionName: ""cache""); :::zone pivot=""redis"" [!TIP] The connectionName parameter must match the name used when adding the Redis resource in the app host project. For more information, see Add Redis resource. :::zone-end :::zone pivot=""garnet"" [!TIP] The connectionName parameter must match the name used when adding the Garnet resource in the app host project. For more information, see Add Garnet resource. :::zone-end :::zone pivot=""valkey"" [!TIP] The connectionName parameter must match the name used when adding the Valkey resource in the app host project. For more information, see Add Valkey resource. :::zone-end You can then retrieve the IConnection instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(IConnectionMultiplexer connectionMux) { // Use connection multiplexer... } For more information on dependency injection, see .NET dependency injection. Add keyed Redis client There might be situations where you want to register multiple IConnectionMultiplexer instances with different connection names. To register keyed Redis clients, call the csharp builder.AddKeyedRedisClient(name: ""chat""); builder.AddKeyedRedisClient(name: ""queue""); Then you can retrieve the IConnectionMultiplexer instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] IConnectionMultiplexer chatConnectionMux, [FromKeyedServices(""queue"")] IConnectionMultiplexer queueConnectionMux) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Stack Exchange Redis client integration provides multiple options to configure the Redis connection based on the requirements and conventions of your project. Use a connection string :::zone pivot=""redis"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddRedis(""cache""); :::zone-end :::zone pivot=""garnet"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddGarnet(""cache""); :::zone-end :::zone pivot=""valkey"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddValkey(""cache""); :::zone-end Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } For more information on how to format this connection string, see the Stack Exchange Redis configuration docs. Use configuration providers [!INCLUDE redis-client-json-settings] Use inline delegates You can also pass the Action<StackExchangeRedisSettings> delegate to set up some or all the options inline, for example to configure DisableTracing: csharp builder.AddRedisClient( ""cache"", static settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Stack Exchange Redis integration handles the following: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.', '<2-hop>\n\nObservability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations might only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire Stack Exchange Redis integration uses the following log categories: Aspire.StackExchange.Redis Tracing The .NET Aspire Stack Exchange Redis integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.StackExchangeRedis Metrics The .NET Aspire Stack Exchange Redis integration currently doesn\'t support metrics by default due to limitations with the StackExchange.Redis library. :::zone pivot=""redis"" [!INCLUDE azure-redis-app-host] [!INCLUDE azure-redis-client] :::zone-end See also Stack Exchange Redis docs .NET Aspire integrations .NET Aspire GitHub repo [!INCLUDE redis-trademark]', '<3-hop>\n\nTelemetry user-centric additions Telemetry remains a vital aspect of .NET Aspire. In .NET Aspire 9, many new features were introduced to the Telemetry service. Improved telemetry filtering Traces can be filtered with attribute values. For example, if you only want to view traces for one endpoint in your app, the http.route attribute on HTTP requests can be filtered to a specified value. Telemetry filtering also supports autocomplete of existing values. The Add filter dialog provides a combo box for selecting from values that dashboard has available. This feature makes it much easier to filter to real data and helps avoid typos by entered a value yourself. For more information, see .NET Aspire dashboard: Filter traces. Combine telemetry from multiple resources When a resource has multiple replicas, you can now filter telemetry to view data from all instances at once. Select the parent resource, labeled (application). For more information, see .NET Aspire dashboard: Combine telemetry from multiple resources. Browser telemetry support The dashboard supports OpenTelemetry Protocol (OTLP) over HTTP and cross-origin resource sharing (CORS). These features unlock the ability to send OpenTelemetry from browser apps to the .NET Aspire dashboard. For example, a browser-based single page app (SPA) can configure the JavaScript OpenTelemetry SDK to send structured logs, traces, and metrics created in the browser to the dashboard. Browser telemetry is displayed alongside server telemetry. :::image type=""content"" source=""media/dashboard-browser-telemetry.png"" lightbox=""media/dashboard-browser-telemetry.png"" alt-text=""Trace detail page with browser telemetry""::: For more information on configuring browser telemetry, see Enable browser telemetry documentation. App Host (Orchestration) The .NET Aspire app host is one of the most important features of .NET Aspire. In .NET Aspire 9, several new features were added specific to the app host. Waiting for dependencies If you\'ve been following along with .NET Aspire, you already know that your app host project is where you define your app model. You create a distributed application builder, add and configure resources, and express their dependencies. Now, you can specify that a resource should wait for another resource before starting. This can help avoid connection errors during startup by only starting resources when their dependencies are ""ready."" ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbit = builder.AddRabbitMQ(""rabbit""); builder.AddProject builder.Build().Run(); ``` When the app host starts, it waits for the rabbit resource to be ready before starting the api resource. There are two methods exposed to wait for a resource: For more information, see .NET Aspire app host: Waiting for resources. Resource health checks The WaitFor API uses standard .NET health checks to determine if a resource is ready. But what does ""a resource being ready"" mean? The best part is, that\'s configurable by the consumer beyond their default values. When a resource doesn\'t expose any health checks (no health checks registered in the app), the app host waits for the resource to be in the For resources that expose HTTP endpoints, you can easily add a health check that polls a specific path for an HTTP 200 response. ```csharp var builder = DistributedApplication.CreateBuilder(args); var catalogApi = builder.AddContainer(""catalog-api"", ""catalog-api"") .WithHttpEndpoint(targetPort: 8080) .WithHttpHealthCheck(""/health""); builder.AddProject builder.Build().Run(); ``` The preceding example adds a health check to the catalog-api resource. The app host waits for the health check to return a healthy status before starting the store resource. It determines that the resource is ready when the /health endpoint returns an HTTP 200 status code. While store is waiting for catalog-api to become healthy, the resources in the dashboard appear as: :::image type=""content"" source=""media/waiting-for-unhealthy-resource.png"" lightbox=""media/waiting-for-unhealthy-resource.png"" alt-text=""Waiting for an unhealthy resource before starting""::: The app host\'s health check mechanism builds upon the Health checks report data, which is displayed in the dashboard: :::image type=""content"" source=""media/health-check-details.png"" lightbox=""media/health-check-details.png"" alt-text=""Health check details in the dashboard\'s resource details view""::: Creating a custom health check is straightforward. Start by defining the health check, then associate its name with any resources it applies to. ```csharp var builder = DistributedApplication.CreateBuilder(args); var healthyAfter = DateTime.Now.AddSeconds(20); builder.Services.AddHealthChecks().AddCheck( ""delay20secs"", () => DateTime.Now > healthyAfter ? HealthCheckResult.Healthy() : HealthCheckResult.Unhealthy() ); var cache = builder.AddRedis(""cache"") .WithHealthCheck(""delay20secs""); builder.AddProject The preceding example adds a health check to the cache resource, which reports it as unhealthy for the first 20 seconds after the app host starts. So, the myapp resource waits for 20 seconds before starting, ensuring the cache resource is healthy. The Persistent containers The app host now supports persistent containers. Persistent containers deviate from the typical container life cycle of .NET Aspire orchestrated apps. While they\'re created and started (when not already available) by the .NET Aspire orchestrator, they\'re not destroyed by .NET Aspire. This is useful when you want to keep the container running even after the app host has stopped. [!IMPORTANT] To delete these containers, you must manually stop them using the container runtime. To define an IResourceBuilder<ContainerResource> with a persistent lifetime, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var queue = builder.AddRabbitMQ(""rabbit"") .WithLifetime(ContainerLifetime.Persistent); builder.AddProject builder.Build().Run(); ``` The dashboard shows persistent containers with a pin icon: :::image type=""content"" source=""media/persistent-container.png"" lightbox=""media/persistent-container.png"" alt-text=""Persistent containers""::: After the app host is stopped, the container will continue to run: :::image type=""content"" source=""media/persistent-container-docker-desktop.png"" lightbox=""media/persistent-container-docker-desktop.png"" alt-text=""Docker desktop showing RabbitMQ.""::: The container persistence mechanism attempts to identify when you might wish to recreate the container. For example, if the environment for the container changes, then the container is restarted so that you don\'t need to manually stop the container if the input configuration for the resource has changed. Resource commands The app host supports adding custom commands to resources. This is useful when you want to add custom functionality that is not natively supported by the app host. There\'s likely many opportunities where exposing custom extension methods on resources will be useful. The .NET Aspire Community Toolkit might be a good place to share these extensions. When you define a custom command, it\'s available in the dashboard as a user experience feature. [!IMPORTANT] These .NET Aspire dashboard commands are only available when running the dashboard locally. They\'re not available when running the dashboard in Azure Container Apps. For more information on creating custom resource commands, see How-to: Create custom resource commands in .NET Aspire.']","The .NET Aspire Redis integration facilitates telemetry and observability by automatically setting up Logging, Tracing, and Metrics configurations, which are essential components of observability. The integration uses specific log categories such as Aspire.StackExchange.Redis and emits tracing activities using OpenTelemetry, although it currently does not support metrics by default due to limitations with the StackExchange.Redis library. In .NET Aspire 9, several new features were introduced to enhance telemetry, including improved telemetry filtering, which allows traces to be filtered with attribute values, and the ability to combine telemetry from multiple resources. Additionally, browser telemetry support was added, enabling the sending of OpenTelemetry from browser apps to the .NET Aspire dashboard, where it is displayed alongside server telemetry.",multi_hop_abstract_query_synthesizer
30,How does the .NET Aspire app host facilitate local Azure provisioning and what are the necessary Azure hosting integrations required for successful configuration?,"['<1-hop>\n\ntitle: Local Azure provisioning description: Learn how to use Azure resources in your local development environment. ms.date: 12/13/2024 uid: dotnet/aspire/local-azure-provisioning Local Azure provisioning .NET Aspire simplifies local cloud-native app development with its compelling app host model. This model allows you to run your app locally with the same configuration and services as in Azure. In this article you learn how to provision Azure resources from your local development environment through the .NET Aspire app host. [!NOTE] To be clear, resources are provisioned in Azure, but the provisioning process is initiated from your local development environment. To optimize your local development experience, consider using emulator or containers when available. For more information, see Typical developer experience. Requirements This article assumes that you have an Azure account and subscription. If you don\'t have an Azure account, you can create a free one at Azure Free Account. For provisioning functionality to work correctly, you\'ll need to be authenticated with Azure. Ensure that you have the Azure Developer CLI installed. Additionally, you\'ll need to provide some configuration values so that the provisioning logic can create resources on your behalf. App host provisioning APIs The app host provides a set of APIs to express Azure resources. These APIs are available as extension methods in .NET Aspire Azure hosting libraries, extending the When the app host starts, the following provisioning logic is executed: The Azure configuration section is validated. When invalid the dashboard and app host output provides hints as to what\'s missing. For more information, see Missing configuration value hints. When valid Azure resources are conditionally provisioned: If an Azure deployment for a given resource doesn\'t exist, it\'s created and configured as a deployment. The configuration of said deployment is stamped with a checksum as a means to support only provisioning resources as necessary. Use existing Azure resources The app host automatically manages provisioning of Azure resources. The first time the app host runs, it provisions the resources specified in the app host. Subsequent runs don\'t provision the resources again unless the app host configuration changes. If you\'ve already provisioned Azure resources outside of the app host and want to use them, you can provide the connection string with the ```csharp // Service registration var secrets = builder.ExecutionContext.IsPublishMode ? builder.AddAzureKeyVault(""secrets"") : builder.AddConnectionString(""secrets""); // Service consumption builder.AddProject The preceding code snippet shows how to add an Azure Key Vault to the app host. The Alternatively, for some Azure resources, you can opt-in to running them as an emulator with the RunAsEmulator API. This API is available for Azure Cosmos DB and Azure Storage integrations. For example, to run Azure Cosmos DB as an emulator, you can use the following code snippet: csharp var cosmos = builder.AddAzureCosmosDB(""cosmos"") .RunAsEmulator(); The', '<2-hop>\n\n.NET Aspire Azure hosting integrations If you\'re using Azure resources in your app host, you\'re using one or more of the .NET Aspire Azure hosting integrations. These hosting libraries provide extension methods to the Configuration When utilizing Azure resources in your local development environment, you need to provide the necessary configuration values. Configuration values are specified under the Azure section: SubscriptionId: The Azure subscription ID. AllowResourceGroupCreation: A boolean value that indicates whether to create a new resource group. ResourceGroup: The name of the resource group to use. Location: The Azure region to use. Consider the following example :::no-loc text=""appsettings.json""::: configuration: json { ""Azure"": { ""SubscriptionId"": ""<Your subscription id>"", ""AllowResourceGroupCreation"": true, ""ResourceGroup"": ""<Valid resource group name>"", ""Location"": ""<Valid Azure location>"" } } [!IMPORTANT] It\'s recommended to store these values as app secrets. For more information, see Manage app secrets. After you\'ve configured the necessary values, you can start provisioning Azure resources in your local development environment. Azure provisioning credential store The .NET Aspire app host uses a credential store for Azure resource authentication and authorization. Depending on your subscription, the correct credential store may be needed for multi-tenant provisioning scenarios. With the ðŸ“¦ Aspire.Hosting.Azure NuGet package installed, and if your app host depends on Azure resources, the default Azure credential store relies on the json { ""Azure"": { ""CredentialSource"": ""AzureCli"" } } As with all configuration-based settings, you can configure these with alternative providers, such as user secrets or environment variables. The Azure:CredentialSource value can be set to one of the following values: AzureCli: Delegates to the AzurePowerShell: Delegates to the VisualStudio: Delegates to the VisualStudioCode: Delegates to the AzureDeveloperCli: Delegates to the InteractiveBrowser: Delegates to the [!TIP] For more information about the Azure SDK authentication and authorization, see Credential chains in the Azure Identity library for .NET. Tooling support In Visual Studio, you can use Connected Services to configure the default Azure provisioning settings. Select the app host project, right-click on the Connected Services node, and select Azure Resource Provisioning Settings: :::image type=""content"" loc-scope=""visual-studio"" source=""media/azure-resource-provisioning-settings.png"" lightbox=""media/azure-resource-provisioning-settings.png"" alt-text=""Visual Studio 2022: .NET Aspire App Host project, Connected Services context menu.""::: This will open a dialog where you can configure the Azure provisioning settings, as shown in the following screenshot: :::image type=""content"" loc-scope=""visual-studio"" source=""media/azure-provisioning-settings-dialog.png"" lightbox=""media/azure-provisioning-settings-dialog.png"" alt-text=""Visual Studio 2022: Azure Resource Provisioning Settings dialog.""::: Missing configuration value hints When the Azure configuration section is missing, has missing values, or is invalid, the .NET Aspire dashboard provides useful hints. For example, consider an app host that\'s missing the SubscriptionId configuration value that\'s attempting to use an Azure Key Vault resource. The Resources page indicates the State as Missing subscription configuration: :::image type=""content"" source=""media/resources-kv-missing-subscription.png"" alt-text="".NET Aspire dashboard: Missing subscription configuration.""::: Additionally, the Console logs display this information as well, consider the following screenshot: :::image type=""content"" source=""media/console-logs-kv-missing-subscription.png"" lightbox=""media/console-logs-kv-missing-subscription.png"" alt-text="".NET Aspire dashboard: Console logs, missing subscription configuration.""::: Known limitations After provisioning Azure resources in this way, you must manually clean up the resources in the Azure portal as .NET Aspire doesn\'t provide a built-in mechanism to delete Azure resources. The easiest way to achieve this is by deleting the configured resource group. This can be done in the Azure portal or by using the Azure CLI: azurecli az group delete --name <ResourceGroupName> Replace <ResourceGroupName> with the name of the resource group you want to delete. For more information, see az group delete.']","The .NET Aspire app host facilitates local Azure provisioning by allowing developers to initiate the provisioning process from their local development environment, using the same configuration and services as in Azure. This is achieved through a set of APIs available as extension methods in .NET Aspire Azure hosting libraries. These APIs help express Azure resources and manage their provisioning. For successful configuration, necessary Azure hosting integrations include specifying configuration values such as SubscriptionId, AllowResourceGroupCreation, ResourceGroup, and Location in the appsettings.json file. Additionally, the app host uses a credential store for Azure resource authentication and authorization, which can be configured using various credential sources like AzureCli, AzurePowerShell, VisualStudio, and others. Proper configuration of these elements ensures that Azure resources are provisioned correctly and efficiently.",multi_hop_abstract_query_synthesizer
31,How .NET Aspire PostgreSQL Entity Framework Core integration use logging and what categories it include?,"['<1-hop>\n\ntitle: .NET Aspire PostgreSQL Entity Framework Core integration description: Learn how to integrate PostgreSQL with .NET Aspire applications using Entity Framework Core, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-ef-core-integration .NET Aspire PostgreSQL Entity Framework Core integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL Entity Framework Core integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL Entity Framework Core client integration, install the ðŸ“¦ Aspire.Npgsql.EntityFrameworkCore.PostgreSQL NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The .NET Aspire PostgreSQL Entity Framework Core client integration registers your desired DbContext subclass instances that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql.EntityFrameworkCore.PostgreSQL PackageReference xml <PackageReference Include=""Aspire.Npgsql.EntityFrameworkCore.PostgreSQL"" Version=""*"" /> Add Npgsql database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDbContext<YourDbContext>(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding YourDbContext to the builder, you can get the YourDbContext instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(YourDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add Npgsql database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichNpgsqlDbContext<YourDbContext>( connectionName: ""postgresdb"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30; }); The settings parameter is an instance of the Configuration The .NET Aspire PostgreSQL Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling the csharp builder.AddNpgsqlDbContext<MyDbContext>(""pgdb""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""pgdb"": ""Host=myserver;Database=test"" } } The EnrichNpgsqlDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it\'s called. For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL Entity Framework Core integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""EntityFrameworkCore"": { ""PostgreSQL"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true } } } } } For the complete PostgreSQL Entity Framework Core client integration JSON schema, see Aspire.Npgsql.EntityFrameworkCore.PostgreSQL/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlEntityFrameworkCorePostgreSQLSettings> delegate to set up some or all the options inline, for example to set the ConnectionString: csharp builder.AddNpgsqlDbContext<YourDbContext>( ""pgdb"", static settings => settings.ConnectionString = ""<YOUR CONNECTION STRING>""); Configure multiple DbContext classes If you want to register more than one json { ""Aspire"": { ""Npgsql"": { ""EntityFrameworkCore"": { ""PostgreSQL"": { ""ConnectionString"": ""<YOUR CONNECTION STRING>"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""AnotherDbContext"": { ""ConnectionString"": ""<ANOTHER CONNECTION STRING>"", ""DisableTracing"": false } } } } } } Then calling the csharp builder.AddNpgsqlDbContext<AnotherDbContext>(); [!INCLUDE integration-health-checks] By default, the .NET Aspire PostgreSQL Entity Framework Core integrations handles the following: Adds the DbContextHealthCheck, which calls EF Core\'s Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nLogging The .NET Aspire PostgreSQL Entity Framework Core integration uses the following Log categories: Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Database.Connection Microsoft.EntityFrameworkCore.Database.Transaction Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Migrations Microsoft.EntityFrameworkCore.Model Microsoft.EntityFrameworkCore.Model.Validation Microsoft.EntityFrameworkCore.Query Microsoft.EntityFrameworkCore.Update Tracing The .NET Aspire PostgreSQL Entity Framework Core integration will emit the following Tracing activities using OpenTelemetry: Npgsql Metrics The .NET Aspire PostgreSQL Entity Framework Core integration will emit the following metrics using OpenTelemetry: Microsoft.EntityFrameworkCore: ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second Npgsql: ec_Npgsql_bytes_written_per_second ec_Npgsql_bytes_read_per_second ec_Npgsql_commands_per_second ec_Npgsql_total_commands ec_Npgsql_current_commands ec_Npgsql_failed_commands ec_Npgsql_prepared_commands_ratio ec_Npgsql_connection_pools ec_Npgsql_multiplexing_average_commands_per_batch ec_Npgsql_multiplexing_average_write_time_per_batch [!INCLUDE postgresql-flexible-server] [!INCLUDE azure-postgresql-ef-client] See also Azure Database for PostgreSQL documentation .NET Aspire integrations .NET Aspire GitHub repo', '<3-hop>\n\ntitle: Add .NET Aspire to an existing .NET app description: Learn how to add .NET Aspire integrations, orchestration, and tooling to a microservices app that already exists. ms.date: 11/08/2024 ms.topic: how-to zone_pivot_groups: dev-environment Tutorial: Add .NET Aspire to an existing .NET app If you have existing microservices and .NET web app, you can add .NET Aspire to it and get all the included features and benefits. In this article, you add .NET Aspire orchestration to a simple, preexisting .NET 9 project. You learn how to: [!div class=""checklist""] Understand the structure of the existing microservices app. Enroll existing projects in .NET Aspire orchestration. Understand the changes enrollment makes in the projects. Start the .NET Aspire project. [!INCLUDE aspire-prereqs] Get started Let\'s start by obtaining the code for the solution: Open a command prompt and change directories to where you want to store the code. To clone to .NET 9 example solution, use the following git clone command: bash git clone https://github.com/MicrosoftDocs/mslearn-dotnet-cloudnative-devops.git eShopLite', '<4-hop>\n\nAdd .NET Aspire to the Store web app Now, let\'s enroll the Store project, which implements the web user interface, in .NET Aspire orchestration: :::zone pivot=""visual-studio"" In Visual Studio, in the Solution Explorer, right-click the Store project, select Add, and then select .NET Aspire Orchestrator Support. In the Add .NET Aspire Orchestrator Support dialog, select OK. :::image type=""content"" loc-scope=""visual-studio"" source=""media/add-aspire-orchestrator-support.png"" alt-text=""Screenshot of the Add .NET Aspire Orchestrator Support dialog.""::: You should now have two new projects, both added to the solution: eShopLite.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator is set as the Startup project, and it depends on the eShopLite.Store project. eShopLite.ServiceDefaults: A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. In the eShopLite.AppHost project, open the :::no-loc text=""Program.cs""::: file. Notice this line of code, which registers the Store project in the .NET Aspire orchestration: csharp builder.AddProject<Projects.Store>(""store""); For more information, see To add the Products project to .NET Aspire: In Visual Studio, in the Solution Explorer, right-click the Products project, select Add, and then select .NET Aspire Orchestrator Support. A dialog indicating that .NET Aspire Orchestrator project already exists, select OK. :::image type=""content"" loc-scope=""visual-studio"" source=""media/orchestrator-already-added.png"" alt-text=""Screenshot indicating that the.NET Aspire Orchestrator was already added.""::: In the eShopLite.AppHost project, open the :::no-loc text=""Program.cs""::: file. Notice this line of code, which registers the Products project in the .NET Aspire orchestration: csharp builder.AddProject<Projects.Products>(""products""); Also notice that the eShopLite.AppHost project, now depends on both the Store and Products projects. :::zone-end :::zone pivot=""vscode,dotnet-cli"" Create an app host project In order to orchestrate the existing projects, you need to create a new app host project. To create a new app host project from the available .NET Aspire templates, use the following .NET CLI command: dotnetcli dotnet new aspire-apphost -o eShopLite.AppHost Add the app host project to existing solution: Unix dotnetcli dotnet sln ./eShopLite.sln add ./eShopLite.AppHost/eShopLite.AppHost.csproj Windows dotnetcli dotnet sln .\\eShopLite.sln add .\\eShopLite.AppHost\\eShopLite.AppHost.csproj Add the Store project as a project reference to the app host project using the following .NET CLI command: Unix dotnetcli dotnet add ./eShopLite.AppHost/eShopLite.AppHost.csproj reference ./Store/Store.csproj Windows dotnetcli dotnet add .\\eShopLite.AppHost\\eShopLite.AppHost.csproj reference .\\Store\\Store.csproj Create a service defaults project After the app host project is created, you need to create a new service defaults project. To create a new service defaults project from the available .NET Aspire templates, use the following .NET CLI command: dotnetcli dotnet new aspire-servicedefaults -o eShopLite.ServiceDefaults To add the project to the solution, use the following .NET CLI command: Unix dotnetcli dotnet sln ./eShopLite.sln add ./eShopLite.ServiceDefaults/eShopLite.ServiceDefaults.csproj Windows dotnetcli dotnet sln .\\eShopLite.sln add .\\eShopLite.ServiceDefaults\\eShopLite.ServiceDefaults.csproj Update the app host project to add a project reference to the Products project: Unix dotnetcli dotnet add ./eShopLite.AppHost/eShopLite.AppHost.csproj reference ./Products/Products.csproj Windows dotnetcli dotnet add .\\eShopLite.AppHost\\eShopLite.AppHost.csproj reference .\\Products\\Products.csproj Both the Store and Products projects need to reference the service defaults project so that they can easily include service discovery. To add a reference to the service defaults project in the Store project, use the following .NET CLI command: Unix dotnetcli dotnet add ./Store/Store.csproj reference ./eShopLite.ServiceDefaults/eShopLite.ServiceDefaults.csproj Windows dotnetcli dotnet add .\\Store\\Store.csproj reference .\\eShopLite.ServiceDefaults\\eShopLite.ServiceDefaults.csproj The same command with slightly different paths should be used to add a reference to the service defaults project in the Products project: Unix dotnetcli dotnet add ./Products/Products.csproj reference ./eShopLite.ServiceDefaults/eShopLite.ServiceDefaults.csproj Windows dotnetcli dotnet add .\\Products\\Products.csproj reference .\\eShopLite.ServiceDefaults\\eShopLite.ServiceDefaults.csproj In both the Store and Products projects, update their :::no-loc text=""Program.cs""::: files, adding the following line immediately after their var builder = WebApplication.CreateBuilder(args); line: csharp builder.AddServiceDefaults(); Update the app host project Open the :::no-loc text=""Program.cs""::: file of the app host project, and replace its contents with the following C# code: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code: Creates a new DistributedApplicationBuilder instance. Adds the Store project to the orchestrator. Adds the Products project to the orchestrator. Builds and runs the orchestrator. :::zone-end Service Discovery At this point, both projects are part of .NET Aspire orchestration, but the Store needs to be able to discover the Products backend address through .NET Aspire\'s service discovery. To enable service discovery, open the :::no-loc text=""Program.cs""::: file in eShopLite.AppHost and update the code that the Store adds a reference to the Products project: ```csharp var builder = DistributedApplication.CreateBuilder(args); var products = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code expresses that the Store project depends on the Products project. For more information, see .NET Aspire app host: Reference resources. This reference is used to discover the address of the Products project. Additionally, the Store project is configured to use external HTTP endpoints. If you later choose to deploy this app, you\'d need the call to Next, update the :::no-loc text=""appsettings.json""::: in the Store project with the following JSON: json { ""DetailedErrors"": true, ""Logging"": { ""LogLevel"": { ""Default"": ""Information"", ""Microsoft.AspNetCore"": ""Warning"" } }, ""AllowedHosts"": ""*"", ""ProductEndpoint"": ""http://products"", ""ProductEndpointHttps"": ""https://products"" } The addresses for both the endpoints now uses the ""products"" name that was added to the orchestrator in the app host. These names are used to discover the address of the Products project.', '<5-hop>\n\nExplore the enrolled app Let\'s start the solution and examine the new behavior that .NET Aspire provides. :::zone pivot=""visual-studio"" [!NOTE] Notice that the eShopLite.AppHost project is the new startup project. In Visual Studio, to start debugging, press F5 Visual Studio builds the projects. If the Start Docker Desktop dialog appears, select Yes. Visual Studio starts the Docker engine and creates the necessary containers. When the deployment is complete, the .NET Aspire dashboard is displayed. In the dashboard, select the endpoint for the products project. A new browser tab appears and displays the product catalog in JSON format. In the dashboard, select the endpoint for the store project. A new browser tab appears and displays the home page for the web app. In the menu on the left, select Products. The product catalog is displayed. To stop debugging, close the browser. :::zone-end :::zone pivot=""vscode"" Delete the launch.json file that you created earlier, it no longer serves a purpose. Instead, start the app host project, which orchestrates the other projects: Start the app host project by right-clicking the eShopLite.AppHost project in the Solution Explorer and selecting Debug > Start New Instance: :::image type=""content"" source=""media/vscode-run-app-host.png"" lightbox=""media/vscode-run-app-host.png"" alt-text=""Visual Studio Code: Solution Explorer selecting Debug > Start New Instance."" ::: [!NOTE] If Docker Desktop (or Podman) isn\'t running, you\'ll experience an error. Start the OCI compliant container engine and try again. :::zone-end :::zone pivot=""dotnet-cli"" Start the app host project by running the following command: dotnetcli dotnet run --project ./eShopLite.AppHost/eShopLite.AppHost.csproj [!NOTE] If Docker Desktop (or Podman) isn\'t running, you\'ll experience an error. Start the OCI compliant container engine and try again. :::zone-end :::zone pivot=""vscode,dotnet-cli"" In the dashboard, select the endpoint for the products project. A new browser tab appears and displays the product catalog in JSON format. In the dashboard, select the endpoint for the store project. A new browser tab appears and displays the home page for the web app. In the menu on the left, select Products. The product catalog is displayed. To stop debugging, close the browser. :::zone-end Congratulations, you added .NET Aspire orchestration to your pre-existing web app. You can now add .NET Aspire integrations and use the .NET Aspire tooling to streamline your cloud-native web app development.']",".NET Aspire PostgreSQL Entity Framework Core integration uses logging to track various activities and operations within the application. The logging categories included are: Microsoft.EntityFrameworkCore.ChangeTracking, Microsoft.EntityFrameworkCore.Database.Command, Microsoft.EntityFrameworkCore.Database.Connection, Microsoft.EntityFrameworkCore.Database.Transaction, Microsoft.EntityFrameworkCore.Infrastructure, Microsoft.EntityFrameworkCore.Migrations, Microsoft.EntityFrameworkCore.Model, Microsoft.EntityFrameworkCore.Model.Validation, Microsoft.EntityFrameworkCore.Query, and Microsoft.EntityFrameworkCore.Update.",multi_hop_abstract_query_synthesizer
32,"How can a cloud-native application developer use Visual Studio to integrate .NET Aspire messaging with Azure Service Bus, and what are the steps to upgrade the app host project to .NET Aspire 9.0?","['<1-hop>\n\ntitle: Use .NET Aspire messaging integrations in ASP.NET Core description: Learn how to connect an ASP.NET Core app to messaging services using .NET Aspire integrations. ms.date: 08/12/2024 ms.topic: tutorial zone_pivot_groups: dev-environment Tutorial: Use .NET Aspire messaging integrations in ASP.NET Core Cloud-native apps often require scalable messaging solutions that provide capabilities such as messaging queues and topics and subscriptions. .NET Aspire integrations simplify the process of connecting to various messaging providers, such as Azure Service Bus. In this tutorial, you\'ll create an ASP.NET Core app that uses .NET Aspire integrations to connect to Azure Service Bus to create a notification system. Submitted messages will be sent to a Service Bus topic for consumption by subscribers. You\'ll learn how to: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire integrations Add an .NET Aspire integration to connect to Azure Service Bus Configure and use .NET Aspire integration features to send and receive data [!INCLUDE aspire-prereqs] In addition to the preceding prerequisites, you also need to install the Azure CLI. To install the Azure CLI, follow the instructions in the Azure CLI installation guide. Set up the Azure Service Bus account For this tutorial, you\'ll need access to an Azure Service Bus namespace with a topic and subscription configured. Use one of the following options to set up the require resources: Azure portal: Create a service bus account with a topic and subscription. Alternatively: Azure CLI: Run the following commands in the Azure CLI or CloudShell to set up the required Azure Service Bus resources: azurecli-interactive az group create -n <your-resource-group-name> --location eastus az servicebus namespace create -g <your-resource-group-name> --name <your-namespace-name> --location eastus az servicebus topic create -g <your-resource-group-name> --namespace-name <your-namespace-name> --name notifications az servicebus topic subscription create -g <your-resource-group-name> --namespace-name <your-namespace-name> --topic-name notifications --name mobile [!NOTE] Replace the your-resource-group-name and your-namespace-name placeholders with your own values. Service Bus namespace names must be globally unique across Azure. Azure authentication This quickstart can be completed using either passwordless authentication or a connection string. Passwordless connections use Azure Active Directory and role-based access control (RBAC) to connect to a Service Bus namespace. You don\'t need to worry about having hard-coded connection string in your code, a configuration file, or in secure storage such as Azure Key Vault. You can also use a connection string to connect to a Service Bus namespace, but the passwordless approach is recommended for real-world applications and production environments. For more information, read about Authentication and authorization or visit the passwordless overview page. Passwordless (Recommended) On your Service Bus namespace, assign the following role to the user account you logged into Visual Studio or the Azure CLI with: Service Bus Data Owner: Assign an Azure RBAC role Connection string Retrieve the connection string for your Service Bus namespace from the Shared access policies menu in the Azure portal. Keep it somewhere safe for use during the quickstart. :::image type=""content"" source=""../media/aspire-service-bus.png"" alt-text=""Screenshot of Aspire service bus connection string menu."":::', '<2-hop>\n\nCreate the sample solution To create a new .NET Aspire Starter Application, you can use either Visual Studio, Visual Studio Code, or the .NET CLI. :::zone pivot=""visual-studio"" [!INCLUDE visual-studio-file-new] :::zone-end :::zone pivot=""vscode"" [!INCLUDE vscode-file-new] :::zone-end :::zone pivot=""dotnet-cli"" [!INCLUDE dotnet-cli-file-new] :::zone-end Add the Worker Service project Next, add a Worker Service project to the solution to retrieve and process messages to and from Azure Service Bus. :::zone pivot=""visual-studio"" In the solution explorer, right click on the top level AspireSample solution node and select Add > New project. Search for and select the Worker Service template and choose Next. For the Project name, enter AspireSample.WorkerService and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Make sure Enlist in .NET Aspire orchestration is checked and select Create. Visual Studio adds the project to your solution and updates the :::no-loc text=""Program.cs""::: file of the AspireSample.AppHost project with a new line of code: csharp builder.AddProject<Projects.AspireSample_WorkerService>( ""aspiresample-workerservice""); Visual Studio tooling added this line of code to register your new project with the :::zone-end :::zone pivot=""vscode"" From the Solution Explorer in Visual Studio Code, select the + button next to the solution name to add a new project to the solution: :::image type=""content"" source=""media/vscode-add-project.png"" lightbox=""media/vscode-add-project.png"" alt-text=""Visual Studio Code: Add new project from C# DevKit Solution Explorer.""::: To filter the project templates, enter Worker in the search box and select the Worker Service template that\'s found: :::image type=""content"" source=""media/vscode-create-worker.png"" lightbox=""media/vscode-create-worker.png"" alt-text=""Visual Studio Code: Filter to Worker Service project template from Add project.""::: Choose the Worker Service template and enter the project name as AspireSample.WorkerService. Select Default directory to create the project in the same directory as the solution. Select Create project to add the project to the solution. Right-click on the AspireSample.AppHost project in the Solution Explorer and select Add Project Reference: :::image type=""content"" source=""media/vscode-add-project-reference.png"" lightbox=""media/vscode-add-project-reference.png"" alt-text=""Visual Studio Code: Add project reference from AspireSample.AppHost to AspireSample.WorkerService.""::: Add the following line of code to the :::no-loc text=""Program.cs""::: file in the AspireSample.AppHost project before the call to builder.Build().Run();: csharp builder.AddProject<Projects.AspireSample_WorkerService>( ""aspiresample-workerservice""); :::zone-end :::zone pivot=""dotnet-cli"" In the root directory of the app, use the dotnet new command to create a new Worker Service app: dotnetcli dotnet new worker --name AspireSample.WorkerService Use the dotnet sln command to add the project to the solution: dotnetcli dotnet sln AspireSample.sln add AspireSample.WorkerService/AspireSample.WorkerService.csproj Use the dotnet add command to add a project reference between the .AppHost and .WorkerService project: dotnetcli dotnet add AspireSample.AppHost/AspireSample.AppHost.csproj reference AspireSample.WorkerService/AspireSample.WorkerService.csproj Add the following line of code to the :::no-loc text=""Program.cs""::: file in the AspireSample.AppHost project before the call to builder.Build().Run();: csharp builder.AddProject<Projects.AspireSample_WorkerService>( ""aspiresample-workerservice""); :::zone-end The completed solution structure should resemble the following, assuming the top-level directory is named aspire-messaging: Directory â””â”€â”€â”€ðŸ“‚ aspire-messaging â”œâ”€â”€â”€ðŸ“‚ AspireSample.WorkerService â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.WorkerService.csproj â”‚ â”œâ”€â”€â”€ Program.cs â”‚ â””â”€â”€â”€ Worker.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.ApiService â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.ApiService.csproj â”‚ â””â”€â”€â”€ Program.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.AppHost â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.AppHost.csproj â”‚ â””â”€â”€â”€ Program.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.ServiceDefaults â”‚ â”œâ”€â”€â”€ AspireSample.ServiceDefaults.csproj â”‚ â””â”€â”€â”€ Extensions.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.Web â”‚ â”œâ”€â”€â”€ðŸ“‚ Components â”‚ â”‚ â”œâ”€â”€â”€ðŸ“‚ Layout â”‚ â”‚ â”‚ â”œâ”€â”€â”€ MainLayout.razor â”‚ â”‚ â”‚ â”œâ”€â”€â”€ MainLayout.razor.css â”‚ â”‚ â”‚ â”œâ”€â”€â”€ NavMenu.razor â”‚ â”‚ â”‚ â””â”€â”€â”€ NavMenu.razor.css â”‚ â”‚ â”œâ”€â”€â”€ðŸ“‚ Pages â”‚ â”‚ â”‚ â”œâ”€â”€â”€ Counter.razor â”‚ â”‚ â”‚ â”œâ”€â”€â”€ Error.razor â”‚ â”‚ â”‚ â”œâ”€â”€â”€ Home.razor â”‚ â”‚ â”‚ â””â”€â”€â”€ Weather.razor â”‚ â”‚ â”œâ”€â”€â”€ _Imports.razor â”‚ â”‚ â”œâ”€â”€â”€ App.razor â”‚ â”‚ â””â”€â”€â”€ Routes.razor â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ðŸ“‚ wwwroot â”‚ â”‚ â”œâ”€â”€â”€ðŸ“‚ bootstrap â”‚ â”‚ â”‚ â”œâ”€â”€â”€ bootstrap.min.css â”‚ â”‚ â”‚ â””â”€â”€â”€ bootstrap.min.css.map â”‚ â”‚ â”œâ”€â”€â”€ app.css â”‚ â”‚ â””â”€â”€â”€ favicon.png â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.Web.csproj â”‚ â”œâ”€â”€â”€ Program.cs â”‚ â””â”€â”€â”€ WeatherApiClient.cs â””â”€â”€â”€ AspireSample.sln', '<3-hop>\n\nUpdate the NuGet packages in your project files to the latest versions. Adjust your Program.cs file to use the new APIs and remove any obsolete APIs. Edit your app host project file To upgrade your app host project to .NET Aspire 9.0, you need to update your project file to use the new ðŸ“¦ Aspire.AppHost.Sdk: ```diff ``` Optionally upgrade the target framework moniker (TFM) .NET Aspire 9.0 runs on .NET 9.0, but you can also run it on .NET 8.0. In other words, just because you\'re using the .NET Aspire SDK, and pointing to version 9.0 packages, you can still target .NET 8.0. If you want to run your .NET Aspire 9.0 project on .NET 9.0, you need to update the TargetFramework property in your project file: ```diff ``` For more information on TFMs, see Target frameworks in SDK-style projects: Latest versions. Overall app host project differences If you followed all of the preceding steps, your app host project file should look like this: ```diff ``` The changes include the addition of the Aspire.AppHost.Sdk, the update of the TargetFramework property to net9.0, and the update of the Aspire.Hosting.AppHost package to version 9.0.0. Adjust your Program.cs file With the introduction of .NET Aspire 9.0, there are some breaking changes. Some APIs were originally marked as experimental (with the For the complete list of breaking changes in .NET Aspire 9.0, see Breaking changes in .NET Aspire 9.0. Use the Upgrade Assistant The Upgrade Assistant is a tool that helps upgrade targeted projects to the latest version. If you\'re new to the Upgrade Assistant, there\'s two modalities to choose from: The Visual Studio extension version. The .NET CLI global tool version. Regardless of how you install the Upgrade Assistant, you can use it to upgrade your .NET Aspire 8.x projects to .NET Aspire 9.0. :::zone pivot=""visual-studio"" To upgrade the .NET Aspire app host project to .NET Aspire 9.0 with Visual Studio, right-click the project in Solution Explorer and select Upgrade. [!IMPORTANT] If the Upgrade Assistant isn\'t already installed, you\'ll be prompted to install it. The Upgrade Assistant displays a welcome package. Select the Aspire upgrades option: :::image type=""content"" source=""media/upgrade-assistant-welcome-aspire.png"" lightbox=""media/upgrade-assistant-welcome-aspire.png"" alt-text=""Visual Studio: Upgrade Assistant welcome page with .NET Aspire app host project.""::: With the Aspire upgrades option selected, the Upgrade Assistant displays the selectable upgrade target components. Leave all the options checked and select Upgrade selection: :::image type=""content"" source=""media/upgrade-assistant-aspire-app-host-comps.png"" lightbox=""media/upgrade-assistant-aspire-app-host-comps.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire selectable components to upgrade.""::: Finally, after selecting the components to upgrade, the Upgrade Assistant displays the results of the upgrade process. If everything was successful, you see green check marks next to each component: :::image type=""content"" source=""media/upgrade-assistant-aspire-upgraded.png"" lightbox=""media/upgrade-assistant-aspire-upgraded.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire app host project upgraded successfully.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To upgrade the .NET Aspire app host project, ensure that you installed the Upgrade Assistant CLI. Open a terminal session at the root directory of the .NET Aspire app host project file, and run the following command: dotnetcli upgrade-assistant upgrade The output is interactive, expecting you to select the upgrade type. Choose the Aspire upgrades option: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ How do you want to upgrade project AspireSample.AppHost? Aspire upgrades Upgrade to latest .NET Aspire version (aspire.latest) Upgrade project to a newer .NET version In-place project upgrade (framework.inplace) NuGet upgrades NuGet central package management (CPM) (nuget.cpm) Navigation Back Exit ``` Use your keyboard to navigate up â†‘ or down â†“, and select the Aspire upgrades option. The Upgrade Assistant prompts for final confirmation. Enter Y to continue with the upgrade: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Upgrade type aspire.latest Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type / Upgrade â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ We have gathered all required options and are ready to do the upgrade. Do you want to continue? [y/n] (y): ``` Finally, after the upgrade process is complete, the Upgrade Assistant displays the results of the upgrade process: dotnetcli Finalizing operation... Complete: 3 succeeded, 0 failed, 7 skipped. :::zone-end Update the NuGet packages To take advantage of the latest updates in your .NET Aspire solution, update all NuGet packages to version 9.0.0. :::zone pivot=""visual-studio"" :::image type=""content"" source=""media/visual-studio-update-nuget.png"" lightbox=""media/visual-studio-update-nuget.png"" alt-text=""Visual Studio: Update all NuGet packages for the .NET Aspire solution.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To update your app host project, use the following .NET CLI command to update the Aspire.Hosting.AppHost package to version 9.0.0: dotnetcli dotnet add package Aspire.Hosting.AppHost --version 9.0.0 When a package reference already exists, the dotnet add package command updates the reference to the specified version. For more information, see dotnet add package. :::zone-end With the app host project updated, your project file should look like this: ```diff ``` [!TIP] You\'ll want to also update the NuGet packages in your other projects to the latest versions. Verify the upgrade As with any upgrade, ensure that the app runs as expected and that all tests pass. Build the solution and look for suggestions, warnings, or errors in the output windowâ€”address anything that wasn\'t an issue before. If you encounter any issues, let us know by filing a GitHub issue.']","A cloud-native application developer can use Visual Studio to integrate .NET Aspire messaging with Azure Service Bus by creating a new .NET Aspire Starter Application and adding a Worker Service project to the solution. This involves using Visual Studio's Solution Explorer to add a new project, selecting the Worker Service template, and configuring it to retrieve and process messages to and from Azure Service Bus. The developer should ensure that .NET 9.0 is selected and that the project is enlisted in .NET Aspire orchestration. To upgrade the app host project to .NET Aspire 9.0, the developer needs to update the project file to use the new Aspire.AppHost.Sdk and optionally upgrade the TargetFramework property to net9.0. The Upgrade Assistant tool can be used to facilitate this process, either through the Visual Studio extension or the .NET CLI global tool. The developer should also update all NuGet packages to version 9.0.0 to take advantage of the latest updates.",multi_hop_abstract_query_synthesizer
33,"How does the .NET Aspire RabbitMQ integration facilitate cloud-native application development, and what role does it play alongside the Oracle Entity Framework Core integration?","['<1-hop>\n\ntitle: .NET Aspire RabbitMQ integration description: Learn how to use the .NET Aspire RabbitMQ message-broker integration, which includes both hosting and client integrations. ms.date: 10/11/2024 uid: messaging/rabbitmq-integration .NET Aspire RabbitMQ integration [!INCLUDE includes-hosting-and-client] RabbitMQ is a reliable messaging and streaming broker, which is easy to deploy on cloud environments, on-premises, and on your local machine. The .NET Aspire RabbitMQ integration enables you to connect to existing RabbitMQ instances, or create new instances from .NET with the docker.io/library/rabbitmq container image.', '<2-hop>\n\ntitle: .NET Aspire Oracle Entity Framework Core integration description: Learn how to use the .NET Aspire Oracle Entity Framework Core integration, which includes both hosting and client integrations. ms.date: 01/21/2025 uid: database/oracle-entity-framework-integration .NET Aspire Oracle Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Oracle Database is a widely-used relational database management system owned and developed by Oracle. The .NET Aspire Oracle Entity Framework Core integration enables you to connect to existing Oracle servers or create new servers from .NET with the container-registry.orcale.com/databse/free container image. Hosting integration The .NET Aspire Oracle hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Oracle PackageReference xml <PackageReference Include=""Aspire.Hosting.Oracle"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications.']","The .NET Aspire RabbitMQ integration facilitates cloud-native application development by providing a reliable messaging and streaming broker that can be easily deployed in cloud environments, on-premises, or locally. It allows developers to connect to existing RabbitMQ instances or create new ones using the docker.io/library/rabbitmq container image. This integration is crucial for building scalable and efficient cloud applications by enabling seamless communication between different services. Alongside this, the .NET Aspire Oracle Entity Framework Core integration allows developers to connect to existing Oracle servers or create new ones using the container-registry.oracle.com/database/free container image. This integration supports the management of relational data within cloud-native applications, ensuring robust data handling and storage capabilities. Together, these integrations enhance the performance and scalability of cloud-native applications by combining efficient messaging with reliable data management.",multi_hop_abstract_query_synthesizer
34,"How does the .NET Aspire SQL Server Entity Framework Core integration utilize Microsoft technologies for hosting and client integrations, and what role do logging and tracing play in the Microsoft Entity Framework Core Cosmos DB integration?","['<1-hop>\n\ntitle: .NET Aspire SQL Server Entity Framework Core integration description: Learn how to use the .NET Aspire SQL Server Entity Framework integration, which includes both hosting and client integrations. ms.date: 12/02/2024 uid: database/sql-server-ef-core-integration .NET Aspire SQL Server Entity Framework Core integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server Entity Framework Core integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server Entity Framework Core integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server Entity Framework Core client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.SqlServer"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add SQL Server database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerDbContext. For more information, see Add SQL Server resource and database resource. To retrieve ExampleDbContext object from a service: csharp public class ExampleService(ExampleDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add SQL Server database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichSqlServerDbContext<ExampleDbContext>( connectionName: ""database"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the Configuration The .NET Aspire SQL Server Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling builder.AddSqlServerDbContext<TContext>(): csharp builder.AddSqlServerDbContext<ExampleDbContext>(""sql""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""sql"": ""Data Source=myserver;Initial Catalog=master"" } } The EnrichSqlServerDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it\'s called. For more information, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server Entity Framework Core integration supports The following is an example of an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""SqlServer"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableMetrics"": false } } } } } Use inline configurations You can also pass the Action<MicrosoftEntityFrameworkCoreSqlServerSettings> delegate to set up some or all the options inline, for example to turn off the metrics: csharp builder.AddSqlServerDbContext<YourDbContext>( ""sql"", static settings => settings.DisableMetrics = true); Configure multiple DbContext connections If you want to register more than one DbContext with different configuration, you can use $""Aspire.Microsoft.EntityFrameworkCore.SqlServer:{typeof(TContext).Name}"" configuration section name. The json configuration would look like: json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""SqlServer"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableMetrics"": false, ""AnotherDbContext"": { ""ConnectionString"": ""AnotherDbContext_CONNECTIONSTRING"", ""DisableTracing"": false } } } } } } Then calling the AddSqlServerDbContext method with AnotherDbContext type parameter would load the settings from Aspire:Microsoft:EntityFrameworkCore:SqlServer:AnotherDbContext section. csharp builder.AddSqlServerDbContext<AnotherDbContext>(""another-sql""); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the SQL Server database to connect to. DbContextPooling A boolean value that indicates whether the db context will be pooled or explicitly created every time it\'s requested MaxRetryCount The maximum number of retry attempts. Default value is 6, set it to 0 to disable the retry mechanism. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. DisableMetrics A boolean value that indicates whether the OpenTelemetry metrics are disabled or not. Timeout The time in seconds to wait for the command to execute. [!INCLUDE integration-health-checks] By default, the .NET Aspire Sql Server Entity Framework Core integration handles the following: Adds the DbContextHealthCheck, which calls EF Core\'s Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nLogging The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration uses the following log categories: Azure-Cosmos-Operation-Request-Diagnostics Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Query Tracing The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration will emit the following tracing activities using OpenTelemetry: Azure.Cosmos.Operation OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently supports the following metrics: Microsoft.EntityFrameworkCore ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second See also Azure Cosmos DB docs .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire SQL Server Entity Framework Core integration leverages Microsoft technologies by enabling connections to SQL Server instances using the mcr.microsoft.com/mssql/server container image. It includes hosting integration that automatically adds a health check for the SQL Server resource, ensuring that the server is running and a connection can be established. This integration relies on the AspNetCore.HealthChecks.SqlServer NuGet package. For client integration, developers can install the Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package to facilitate the use of SQL Server Entity Framework Core in their applications. Logging and tracing in the Microsoft Entity Framework Core Cosmos DB integration are crucial for monitoring and diagnostics. The integration uses specific log categories such as Microsoft.EntityFrameworkCore.ChangeTracking and Microsoft.EntityFrameworkCore.Database.Command. It also emits tracing activities using OpenTelemetry, including Azure.Cosmos.Operation, which helps in tracking the performance and operations of the Cosmos DB integration.",multi_hop_specific_query_synthesizer
35,"How does the integration of Aspire.Hosting.Redis enhance caching capabilities in cloud-native applications, and what role does Aspire.Hosting.NodeJS play in hosting Node.js server apps?","['<1-hop>\n\nExplore the Angular client There are several key modifications from the original Angular template. The first is the addition of a proxy.conf.js file. This file is used to proxy requests from the Angular client to the ""weatherapi"" service. :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/proxy.conf.js""::: The .NET Aspire app host sets the services__weatherapi__http__0 environment variable, which is used to resolve the ""weatherapi"" service endpoint. The preceding configuration proxies HTTP requests that start with /api to the target URL specified in the environment variable. The second update is to the package.json file. This file is used to configure the Angular client to run on a different port than the default port. This is achieved by using the PORT environment variable, and the run-script-os npm package to set the port. :::code language=""json"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/package.json""::: The scripts section of the package.json file is used to define the start script. This script is used by the npm start command to start the Angular client app. The start script is configured to use the run-script-os package to set the port, which delegates to the ng serve command passing the appropriate --port switch based on the OS-appropriate syntax. In order to make HTTP calls to the ""weatherapi"" service, the Angular client app needs to be configured to provide the Angular HttpClient for dependency injection. This is achieved by using the provideHttpClient helper function while configuring the application in the app.config.ts file. :::code language=""typescript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/src/app/app.config.ts""::: Finally, the Angular client app needs to call the /api/WeatherForecast endpoint to retrieve the weather forecast data. There are several HTML, CSS, and TypeScript updates, all of which are made to the following files: app.component.css: Update the CSS to style the table. app.component.html: Update the HTML to display the weather forecast data in a table. app.component.ts: Update the TypeScript to call the /api/WeatherForecast endpoint and display the data in the table. :::code language=""typescript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/src/app/app.component.ts""::: Angular app running To visualize the Angular client app, navigate to the ""angular"" endpoint in the .NET Aspire dashboard. The following image depicts the Angular client app: :::image type=""content"" source=""media/angular-app.png"" lightbox=""media/angular-app.png"" alt-text=""Angular client app with fake forecast weather data displayed as a table.""::: Explore the React client The React app wasn\'t written using a template, and instead was written manually. The complete source code can be found in the dotnet/aspire-samples repository. Some of the key points of interest are found in the src/App.js file: :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.React/src/components/App.js""::: The App function is the entry point for the React client app. It uses the useState and useEffect hooks to manage the state of the weather forecast data. The fetch API is used to make an HTTP request to the /api/WeatherForecast endpoint. The response is then converted to JSON and set as the state of the weather forecast data. :::code language=""javascript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.React/webpack.config.js""::: The preceding code defines the module.exports as follows: The entry property is set to the src/index.js file. The devServer relies on a proxy to forward requests to the ""weatherapi"" service, sets the port to the PORT environment variable, and allows all hosts. The output results in a dist folder with a bundle.js file. The plugins set the src/index.html file as the template, and expose the favicon.ico file. The final updates are to the following files: App.css: Update the CSS to style the table. App.js: Update the JavaScript to call the /api/WeatherForecast endpoint and display the data in the table. React app running To visualize the React client app, navigate to the ""react"" endpoint in the .NET Aspire dashboard. The following image depicts the React client app: :::image type=""content"" source=""media/react-app.png"" lightbox=""media/react-app.png"" alt-text=""React client app with fake forecast weather data displayed as a table.""::: Explore the Vue client There are several key modifications from the original Vue template. The primary updates were the addition of the fetch call in the TheWelcome.vue file to retrieve the weather forecast data from the /api/WeatherForecast endpoint. The following code snippet demonstrates the fetch call: :::code language=""html"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Vue/src/components/TheWelcome.vue""::: As the TheWelcome integration is mounted, it calls the /api/weatherforecast endpoint to retrieve the weather forecast data. The response is then set as the forecasts data property. To set the server port, the Vue client app uses the PORT environment variable. This is achieved by updating the vite.config.ts file: :::code language=""typescript"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Vue/vite.config.ts""::: Additionally, the Vite config specifies the server.proxy property to forward requests to the ""weatherapi"" service. This is achieved by using the services__weatherapi__http__0 environment variable, which is set by the .NET Aspire app host. The final update from the template is made to the TheWelcome.vue file. This file calls the /api/WeatherForecast endpoint to retrieve the weather forecast data, and displays the data in a table. It includes CSS, HTML, and TypeScript updates. Vue app running To visualize the Vue client app, navigate to the ""vue"" endpoint in the .NET Aspire dashboard. The following image depicts the Vue client app: :::image type=""content"" source=""media/vue-app.png"" lightbox=""media/vue-app.png"" alt-text=""Vue client app with fake forecast weather data displayed as a table.""::: Deployment considerations The sample source code for this article is designed to run locally. Each client app deploys as a container image. The Dockerfile for each client app is used to build the container image. Each Dockerfile is identical, using a multistage build to create a production-ready container image. :::code language=""dockerfile"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/Dockerfile""::: The client apps are currently configured to run as true SPA apps, and aren\'t configured to run in a server-side rendered (SSR) mode. They sit behind nginx, which is used to serve the static files. They use a default.conf.template file to configure nginx to proxy requests to the client app. :::code language=""nginx"" source=""~/aspire-samples/samples/AspireWithJavaScript/AspireJavaScript.Angular/default.conf.template""::: Node.js server app considerations While this article focuses on client apps, you might have scenarios where you need to host a Node.js server app. The same semantics are required to host a Node.js server app as a SPA client app. The .NET Aspire app host requires a package reference to the Aspire.Hosting.NodeJS NuGet package and the code needs to call either AddNodeApp or AddNpmApp. These APIs are useful for adding existing JavaScript apps to the .NET Aspire app host. When configuring secrets', '<2-hop>\n\ntitle: Implement caching with .NET Aspire integrations description: Learn how to connect to Redis and cache data using .NET Aspire integrations. ms.date: 11/08/2024 ms.topic: tutorial Tutorial: Implement caching with .NET Aspire integrations Cloud-native apps often require various types of scalable caching solutions to improve performance. .NET Aspire integrations simplify the process of connecting to popular caching services such as Redis. In this article, you\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET core app that is set up to use .NET Aspire. Add .NET Aspire integrations to connect to Redis and implement caching. Configure the .NET Aspire integrations to meet specific requirements. This article explores how to use two different types of ASP.NET Core caching using .NET Aspire and Redis: Output caching: A configurable, extensible caching method for storing entire HTTP responses for future requests. Distributed caching: A cache shared by multiple app servers that allows you to cache specific pieces of data. A distributed cache is typically maintained as an external service to the app servers that access it and can improve the performance and scalability of an ASP.NET Core app. [!INCLUDE aspire-prereqs] Create the project At the top of Visual Studio, navigate to File > New > Project.... In the dialog window, enter .NET Aspire into the project template search box and select .NET Aspire Starter Application. Choose Next. On the Configure your new project screen: Enter a Project name of AspireRedis. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Uncheck Use Redis for caching. You will implement your own caching setup. Select Create. Visual Studio creates a new .NET Aspire solution that consists of the following projects: AspireRedis.Web - A Blazor UI project with default .NET Aspire configurations. AspireRedis.ApiService - A Minimal API with default .NET Aspire configurations that provides the frontend with data. AspireRedis.AppHost - An orchestrator project designed to connect and configure the different projects and services of your app. AspireRedis.ServiceDefaults - A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. Configure the App Host project Add the ðŸ“¦ Aspire.Hosting.Redis NuGet package to the AspireRedis.AppHost project: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Redis PackageReference xml <PackageReference Include=""Aspire.Hosting.Redis"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Update the :::no-loc text=""Program.cs""::: file of the AspireRedis.AppHost project to match the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var redis = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code creates a local Redis container instance and configures the UI and API to use the instance automatically for both output and distributed caching. The code also configures communication between the frontend UI and the backend API using service discovery. With .NET Aspire\'s implicit service discovery, setting up and managing service connections is streamlined for developer productivity. In the context of this tutorial, the feature simplifies how you connect to Redis. Traditionally, you\'d manually specify the Redis connection string in each project\'s :::no-loc text=""appsettings.json""::: file: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } Configuring connection string with this method, while functional, requires duplicating the connection string across multiple projects, which can be cumbersome and error-prone.']","The integration of Aspire.Hosting.Redis enhances caching capabilities in cloud-native applications by simplifying the process of connecting to popular caching services such as Redis. It allows developers to implement both output caching and distributed caching, which can improve the performance and scalability of ASP.NET Core apps. Output caching stores entire HTTP responses for future requests, while distributed caching allows multiple app servers to share cached data, typically maintained as an external service. On the other hand, Aspire.Hosting.NodeJS plays a crucial role in hosting Node.js server apps within the .NET Aspire ecosystem. It requires a package reference to the Aspire.Hosting.NodeJS NuGet package and involves using APIs like AddNodeApp or AddNpmApp to add existing JavaScript apps to the .NET Aspire app host, ensuring seamless integration and hosting of Node.js applications alongside .NET services.",multi_hop_specific_query_synthesizer
36,how use AspNetCore.HealthChecks.MongoDb and AspNetCore.HealthChecks.Nats?,"['<1-hop>\n\nAdd MongoDB server resource with data volume To add a data volume to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithDataVolume(); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the MongoDB server data outside the lifecycle of its container. The data volume is mounted at the /data/db path in the MongoDB server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add MongoDB server resource with data bind mount To add a data bind mount to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithDataBindMount(@""C:\\MongoDB\\Data""); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the MongoDB server data across container restarts. The data bind mount is mounted at the C:\\MongoDB\\Data on Windows (or /MongoDB/Data on Unix) path on the host machine in the MongoDB server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add MongoDB server resource with initialization data bind mount To add an initialization folder data bind mount to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithInitBindMount(@""C:\\MongoDB\\Init""); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` The initialization data bind mount is used to initialize the MongoDB server with data. The initialization data bind mount is mounted at the C:\\MongoDB\\Init on Windows (or /MongoDB/Init on Unix) path on the host machine in the MongoDB server container and maps to the /docker-entrypoint-initdb.d path in the MongoDB server container. MongoDB executes the scripts found in this folder, which is useful for loading data into the database. Add MongoDB server resource with parameters When you want to explicitly provide the password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username""); var password = builder.AddParameter(""password"", secret: true); var mongo = builder.AddMongoDB(""mongo"", username, password); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Add MongoDB Express resource MongoDB Express is a web-based MongoDB admin user interface. To add a MongoDB Express resource that corresponds to the docker.io/library/mongo-express container image, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithMongoExpress(); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!TIP] To configure the host port for the The preceding code adds a MongoDB Express resource that is configured to connect to the MongoDB server resource. The default credentials are: ME_CONFIG_MONGODB_SERVER: The name assigned to the parent MongoDBServerResource, in this case it would be mongo. ME_CONFIG_BASICAUTH: A value of false. ME_CONFIG_MONGODB_PORT: Assigned from the primary endpoint\'s target port of the parent MongoDBServerResource. ME_CONFIG_MONGODB_ADMINUSERNAME: The same username as configured in the parent MongoDBServerResource. ME_CONFIG_MONGODB_ADMINPASSWORD: The same password as configured in the parent MongoDBServerResource. Additionally, the WithMongoExpress API exposes an optional configureContainer parameter of type Action<IResourceBuilder<MongoExpressContainerResource>> that you use to configure the MongoDB Express container resource. Hosting integration health checks The MongoDB hosting integration automatically adds a health check for the MongoDB server resource. The health check verifies that the MongoDB server resource is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.MongoDb NuGet package.', '<2-hop>\n\ntitle: .NET Aspire NATS integration description: Learn how to use the .NET Aspire NATS integration to send logs and traces to a NATS Server. ms.date: 10/11/2024 uid: messaging/nats-integration .NET Aspire NATS integration [!INCLUDE includes-hosting-and-client] NATS is a high-performance, secure, distributed messaging system. The .NET Aspire NATS integration enables you to connect to existing NATS instances, or create new instances from .NET with the docker.io/library/nats container image. Hosting integration NATS hosting integration for .NET Aspire models a NATS server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Nats PackageReference xml <PackageReference Include=""Aspire.Hosting.Nats"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add NATS server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/nats image, it creates a new NATS server instance on your local machine. A reference to your NATS server (the nats variable) is added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing NATS server, call Add NATS server resource with JetStream To add the NATS JetStream to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithJetStream(); builder.AddProject // After adding all resources, run the app... ``` The NATS JetStream functionality provides a built-in persistence engine called JetStream which enables messages to be stored and replayed at a later time. You can optionally provide a srcMountPath parameter to specify the path to the JetStream data directory on the host machine (the provided mount path maps to the container\'s -sd argument). Add NATS server resource with data volume To add a data volume to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the NATS server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/nats path in the NATS server container. A name is generated at random unless you provide a set the name parameter. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add NATS server resource with data bind mount To add a data bind mount to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataBindMount( source: @""C:\\NATS\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the NATS server data across container restarts. The data bind mount is mounted at the C:\\NATS\\Data on Windows (or /NATS/Data on Unix) path on the host machine in the NATS server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The NATS hosting integration automatically adds a health check for the NATS server resource. The health check verifies that the NATS server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Nats NuGet package.']","To use AspNetCore.HealthChecks.MongoDb, the MongoDB hosting integration automatically adds a health check for the MongoDB server resource. This health check verifies that the MongoDB server resource is running and that a connection can be established to it. Similarly, for AspNetCore.HealthChecks.Nats, the NATS hosting integration automatically adds a health check for the NATS server resource, ensuring that the NATS server is running and a connection can be established. Both integrations rely on their respective NuGet packages to perform these health checks.",multi_hop_specific_query_synthesizer
37,How do the AspNetCore.HealthChecks.CosmosDb and AspNetCore.HealthChecks.Kafka packages ensure the health of their respective services in .NET Aspire integrations?,"['<1-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: .NET Aspire Apache Kafka integration description: Learn how to use the .NET Aspire Apache Kafka client message-broker integration. ms.date: 10/11/2024 uid: messaging/kafka-integration .NET Aspire Apache Kafka integration [!INCLUDE includes-hosting-and-client] Apache Kafka is an open-source distributed event streaming platform. It\'s useful for building real-time data pipelines and streaming applications. The .NET Aspire Apache Kafka integration enables you to connect to existing Kafka instances, or create new instances from .NET with the docker.io/confluentinc/confluent-local container image. Hosting integration The Apache Kafka hosting integration models a Kafka server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Kafka PackageReference xml <PackageReference Include=""Aspire.Hosting.Kafka"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Kafka server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/confluentinc/confluent-local image, it creates a new Kafka server instance on your local machine. A reference to your Kafka server (the kafka variable) is added to the ExampleProject. The Kafka server resource includes default ports The [!TIP] If you\'d rather connect to an existing Kafka server, call Add Kafka UI To add the Kafka UI to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithKafkaUI(); builder.AddProject // After adding all resources, run the app... ``` The Kafka UI is a free, open-source web UI to monitor and manage Apache Kafka clusters. .NET Aspire adds another container image docker.io/provectuslabs/kafka-ui to the app host that runs the Kafka UI. Change the Kafka UI host port To change the Kafka UI host port, chain a call to the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithKafkaUI(kafkaUI => kafkaUI.WithHostPort(9100)); builder.AddProject // After adding all resources, run the app... ``` The Kafka UI is accessible at http://localhost:9100 in the preceding example. Add Kafka server resource with data volume To add a data volume to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Kafka server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/kafka/data path in the Kafka server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Kafka server resource with data bind mount To add a data bind mount to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithDataBindMount( source: @""C:\\Kafka\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Kafka server data across container restarts. The data bind mount is mounted at the C:\\Kafka\\Data on Windows (or /Kafka/Data on Unix) path on the host machine in the Kafka server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Kafka hosting integration automatically adds a health check for the Kafka server resource. The health check verifies that a Kafka producer with the specified connection name is able to connect and persist a topic to the Kafka server. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Kafka NuGet package.']","The AspNetCore.HealthChecks.CosmosDb package is used in the .NET Aspire Azure Cosmos DB integration to automatically add a health check for the Cosmos DB resource. This health check verifies that the Cosmos DB is running and that a connection can be established to it. Similarly, the AspNetCore.HealthChecks.Kafka package is utilized in the .NET Aspire Apache Kafka integration to automatically add a health check for the Kafka server resource. This health check ensures that a Kafka producer with the specified connection name can connect and persist a topic to the Kafka server.",multi_hop_specific_query_synthesizer
38,"What are the steps to upgrade a .NET Aspire 8.x project to .NET Aspire 9.0 using the Upgrade Assistant, and what changes are required in the project files?","['<1-hop>\n\nUpdate the NuGet packages in your project files to the latest versions. Adjust your Program.cs file to use the new APIs and remove any obsolete APIs. Edit your app host project file To upgrade your app host project to .NET Aspire 9.0, you need to update your project file to use the new ðŸ“¦ Aspire.AppHost.Sdk: ```diff ``` Optionally upgrade the target framework moniker (TFM) .NET Aspire 9.0 runs on .NET 9.0, but you can also run it on .NET 8.0. In other words, just because you\'re using the .NET Aspire SDK, and pointing to version 9.0 packages, you can still target .NET 8.0. If you want to run your .NET Aspire 9.0 project on .NET 9.0, you need to update the TargetFramework property in your project file: ```diff ``` For more information on TFMs, see Target frameworks in SDK-style projects: Latest versions. Overall app host project differences If you followed all of the preceding steps, your app host project file should look like this: ```diff ``` The changes include the addition of the Aspire.AppHost.Sdk, the update of the TargetFramework property to net9.0, and the update of the Aspire.Hosting.AppHost package to version 9.0.0. Adjust your Program.cs file With the introduction of .NET Aspire 9.0, there are some breaking changes. Some APIs were originally marked as experimental (with the For the complete list of breaking changes in .NET Aspire 9.0, see Breaking changes in .NET Aspire 9.0. Use the Upgrade Assistant The Upgrade Assistant is a tool that helps upgrade targeted projects to the latest version. If you\'re new to the Upgrade Assistant, there\'s two modalities to choose from: The Visual Studio extension version. The .NET CLI global tool version. Regardless of how you install the Upgrade Assistant, you can use it to upgrade your .NET Aspire 8.x projects to .NET Aspire 9.0. :::zone pivot=""visual-studio"" To upgrade the .NET Aspire app host project to .NET Aspire 9.0 with Visual Studio, right-click the project in Solution Explorer and select Upgrade. [!IMPORTANT] If the Upgrade Assistant isn\'t already installed, you\'ll be prompted to install it. The Upgrade Assistant displays a welcome package. Select the Aspire upgrades option: :::image type=""content"" source=""media/upgrade-assistant-welcome-aspire.png"" lightbox=""media/upgrade-assistant-welcome-aspire.png"" alt-text=""Visual Studio: Upgrade Assistant welcome page with .NET Aspire app host project.""::: With the Aspire upgrades option selected, the Upgrade Assistant displays the selectable upgrade target components. Leave all the options checked and select Upgrade selection: :::image type=""content"" source=""media/upgrade-assistant-aspire-app-host-comps.png"" lightbox=""media/upgrade-assistant-aspire-app-host-comps.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire selectable components to upgrade.""::: Finally, after selecting the components to upgrade, the Upgrade Assistant displays the results of the upgrade process. If everything was successful, you see green check marks next to each component: :::image type=""content"" source=""media/upgrade-assistant-aspire-upgraded.png"" lightbox=""media/upgrade-assistant-aspire-upgraded.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire app host project upgraded successfully.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To upgrade the .NET Aspire app host project, ensure that you installed the Upgrade Assistant CLI. Open a terminal session at the root directory of the .NET Aspire app host project file, and run the following command: dotnetcli upgrade-assistant upgrade The output is interactive, expecting you to select the upgrade type. Choose the Aspire upgrades option: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ How do you want to upgrade project AspireSample.AppHost? Aspire upgrades Upgrade to latest .NET Aspire version (aspire.latest) Upgrade project to a newer .NET version In-place project upgrade (framework.inplace) NuGet upgrades NuGet central package management (CPM) (nuget.cpm) Navigation Back Exit ``` Use your keyboard to navigate up â†‘ or down â†“, and select the Aspire upgrades option. The Upgrade Assistant prompts for final confirmation. Enter Y to continue with the upgrade: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Upgrade type aspire.latest Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type / Upgrade â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ We have gathered all required options and are ready to do the upgrade. Do you want to continue? [y/n] (y): ``` Finally, after the upgrade process is complete, the Upgrade Assistant displays the results of the upgrade process: dotnetcli Finalizing operation... Complete: 3 succeeded, 0 failed, 7 skipped. :::zone-end Update the NuGet packages To take advantage of the latest updates in your .NET Aspire solution, update all NuGet packages to version 9.0.0. :::zone pivot=""visual-studio"" :::image type=""content"" source=""media/visual-studio-update-nuget.png"" lightbox=""media/visual-studio-update-nuget.png"" alt-text=""Visual Studio: Update all NuGet packages for the .NET Aspire solution.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To update your app host project, use the following .NET CLI command to update the Aspire.Hosting.AppHost package to version 9.0.0: dotnetcli dotnet add package Aspire.Hosting.AppHost --version 9.0.0 When a package reference already exists, the dotnet add package command updates the reference to the specified version. For more information, see dotnet add package. :::zone-end With the app host project updated, your project file should look like this: ```diff ``` [!TIP] You\'ll want to also update the NuGet packages in your other projects to the latest versions. Verify the upgrade As with any upgrade, ensure that the app runs as expected and that all tests pass. Build the solution and look for suggestions, warnings, or errors in the output windowâ€”address anything that wasn\'t an issue before. If you encounter any issues, let us know by filing a GitHub issue.', ""<2-hop>\n\ntitle: Upgrade to .NET Aspire 9.0 description: Learn how to upgrade all your .NET Aspire 8.x projects to .NET Aspire 9.0. ms.date: 11/11/2024 zone_pivot_groups: dev-environment Upgrade to .NET Aspire 9.0 .NET Aspire 9.0 is now generally available. In this article, you learn the steps involved in updating your existing .NET Aspire 8.x projects to .NET Aspire 9.0. There are a few ways in which you can update your projects to .NET Aspire 9.0: Manually upgrade your projects to .NET Aspire 9.0. Use the Upgrade Assistant to upgrade your projects to .NET Aspire 9.0. [!TIP] If you're new to .NET Aspire, there's no reason to upgrade anything. For more information, see .NET Aspire setup and tooling. Prerequisites Before you upgrade your projects to .NET Aspire 9.0, ensure that you have the following prerequisites: Install the latest tooling. Use the .NET Aspire SDK. [!NOTE] Feel free to uninstall the .NET Aspire workload as you'll no longer need it. dotnetcli dotnet workload uninstall aspire For more information, see dotnet workload uninstall. If you don't uninstall the .NET Aspire workload, and you're using the new .NET Aspire SDK and templates, you see both .NET Aspire 8.0 and .NET Aspire 9.0 templates.  Use the Upgrade Assistant to upgrade your projects to .NET Aspire 9.0. [!TIP] If you're new to .NET Aspire, there's no reason to upgrade anything. For more information, see .NET Aspire setup and tooling. Prerequisites Before you upgrade your projects to .NET Aspire 9.0, ensure that you have the following prerequisites: Install the latest tooling. Use the .NET Aspire SDK. [!NOTE] Feel free to uninstall the .NET Aspire workload as you'll no longer need it. dotnetcli dotnet workload uninstall aspire For more information, see dotnet workload uninstall. If you don't uninstall the .NET Aspire workload, and you're using the new .NET Aspire SDK and templates, you see both .NET Aspire 8.0 and .NET Aspire 9.0 templates. Manually upgrade to .NET Aspire 9.0 To upgrade your projects to .NET Aspire 9.0, you need to update your project files. The following steps guide you through the process: Edit your app host project file to use the new .NET Aspire 9.0 SDK (Aspire.AppHost.Sdk).""]","To upgrade a .NET Aspire 8.x project to .NET Aspire 9.0 using the Upgrade Assistant, you need to follow these steps: First, ensure that the Upgrade Assistant is installed, either as a Visual Studio extension or as a .NET CLI global tool. In Visual Studio, right-click the project in Solution Explorer and select 'Upgrade'. If the Upgrade Assistant isn't installed, you'll be prompted to install it. Choose the 'Aspire upgrades' option and select the components to upgrade. After the upgrade process, verify that the upgrade was successful by checking for green check marks next to each component. For the .NET CLI, open a terminal session at the root directory of the project file and run the command 'dotnetcli upgrade-assistant upgrade'. Select the 'Aspire upgrades' option and confirm the upgrade. After the upgrade, update the NuGet packages to version 9.0.0 using the command 'dotnet add package Aspire.Hosting.AppHost --version 9.0.0'. In the project files, update the TargetFramework property to 'net9.0' and ensure the Aspire.AppHost.Sdk is used. Verify the upgrade by building the solution and checking for any issues.",multi_hop_specific_query_synthesizer
39,How can the Program.cs file be utilized to integrate both MongoDB and Milvus clients in a .NET Aspire application?,"['<1-hop>\n\nClient integration To get started with the .NET Aspire MongoDB client integration, install the ðŸ“¦ Aspire.MongoDB.Driver NuGet package in the client-consuming project, that is, the project for the application that uses the MongoDB client. The MongoDB client integration registers a IMongoClient instance that you can use to interact with the MongoDB server resource. If your app host adds MongoDB database resources, the IMongoDatabase instance is also registered. .NET CLI dotnetcli dotnet add package Aspire.MongoDB.Driver PackageReference xml <PackageReference Include=""Aspire.MongoDB.Driver"" Version=""*"" /> Add MongoDB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddMongoDBClient(connectionName: ""mongodb""); [!TIP] The connectionName parameter must match the name used when adding the MongoDB server resource (or the database resource when provided) in the app host project. In other words, when you call AddDatabase and provide a name of mongodb that same name should be used when calling AddMongoDBClient. For more information, see Add MongoDB server resource and database resource. You can then retrieve the IMongoClient instance using dependency injection. For example, to retrieve the client from an example service: csharp public class ExampleService(IMongoClient client) { // Use client... } The IMongoClient is used to interact with the MongoDB server resource. It can be used to create databases that aren\'t already known to the app host project. When you define a MongoDB database resource in your app host, you could instead require that the dependency injection container provides an IMongoDatabase instance. For more information on dependency injection, see .NET dependency injection. Add keyed MongoDB client There might be situations where you want to register multiple IMongoDatabase instances with different connection names. To register keyed MongoDB clients, call the csharp builder.AddKeyedMongoDBClient(name: ""mainDb""); builder.AddKeyedMongoDBClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your MongoDB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the IMongoDatabase instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] IMongoDatabase mainDatabase, [FromKeyedServices(""loggingDb"")] IMongoDatabase loggingDatabase) { // Use databases... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire MongoDB database integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddMongoDBClient(): csharp builder.AddMongoDBClient(""mongo""); The connection string is retrieved from the ConnectionStrings configuration section. Consider the following MongoDB example JSON configuration: json { ""ConnectionStrings"": { ""mongo"": ""mongodb://server:port/test"", } } Alternatively, consider the following MongoDB Atlas example JSON configuration: json { ""ConnectionStrings"": { ""mongo"": ""mongodb+srv://username:password@server.mongodb.net/"", } } For more information on how to format this connection string, see MongoDB: ConnectionString documentation. Use configuration providers The .NET Aspire MongoDB integration supports json { ""Aspire"": { ""MongoDB"": { ""Driver"": { ""ConnectionString"": ""mongodb://server:port/test"", ""DisableHealthChecks"": false, ""HealthCheckTimeout"": 10000, ""DisableTracing"": false }, } } Use inline configurations You can also pass the Action<MongoDBSettings> delegate to set up some or all the options inline: csharp builder.AddMongoDBClient(""mongodb"", static settings => settings.ConnectionString = ""mongodb://server:port/test""); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the MongoDB database database to connect to. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. HealthCheckTimeout An int? value that indicates the MongoDB health check timeout in milliseconds. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. [!INCLUDE integration-health-checks] By default, the .NET Aspire MongoDB client integration handles the following scenarios: Adds a health check when enabled that verifies that a connection can be made commands can be run against the MongoDB database within a certain amount of time. Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire MongoDB database integration uses standard .NET logging, and you see log entries from the following categories: MongoDB[.*]: Any log entries from the MongoDB namespace. Tracing The .NET Aspire MongoDB database integration emits the following Tracing activities using OpenTelemetry: MongoDB.Driver.Core.Extensions.DiagnosticSources Metrics The .NET Aspire MongoDB database integration doesn\'t currently expose any OpenTelemetry metrics. See also MongoDB database .NET Aspire integrations .NET Aspire GitHub repo', '<2-hop>\n\nClient integration To get started with the .NET Aspire Milvus client integration, install the ðŸ“¦ Aspire.Milvus.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Milvus database client. The Milvus client integration registers a Milvus.Client.MilvusClient instance that you can use to interact with Milvus databases. .NET CLI dotnetcli dotnet add package Aspire.Milvus.Client PackageReference xml <PackageReference Include=""Aspire.Milvus.Client"" Version=""*"" /> Add a Milvus client In the Program.cs file of your client-consuming project, call the csharp builder.AddMilvusClient(""milvusdb""); [!TIP] The connectionName parameter must match the name used when adding the Milvus database resource in the app host project. In other words, when you call AddDatabase and provide a name of milvusdb that same name should be used when calling AddMilvusClient. For more information, see Add a Milvus server resource and database resource. You can then retrieve the MilvusClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(MilvusClient client) { // Use the Milvus Client... } For more information on dependency injection, see .NET dependency injection. Add a keyed Milvus client There might be situations where you want to register multiple MilvusClient instances with different connection names. To register keyed Milvus clients, call the csharp builder.AddKeyedMilvusClient(name: ""mainDb""); builder.AddKeyedMilvusClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Milvus resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the MilvusClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] MilvusClient mainDbClient, [FromKeyedServices(""loggingDb"")] MilvusClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Milvus client integration provides multiple options to configure the connection to Milvus based on the requirements and conventions of your project. [!TIP] The default use is root and the default password is Milvus. To configure a different password in the Milvus container, see Handling credentials and passing other parameters for the Milvus resource. Use the following techniques to configure consuming client apps in your .NET Aspire solution with the same password or other settings. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddMilvusClient(): csharp builder.AddMilvusClient(""milvus""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""milvus"": ""Endpoint=http://localhost:19530/;Key=root:Non-default-P@ssw0rd"" } } By default the MilvusClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Milvus client integration supports json { ""Aspire"": { ""Milvus"": { ""Client"": { ""Endpoint"": ""http://localhost:19530/"", ""Database"": ""milvusdb"", ""Key"": ""root:Non-default-P@ssw0rd"", ""DisableHealthChecks"": false } } } } For the complete Milvus client integration JSON schema, see Aspire.Milvus.Client/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MilvusSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddMilvusClient( ""milvus"", static settings => settings.Key = ""root:Non-default-P@ssw0rd""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Milvus database integration: Adds the health check when Uses the configured client to perform a HealthAsync. If the result is healthy, the health check is considered healthy, otherwise it\'s unhealthy. Likewise, if there\'s an exception, the health check is considered unhealthy with the error propagating through the health check failure. [!INCLUDE integration-observability-and-telemetry]']","In a .NET Aspire application, the Program.cs file is used to integrate both MongoDB and Milvus clients by calling specific builder methods. For MongoDB, you use builder.AddMongoDBClient(connectionName: ""mongodb""); to register an IMongoClient instance, ensuring the connectionName matches the name used when adding the MongoDB server resource. Similarly, for Milvus, you call builder.AddMilvusClient(""milvusdb""); to register a MilvusClient instance, with the connectionName matching the Milvus database resource. Both integrations allow for dependency injection to retrieve the respective client instances in services.",multi_hop_specific_query_synthesizer
40,How you use .NET CLI to create and configure a new Worker Service project with .NET Aspire templates?,"['<1-hop>\n\nCreate the sample solution To create a new .NET Aspire Starter Application, you can use either Visual Studio, Visual Studio Code, or the .NET CLI. :::zone pivot=""visual-studio"" [!INCLUDE visual-studio-file-new] :::zone-end :::zone pivot=""vscode"" [!INCLUDE vscode-file-new] :::zone-end :::zone pivot=""dotnet-cli"" [!INCLUDE dotnet-cli-file-new] :::zone-end Add the Worker Service project Next, add a Worker Service project to the solution to retrieve and process messages to and from Azure Service Bus. :::zone pivot=""visual-studio"" In the solution explorer, right click on the top level AspireSample solution node and select Add > New project. Search for and select the Worker Service template and choose Next. For the Project name, enter AspireSample.WorkerService and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Make sure Enlist in .NET Aspire orchestration is checked and select Create. Visual Studio adds the project to your solution and updates the :::no-loc text=""Program.cs""::: file of the AspireSample.AppHost project with a new line of code: csharp builder.AddProject<Projects.AspireSample_WorkerService>( ""aspiresample-workerservice""); Visual Studio tooling added this line of code to register your new project with the :::zone-end :::zone pivot=""vscode"" From the Solution Explorer in Visual Studio Code, select the + button next to the solution name to add a new project to the solution: :::image type=""content"" source=""media/vscode-add-project.png"" lightbox=""media/vscode-add-project.png"" alt-text=""Visual Studio Code: Add new project from C# DevKit Solution Explorer.""::: To filter the project templates, enter Worker in the search box and select the Worker Service template that\'s found: :::image type=""content"" source=""media/vscode-create-worker.png"" lightbox=""media/vscode-create-worker.png"" alt-text=""Visual Studio Code: Filter to Worker Service project template from Add project.""::: Choose the Worker Service template and enter the project name as AspireSample.WorkerService. Select Default directory to create the project in the same directory as the solution. Select Create project to add the project to the solution. Right-click on the AspireSample.AppHost project in the Solution Explorer and select Add Project Reference: :::image type=""content"" source=""media/vscode-add-project-reference.png"" lightbox=""media/vscode-add-project-reference.png"" alt-text=""Visual Studio Code: Add project reference from AspireSample.AppHost to AspireSample.WorkerService.""::: Add the following line of code to the :::no-loc text=""Program.cs""::: file in the AspireSample.AppHost project before the call to builder.Build().Run();: csharp builder.AddProject<Projects.AspireSample_WorkerService>( ""aspiresample-workerservice""); :::zone-end :::zone pivot=""dotnet-cli"" In the root directory of the app, use the dotnet new command to create a new Worker Service app: dotnetcli dotnet new worker --name AspireSample.WorkerService Use the dotnet sln command to add the project to the solution: dotnetcli dotnet sln AspireSample.sln add AspireSample.WorkerService/AspireSample.WorkerService.csproj Use the dotnet add command to add a project reference between the .AppHost and .WorkerService project: dotnetcli dotnet add AspireSample.AppHost/AspireSample.AppHost.csproj reference AspireSample.WorkerService/AspireSample.WorkerService.csproj Add the following line of code to the :::no-loc text=""Program.cs""::: file in the AspireSample.AppHost project before the call to builder.Build().Run();: csharp builder.AddProject<Projects.AspireSample_WorkerService>( ""aspiresample-workerservice""); :::zone-end The completed solution structure should resemble the following, assuming the top-level directory is named aspire-messaging: Directory â””â”€â”€â”€ðŸ“‚ aspire-messaging â”œâ”€â”€â”€ðŸ“‚ AspireSample.WorkerService â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.WorkerService.csproj â”‚ â”œâ”€â”€â”€ Program.cs â”‚ â””â”€â”€â”€ Worker.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.ApiService â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.ApiService.csproj â”‚ â””â”€â”€â”€ Program.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.AppHost â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.AppHost.csproj â”‚ â””â”€â”€â”€ Program.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.ServiceDefaults â”‚ â”œâ”€â”€â”€ AspireSample.ServiceDefaults.csproj â”‚ â””â”€â”€â”€ Extensions.cs â”œâ”€â”€â”€ðŸ“‚ AspireSample.Web â”‚ â”œâ”€â”€â”€ðŸ“‚ Components â”‚ â”‚ â”œâ”€â”€â”€ðŸ“‚ Layout â”‚ â”‚ â”‚ â”œâ”€â”€â”€ MainLayout.razor â”‚ â”‚ â”‚ â”œâ”€â”€â”€ MainLayout.razor.css â”‚ â”‚ â”‚ â”œâ”€â”€â”€ NavMenu.razor â”‚ â”‚ â”‚ â””â”€â”€â”€ NavMenu.razor.css â”‚ â”‚ â”œâ”€â”€â”€ðŸ“‚ Pages â”‚ â”‚ â”‚ â”œâ”€â”€â”€ Counter.razor â”‚ â”‚ â”‚ â”œâ”€â”€â”€ Error.razor â”‚ â”‚ â”‚ â”œâ”€â”€â”€ Home.razor â”‚ â”‚ â”‚ â””â”€â”€â”€ Weather.razor â”‚ â”‚ â”œâ”€â”€â”€ _Imports.razor â”‚ â”‚ â”œâ”€â”€â”€ App.razor â”‚ â”‚ â””â”€â”€â”€ Routes.razor â”‚ â”œâ”€â”€â”€ðŸ“‚ Properties â”‚ â”‚ â””â”€â”€â”€ launchSettings.json â”‚ â”œâ”€â”€â”€ðŸ“‚ wwwroot â”‚ â”‚ â”œâ”€â”€â”€ðŸ“‚ bootstrap â”‚ â”‚ â”‚ â”œâ”€â”€â”€ bootstrap.min.css â”‚ â”‚ â”‚ â””â”€â”€â”€ bootstrap.min.css.map â”‚ â”‚ â”œâ”€â”€â”€ app.css â”‚ â”‚ â””â”€â”€â”€ favicon.png â”‚ â”œâ”€â”€â”€ appsettings.Development.json â”‚ â”œâ”€â”€â”€ appsettings.json â”‚ â”œâ”€â”€â”€ AspireSample.Web.csproj â”‚ â”œâ”€â”€â”€ Program.cs â”‚ â””â”€â”€â”€ WeatherApiClient.cs â””â”€â”€â”€ AspireSample.sln', '<2-hop>\n\nProject templates and tooling .NET Aspire provides a set of project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI. These templates are designed to help you create and interact with .NET Aspire projects, or add .NET Aspire into your existing codebase. The templates include a set of opinionated defaults to help you get started quickly - for example, it has boilerplate code for turning on health checks and logging in .NET apps. These defaults are fully customizable, so you can edit and adapt them to suit your needs. .NET Aspire templates also include boilerplate extension methods that handle common service configurations for you: csharp builder.AddServiceDefaults(); For more information on what AddServiceDefaults does, see .NET Aspire service defaults. When added to your :::no-loc text=""Program.cs""::: file, the preceding code handles the following concerns: OpenTelemetry: Sets up formatted logging, runtime metrics, built-in meters, and tracing for ASP.NET Core, gRPC, and HTTP. For more information, see .NET Aspire telemetry. Default health checks: Adds default health check endpoints that tools can query to monitor your app. For more information, see .NET app health checks in C#. Service discovery: Enables service discovery for the app and configures Next steps [!div class=""nextstepaction""] Quickstart: Build your first .NET Aspire project']","To create and configure a new Worker Service project using the .NET CLI with .NET Aspire templates, you start by using the 'dotnet new' command in the root directory of your app: 'dotnet new worker --name AspireSample.WorkerService'. This command creates a new Worker Service app. Next, you add the project to your solution using 'dotnet sln AspireSample.sln add AspireSample.WorkerService/AspireSample.WorkerService.csproj'. To establish a project reference between the .AppHost and .WorkerService projects, use 'dotnet add AspireSample.AppHost/AspireSample.AppHost.csproj reference AspireSample.WorkerService/AspireSample.WorkerService.csproj'. Finally, add the line 'builder.AddProject<Projects.AspireSample_WorkerService>(""aspiresample-workerservice"");' to the 'Program.cs' file in the AspireSample.AppHost project before the call to 'builder.Build().Run();'. This setup utilizes the .NET Aspire templates, which include opinionated defaults and boilerplate code for health checks and logging, to quickly get your project started.",multi_hop_specific_query_synthesizer
41,how to connect asp.net core app to azure sql database using .net aspire and deploy it to azure?,"['<1-hop>\n\ntitle: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core description: Learn how to connect an ASP.NET Core app to to SQL Server using .NET Aspire and Entity Framework Core. ms.date: 12/02/2024 ms.topic: tutorial Tutorial: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core In this tutorial, you create an ASP.NET Core app that uses a .NET Aspire Entity Framework Core SQL Server integration to connect to SQL Server to read and write support ticket data. Entity Framework Core is a lightweight, extensible, open source object-relational mapper that enables .NET developers to work with databases using .NET objects. You\'ll learn how to: [!div class=""checklist""] Create a basic .NET app that is set up to use .NET Aspire integrations Add a .NET Aspire integration to connect to SQL Server Configure and use .NET Aspire Component features to read and write from the database [!INCLUDE aspire-prereqs] Create the sample solution At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Blazor and select Blazor Web App. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQLEFCore. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Ensure the Interactive render mode is set to None. Check the Enlist in .NET Aspire orchestration option and select Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQLEFCore: A Blazor project that depends on service defaults. AspireSQLEFCore.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQLEFCore.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Create the database model and context classes To represent a user submitted support request, add the following SupportTicket model class at the root of the AspireSQLEFCore project. :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/SupportTicket.cs""::: Add the following TicketDbContext data context class at the root of the AspireSQLEFCore project. The class inherits :::code source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/TicketContext.cs""::: Add the .NET Aspire integration to the Blazor app Add the .NET Aspire Entity Framework Core Sql Server library package to your AspireSQLEFCore project: dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer Your AspireSQLEFCore project is now set up to use .NET Aspire integrations. Here\'s the updated AspireSQLEFCore.csproj file: :::code language=""xml"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/AspireSQLEFCore.csproj"" highlight=""10""::: Configure the .NET Aspire integration In the :::no-loc text=""Program.cs""::: file of the AspireSQLEFCore project, add a call to the :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-14"" highlight=""5""::: This method accomplishes the following tasks: Registers a TicketContext with the DI container for connecting to the containerized Azure SQL Database. Automatically enable corresponding health checks, logging, and telemetry. Create the database While developing locally, you need to create a database inside the SQL Server container. Update the :::no-loc text=""Program.cs""::: file with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Program.cs"" range=""1-30"" highlight=""16-30""::: The preceding code: Checks if the app is running in a development environment. If it is, it retrieves the TicketContext service from the DI container and calls Database.EnsureCreated() to create the database if it doesn\'t already exist. [!NOTE] Note that EnsureCreated() is not suitable for production environments, and it only creates the database as defined in the context. It doesn\'t apply any migrations. For more information on Entity Framework Core migrations in .NET Aspire, see Apply Entity Framework Core migrations in .NET Aspire. Create the form The app requires a form for the user to be able to submit support ticket information and save the entry to the database. Use the following Razor markup to create a basic form, replacing the contents of the Home.razor file in the AspireSQLEFCore/Components/Pages directory: :::code language=""razor"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore/Components/Pages/Home.razor""::: For more information about creating forms in Blazor, see ASP.NET Core Blazor forms overview. Configure the AppHost The AspireSQLEFCore.AppHost project is the orchestrator for your app. It\'s responsible for connecting and configuring the different projects and services of your app. The orchestrator should be set as the startup project. Add the .NET Aspire Hosting Sql Server NuGet package to your AspireStorage.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQLEFCore.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/AspireSQLEFCore/AspireSQLEFCore.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The Entity Framework classes you configured earlier will automatically use this connection when migrating and connecting to the database.', '<2-hop>\n\ntitle: Deploy a ASP.NET Core app that connects to SQL Server to Azure description: Learn how to deploy a ASP.NET Core app that connects to SQL Server to Azure ms.date: 11/08/2024 ms.topic: how-to Tutorial: Deploy a .NET Aspire project with a SQL Server Database to Azure In this tutorial, you learn to configure an ASP.NET Core app with a SQL Server Database for deployment to Azure. .NET Aspire provides multiple SQL Server integration configurations that provision different database services in Azure. You\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET Core app that is configured to use the .NET Aspire SQL Server integration Configure the app to provision an Azure SQL Database Configure the app to provision a containerized SQL Server database [!NOTE] This document focuses specifically on .NET Aspire configurations to provision and deploy SQL Server resources in Azure. Visit the Azure Container Apps deployment tutorial to learn more about the full .NET Aspire deployment process. [!INCLUDE aspire-prereqs] Create the sample solution Visual Studio At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Aspire and select .NET Aspire - Starter Application. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQL. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Verify that .NET 9.0 is selected and choose Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. .NET CLI In an empty directory, run the following command to create a new .NET Aspire project: dotnetcli dotnet new aspire-starter --output AspireSQL The .NET CLI creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Configure the app for SQL Server deployment .NET Aspire provides two built-in configuration options to streamline SQL Server deployment on Azure: Provision a containerized SQL Server database using Azure Container Apps Provision an Azure SQL Database instance Add the .NET Aspire integration to the app Add the appropriate .NET Aspire integration to the AspireSQL.AppHost project for your desired hosting service. Azure SQL Database Add the ðŸ“¦ Aspire.Hosting.Azure.Sql NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.Azure.Sql SQL Server Container Add the ðŸ“¦ Aspire.Hosting.SqlServer NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Configure the AppHost project Configure the AspireSQL.AppHost project for your desired SQL database service. Azure SQL Database Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeployazure/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The PublishAsAzureSqlDatabase method ensures that tools such as the Azure Developer CLI or Visual Studio create an Azure SQL Database resource during the deployment process. SQL Server Container Replace the contents of the Program.cs file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeploycontainer/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. This configuration also ensures that tools such as the Azure Developer CLI or Visual Studio create a containerized SQL Server instance during the deployment process.']","To connect an ASP.NET Core app to an Azure SQL Database using .NET Aspire, you first need to create a basic .NET app set up to use .NET Aspire integrations. This involves adding the .NET Aspire Entity Framework Core SQL Server library package to your project and configuring the app to connect to a containerized Azure SQL Database. Once the app is configured, you can deploy it to Azure by provisioning an Azure SQL Database instance. This is done by adding the Aspire.Hosting.Azure.Sql NuGet package to your AppHost project and configuring it to ensure that tools like the Azure Developer CLI or Visual Studio create the necessary Azure SQL Database resource during the deployment process.",multi_hop_specific_query_synthesizer
42,How do the AspNetCore.HealthChecks.Npgsql and AspNetCore.HealthChecks.Kafka packages enhance the reliability of .NET Aspire applications integrating PostgreSQL and Kafka?,"['<1-hop>\n\ntitle: .NET Aspire Apache Kafka integration description: Learn how to use the .NET Aspire Apache Kafka client message-broker integration. ms.date: 10/11/2024 uid: messaging/kafka-integration .NET Aspire Apache Kafka integration [!INCLUDE includes-hosting-and-client] Apache Kafka is an open-source distributed event streaming platform. It\'s useful for building real-time data pipelines and streaming applications. The .NET Aspire Apache Kafka integration enables you to connect to existing Kafka instances, or create new instances from .NET with the docker.io/confluentinc/confluent-local container image. Hosting integration The Apache Kafka hosting integration models a Kafka server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Kafka PackageReference xml <PackageReference Include=""Aspire.Hosting.Kafka"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Kafka server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/confluentinc/confluent-local image, it creates a new Kafka server instance on your local machine. A reference to your Kafka server (the kafka variable) is added to the ExampleProject. The Kafka server resource includes default ports The [!TIP] If you\'d rather connect to an existing Kafka server, call Add Kafka UI To add the Kafka UI to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithKafkaUI(); builder.AddProject // After adding all resources, run the app... ``` The Kafka UI is a free, open-source web UI to monitor and manage Apache Kafka clusters. .NET Aspire adds another container image docker.io/provectuslabs/kafka-ui to the app host that runs the Kafka UI. Change the Kafka UI host port To change the Kafka UI host port, chain a call to the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithKafkaUI(kafkaUI => kafkaUI.WithHostPort(9100)); builder.AddProject // After adding all resources, run the app... ``` The Kafka UI is accessible at http://localhost:9100 in the preceding example. Add Kafka server resource with data volume To add a data volume to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Kafka server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/kafka/data path in the Kafka server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Kafka server resource with data bind mount To add a data bind mount to the Kafka server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var kafka = builder.AddKafka(""kafka"") .WithDataBindMount( source: @""C:\\Kafka\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Kafka server data across container restarts. The data bind mount is mounted at the C:\\Kafka\\Data on Windows (or /Kafka/Data on Unix) path on the host machine in the Kafka server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Kafka hosting integration automatically adds a health check for the Kafka server resource. The health check verifies that a Kafka producer with the specified connection name is able to connect and persist a topic to the Kafka server. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Kafka NuGet package.', '<2-hop>\n\ntitle: .NET Aspire PostgreSQL Entity Framework Core integration description: Learn how to integrate PostgreSQL with .NET Aspire applications using Entity Framework Core, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-ef-core-integration .NET Aspire PostgreSQL Entity Framework Core integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL Entity Framework Core integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL Entity Framework Core client integration, install the ðŸ“¦ Aspire.Npgsql.EntityFrameworkCore.PostgreSQL NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The .NET Aspire PostgreSQL Entity Framework Core client integration registers your desired DbContext subclass instances that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql.EntityFrameworkCore.PostgreSQL PackageReference xml <PackageReference Include=""Aspire.Npgsql.EntityFrameworkCore.PostgreSQL"" Version=""*"" /> Add Npgsql database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDbContext<YourDbContext>(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding YourDbContext to the builder, you can get the YourDbContext instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(YourDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add Npgsql database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichNpgsqlDbContext<YourDbContext>( connectionName: ""postgresdb"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30; }); The settings parameter is an instance of the Configuration The .NET Aspire PostgreSQL Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling the csharp builder.AddNpgsqlDbContext<MyDbContext>(""pgdb""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""pgdb"": ""Host=myserver;Database=test"" } } The EnrichNpgsqlDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it\'s called. For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL Entity Framework Core integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""EntityFrameworkCore"": { ""PostgreSQL"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true } } } } } For the complete PostgreSQL Entity Framework Core client integration JSON schema, see Aspire.Npgsql.EntityFrameworkCore.PostgreSQL/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlEntityFrameworkCorePostgreSQLSettings> delegate to set up some or all the options inline, for example to set the ConnectionString: csharp builder.AddNpgsqlDbContext<YourDbContext>( ""pgdb"", static settings => settings.ConnectionString = ""<YOUR CONNECTION STRING>""); Configure multiple DbContext classes If you want to register more than one json { ""Aspire"": { ""Npgsql"": { ""EntityFrameworkCore"": { ""PostgreSQL"": { ""ConnectionString"": ""<YOUR CONNECTION STRING>"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""AnotherDbContext"": { ""ConnectionString"": ""<ANOTHER CONNECTION STRING>"", ""DisableTracing"": false } } } } } } Then calling the csharp builder.AddNpgsqlDbContext<AnotherDbContext>(); [!INCLUDE integration-health-checks] By default, the .NET Aspire PostgreSQL Entity Framework Core integrations handles the following: Adds the DbContextHealthCheck, which calls EF Core\'s Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]']","The AspNetCore.HealthChecks.Npgsql package enhances the reliability of .NET Aspire applications integrating PostgreSQL by automatically adding a health check for the PostgreSQL server resource. This health check verifies that the PostgreSQL server is running and that a connection can be established to it. Similarly, the AspNetCore.HealthChecks.Kafka package is used in the Kafka hosting integration to automatically add a health check for the Kafka server resource. This health check ensures that a Kafka producer with the specified connection name can connect and persist a topic to the Kafka server. These health checks are crucial for maintaining the reliability and performance of applications by ensuring that the necessary services are operational and accessible.",multi_hop_specific_query_synthesizer
43,"How does .NET Aspire facilitate the use of Azure Storage in both publish and run modes, and what role do local emulators play in this process?","['<1-hop>\n\ntitle: Azure integrations overview description: Overview of the Azure integrations available in the .NET Aspire. ms.date: 12/17/2024 uid: dotnet/aspire/integrations/azure-overview .NET Aspire Azure integrations overview Azure is the most popular cloud platform for building and deploying .NET applications. The Azure SDK for .NET allows for easy management and use of Azure services. .NET Aspire provides a set of integrations with Azure services, where you\'re free to add new resources or connect to existing ones. This article details some common aspects of all Azure integrations in .NET Aspire and aims to help you understand how to use them. Add connection to existing Azure resources .NET Aspire provides the ability to connect to existing resources, including Azure resources. Expressing connection strings is useful when you have existing Azure resources that you want to use in your .NET Aspire app. The [!INCLUDE connection-strings-alert] Consider the following example, where in publish mode you add an Azure Storage resource while in run mode you add a connection string to an existing Azure Storage: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.ExecutionContext.IsPublishMode ? builder.AddAzureStorage(""storage"") : builder.AddConnectionString(""storage""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Creates a new builder instance. Adds a Azure Storage resource named storage in ""publish"" mode. Adds a connection string to an existing Azure Storage named storage in ""run"" mode. Adds a project named api to the builder. The api project references the storage resource regardless of the mode. The consuming API project uses the connection string information with no knowledge of how the app host configured it. In ""publish"" mode, the code adds a new Azure Storage resourceâ€”which would be reflected in the deployment manifest accordingly. When in ""run"" mode, the connection string corresponds to a configuration value visible to the app host. It\'s assumed that any and all role assignments for the target resource have been configured. This means, you\'d likely configure an environment variable or a user secret to store the connection string. The configuration is resolved from the ConnectionStrings__storage (or ConnectionStrings:storage) configuration key. These configuration values can be viewed when the app runs. For more information, see Resource details. Add Azure resources All .NET Aspire Azure hosting integrations expose Azure resources and by convention are added using AddAzure* APIs. When you add these resources to your .NET Aspire app host, they represent an Azure service. The AddAzure* API returns an <xref:Aspire.Hosting.ApplicationModel.IResourceBuilder1> whereTis the type of Azure resource. TheseIResourceBuilder Typical developer experience When your .NET Aspire app host contains Azure resources, and you run it locally (typical developer F5 or dotnet run experience), the Azure resources are provisioned in your Azure subscription. This allows you as the developer to debug against them locally in the context of your app host. .NET Aspire aims to minimize costs by defaulting to Basic or Standard Stock Keeping Unit (SKU) for its Azure integrations. While these sensible defaults are provided, you can customize the Azure resources to suit your needs. Additionally, some integrations support emulators or containers, which are useful for local development, testing, and debugging. By default, when you run your app locally, the Azure resources use the actual Azure service. However, you can configure them to use local emulators or containers, avoiding costs associated with the actual Azure service during local development.', '<2-hop>\n\nLocal emulators Some Azure services can be run locally in emulators. Currently, .NET Aspire supports the following Azure emulators: Hosting integration Description Azure Cosmos DB Call on the IResourceBuilder<AzureCosmosDBResource> to configure the Cosmos DB resource to be emulated with the NoSQL API . Azure Event Hubs Call on the IResourceBuilder<AzureEventHubsResource> to configure the Event Hubs resource to be emulated . Azure Storage Call on the IResourceBuilder<AzureStorageResource> to configure the Storage resource to be emulated with Azurite . To have your Azure resources use the local emulators, chain a call the RunAsEmulator method on the Azure resource builder. This method configures the Azure resource to use the local emulator instead of the actual Azure service. [!IMPORTANT] Calling any of the available RunAsEmulator APIs on an Azure resource builder doesn\'t impact the publishing manifest. When you publish your app, generated Bicep file reflects the actual Azure service, not the local emulator. var endpoint = storage.GetOutput(""endpoint""); var apiService = builder.AddProject For more information, see Bicep outputs. Get secret outputs from Bicep references It\'s important to avoid outputs for secrets when working with Bicep. If an output is considered a secret, meaning it shouldn\'t be exposed in logs or other places, you can treat it as such. This can be achieved by storing the secret in Azure Key Vault and referencing it in the Bicep template. .NET Aspire\'s Azure integration provides a pattern for securely storing outputs from the Bicep template by allows resources to use the keyVaultName parameter to store secrets in Azure Key Vault. Consider the following Bicep template as an example the helps to demonstrate this concept of securing secret outputs: :::code language=""bicep"" source=""snippets/AppHost.Bicep/cosmosdb.bicep"" highlight=""2,41""::: The preceding Bicep template expects a keyVaultName parameter, among several other parameters. It then defines an Azure Cosmos DB resource and stashes a secret into Azure Key Vault, named connectionString which represents the fully qualified connection string to the Cosmos DB instance. To access this secret connection string value, you can use the following code snippet: :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.cs"" id=""secrets""::: In the preceding code snippet, the cosmos Bicep template is added as a reference to the builder. The connectionString secret output is retrieved from the Bicep template and stored in a variable. The secret output is then passed as an environment variable (ConnectionStrings__cosmos) to the api project. This environment variable is used to connect to the Cosmos DB instance. When this resource is deployed, the underlying deployment mechanism will automatically Reference secrets from Azure Key Vault. To guarantee secret isolation, .NET Aspire creates a Key Vault per source. [!NOTE] In local provisioning mode, the secret is extracted from Key Vault and set it in an environment variable. For more information, see Local Azure provisioning. Publishing When you publish your app, the Azure provisioning generated Bicep is used by the Azure Developer CLI to create the Azure resources in your Azure subscription. .NET Aspire outputs a publishing manifest, that\'s also a vital part of the publishing process. The Azure Developer CLI is a command-line tool that provides a set of commands to manage Azure resources. For more information on publishing and deployment, see Deploy a .NET Aspire project to Azure Container Apps using the Azure Developer CLI (in-depth guide).']",".NET Aspire facilitates the use of Azure Storage by allowing developers to add an Azure Storage resource in 'publish' mode and a connection string to an existing Azure Storage in 'run' mode. In 'publish' mode, a new Azure Storage resource is added, which is reflected in the deployment manifest. In 'run' mode, the connection string corresponds to a configuration value visible to the app host, allowing the consuming API project to use the connection string information without knowledge of the app host's configuration. Local emulators, such as Azurite for Azure Storage, can be used to run Azure services locally. By chaining a call to the RunAsEmulator method on the Azure resource builder, developers can configure the Azure resource to use the local emulator instead of the actual Azure service. This setup is beneficial for local development, testing, and debugging, as it avoids costs associated with using the actual Azure service.",multi_hop_specific_query_synthesizer
44,How .NET CLI help in building and configuring .NET Aspire projects?,"['<1-hop>\n\ntitle: .NET Aspire overview description: Learn about .NET Aspire, an application stack designed to improve the experience of building distributed applications. ms.date: 11/12/2024 .NET Aspire overview :::row::: :::column::: :::image type=""icon"" border=""false"" source=""../../assets/dotnet-aspire-logo-128.svg""::: :::column-end::: :::column span=""3""::: .NET Aspire is a set of tools, templates, and packages for building observable, production ready apps.\u200b\u200b .NET Aspire is delivered through a collection of NuGet packages that bootstrap or improve specific challenges with modern app development. Today\'s apps generally consume a large number of services, such as databases, messaging, and caching, many of which are supported via .NET Aspire Integrations. For information on support, see the .NET Aspire Support Policy. :::column-end::: :::row-end::: Why .NET Aspire? .NET Aspire improves the experience of building apps that have a variety of projects and resources. With dev-time productivity enhancements that emulate deployed scenarios, you can quickly develop interconnected apps. Designed for flexibility, .NET Aspire allows you to replace or extend parts with your preferred tools and workflows. Key features include: Dev-Time Orchestration: .NET Aspire provides features for running and connecting multi-project applications, container resources, and other dependencies for local development environments. Integrations: .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects.  .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects. Dev-time orchestration In .NET Aspire, ""orchestration"" primarily focuses on enhancing the local development experience by simplifying the management of your app\'s configuration and interconnections. It\'s important to note that .NET Aspire\'s orchestration isn\'t intended to replace the robust systems used in production environments, such as Kubernetes. Instead, it\'s a set of abstractions that streamline the setup of service discovery, environment variables, and container configurations, eliminating the need to deal with low-level implementation details. With .NET Aspire, your code has a consistent bootstrapping experience on any dev machine without the need for complex manual steps, making it easier to manage during the development phase. .NET Aspire orchestration assists with the following concerns: App composition: Specify the .NET projects, containers, executables, and cloud resources that make up the application. Service discovery and connection string management: The app host injects the right connection strings, network configurations, and service discovery information to simplify the developer experience. For example, using .NET Aspire, the following code creates a local Redis container resource, waits for it to become available, and then configures the appropriate connection string in the ""frontend"" project with a few helper method calls: ```csharp // Create a distributed application builder given the command line arguments. var builder = DistributedApplication.CreateBuilder(args); // Add a Redis server to the application. var cache = builder.AddRedis(""cache""); // Add the frontend project to the application and configure it to use the // Redis server, defined as a referenced dependency. builder.AddProject For more information, see .NET Aspire orchestration overview. [!IMPORTANT] The call to .NET Aspire integrations .NET Aspire integrations are NuGet packages designed to simplify connections to popular services and platforms, such as Redis or PostgreSQL. .NET Aspire integrations handle cloud resource setup and interaction for you through standardized patterns, such as adding health checks and telemetry. Integrations are two-fold - ""hosting"" integrations represents the service you\'re connecting to, and ""client"" integrations represents the client or consumer of that service. In other words, for many hosting packages there\'s a corresponding client package that handles the service connection within your code. Each integration is designed to work with the .NET Aspire app host, and their configurations are injected automatically by referencing named resources. In other words, if Example.ServiceFoo references Example.ServiceBar, Example.ServiceFoo inherits the integration\'s required configurations to allow them to communicate with each other automatically. For example, consider the following code using the .NET Aspire Service Bus integration: csharp builder.AddAzureServiceBusClient(""servicebus""); The Registers a Applies Enables corresponding health checks, logging, and telemetry specific to the Azure Service Bus usage. A full list of available integrations is detailed on the .NET Aspire integrations overview page.', '<2-hop>\n\nProject templates and tooling .NET Aspire provides a set of project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI. These templates are designed to help you create and interact with .NET Aspire projects, or add .NET Aspire into your existing codebase. The templates include a set of opinionated defaults to help you get started quickly - for example, it has boilerplate code for turning on health checks and logging in .NET apps. These defaults are fully customizable, so you can edit and adapt them to suit your needs. .NET Aspire templates also include boilerplate extension methods that handle common service configurations for you: csharp builder.AddServiceDefaults(); For more information on what AddServiceDefaults does, see .NET Aspire service defaults. When added to your :::no-loc text=""Program.cs""::: file, the preceding code handles the following concerns: OpenTelemetry: Sets up formatted logging, runtime metrics, built-in meters, and tracing for ASP.NET Core, gRPC, and HTTP. For more information, see .NET Aspire telemetry. Default health checks: Adds default health check endpoints that tools can query to monitor your app. For more information, see .NET app health checks in C#. Service discovery: Enables service discovery for the app and configures Next steps [!div class=""nextstepaction""] Quickstart: Build your first .NET Aspire project']",".NET CLI provides project templates and tooling experiences that assist in creating and interacting with .NET Aspire projects. These templates include opinionated defaults, such as boilerplate code for health checks and logging, which can be customized to suit specific needs. This streamlines the development process by handling common service configurations and enabling service discovery, making it easier to build and configure .NET Aspire projects.",multi_hop_specific_query_synthesizer
45,how do you use AspNetCore.HealthChecks.Npgsql and AspNetCore.HealthChecks.Nats for health checks in .NET Aspire applications?,"['<1-hop>\n\ntitle: .NET Aspire PostgreSQL integration description: Learn how to integrate PostgreSQL with .NET Aspire applications, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-integration .NET Aspire PostgreSQL integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL client integration, install the ðŸ“¦ Aspire.Npgsql NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The PostgreSQL client integration registers an NpgsqlDataSource instance that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql PackageReference xml <PackageReference Include=""Aspire.Npgsql"" Version=""*"" /> Add Npgsql client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDataSource(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding NpgsqlDataSource to the builder, you can get the NpgsqlDataSource instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(NpgsqlDataSource dataSource) { // Use dataSource... } For more information on dependency injection, see .NET dependency injection. Add keyed Npgsql client There might be situations where you want to register multiple NpgsqlDataSource instances with different connection names. To register keyed Npgsql clients, call the csharp builder.AddKeyedNpgsqlDataSource(name: ""chat""); builder.AddKeyedNpgsqlDataSource(name: ""queue""); Then you can retrieve the NpgsqlDataSource instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] NpgsqlDataSource chatDataSource, [FromKeyedServices(""queue"")] NpgsqlDataSource queueDataSource) { // Use data sources... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire PostgreSQL integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddNpgsqlDataSource(""postgresdb""); Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""postgresdb"": ""Host=myserver;Database=postgresdb"" } } For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DisableHealthChecks"": false, ""DisableTracing"": true, ""DisableMetrics"": false } } } For the complete PostgreSQL client integration JSON schema, see Aspire.Npgsql/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks: csharp builder.AddNpgsqlDataSource( ""postgresdb"", static settings => settings.DisableHealthChecks = true); [!INCLUDE integration-health-checks] Adds the NpgSqlHealthCheck, which verifies that commands can be successfully executed against the underlying Postgres Database. Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: .NET Aspire NATS integration description: Learn how to use the .NET Aspire NATS integration to send logs and traces to a NATS Server. ms.date: 10/11/2024 uid: messaging/nats-integration .NET Aspire NATS integration [!INCLUDE includes-hosting-and-client] NATS is a high-performance, secure, distributed messaging system. The .NET Aspire NATS integration enables you to connect to existing NATS instances, or create new instances from .NET with the docker.io/library/nats container image. Hosting integration NATS hosting integration for .NET Aspire models a NATS server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Nats PackageReference xml <PackageReference Include=""Aspire.Hosting.Nats"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add NATS server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/nats image, it creates a new NATS server instance on your local machine. A reference to your NATS server (the nats variable) is added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing NATS server, call Add NATS server resource with JetStream To add the NATS JetStream to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithJetStream(); builder.AddProject // After adding all resources, run the app... ``` The NATS JetStream functionality provides a built-in persistence engine called JetStream which enables messages to be stored and replayed at a later time. You can optionally provide a srcMountPath parameter to specify the path to the JetStream data directory on the host machine (the provided mount path maps to the container\'s -sd argument). Add NATS server resource with data volume To add a data volume to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the NATS server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/nats path in the NATS server container. A name is generated at random unless you provide a set the name parameter. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add NATS server resource with data bind mount To add a data bind mount to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataBindMount( source: @""C:\\NATS\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the NATS server data across container restarts. The data bind mount is mounted at the C:\\NATS\\Data on Windows (or /NATS/Data on Unix) path on the host machine in the NATS server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The NATS hosting integration automatically adds a health check for the NATS server resource. The health check verifies that the NATS server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Nats NuGet package.']","In .NET Aspire applications, the AspNetCore.HealthChecks.Npgsql NuGet package is used for PostgreSQL hosting integration to automatically add a health check for the PostgreSQL server resource. This health check verifies that the PostgreSQL server is running and that a connection can be established to it. Similarly, the AspNetCore.HealthChecks.Nats NuGet package is used for NATS hosting integration to automatically add a health check for the NATS server resource. This health check ensures that the NATS server is running and that a connection can be established to it.",multi_hop_specific_query_synthesizer
46,How can a cloud application developer leverage .NET Aspire to integrate both Azure Service Bus and Azure Event Hubs for enhanced messaging capabilities?,"['<1-hop>\n\nExample usage The following example assumes that you have an Azure Event Hubs namespace and an Event Hub created and wish to configure an EventHubProducerClient to send events to the Event Hub. The EventHubBufferedProducerClient, EventHubConsumerClient, EventProcessorClient, and PartitionReceiverare configured in a similar manner. In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the AddAzureEventHubProducerClient extension to register a EventHubProducerClient for use via the dependency injection container. csharp builder.AddAzureEventHubProducerClient(""eventHubsConnectionName""); You can then retrieve the EventHubProducerClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(EventHubProducerClient client) { // Use client... } For more information, see the Azure.Messaging.EventHubs documentation for examples on using the EventHubProducerClient. App host usage To add Azure Event Hub hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.EventHubs PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.EventHubs"" Version=""*"" /> In your app host project, add an Event Hubs connection and an Event Hub resource and consume the connection using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .AddEventHub(""MyHub""); var exampleService = builder.AddProject The AddAzureEventHubs method will read connection information from the AppHost\'s configuration (for example, from ""user secrets"") under the ConnectionStrings:eventHubsConnectionName config key. The WithReference method passes that connection information into a connection string named eventHubsConnectionName in the ExampleService project. As of .NET Aspire 8.1, the Azure EventHubs extension for .NET Aspire supports launching a local emulator for EventHubs. You can use the emulator by applying the RunAsEmulator() extension method as follows: csharp var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .RunAsEmulator() .AddEventHub(""MyHub""); The emulator for Azure EventHubs results in two container resources being launched inside .NET Aspire derived from the name of the Event Hubs resource name. [!IMPORTANT] Even though we are creating an Event Hub using the AddEventHub at the same time as the namespace, as of .NET Aspire version preview-5, the connection string will not include the EntityPath property, so the EventHubName property must be set in the settings callback for the preferred client. Future versions of Aspire will include the EntityPath property in the connection string and will not require the EventHubName property to be set in this scenario. In the :::no-loc text=""Program.cs""::: file of ExampleService, the connection can be consumed using by calling of the supported Event Hubs client extension methods: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; }); Configuration The .NET Aspire Azure Event Hubs library provides multiple options to configure the Azure Event Hubs connection based on the requirements and conventions of your project. Either a FullyQualifiedNamespace or a ConnectionString is a required to be supplied. Use a connection string When using a connection string from the ConnectionStrings configuration section, provide the name of the connection string when calling builder.AddAzureEventHubProducerClient() and other supported Event Hubs clients. In this example, the connection string does not include the EntityPath property, so the EventHubName property must be set in the settings callback: csharp builder.AddAzureEventHubProducerClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; }); And then the connection information will be retrieved from the ConnectionStrings configuration section. Two connection formats are supported: Fully Qualified Namespace (FQN) The recommended approach is to use a fully qualified namespace, which works with the AzureMessagingEventHubsSettings.Credential property to establish a connection. If no credential is configured, the json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""{your_namespace}.servicebus.windows.net"" } } Connection string Alternatively, use a connection string: json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""Endpoint=sb://mynamespace.servicebus.windows.net/;SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey;EntityPath=MyHub"" } } Use configuration providers The .NET Aspire Azure Event Hubs library supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""EventHubs"": { ""EventProcessorClient"": { ""EventHubName"": ""MyHub"", ""ClientOptions"": { ""Identifier"": ""PROCESSOR_ID"" } } } } } } } You can also setup the Options type using the optional Action<IAzureClientBuilder<EventProcessorClient, EventProcessorClientOptions>> configureClientBuilder parameter of the AddAzureEventProcessorClient method. For example, to set the processor\'s client ID for this client: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Identifier = ""PROCESSOR_ID"")); [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Azure Event Hubs integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Event Hubs integration will emit the following tracing activities using OpenTelemetry: ""Azure.Messaging.EventHubs.*"" Metrics The .NET Aspire Azure Event Hubs integration currently doesn\'t support metrics by default due to limitations with the Azure SDK for .NET. If that changes in the future, this section will be updated to reflect those changes. See also Azure Event Hubs .NET Aspire integrations .NET Aspire GitHub repo', '<2-hop>\n\ntitle: .NET Aspire Azure Service Bus integration description: This article describes the .NET Aspire Azure Service Bus integration features and capabilities ms.topic: how-to ms.date: 08/12/2024 .NET Aspire Azure Service Bus integration Cloud-native apps often require communication with messaging services such as Azure Service Bus. Messaging services help decouple applications and enable scenarios that rely on features such as queues, topics and subscriptions, atomic transactions, load balancing, and more. The .NET Aspire Service Bus integration handles the following concerns to connect your app to Azure Service Bus: A Applies ServiceBusClient configurations either inline through code or through configuration file settings. Prerequisites Azure subscription - create one for free Azure Service Bus namespace, learn more about how to add a Service Bus namespace. Alternatively, you can use a connection string, which is not recommended in production environments. Get started To get started with the .NET Aspire Azure Service Bus integration, install the ðŸ“¦ Aspire.Azure.Messaging.ServiceBus NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Service Bus client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.ServiceBus"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Example usage In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureServiceBusClient(""messaging""); To retrieve the configured csharp public class ExampleService(ServiceBusClient client) { // ... } App host usage To add Azure Service Bus hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.ServiceBus PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.ServiceBus"" Version=""*"" /> In your app host project, register the Service Bus integration and consume the service using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var serviceBus = builder.ExecutionContext.IsPublishMode ? builder.AddAzureServiceBus(""messaging"") : builder.AddConnectionString(""messaging""); builder.AddProject Configuration The .NET Aspire Service Bus integration provides multiple options to configure the ServiceBusClient based on the requirements and conventions of your project. Use configuration providers The Service Bus integration supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""ServiceBus"": { ""DisableHealthChecks"": true, ""DisableTracing"": false, ""ClientOptions"": { ""Identifier"": ""CLIENT_ID"" } } } } } } If you have set up your configurations in the Aspire:Azure:Messaging:ServiceBus section of your :::no-loc text=""appsettings.json""::: file you can just call the method AddAzureServiceBusClient without passing any parameters. Use inline delegates You can also pass the Action<AzureMessagingServiceBusSettings> delegate to set up some or all the options inline, for example to set the FullyQualifiedNamespace: csharp builder.AddAzureServiceBusClient( ""messaging"", static settings => settings.FullyQualifiedNamespace = ""YOUR_SERVICE_BUS_NAMESPACE""); You can also set up the ServiceBusClientOptions using Action<IAzureClientBuilder<ServiceBusClient, ServiceBusClientOptions>> delegate, the second parameter of the AddAzureServiceBus method. For example to set the ServiceBusClient ID to identify the client: csharp builder.AddAzureServiceBusClient( ""messaging"", static clientBuilder => clientBuilder.ConfigureOptions( static options => options.Identifier = ""CLIENT_ID"")); Configuration options The following configurable options are exposed through the Name Description ConnectionString The connection string used to connect to the Service Bus namespace. Credential The credential used to authenticate to the Service Bus namespace. FullyQualifiedNamespace The fully qualified Service Bus namespace. DisableTracing Disables tracing for the Service Bus client. â€  HealthCheckQueueName The name of the queue used for health checks. â€  HealthCheckTopicName The name of the topic used for health checks. â€  At least one of the name options are mandatory when enabling health checks. [!INCLUDE integration-observability-and-telemetry]']","A cloud application developer can leverage .NET Aspire to integrate both Azure Service Bus and Azure Event Hubs by utilizing the respective integration features provided by the framework. For Azure Event Hubs, the developer can configure an EventHubProducerClient using the AddAzureEventHubProducerClient extension method, which allows for sending events to an Event Hub. This setup can be done in the Program.cs file of the client-consuming project, and the connection information can be managed through configuration providers or connection strings. Additionally, the developer can use the RunAsEmulator() extension method to launch a local emulator for Event Hubs. For Azure Service Bus, the developer can install the Aspire.Azure.Messaging.ServiceBus NuGet package and configure a ServiceBusClient using the AddAzureServiceBusClient method. This setup can also be managed through configuration providers or inline delegates to set options such as the FullyQualifiedNamespace. By integrating both services, the developer can achieve decoupled communication, load balancing, and other advanced messaging scenarios in cloud-native applications.",multi_hop_specific_query_synthesizer
47,How can the Program.cs file be adjusted to integrate Azure Cosmos DB in a .NET Aspire 9.0 project?,"['<1-hop>\n\nUpdate the NuGet packages in your project files to the latest versions. Adjust your Program.cs file to use the new APIs and remove any obsolete APIs. Edit your app host project file To upgrade your app host project to .NET Aspire 9.0, you need to update your project file to use the new ðŸ“¦ Aspire.AppHost.Sdk: ```diff ``` Optionally upgrade the target framework moniker (TFM) .NET Aspire 9.0 runs on .NET 9.0, but you can also run it on .NET 8.0. In other words, just because you\'re using the .NET Aspire SDK, and pointing to version 9.0 packages, you can still target .NET 8.0. If you want to run your .NET Aspire 9.0 project on .NET 9.0, you need to update the TargetFramework property in your project file: ```diff ``` For more information on TFMs, see Target frameworks in SDK-style projects: Latest versions. Overall app host project differences If you followed all of the preceding steps, your app host project file should look like this: ```diff ``` The changes include the addition of the Aspire.AppHost.Sdk, the update of the TargetFramework property to net9.0, and the update of the Aspire.Hosting.AppHost package to version 9.0.0. Adjust your Program.cs file With the introduction of .NET Aspire 9.0, there are some breaking changes. Some APIs were originally marked as experimental (with the For the complete list of breaking changes in .NET Aspire 9.0, see Breaking changes in .NET Aspire 9.0. Use the Upgrade Assistant The Upgrade Assistant is a tool that helps upgrade targeted projects to the latest version. If you\'re new to the Upgrade Assistant, there\'s two modalities to choose from: The Visual Studio extension version. The .NET CLI global tool version. Regardless of how you install the Upgrade Assistant, you can use it to upgrade your .NET Aspire 8.x projects to .NET Aspire 9.0. :::zone pivot=""visual-studio"" To upgrade the .NET Aspire app host project to .NET Aspire 9.0 with Visual Studio, right-click the project in Solution Explorer and select Upgrade. [!IMPORTANT] If the Upgrade Assistant isn\'t already installed, you\'ll be prompted to install it. The Upgrade Assistant displays a welcome package. Select the Aspire upgrades option: :::image type=""content"" source=""media/upgrade-assistant-welcome-aspire.png"" lightbox=""media/upgrade-assistant-welcome-aspire.png"" alt-text=""Visual Studio: Upgrade Assistant welcome page with .NET Aspire app host project.""::: With the Aspire upgrades option selected, the Upgrade Assistant displays the selectable upgrade target components. Leave all the options checked and select Upgrade selection: :::image type=""content"" source=""media/upgrade-assistant-aspire-app-host-comps.png"" lightbox=""media/upgrade-assistant-aspire-app-host-comps.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire selectable components to upgrade.""::: Finally, after selecting the components to upgrade, the Upgrade Assistant displays the results of the upgrade process. If everything was successful, you see green check marks next to each component: :::image type=""content"" source=""media/upgrade-assistant-aspire-upgraded.png"" lightbox=""media/upgrade-assistant-aspire-upgraded.png"" alt-text=""Visual Studio: Upgrade Assistant .NET Aspire app host project upgraded successfully.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To upgrade the .NET Aspire app host project, ensure that you installed the Upgrade Assistant CLI. Open a terminal session at the root directory of the .NET Aspire app host project file, and run the following command: dotnetcli upgrade-assistant upgrade The output is interactive, expecting you to select the upgrade type. Choose the Aspire upgrades option: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ How do you want to upgrade project AspireSample.AppHost? Aspire upgrades Upgrade to latest .NET Aspire version (aspire.latest) Upgrade project to a newer .NET version In-place project upgrade (framework.inplace) NuGet upgrades NuGet central package management (CPM) (nuget.cpm) Navigation Back Exit ``` Use your keyboard to navigate up â†‘ or down â†“, and select the Aspire upgrades option. The Upgrade Assistant prompts for final confirmation. Enter Y to continue with the upgrade: ```dotnetcli Selected options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project ..\\AspireSample\\AspireSample.AppHost\\AspireSample.AppHost.csproj Upgrade type aspire.latest Steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Source project / Upgrade type / Upgrade â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ We have gathered all required options and are ready to do the upgrade. Do you want to continue? [y/n] (y): ``` Finally, after the upgrade process is complete, the Upgrade Assistant displays the results of the upgrade process: dotnetcli Finalizing operation... Complete: 3 succeeded, 0 failed, 7 skipped. :::zone-end Update the NuGet packages To take advantage of the latest updates in your .NET Aspire solution, update all NuGet packages to version 9.0.0. :::zone pivot=""visual-studio"" :::image type=""content"" source=""media/visual-studio-update-nuget.png"" lightbox=""media/visual-studio-update-nuget.png"" alt-text=""Visual Studio: Update all NuGet packages for the .NET Aspire solution.""::: :::zone-end :::zone pivot=""vscode,dotnet-cli"" To update your app host project, use the following .NET CLI command to update the Aspire.Hosting.AppHost package to version 9.0.0: dotnetcli dotnet add package Aspire.Hosting.AppHost --version 9.0.0 When a package reference already exists, the dotnet add package command updates the reference to the specified version. For more information, see dotnet add package. :::zone-end With the app host project updated, your project file should look like this: ```diff ``` [!TIP] You\'ll want to also update the NuGet packages in your other projects to the latest versions. Verify the upgrade As with any upgrade, ensure that the app runs as expected and that all tests pass. Build the solution and look for suggestions, warnings, or errors in the output windowâ€”address anything that wasn\'t an issue before. If you encounter any issues, let us know by filing a GitHub issue.', '<2-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']","To integrate Azure Cosmos DB in a .NET Aspire 9.0 project, you need to adjust the Program.cs file of your client-consuming project. First, install the Aspire.Microsoft.Azure.Cosmos NuGet package. Then, in the Program.cs file, call the builder.AddAzureCosmosClient(connectionName: ""cosmos-db""). Ensure that the connectionName parameter matches the name used when adding the Cosmos DB resource in the app host project. This setup allows the Cosmos DB client to be registered and used within the application, leveraging dependency injection for accessing the CosmosClient instances.",multi_hop_specific_query_synthesizer
48,How does the AspireSample.ApiService integrate with Azure Service Bus and what role does the AspireSample.AppHost play in this setup?,"['<1-hop>\n\nAdd the .NET Aspire integration to the API Add the .NET Aspire Azure Service Bus integration to your AspireSample.ApiService app: :::zone pivot=""visual-studio"" In the Solution Explorer, double-click the AspireSample.ApiService.csproj file to open its XML file. Add the following <PackageReference> item to the <ItemGroup> element: xml <ItemGroup> <PackageReference Include=""Aspire.Azure.Messaging.ServiceBus"" Version=""8.0.1"" /> </ItemGroup> :::zone-end :::zone pivot=""vscode"" In the Solution Explorer, right-click on the AspireSample.ApiService project and select Add NuGet Package: :::image type=""content"" source=""media/vscode-add-nuget-package.png"" lightbox=""media/vscode-add-nuget-package.png"" alt-text=""Visual Studio Code: Add NuGet package to AspireSample.ApiService project.""::: Enter Aspire.Azure.Messaging.ServiceBus in the search box and select the package from the list. Select the (latest) version to install the package. :::zone-end :::zone pivot=""dotnet-cli"" dotnetcli dotnet add package Aspire.Azure.Messaging.ServiceBus :::zone-end In the :::no-loc text=""Program.cs""::: file of the AspireSample.ApiService project, add a call to the AddAzureServiceBusClient extension methodâ€”replacing the existing call to AddServiceDefaults: csharp // Add service defaults & Aspire integrations. builder.AddServiceDefaults(); builder.AddAzureServiceBusClient(""serviceBusConnection""); For more information, see This method accomplishes the following tasks: Registers a Automatically enables corresponding health checks, logging, and telemetry for the respective services. In the :::no-loc text=""appsettings.json""::: file of the same project, add the corresponding connection information: Passwordless (Recommended) json { // Existing configuration is omitted for brevity. ""ConnectionStrings"": { ""serviceBusConnection"": ""{your_namespace}.servicebus.windows.net"" } } Connection String json { // Existing configuration is omitted for brevity. ""ConnectionStrings"": { ""serviceBusConnection"": ""Endpoint=sb://{your_namespace}.servicebus.windows.net/; SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey"" } } [!NOTE] Make sure to replace {your_namespace} in the service URIs with the name of your own Service Bus namespace. Create the API endpoint The API must provide an endpoint to receive data and publish it to the Service Bus topic and broadcast to subscribers. Add the following endpoint to the AspireSample.ApiService project to send a message to the Service Bus topic. Replace all of the contents of the :::no-loc text=""Program.cs""::: file with the following C# code: ```csharp using Azure.Messaging.ServiceBus; var builder = WebApplication.CreateBuilder(args); // Add service defaults & Aspire integrations. builder.AddServiceDefaults(); builder.AddAzureServiceBusClient(""serviceBusConnection""); // Add services to the container. builder.Services.AddProblemDetails(); var app = builder.Build(); // Configure the HTTP request pipeline. app.UseExceptionHandler(); app.MapPost(""/notify"", static async (ServiceBusClient client, string message) => { var sender = client.CreateSender(""notifications""); // Create a batch using ServiceBusMessageBatch messageBatch = await sender.CreateMessageBatchAsync(); if (messageBatch.TryAddMessage( new ServiceBusMessage($""Message {message}"")) is false) { // If it\'s too large for the batch. throw new Exception( $""The message {message} is too large to fit in the batch.""); } // Use the producer client to send the batch of // messages to the Service Bus topic. await sender.SendMessagesAsync(messageBatch); Console.WriteLine($""A message has been published to the topic.""); }); app.MapDefaultEndpoints(); app.Run(); ``` Add the .NET Aspire integration to the Worker Service Add the .NET Aspire Azure Service Bus integration to your AspireSample.WorkerService project. Follow the same steps as you did before when you added the Aspire.Azure.Messaging.ServiceBus NuGet package to the AspireSample.ApiService project. Once it\'s been added, you can configure the worker service to process messages from the Service Bus topic. In the :::no-loc text=""Program.cs""::: file of the AspireSample.WorkerService project, repace the existing code with the following: ```csharp using AspireSample.WorkerService; var builder = Host.CreateApplicationBuilder(args); builder.AddAzureServiceBusClient(""serviceBusConnection""); builder.Services.AddHostedService var host = builder.Build(); host.Run(); ``` The AddAzureServiceBusClient method accomplishes the following tasks: Registers a Automatically enables corresponding health checks, logging, and telemetry for the respective services. In the :::no-loc text=""appsettings.json""::: file of the AspireSample.WorkerService project, add the corresponding connection information: Passwordless (Recommended) json { // Existing configuration is omitted for brevity. ""ConnectionStrings"": { ""serviceBusConnection"": ""{your_namespace}.servicebus.windows.net"" } } Connection String json { // Existing configuration is omitted for brevity. ""ConnectionStrings"": { ""serviceBusConnection"": ""Endpoint=sb://{your_namespace}.servicebus.windows.net/; SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey"" } } [!NOTE] Make sure to replace {your_namespace} in the Service URIs with the name of your own Service Bus namespace. Process the message from the subscriber When a new message is placed on the messages queue, the worker service should retrieve, process, and delete the message. Update the :::no-loc text=""Worker.cs""::: class to match the following code: ```csharp using Azure.Messaging.ServiceBus; namespace AspireSample.WorkerService; public sealed class Worker( ILogger // Add handler to process messages processor.ProcessMessageAsync += MessageHandler; // Add handler to process any errors processor.ProcessErrorAsync += ErrorHandler; // Start processing await processor.StartProcessingAsync(); logger.LogInformation("""""" Wait for a minute and then press any key to end the processing """"""); Console.ReadKey(); // Stop processing logger.LogInformation("""""" Stopping the receiver... """"""); await processor.StopProcessingAsync(); logger.LogInformation(""Stopped receiving messages""); } } async Task MessageHandler(ProcessMessageEventArgs args) { string body = args.Message.Body.ToString(); logger.LogInformation(""Received: {Body} from subscription."", body); // Complete the message. messages is deleted from the subscription. await args.CompleteMessageAsync(args.Message); } // Handle any errors when receiving messages Task ErrorHandler(ProcessErrorEventArgs args) { logger.LogError(args.Exception, ""{Error}"", args.Exception.Message); return Task.CompletedTask; } } ``` Run and test the app locally The sample app is now ready for testing. Verify that the data submitted to the API is sent to the Azure Service Bus topic and consumed by the subscriber worker service: :::zone pivot=""visual-studio"" Launch the .NET Aspire project by selecting the Start debugging button, or by pressing F5. The .NET Aspire dashboard app should open in the browser. :::zone-end :::zone pivot=""vscode"" Launch the .NET Aspire project by selecting the Start debugging button, or by pressing F5. The .NET Aspire dashboard app should open in the browser. :::zone-end :::zone pivot=""dotnet-cli"" Launch the .NET Aspire project by running dotnet run --project AspireSample.AppHost. The .NET Aspire dashboard app should open in the browser. :::zone-end On the resources page, in the apiservice row, find the link in the Endpoints that opens the weatherforecast endpoint. Note the HTTPS port number. On the .NET Aspire dashboard, navigate to the logs for the aspiresample-workerservice project. In a terminal window, use the curl command to send a test message to the API: bash curl -X POST -H ""Content-Type: application/json"" https://localhost:{port}/notify?message=hello%20aspire Be sure to replace {port} with the port number from earlier. 5. Switch back to the aspiresample-workerservice logs. You should see the test message printed in the output logs. Congratulations! You created and configured an ASP.NET Core API that connects to Azure Service Bus using Aspire integrations. [!INCLUDE clean-up-resources]', '<2-hop>\n\nUnderstand the .NET Aspire solution structure The solution consists of the following projects: AspireSample.ApiService: An ASP.NET Core Minimal API project is used to provide data to the front end. This project depends on the shared AspireSample.ServiceDefaults project. AspireSample.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the Startup project, and it depends on the AspireSample.ApiService and AspireSample.Web projects. AspireSample.ServiceDefaults: A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. AspireSample.Web: An ASP.NET Core Blazor App project with default .NET Aspire service configurations, this project depends on the AspireSample.ServiceDefaults project. For more information, see .NET Aspire service defaults. Your AspireSample directory should resemble the following structure: [!INCLUDE template-directory-structure] Explore the starter projects Each project in an .NET Aspire solution plays a role in the composition of your app. The .Web_ project is a standard ASP.NET Core Blazor App that provides a front end UI. For more information, see What\'s new in ASP.NET Core 9.0: Blazor. The _.ApiService project is a standard ASP.NET Core Minimal API template project. Both of these projects depend on the *.ServiceDefaults project, which is a shared project that\'s used to manage configurations that are reused across projects in your solution. The two projects of interest in this quickstart are the .AppHost_ and _.ServiceDefaults projects detailed in the following sections. .NET Aspire host project The *.AppHost project is responsible for acting as the orchestrator, and sets the IsAspireHost property of the project file to true: :::code language=""xml"" source=""snippets/quickstart/AspireSample/AspireSample.AppHost/AspireSample.AppHost.csproj"" highlight=""10""::: For more information, see .NET Aspire orchestration overview and .NET Aspire SDK. Consider the :::no-loc text=""Program.cs""::: file of the AspireSample.AppHost project: :::code source=""snippets/quickstart/AspireSample/AspireSample.AppHost/Program.cs""::: If you\'ve used either the .NET Generic Host or the ASP.NET Core Web Host before, the app host programming model and builder pattern should be familiar to you. The preceding code: Creates an Calls Calls Calls AddProject again, this time adding the AspireSample.Web project to the application model. It also chains multiple calls to Finally, the app is built and run. The [!TIP] The call to .NET Aspire service defaults project The *.ServiceDefaults project is a shared project that\'s used to manage configurations that are reused across the projects in your solution. This project ensures that all dependent services share the same resilience, service discovery, and OpenTelemetry configuration. A shared .NET Aspire project file contains the IsAspireSharedProject property set as true: :::code language=""xml"" source=""snippets/quickstart/AspireSample/AspireSample.ServiceDefaults/AspireSample.ServiceDefaults.csproj"" highlight=""7""::: The service defaults project exposes an extension method on the Orchestrate service communication .NET Aspire provides orchestration features to assist with configuring connections and communication between the different parts of your app. The AspireSample.AppHost project added the AspireSample.ApiService and AspireSample.Web projects to the application model. It also declared their names as ""webfrontend"" for Blazor front end, ""apiservice"" for the API project reference. Additionally, a Redis server resource labeled ""cache"" was added. These names are used to configure service discovery and communication between the projects in your app. The front end app defines a typed :::code source=""snippets/quickstart/AspireSample/AspireSample.Web/WeatherApiClient.cs""::: The HttpClient is configured to use service discovery. Consider the following code from the :::no-loc text=""Program.cs""::: file of the AspireSample.Web project: :::code source=""snippets/quickstart/AspireSample/AspireSample.Web/Program.cs"" highlight=""7-8,14-19""::: The preceding code: Calls AddServiceDefaults, configuring the shared defaults for the app. Calls Calls For more information, see Make HTTP requests with the HttpClient class. See also .NET Aspire integrations overview Service discovery in .NET Aspire .NET Aspire service defaults Health checks in .NET Aspire .NET Aspire telemetry Troubleshoot untrusted localhost certificate in .NET Aspire Next steps [!div class=""nextstepaction""] Tutorial: Add .NET Aspire to an existing .NET app']","The AspireSample.ApiService integrates with Azure Service Bus by adding the .NET Aspire Azure Service Bus integration. This involves modifying the AspireSample.ApiService.csproj file to include the Aspire.Azure.Messaging.ServiceBus package and configuring the Program.cs file to use the AddAzureServiceBusClient method, which registers the necessary services and enables health checks, logging, and telemetry. The API provides an endpoint to receive data and publish it to the Service Bus topic. The AspireSample.AppHost acts as the orchestrator in this setup, connecting and configuring the different projects and services, including the AspireSample.ApiService. It ensures that the service discovery and communication between the projects are properly configured, using shared configurations from the AspireSample.ServiceDefaults project.",multi_hop_specific_query_synthesizer
49,"How does the .NET Aspire app host model facilitate the integration of Azure Cosmos DB, and what logging and tracing capabilities are provided for its operations?","['<1-hop>\n\ntitle: Local Azure provisioning description: Learn how to use Azure resources in your local development environment. ms.date: 12/13/2024 uid: dotnet/aspire/local-azure-provisioning Local Azure provisioning .NET Aspire simplifies local cloud-native app development with its compelling app host model. This model allows you to run your app locally with the same configuration and services as in Azure. In this article you learn how to provision Azure resources from your local development environment through the .NET Aspire app host. [!NOTE] To be clear, resources are provisioned in Azure, but the provisioning process is initiated from your local development environment. To optimize your local development experience, consider using emulator or containers when available. For more information, see Typical developer experience. Requirements This article assumes that you have an Azure account and subscription. If you don\'t have an Azure account, you can create a free one at Azure Free Account. For provisioning functionality to work correctly, you\'ll need to be authenticated with Azure. Ensure that you have the Azure Developer CLI installed. Additionally, you\'ll need to provide some configuration values so that the provisioning logic can create resources on your behalf. App host provisioning APIs The app host provides a set of APIs to express Azure resources. These APIs are available as extension methods in .NET Aspire Azure hosting libraries, extending the When the app host starts, the following provisioning logic is executed: The Azure configuration section is validated. When invalid the dashboard and app host output provides hints as to what\'s missing. For more information, see Missing configuration value hints. When valid Azure resources are conditionally provisioned: If an Azure deployment for a given resource doesn\'t exist, it\'s created and configured as a deployment. The configuration of said deployment is stamped with a checksum as a means to support only provisioning resources as necessary. Use existing Azure resources The app host automatically manages provisioning of Azure resources. The first time the app host runs, it provisions the resources specified in the app host. Subsequent runs don\'t provision the resources again unless the app host configuration changes. If you\'ve already provisioned Azure resources outside of the app host and want to use them, you can provide the connection string with the ```csharp // Service registration var secrets = builder.ExecutionContext.IsPublishMode ? builder.AddAzureKeyVault(""secrets"") : builder.AddConnectionString(""secrets""); // Service consumption builder.AddProject The preceding code snippet shows how to add an Azure Key Vault to the app host. The Alternatively, for some Azure resources, you can opt-in to running them as an emulator with the RunAsEmulator API. This API is available for Azure Cosmos DB and Azure Storage integrations. For example, to run Azure Cosmos DB as an emulator, you can use the following code snippet: csharp var cosmos = builder.AddAzureCosmosDB(""cosmos"") .RunAsEmulator(); The', '<2-hop>\n\nLogging The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration uses the following log categories: Azure-Cosmos-Operation-Request-Diagnostics Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Query Tracing The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration will emit the following tracing activities using OpenTelemetry: Azure.Cosmos.Operation OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently supports the following metrics: Microsoft.EntityFrameworkCore ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second See also Azure Cosmos DB docs .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire app host model facilitates the integration of Azure Cosmos DB by allowing developers to run their applications locally with the same configuration and services as in Azure. This is achieved through the use of provisioning APIs available as extension methods in .NET Aspire Azure hosting libraries. Developers can opt to run Azure Cosmos DB as an emulator using the RunAsEmulator API, which simplifies local development and testing. For logging and tracing, the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration uses specific log categories such as Azure-Cosmos-Operation-Request-Diagnostics and emits tracing activities using OpenTelemetry, including Azure.Cosmos.Operation. These capabilities help in monitoring and diagnosing the operations of Azure Cosmos DB within the application.",multi_hop_specific_query_synthesizer
50,How do you test a .NET Aspire app locally and what role does telemetry play in enhancing its performance?,"['<1-hop>\n\nRun and test the app locally The sample app is now ready for testing. Verify that the submitted form data is persisted to the database by completing the following steps: Select the run button at the top of Visual Studio (or F5) to launch your .NET Aspire project dashboard in the browser. On the projects page, in the AspireSQLEFCore row, click the link in the Endpoints column to open the UI of your app. :::image type=""content"" source=""media/app-home-screen.png"" lightbox=""media/app-home-screen.png"" alt-text=""A screenshot showing the home page of the .NET Aspire support application.""::: Enter sample data into the Title and Description form fields. Select the Submit button, and the form submits the support ticket for processing â€” (then select Clear to clear the form). The data you submitted displays in the table at the bottom of the page when the page reloads. See also .NET Aspire with SQL Database deployment .NET Aspire deployment via Azure Container Apps Deploy a .NET Aspire project using GitHub Actions', '<2-hop>\n\nTelemetry user-centric additions Telemetry remains a vital aspect of .NET Aspire. In .NET Aspire 9, many new features were introduced to the Telemetry service. Improved telemetry filtering Traces can be filtered with attribute values. For example, if you only want to view traces for one endpoint in your app, the http.route attribute on HTTP requests can be filtered to a specified value. Telemetry filtering also supports autocomplete of existing values. The Add filter dialog provides a combo box for selecting from values that dashboard has available. This feature makes it much easier to filter to real data and helps avoid typos by entered a value yourself. For more information, see .NET Aspire dashboard: Filter traces. Combine telemetry from multiple resources When a resource has multiple replicas, you can now filter telemetry to view data from all instances at once. Select the parent resource, labeled (application). For more information, see .NET Aspire dashboard: Combine telemetry from multiple resources. Browser telemetry support The dashboard supports OpenTelemetry Protocol (OTLP) over HTTP and cross-origin resource sharing (CORS). These features unlock the ability to send OpenTelemetry from browser apps to the .NET Aspire dashboard. For example, a browser-based single page app (SPA) can configure the JavaScript OpenTelemetry SDK to send structured logs, traces, and metrics created in the browser to the dashboard. Browser telemetry is displayed alongside server telemetry. :::image type=""content"" source=""media/dashboard-browser-telemetry.png"" lightbox=""media/dashboard-browser-telemetry.png"" alt-text=""Trace detail page with browser telemetry""::: For more information on configuring browser telemetry, see Enable browser telemetry documentation. App Host (Orchestration) The .NET Aspire app host is one of the most important features of .NET Aspire. In .NET Aspire 9, several new features were added specific to the app host. Waiting for dependencies If you\'ve been following along with .NET Aspire, you already know that your app host project is where you define your app model. You create a distributed application builder, add and configure resources, and express their dependencies. Now, you can specify that a resource should wait for another resource before starting. This can help avoid connection errors during startup by only starting resources when their dependencies are ""ready."" ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbit = builder.AddRabbitMQ(""rabbit""); builder.AddProject builder.Build().Run(); ``` When the app host starts, it waits for the rabbit resource to be ready before starting the api resource. There are two methods exposed to wait for a resource: For more information, see .NET Aspire app host: Waiting for resources. Resource health checks The WaitFor API uses standard .NET health checks to determine if a resource is ready. But what does ""a resource being ready"" mean? The best part is, that\'s configurable by the consumer beyond their default values. When a resource doesn\'t expose any health checks (no health checks registered in the app), the app host waits for the resource to be in the For resources that expose HTTP endpoints, you can easily add a health check that polls a specific path for an HTTP 200 response. ```csharp var builder = DistributedApplication.CreateBuilder(args); var catalogApi = builder.AddContainer(""catalog-api"", ""catalog-api"") .WithHttpEndpoint(targetPort: 8080) .WithHttpHealthCheck(""/health""); builder.AddProject builder.Build().Run(); ``` The preceding example adds a health check to the catalog-api resource. The app host waits for the health check to return a healthy status before starting the store resource. It determines that the resource is ready when the /health endpoint returns an HTTP 200 status code. While store is waiting for catalog-api to become healthy, the resources in the dashboard appear as: :::image type=""content"" source=""media/waiting-for-unhealthy-resource.png"" lightbox=""media/waiting-for-unhealthy-resource.png"" alt-text=""Waiting for an unhealthy resource before starting""::: The app host\'s health check mechanism builds upon the Health checks report data, which is displayed in the dashboard: :::image type=""content"" source=""media/health-check-details.png"" lightbox=""media/health-check-details.png"" alt-text=""Health check details in the dashboard\'s resource details view""::: Creating a custom health check is straightforward. Start by defining the health check, then associate its name with any resources it applies to. ```csharp var builder = DistributedApplication.CreateBuilder(args); var healthyAfter = DateTime.Now.AddSeconds(20); builder.Services.AddHealthChecks().AddCheck( ""delay20secs"", () => DateTime.Now > healthyAfter ? HealthCheckResult.Healthy() : HealthCheckResult.Unhealthy() ); var cache = builder.AddRedis(""cache"") .WithHealthCheck(""delay20secs""); builder.AddProject The preceding example adds a health check to the cache resource, which reports it as unhealthy for the first 20 seconds after the app host starts. So, the myapp resource waits for 20 seconds before starting, ensuring the cache resource is healthy. The Persistent containers The app host now supports persistent containers. Persistent containers deviate from the typical container life cycle of .NET Aspire orchestrated apps. While they\'re created and started (when not already available) by the .NET Aspire orchestrator, they\'re not destroyed by .NET Aspire. This is useful when you want to keep the container running even after the app host has stopped. [!IMPORTANT] To delete these containers, you must manually stop them using the container runtime. To define an IResourceBuilder<ContainerResource> with a persistent lifetime, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var queue = builder.AddRabbitMQ(""rabbit"") .WithLifetime(ContainerLifetime.Persistent); builder.AddProject builder.Build().Run(); ``` The dashboard shows persistent containers with a pin icon: :::image type=""content"" source=""media/persistent-container.png"" lightbox=""media/persistent-container.png"" alt-text=""Persistent containers""::: After the app host is stopped, the container will continue to run: :::image type=""content"" source=""media/persistent-container-docker-desktop.png"" lightbox=""media/persistent-container-docker-desktop.png"" alt-text=""Docker desktop showing RabbitMQ.""::: The container persistence mechanism attempts to identify when you might wish to recreate the container. For example, if the environment for the container changes, then the container is restarted so that you don\'t need to manually stop the container if the input configuration for the resource has changed. Resource commands The app host supports adding custom commands to resources. This is useful when you want to add custom functionality that is not natively supported by the app host. There\'s likely many opportunities where exposing custom extension methods on resources will be useful. The .NET Aspire Community Toolkit might be a good place to share these extensions. When you define a custom command, it\'s available in the dashboard as a user experience feature. [!IMPORTANT] These .NET Aspire dashboard commands are only available when running the dashboard locally. They\'re not available when running the dashboard in Azure Container Apps. For more information on creating custom resource commands, see How-to: Create custom resource commands in .NET Aspire.']","To test a .NET Aspire app locally, you need to run the app using Visual Studio by selecting the run button or pressing F5. This launches the .NET Aspire project dashboard in the browser. On the projects page, you can enter sample data into the Title and Description form fields and submit the form to verify that the data is persisted to the database. The submitted data will display in the table at the bottom of the page upon reloading. Telemetry plays a crucial role in enhancing the app's performance by allowing you to filter traces with attribute values, combine telemetry from multiple resources, and support OpenTelemetry Protocol (OTLP) over HTTP. This enables the app to send structured logs, traces, and metrics from browser apps to the .NET Aspire dashboard, providing a comprehensive view of both browser and server telemetry.",multi_hop_specific_query_synthesizer
