,user_input,reference_contexts,reference,synthesizer_name
0,How can appsettings.json be used to configure PostgreSQL integration in .NET Aspire?,"['title: .NET Aspire PostgreSQL integration description: Learn how to integrate PostgreSQL with .NET Aspire applications, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-integration .NET Aspire PostgreSQL integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL client integration, install the ðŸ“¦ Aspire.Npgsql NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The PostgreSQL client integration registers an NpgsqlDataSource instance that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql PackageReference xml <PackageReference Include=""Aspire.Npgsql"" Version=""*"" /> Add Npgsql client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDataSource(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding NpgsqlDataSource to the builder, you can get the NpgsqlDataSource instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(NpgsqlDataSource dataSource) { // Use dataSource... } For more information on dependency injection, see .NET dependency injection. Add keyed Npgsql client There might be situations where you want to register multiple NpgsqlDataSource instances with different connection names. To register keyed Npgsql clients, call the csharp builder.AddKeyedNpgsqlDataSource(name: ""chat""); builder.AddKeyedNpgsqlDataSource(name: ""queue""); Then you can retrieve the NpgsqlDataSource instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] NpgsqlDataSource chatDataSource, [FromKeyedServices(""queue"")] NpgsqlDataSource queueDataSource) { // Use data sources... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire PostgreSQL integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddNpgsqlDataSource(""postgresdb""); Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""postgresdb"": ""Host=myserver;Database=postgresdb"" } } For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DisableHealthChecks"": false, ""DisableTracing"": true, ""DisableMetrics"": false } } } For the complete PostgreSQL client integration JSON schema, see Aspire.Npgsql/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks: csharp builder.AddNpgsqlDataSource( ""postgresdb"", static settings => settings.DisableHealthChecks = true); [!INCLUDE integration-health-checks] Adds the NpgSqlHealthCheck, which verifies that commands can be successfully executed against the underlying Postgres Database. Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]']","The appsettings.json file can be used to configure PostgreSQL integration in .NET Aspire by specifying options under the 'Aspire' section. For example, you can define the connection string and other settings like health checks, tracing, and metrics. A sample configuration might look like this: { ""Aspire"": { ""Npgsql"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DisableHealthChecks"": false, ""DisableTracing"": true, ""DisableMetrics"": false } } }. This allows you to manage PostgreSQL integration settings in a structured and centralized manner.",single_hop_specifc_query_synthesizer
1,Wht is the purpse of Npgsql.Excepton in the .NET Aspire PostgreSQL integrtion?,['Logging The .NET Aspire PostgreSQL integration uses the following log categories: Npgsql.Connection Npgsql.Command Npgsql.Transaction Npgsql.Copy Npgsql.Replication Npgsql.Exception Tracing The .NET Aspire PostgreSQL integration will emit the following Tracing activities using OpenTelemetry: Npgsql Metrics The .NET Aspire PostgreSQL integration will emit the following metrics using OpenTelemetry: Npgsql: ec_Npgsql_bytes_written_per_second ec_Npgsql_bytes_read_per_second ec_Npgsql_commands_per_second ec_Npgsql_total_commands ec_Npgsql_current_commands ec_Npgsql_failed_commands ec_Npgsql_prepared_commands_ratio ec_Npgsql_connection_pools ec_Npgsql_multiplexing_average_commands_per_batch ec_Npgsql_multiplexing_average_write_time_per_batch [!INCLUDE postgresql-flexible-server] [!INCLUDE azure-postgresql-client] See also PostgreSQL docs .NET Aspire integrations .NET Aspire GitHub repo'],Npgsql.Exception is a log category used in the .NET Aspire PostgreSQL integration for logging purposes.,single_hop_specifc_query_synthesizer
2,how .net aspire sql server work?,"['title: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]']",".NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances using the mcr.microsoft.com/mssql/server container image. It includes hosting integration, which automatically adds a health check for the SQL Server resource, and client integration, which allows you to register SQL Server clients in your application using the Aspire.Microsoft.Data.SqlClient NuGet package. Configuration options include using connection strings, configuration providers, or inline delegates.",single_hop_specifc_query_synthesizer
3,what github got to do with .net aspire sql server stuff?,"[""Logging The .NET Aspire SQL Server integration currently doesn't enable logging by default due to limitations of the Tracing The .NET Aspire SQL Server integration emits the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.SqlClient Metrics The .NET Aspire SQL Server integration will emit the following metrics using OpenTelemetry: Microsoft.Data.SqlClient.EventSource active-hard-connections hard-connects hard-disconnects active-soft-connects soft-connects soft-disconnects number-of-non-pooled-connections number-of-pooled-connections number-of-active-connection-pool-groups number-of-inactive-connection-pool-groups number-of-active-connection-pools number-of-inactive-connection-pools number-of-active-connections number-of-free-connections number-of-stasis-connections number-of-reclaimed-connections See also Azure SQL Database SQL Server .NET Aspire database containers sample .NET Aspire integrations .NET Aspire GitHub repo""]","The .NET Aspire GitHub repository provides resources and examples related to .NET Aspire integrations, including SQL Server integration.",single_hop_specifc_query_synthesizer
4,What is the purpose of the AspNetCore.HealthChecks.Oracle NuGet package?,"['title: .NET Aspire Oracle Entity Framework Core integration description: Learn how to use the .NET Aspire Oracle Entity Framework Core integration, which includes both hosting and client integrations. ms.date: 01/21/2025 uid: database/oracle-entity-framework-integration .NET Aspire Oracle Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Oracle Database is a widely-used relational database management system owned and developed by Oracle. The .NET Aspire Oracle Entity Framework Core integration enables you to connect to existing Oracle servers or create new servers from .NET with the container-registry.orcale.com/databse/free container image. Hosting integration The .NET Aspire Oracle hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Oracle PackageReference xml <PackageReference Include=""Aspire.Hosting.Oracle"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Oracle server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Oracle database container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the container-registry.oracle.com/database/free image, it creates a new Oracle server on your local machine. A reference to your Oracle resource builder (the oracle variable) is used to add a database. The database is named oracledb and then added to the ExampleProject. The Oracle resource includes a random password generated using the The [!TIP] If you\'d rather connect to an existing Oracle server, call Add Oracle resource with password parameter The Oracle resource includes default credentials with a random password. Oracle supports configuration-based default passwords by using the environment variable ORACLE_PWD. When you want to provide a password explicitly, you can provide it as a parameter: ```csharp var password = builder.AddParameter(""password"", secret: true); var oracle = builder.AddOracle(""oracle"", password) .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddOracle API, and internally assigns the parameter to the ORACLE_PWD environment variable of the Oracle container. The password parameter is usually specified as a user secret: json { ""Parameters"": { ""password"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Oracle resource with data volume To add a data volume to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataVolume() .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracle""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Oracle data outside the lifecycle of its container. The data volume is mounted at the /opt/oracle/oradata path in the Oracle container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add Oracle resource with data bind mount To add a data bind mount to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataBindMount(source: @""C:\\Oracle\\Data""); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Oracle data across container restarts. The data bind mount is mounted at the C:\\Oracle\\Data on Windows (or /Oracle/Data on Unix) path on the host machine in the Oracle container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Oracle hosting integration automatically adds a health check for the Oracle resource. The health check verifies that the Oracle server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Oracle NuGet package.']",The AspNetCore.HealthChecks.Oracle NuGet package is used in the Oracle hosting integration to automatically add a health check for the Oracle resource. This health check verifies that the Oracle server is running and that a connection can be established to it.,single_hop_specifc_query_synthesizer
5,what u do in Program.cs for oracle db setup?,"['Client integration You need an Oracle database and connection string for accessing the database. To get started with the .NET Aspire Oracle client integration, install the ðŸ“¦ Aspire.Oracle.EntityFrameworkCore NuGet package in the client-consuming project, that is, the project for the application that uses the Oracle client. The Oracle client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Oracle.EntityFrameworkCore PackageReference xml <PackageReference Include=""Aspire.Oracle.EntityFrameworkCore"" Version=""*"" /> Add Oracle client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(connectionName: ""oracledb""); [!TIP] The connectionName parameter must match the name used when adding the Oracle database resource in the app host project. In other words, when you call AddDatabase and provide a name of oracledb that same name should be used when calling AddOracleDatabaseDbContext. For more information, see Add Oracle server and database resources. You can then retrieve the csharp public class ExampleService(ExampleDbContext context) { // Use database context... } For more information on dependency injection, see .NET dependency injection. Add Oracle database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( connectionName: ""oracledb"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the Configuration The .NET Aspire Oracle Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling builder.AddOracleDatabaseDbContext<TContext>(): csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>(""oracleConnection""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""oracleConnection"": ""Data Source=TORCL;User Id=OracleUser;Password=Non-default-P@ssw0rd;"" } } The EnrichOracleDatabaseDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it is called. For more information, see the ODP.NET documentation. Use configuration providers The .NET Aspire Oracle Entity Framework Core integration supports The following is an example of an :::no-loc text=""appsettings.json""::: that configures some of the available options: json { ""Aspire"": { ""Oracle"": { ""EntityFrameworkCore"": { ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableRetry"": false, ""CommandTimeout"": 30 } } } } [!TIP] The CommandTimeout property is in seconds. When set as shown in the preceding example, the timeout is 30 seconds. Use inline delegates You can also pass the Action<OracleEntityFrameworkCoreSettings> delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddOracleDatabaseDbContext<ExampleDbContext>( ""oracle"", static settings => settings.DisableHealthChecks = true); or csharp builder.EnrichOracleDatabaseDbContext<ExampleDbContext>( static settings => settings.DisableHealthChecks = true); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the Oracle database to connect to. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. DisableRetry A boolean value that indicates whether command retries should be disabled or not. CommandTimeout The time in seconds to wait for the command to execute. [!INCLUDE integration-health-checks] By default, the .NET Aspire Oracle Entity Framework Core integration handles the following: Checks if the If so, adds the DbContextHealthCheck, which calls EF Core\'s [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Oracle Entity Framework Core integration uses the following log categories: Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Database.Connection Microsoft.EntityFrameworkCore.Database.Transaction Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Migrations Microsoft.EntityFrameworkCore.Model Microsoft.EntityFrameworkCore.Model.Validation Microsoft.EntityFrameworkCore.Query Microsoft.EntityFrameworkCore.Update Tracing The .NET Aspire Oracle Entity Framework Core integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Oracle Entity Framework Core integration currently supports the following metrics: Microsoft.EntityFrameworkCore See also Oracle Database Oracle Database Documentation Entity Framework Core docs .NET Aspire integrations .NET Aspire GitHub repo']","In the Program.cs file of your client-consuming project, you call the method builder.AddOracleDatabaseDbContext<ExampleDbContext>(connectionName: ""oracledb""). The connectionName parameter must match the name used when adding the Oracle database resource in the app host project.",single_hop_specifc_query_synthesizer
6,What .NET Aspire do with Qdrant?,"[""title: .NET Aspire Qdrant integration description: Learn how to use the .NET Aspire Qdrant integration, which includes both hosting and client integrations. ms.date: 01/13/2025 uid: database/qdrant-integration .NET Aspire Qdrant integration [!INCLUDE includes-hosting-and-client] Qdrant is an open-source vector similarity search engine that efficiently stores, indexes, and searches large-scale vector data. It's commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Qdrant integration. The .NET Aspire Qdrant integration enables you to connect to existing Qdrant databases or create new instances with the qdrant/qdrant container image.""]",The .NET Aspire Qdrant integration allows you to connect to existing Qdrant databases or create new instances using the qdrant/qdrant container image.,single_hop_specifc_query_synthesizer
7,how to use /qdrant/storage for qdrant data in .net app?,"['Hosting integration The Qdrant hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Qdrant PackageReference xml <PackageReference Include=""Aspire.Hosting.Qdrant"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Qdrant resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Qdrant container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the qdrant/qdrant image, it creates a new Qdrant instance on your local machine. The resource is named qdrant and then added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing Qdrant server, call [!TIP] The qdrant/qdrant container image includes a web UI that you can use to explore your vectors and administer the database. To access this tool, start your .NET Aspire solution and then, in the .NET Aspire dashboard, select the endpoint for the Qdrant resource. In your browser\'s address bar, append /dashboard and press Enter. Handling API keys and passing other parameters for the Qdrant resource To connect to Qdrant a client must pass the right API key. In the above code, when .NET Aspire adds a Qdrant resource to your solution, it sets the API key to a random string. If you want to use a specific API key instead, you can pass it as an apiKey parameter: ```csharp var apiKey = builder.AddParameter(""apiKey"", secret: true); var qdrant = builder.AddQdrant(""qdrant"", apiKey); builder.AddProject Qdrant supports configuration-based default API keys by using the environment variable QDRANT__SERVICE__API_KEY. The preceding code gets a parameter to pass to the AddQdrant API, and internally assigns the parameter to the QDRANT__SERVICE__API_KEY environment variable of the Qdrant container. The apiKey parameter is usually specified as a user secret: json { ""Parameters"": { ""apiKey"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Qdrant resource with data volume To add a data volume to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Qdrant data outside the lifecycle of its container. The data volume is mounted at the /qdrant/storage path in the Qdrant container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add Qdrant resource with data bind mount To add a data bind mount to the Qdrant resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataBindMount(source: @""C:\\Qdrant\\Data""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Qdrant data across container restarts. The data bind mount is mounted at the C:\\Qdrant\\Data folder on Windows (or /Qdrant/Data on Unix) on the host machine in the Qdrant container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Qdrant hosting integration automatically adds a health check for the Qdrant resource. The health check verifies that Qdrant is running and that a connection can be established to it.']","To use /qdrant/storage for Qdrant data in a .NET app, you can add a data volume to the Qdrant resource by calling: ```csharp var builder = DistributedApplication.CreateBuilder(args); var qdrant = builder.AddQdrant(""qdrant"") .WithLifetime(ContainerLifetime.Persistent) .WithDataVolume(); builder.AddProject // After adding all resources, run the app... ``` The data volume is mounted at the /qdrant/storage path in the Qdrant container and persists the Qdrant data outside the lifecycle of its container. If a name parameter isn't provided, the name is generated at random.",single_hop_specifc_query_synthesizer
8,what Aspire.Qdrant.Client/ConfigurationSchema.json do?,"['Client integration To get started with the .NET Aspire Qdrant client integration, install the ðŸ“¦ Aspire.Qdrant.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Qdrant client. The Qdrant client integration registers a Qdrant.Client.QdrantClient instance that you can use to interact with Qdrant vector data. .NET CLI dotnetcli dotnet add package Aspire.Qdrant.Client PackageReference xml <PackageReference Include=""Aspire.Qdrant.Client"" Version=""*"" /> Add a Qdrant client In the Program.cs file of your client-consuming project, call the csharp builder.AddQdrantClient(""qdrant""); [!TIP] The connectionName parameter must match the name used when adding the Qdrant resource in the app host project. In other words, when you call AddQdrant and provide a name of qdrant that same name should be used when calling AddQdrantClient. For more information, see Add Qdrant resource. You can then retrieve the QdrantClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(QdrantClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Qdrant client There might be situations where you want to register multiple QdrantClient instances with different connection names. To register keyed Qdrant clients, call the csharp builder.AddKeyedQdrantClient(name: ""mainQdrant""); builder.AddKeyedQdrantClient(name: ""loggingQdrant""); Then you can retrieve the QdrantClient instances using dependency injection. For example, to retrieve the connections from an example service: csharp public class ExampleService( [FromKeyedServices(""mainQdrant"")] QdrantClient mainQdrantClient, [FromKeyedServices(""loggingQdrant"")] QdrantClient loggingQdrantClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Qdrant client integration provides multiple options to configure the connection to Qdrant based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddQdrantClient(): csharp builder.AddQdrantClient(""qdrant""); Then .NET Aspire retrieves the connection string from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""qdrant"": ""Endpoint=http://localhost:6334;Key=123456!@#$%"" } } By default the QdrantClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Qdrant client integration supports json { ""Aspire"": { ""Qdrant"": { ""Client"": { ""Endpoint"": ""http://localhost:6334/"", ""Key"": ""123456!@#$%"" } } } } For the complete Qdrant client integration JSON schema, see Aspire.Qdrant.Client/ConfigurationSchema.json. Use inline delegates You can also pass the Action<QdrantClientSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddQdrantClient( ""qdrant"", settings => settings.Key = ""12345!@#$%""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Qdrant integration uses standard .NET logging, and you\'ll see log entries from the following category: Qdrant.Client Tracing The .NET Aspire Qdrant integration doesn\'t currently emit tracing activities because they are not supported by the Qdrant.Client library. Metrics The .NET Aspire Qdrant integration doesn\'t currently emit metrics because they are not supported by the Qdrant.Client library. See also Qdrant Qdrant documentation Qdrant GitHub repo Qdrant .NET SDK .NET Aspire integrations .NET Aspire GitHub repo']",The Aspire.Qdrant.Client/ConfigurationSchema.json provides the complete JSON schema for configuring the .NET Aspire Qdrant client integration.,single_hop_specifc_query_synthesizer
9,how mysql work with .net aspire for seeding data?,"['title: Seed data in a database using .NET Aspire description: Learn about how to seed database data in .NET Aspire ms.date: 08/12/2024 ms.topic: how-to Seed data in a database using .NET Aspire In this article, you learn how to configure .NET Aspire projects to seed data in a database during app startup. .NET Aspire enables you to seed data using database scripts or Entity Framework Core for common platforms such as SQL Server, PostgreSQL and MySQL. When to seed data Seeding data pre-populates database tables with rows of data so they\'re ready for testing via your app. You may want to seed data for the following scenarios: Manually develop and test different features of your app against a meaningful set of data, such as a product catalog or list of customers. Run test suites to verify that features behave a specific way with a given set of data. Manually seeding data is tedious and time consuming, so you should automate the process when possible. Use volumes to run database scripts for .NET Aspire projects during startup. You can also seed your database using tools like Entity Framework Core, which handles many underlying concerns for you. Understand containerized databases By default, .NET Aspire database integrations rely on containerized databases, which create the following challenges when trying to seed data: .NET Aspire destroys and recreates containers every time the app restarts, which means by default you have to re-seed your database every time the app restarts. Depending on your selected database technology, the new container instance may or may not create a default database, which means you might also have to create the database itself. Even if a default database exists, it most likely will not have the desired name or schema for your specific app. .NET Aspire enables you to resolve these challenges using volumes and a few configurations to seed data effectively. Seed data using volumes and SQL scripts Volumes are the recommended way to automatically seed containerized databases when using SQL scripts. Volumes can store data for multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume mount, which is the physical location on your host. Target: The target path in the container of the data you want to persist. Consider the following volume configuration code from a :::no-loc text=""Program.cs""::: file in a sample AppHost project: csharp var todosDbName = ""Todos""; var todosDb = builder.AddPostgres(""postgres"") .WithEnvironment(""POSTGRES_DB"", todosDbName) .WithBindMount( ""../DatabaseContainers.ApiService/data/postgres"", ""/docker-entrypoint-initdb.d"") .AddDatabase(todosDbName); In this example, the .WithBindMount method parameters configure the following: ../DatabaseContainers.ApiService/data/postgres sets a path to the SQL script in your local project that you want to run in the container to seed data. /docker-entrypoint-initdb.d sets the path to an entry point in the container so your script will be run during container startup. The referenced SQL script located at ../DatabaseContainers.ApiService/data/postgres creates and seeds a Todos table: ```sql -- Postgres init script -- Create the Todos table CREATE TABLE IF NOT EXISTS Todos ( Id SERIAL PRIMARY KEY, Title text UNIQUE NOT NULL, IsComplete boolean NOT NULL DEFAULT false ); -- Insert some sample data into the Todos table INSERT INTO Todos (Title, IsComplete) VALUES (\'Give the dog a bath\', false), (\'Wash the dishes\', false), (\'Do the groceries\', false) ON CONFLICT DO NOTHING; ``` The script runs during startup every time a new container instance is created. Database seeding examples The following examples demonstrate how to seed data using SQL scripts and configurations applied using the .WithBindMount method for different database technologies: [!NOTE] Visit the Database Container Sample App to view the full project and file structure for each database option. SQL Server The configuration code in the .AppHost :::no-loc text=""Program.cs""::: file mounts the required database files and folders and configures an entrypoint so that they run during startup. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""37-49"" ::: The entrypoint.sh script lives in the mounted ./sqlserverconfig project folder and runs when the container starts. The script launches SQL Server and checks that it\'s running. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/sqlserverconfig/entrypoint.sh"" ::: The init.sql SQL script that lives in the mounted ../DatabaseContainers.ApiService/data/sqlserver project folder creates the database and tables. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/sqlserver/init.sql"" ::: PostgreSQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""3-15"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/postgres/init.sql"" ::: MySQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""20-32"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/mysql/init.sql"" :::']","In .NET Aspire, MySQL can be used for seeding data by configuring the .AppHost project to mount the required database files and folders and setting an entry point so that the SQL script runs during container startup. The corresponding SQL script, included in the app, creates and seeds the necessary tables in the MySQL database.",single_hop_specifc_query_synthesizer
10,what program.cs do in .net projects?,"['Seed data using Entity Framework Core You can also seed data in .NET Aspire projects using Entity Framework Core by explicitly running migrations during startup. Entity Framework Core handles underlying database connections and schema creation for you, which eliminates the need to use volumes or run SQL scripts during container startup. [!IMPORTANT] These types of configurations should only be done during development, so make sure to add a conditional that checks your current environment context. Add the following code to the :::no-loc text=""Program.cs""::: file of your API Service project. SQL Server ```csharp // Register DbContext class builder.AddSqlServerDbContext var app = builder.Build(); app.MapDefaultEndpoints(); if (app.Environment.IsDevelopment()) { // Retrieve an instance of the DbContext class and manually run migrations during startup using (var scope = app.Services.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService PostgreSQL ```csharp // Register DbContext class builder.AddNpgsqlDbContext var app = builder.Build(); app.MapDefaultEndpoints(); if (app.Environment.IsDevelopment()) { // Retrieve an instance of the DbContext class and manually run migrations during startup using (var scope = app.Services.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService MySQL ```csharp // Register DbContext class builder.AddMySqlDataSource var app = builder.Build(); app.MapDefaultEndpoints(); if (app.Environment.IsDevelopment()) { // Retrieve an instance of the DbContext class and manually run migrations during startup using (var scope = app.Services.CreateScope()) { var context = scope.ServiceProvider.GetRequiredService Next steps Database seeding is useful in a variety of app development scenarios. Try combining these techniques with the resource implementations demonstrated in the following tutorials: Tutorial: Connect an ASP.NET Core app to SQL Server using .NET Aspire and Entity Framework Core Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations .NET Aspire orchestration overview']","The Program.cs file in .NET projects is used to configure and set up the application, such as registering the DbContext class, building the application, mapping default endpoints, and running migrations during startup in development environments.",single_hop_specifc_query_synthesizer
11,Wht is Blazr in .NET Aspire?,"['title: Deploy a ASP.NET Core app that connects to SQL Server to Azure description: Learn how to deploy a ASP.NET Core app that connects to SQL Server to Azure ms.date: 11/08/2024 ms.topic: how-to Tutorial: Deploy a .NET Aspire project with a SQL Server Database to Azure In this tutorial, you learn to configure an ASP.NET Core app with a SQL Server Database for deployment to Azure. .NET Aspire provides multiple SQL Server integration configurations that provision different database services in Azure. You\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET Core app that is configured to use the .NET Aspire SQL Server integration Configure the app to provision an Azure SQL Database Configure the app to provision a containerized SQL Server database [!NOTE] This document focuses specifically on .NET Aspire configurations to provision and deploy SQL Server resources in Azure. Visit the Azure Container Apps deployment tutorial to learn more about the full .NET Aspire deployment process. [!INCLUDE aspire-prereqs] Create the sample solution Visual Studio At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Aspire and select .NET Aspire - Starter Application. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQL. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Verify that .NET 9.0 is selected and choose Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. .NET CLI In an empty directory, run the following command to create a new .NET Aspire project: dotnetcli dotnet new aspire-starter --output AspireSQL The .NET CLI creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Configure the app for SQL Server deployment .NET Aspire provides two built-in configuration options to streamline SQL Server deployment on Azure: Provision a containerized SQL Server database using Azure Container Apps Provision an Azure SQL Database instance Add the .NET Aspire integration to the app Add the appropriate .NET Aspire integration to the AspireSQL.AppHost project for your desired hosting service. Azure SQL Database Add the ðŸ“¦ Aspire.Hosting.Azure.Sql NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.Azure.Sql SQL Server Container Add the ðŸ“¦ Aspire.Hosting.SqlServer NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Configure the AppHost project Configure the AspireSQL.AppHost project for your desired SQL database service. Azure SQL Database Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeployazure/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The PublishAsAzureSqlDatabase method ensures that tools such as the Azure Developer CLI or Visual Studio create an Azure SQL Database resource during the deployment process. SQL Server Container Replace the contents of the Program.cs file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeploycontainer/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. This configuration also ensures that tools such as the Azure Developer CLI or Visual Studio create a containerized SQL Server instance during the deployment process.']",Blazor is a project within the AspireSQL.Web solution that depends on service defaults.,single_hop_specifc_query_synthesizer
12,What role does SQL Server play in the deployment process for .NET Aspire projects?,"['Deploy the app Tools such as the Azure Developer CLI (azd) support .NET Aspire SQL Server integration configurations to streamline deployments. azd consumes these settings and provisions properly configured resources for you. [!INCLUDE init-workflow] [!INCLUDE azd-up-workflow] Azure SQL Database The deployment process provisioned an Azure SQL Database resource due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-database.png"" alt-text=""A screenshot showing the deployed Azure SQL Database.""::: SQL Server Container The deployment process created a SQL Server app container due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-container.png"" alt-text=""A screenshot showing the containerized SQL Database.""::: [!INCLUDE clean-up-resources] See also .NET Aspire deployment via Azure Container Apps .NET Aspire Azure Container Apps deployment deep dive Deploy a .NET Aspire project using GitHub Actions']","SQL Server is utilized in the deployment process by provisioning an Azure SQL Database resource or creating a SQL Server app container, based on the .AppHost configuration provided.",single_hop_specifc_query_synthesizer
13,Wht is the benfit of usng .NET Aspire Milvus databse integrtion for AI and machne learnng aplications?,"[""title: .NET Aspire Milvus database integration description: Learn how to use the .NET Aspire Milvus database integration, which includes both hosting and client integrations. ms.date: 08/22/2024 uid: database/milvus-integration .NET Aspire Milvus database integration [!INCLUDE includes-hosting-and-client] Milvus is an open-source vector database system that efficiently stores, indexes, and searches large-scale vector data. It's commonly used in machine learning, artificial intelligence, and data science applications. Vector data encodes information as mathematical vectors, which are arrays of numbers or coordinates. Machine learning and AI systems often use vectors to represent unstructured objects like images, text, audio, or video. Each dimension in the vector describes a specific characteristic of the object. By comparing them, systems can classify, search, and identify clusters of objects. In this article, you learn how to use the .NET Aspire Milvus database integration. The .NET Aspire Milvus database integration enables you to connect to existing Milvus databases or create new instances with the milvusdb/milvus container image.""]","The .NET Aspire Milvus database integration allows efficient storage, indexing, and searching of large-scale vector data, which is commonly used in machine learning, artificial intelligence, and data science applications. This enables systems to classify, search, and identify clusters of unstructured objects like images, text, audio, or video by comparing their vector representations.",single_hop_specifc_query_synthesizer
14,What is Attu in the context of managing Milvus databases?,"['Hosting integration The Milvus database hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Milvus PackageReference xml <PackageReference Include=""Aspire.Hosting.Milvus"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Milvus server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithLifetime(ContainerLifetime.Persistent); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Milvus container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the milvusdb/milvus image, it creates a new Milvus instance on your local machine. A reference to your Milvus resource builder (the milvus variable) is used to add a database. The database is named milvusdb and then added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing Milvus server, call Handling credentials and passing other parameters for the Milvus resource The Milvus resource includes default credentials with a username of root and the password Milvus. Milvus supports configuration-based default passwords by using the environment variable COMMON_SECURITY_DEFAULTROOTPASSWORD. To change the default password in the container, pass an apiKey parameter when calling the AddMilvus hosting API: ```csharp var apiKey = builder.AddParameter(""apiKey"", secret: true); var milvus = builder.AddMilvus(""milvus"", apiKey); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddMilvus API, and internally assigns the parameter to the COMMON_SECURITY_DEFAULTROOTPASSWORD environment variable of the Milvus container. The apiKey parameter is usually specified as a user secret: json { ""Parameters"": { ""apiKey"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add a Milvus resource with a data volume To add a data volume to the Milvus service resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithDataVolume(); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Milvus data outside the lifecycle of its container. The data volume is mounted at the /var/lib/milvus path in the SQL Server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add a Milvus resource with a data bind mount To add a data bind mount to the Milvus resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithDataBindMount(source: @""C:\\Milvus\\Data""); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Milvus data across container restarts. The data bind mount is mounted at the C:\\Milvus\\Data on Windows (or /Milvus/Data on Unix) path on the host machine in the Milvus container. For more information on data bind mounts, see Docker docs: Bind mounts. Create an Attu resource Attu is a graphical user interface (GUI) and management tool designed to interact with Milvus and its databases. It includes rich visualization features that can help you investigate and understand your vector data. If you want to use Attu to manage Milvus in your .NET Aspire solution, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var milvus = builder.AddMilvus(""milvus"") .WithAttu() .WithLifetime(ContainerLifetime.Persistent); var milvusdb = milvus.AddDatabase(""milvusdb""); builder.AddProject // After adding all resources, run the app... ``` When you debug the .NET Aspire solution, you\'ll see an Attu container listed in the solution\'s resources. Select the resource\'s endpoint to open the GUI and start managing databases.']",Attu is a graphical user interface (GUI) and management tool designed to interact with Milvus and its databases. It includes rich visualization features that can help you investigate and understand your vector data.,single_hop_specifc_query_synthesizer
15,how to add milvus client in .net app?,"['Client integration To get started with the .NET Aspire Milvus client integration, install the ðŸ“¦ Aspire.Milvus.Client NuGet package in the client-consuming project, that is, the project for the application that uses the Milvus database client. The Milvus client integration registers a Milvus.Client.MilvusClient instance that you can use to interact with Milvus databases. .NET CLI dotnetcli dotnet add package Aspire.Milvus.Client PackageReference xml <PackageReference Include=""Aspire.Milvus.Client"" Version=""*"" /> Add a Milvus client In the Program.cs file of your client-consuming project, call the csharp builder.AddMilvusClient(""milvusdb""); [!TIP] The connectionName parameter must match the name used when adding the Milvus database resource in the app host project. In other words, when you call AddDatabase and provide a name of milvusdb that same name should be used when calling AddMilvusClient. For more information, see Add a Milvus server resource and database resource. You can then retrieve the MilvusClient instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(MilvusClient client) { // Use the Milvus Client... } For more information on dependency injection, see .NET dependency injection. Add a keyed Milvus client There might be situations where you want to register multiple MilvusClient instances with different connection names. To register keyed Milvus clients, call the csharp builder.AddKeyedMilvusClient(name: ""mainDb""); builder.AddKeyedMilvusClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Milvus resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the MilvusClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] MilvusClient mainDbClient, [FromKeyedServices(""loggingDb"")] MilvusClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Milvus client integration provides multiple options to configure the connection to Milvus based on the requirements and conventions of your project. [!TIP] The default use is root and the default password is Milvus. To configure a different password in the Milvus container, see Handling credentials and passing other parameters for the Milvus resource. Use the following techniques to configure consuming client apps in your .NET Aspire solution with the same password or other settings. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddMilvusClient(): csharp builder.AddMilvusClient(""milvus""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""milvus"": ""Endpoint=http://localhost:19530/;Key=root:Non-default-P@ssw0rd"" } } By default the MilvusClient uses the gRPC API endpoint. Use configuration providers The .NET Aspire Milvus client integration supports json { ""Aspire"": { ""Milvus"": { ""Client"": { ""Endpoint"": ""http://localhost:19530/"", ""Database"": ""milvusdb"", ""Key"": ""root:Non-default-P@ssw0rd"", ""DisableHealthChecks"": false } } } } For the complete Milvus client integration JSON schema, see Aspire.Milvus.Client/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MilvusSettings> configureSettings delegate to set up some or all the options inline, for example to set the API key from code: csharp builder.AddMilvusClient( ""milvus"", static settings => settings.Key = ""root:Non-default-P@ssw0rd""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Milvus database integration: Adds the health check when Uses the configured client to perform a HealthAsync. If the result is healthy, the health check is considered healthy, otherwise it\'s unhealthy. Likewise, if there\'s an exception, the health check is considered unhealthy with the error propagating through the health check failure. [!INCLUDE integration-observability-and-telemetry]']","To add a Milvus client in a .NET application, install the Aspire.Milvus.Client NuGet package in the client-consuming project. In the Program.cs file, call builder.AddMilvusClient(""milvusdb""). Ensure the connectionName parameter matches the name used when adding the Milvus database resource in the app host project. You can then retrieve the MilvusClient instance using dependency injection.",single_hop_specifc_query_synthesizer
16,What Aspire do for logging and metrics in .NET?,"[""Logging The .NET Aspire Milvus database integration uses standard .NET logging, and you'll see log entries from the following category: Milvus.Client Tracing The .NET Aspire Milvus database integration doesn't currently emit tracing activities because they are not supported by the Milvus.Client library. Metrics The .NET Aspire Milvus database integration doesn't currently emit metrics because they are not supported by the Milvus.Client library. See also Milvus Milvus GitHub repo Milvus .NET SDK .NET Aspire integrations .NET Aspire GitHub repo""]","The .NET Aspire Milvus database integration uses standard .NET logging, with log entries from the category 'Milvus.Client.' However, it does not currently emit tracing activities or metrics because these are not supported by the Milvus.Client library.",single_hop_specifc_query_synthesizer
17,"How can the Azure Developer CLI (azd) be used to deploy an ASP.NET Core app with .NET Aspire SQL Server integration, and what are the differences in provisioning resources for Azure SQL Database versus a SQL Server container?","['<1-hop>\n\ntitle: Deploy a ASP.NET Core app that connects to SQL Server to Azure description: Learn how to deploy a ASP.NET Core app that connects to SQL Server to Azure ms.date: 11/08/2024 ms.topic: how-to Tutorial: Deploy a .NET Aspire project with a SQL Server Database to Azure In this tutorial, you learn to configure an ASP.NET Core app with a SQL Server Database for deployment to Azure. .NET Aspire provides multiple SQL Server integration configurations that provision different database services in Azure. You\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET Core app that is configured to use the .NET Aspire SQL Server integration Configure the app to provision an Azure SQL Database Configure the app to provision a containerized SQL Server database [!NOTE] This document focuses specifically on .NET Aspire configurations to provision and deploy SQL Server resources in Azure. Visit the Azure Container Apps deployment tutorial to learn more about the full .NET Aspire deployment process. [!INCLUDE aspire-prereqs] Create the sample solution Visual Studio At the top of Visual Studio, navigate to File > New > Project. In the dialog window, search for Aspire and select .NET Aspire - Starter Application. Choose Next. On the Configure your new project screen: Enter a Project Name of AspireSQL. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Verify that .NET 9.0 is selected and choose Create. Visual Studio creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. .NET CLI In an empty directory, run the following command to create a new .NET Aspire project: dotnetcli dotnet new aspire-starter --output AspireSQL The .NET CLI creates a new ASP.NET Core solution that is structured to use .NET Aspire. The solution consists of the following projects: AspireSQL.Web: A Blazor project that depends on service defaults. AspireSQL.ApiService: An API project that depends on service defaults. AspireSQL.AppHost: An orchestrator project designed to connect and configure the different projects and services of your app. The orchestrator should be set as the startup project. AspireSQL.ServiceDefaults: A shared class library to hold configurations that can be reused across the projects in your solution. Configure the app for SQL Server deployment .NET Aspire provides two built-in configuration options to streamline SQL Server deployment on Azure: Provision a containerized SQL Server database using Azure Container Apps Provision an Azure SQL Database instance Add the .NET Aspire integration to the app Add the appropriate .NET Aspire integration to the AspireSQL.AppHost project for your desired hosting service. Azure SQL Database Add the ðŸ“¦ Aspire.Hosting.Azure.Sql NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.Azure.Sql SQL Server Container Add the ðŸ“¦ Aspire.Hosting.SqlServer NuGet package to the AspireSQL.AppHost project: dotnetcli dotnet add package Aspire.Hosting.SqlServer Configure the AppHost project Configure the AspireSQL.AppHost project for your desired SQL database service. Azure SQL Database Replace the contents of the :::no-loc text=""Program.cs""::: file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeployazure/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. The PublishAsAzureSqlDatabase method ensures that tools such as the Azure Developer CLI or Visual Studio create an Azure SQL Database resource during the deployment process. SQL Server Container Replace the contents of the Program.cs file in the AspireSQL.AppHost project with the following code: :::code language=""csharp"" source=""snippets/tutorial/aspiresqldeploycontainer/AspireSQL.AppHost/Program.cs""::: The preceding code adds a SQL Server Container resource to your app and configures a connection to a database called sqldata. This configuration also ensures that tools such as the Azure Developer CLI or Visual Studio create a containerized SQL Server instance during the deployment process.', '<2-hop>\n\nDeploy the app Tools such as the Azure Developer CLI (azd) support .NET Aspire SQL Server integration configurations to streamline deployments. azd consumes these settings and provisions properly configured resources for you. [!INCLUDE init-workflow] [!INCLUDE azd-up-workflow] Azure SQL Database The deployment process provisioned an Azure SQL Database resource due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-database.png"" alt-text=""A screenshot showing the deployed Azure SQL Database.""::: SQL Server Container The deployment process created a SQL Server app container due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-container.png"" alt-text=""A screenshot showing the containerized SQL Database.""::: [!INCLUDE clean-up-resources] See also .NET Aspire deployment via Azure Container Apps .NET Aspire Azure Container Apps deployment deep dive Deploy a .NET Aspire project using GitHub Actions']","The Azure Developer CLI (azd) can be used to deploy an ASP.NET Core app with .NET Aspire SQL Server integration by consuming the configurations provided in the .AppHost project. These configurations streamline the deployment process by provisioning the necessary resources. For an Azure SQL Database, the .AppHost configuration ensures that azd creates a properly configured Azure SQL Database resource during deployment. In contrast, for a SQL Server container, the .AppHost configuration ensures that azd creates a containerized SQL Server instance. Both deployment options are supported by azd, which automates the provisioning and setup of these resources based on the specified configurations.",multi_hop_abstract_query_synthesizer
18,Wht r the new UX enhancemnts in .NET Aspire 9.0 dashboard and how do they suport telemetry improvemnts?,"['<1-hop>\n\ntitle: What\'s new in .NET Aspire 9.0 description: Learn what\'s new in the official general availability version of .NET Aspire 9.0. ms.date: 11/13/2024 What\'s new in .NET Aspire 9.0 ðŸ“¢ .NET Aspire 9.0 is the next major general availability (GA) release of .NET Aspire; it supports both: .NET 8.0 Long Term Support (LTS) or .NET 9.0 Standard Term Support (STS). [!NOTE] You\'re able to use .NET Aspire 9.0 with either .NET 8 or .NET 9! This release addresses some of the most highly requested features and pain points from the community. The best features are community-driven! To join the community on, visit us on :::image type=""icon"" source=""../media/discord-icon.svg"" border=""false""::: Discord to chat with team members and collaborate with us on :::image type=""icon"" source=""../media/github-mark.svg"" border=""false""::: GitHub. For more information on the official .NET version and .NET Aspire version support, see: .NET support policy: Definitions for LTS and STS. .NET Aspire support policy: Important unique product life cycle details. Upgrade to .NET Aspire 9 To upgrade from earlier versions of .NET Aspire to .NET Aspire 9, follow the instructions in the official Upgrade to .NET Aspire 9 guide. The guide provides detailed instructions on how to upgrade your existing .NET Aspire solutions to .NET Aspire 9. Regardless of you\'re doing it manually, or using the Upgrade Assistant, the guide makes short work of the process. Tooling improvements .NET Aspire 9 makes it simpler to configure your environment to develop .NET Aspire applications. You no longer need a .NET workload. Instead, you install the new .NET Aspire SDK into the app host project of your .NET Aspire solutions. For more information, see .NET Aspire setup and tooling. Templates have moved .NET Aspire 9 is moving the contents that used to be installed via the workload into separate NuGet packages. This includes the templates for creating new .NET Aspire projects and solutions. These templates are installed using the dotnet new install command. These can be installed by running the following command: dotnetcli dotnet new install Aspire.ProjectTemplates::9.0.0 [!TIP] If you already have the .NET Aspire workload installed, you need to pass the --force flag to overwrite the existing templates. Feel free to uninstall the .NET Aspire workload. For more information, see .NET Aspire templates.', '<2-hop>\n\nDashboard UX enhancements and new interactivity features The .NET Aspire dashboard continues to improve with each release. Manage resource lifecycle The most requested feature for the dashboard is to manage the life-cycles of your orchestrated named resources. Specifically, the ability to stop, start, and restart resources. This feature works for projects, containers, and executables. It enables restarting individual resources without having to restart the entire app host. For project resources, when the debugger is attached, it\'s reattached on restart. For more information, see .NET Aspire dashboard: Stop or Start a resource. Mobile and responsive support The .NET Aspire dashboard is now mobile-friendly, responsively adapting to a wide range of screen sizes and enabling on-the-go management of deployed .NET Aspire applications. Other accessibility improvements were made, including the display of settings and content overflow on mobile. Sensitive properties, volumes, and health checks in resource details The display of resource details contains several improvements: Properties can be marked as sensitive, automatically masking them in the dashboard UI. This security feature helps to avoid accidentally disclosing keys or passwords when screen sharing the dashboard with other people. For example, container arguments could pass sensitive information and so are masked by default. Configured container volumes are listed in resource details. .NET Aspire 9 adds support for health checks. Detailed information about these checks can now be viewed in the resource details pane, showing why a resource might be marked as unhealthy or degraded. Find out more about health checks here. Colorful console log ANSI escape codes format text in terminals by controlling colors (foreground and background) and styles like bold, underline, and italics. Previously, the dashboard\'s console logs page could only render one ANSI escape code at a time, failing when multiple codes were combined. For example, it could display red text, but not text that was both red and bold. A community contribution from @mangeg improved support for ANSI escape codes and removed this limitation. :::image type=""content"" source=""media/console-logs-ansi-text-format.png"" lightbox=""media/console-logs-ansi-text-format.png"" alt-text=""Colorful console logs""::: Another improvement to console logs is hiding unsupported escape codes. Codes that aren\'t related to displaying text, such as positioning the cursor or communicating with the operating system don\'t make sense in this UI, and are hidden. Telemetry user-centric additions Telemetry remains a vital aspect of .NET Aspire. In .NET Aspire 9, many new features were introduced to the Telemetry service. Improved telemetry filtering Traces can be filtered with attribute values. For example, if you only want to view traces for one endpoint in your app, the http.route attribute on HTTP requests can be filtered to a specified value. Telemetry filtering also supports autocomplete of existing values. The Add filter dialog provides a combo box for selecting from values that dashboard has available. This feature makes it much easier to filter to real data and helps avoid typos by entered a value yourself. For more information, see .NET Aspire dashboard: Filter traces. Combine telemetry from multiple resources When a resource has multiple replicas, you can now filter telemetry to view data from all instances at once. Select the parent resource, labeled (application). For more information, see .NET Aspire dashboard: Combine telemetry from multiple resources. Browser telemetry support The dashboard supports OpenTelemetry Protocol (OTLP) over HTTP and cross-origin resource sharing (CORS). These features unlock the ability to send OpenTelemetry from browser apps to the .NET Aspire dashboard. For example, a browser-based single page app (SPA) can configure the JavaScript OpenTelemetry SDK to send structured logs, traces, and metrics created in the browser to the dashboard. Browser telemetry is displayed alongside server telemetry. :::image type=""content"" source=""media/dashboard-browser-telemetry.png"" lightbox=""media/dashboard-browser-telemetry.png"" alt-text=""Trace detail page with browser telemetry""::: For more information on configuring browser telemetry, see Enable browser telemetry documentation.']","The .NET Aspire 9.0 dashboard introduces several new UX enhancements, including the ability to manage the lifecycle of orchestrated named resources (e.g., stopping, starting, and restarting resources individually), mobile-friendly and responsive design for on-the-go management, and improved accessibility features like masking sensitive properties in the UI. These enhancements support telemetry improvements by enabling better filtering of traces with attribute values, combining telemetry from multiple resource replicas, and adding browser telemetry support. For example, browser-based apps can now send OpenTelemetry data to the dashboard, which is displayed alongside server telemetry.",multi_hop_abstract_query_synthesizer
19,How do .NET Aspire project templates and integrations simplify the development of distributed applications?,"['<1-hop>\n\ntitle: .NET Aspire overview description: Learn about .NET Aspire, an application stack designed to improve the experience of building distributed applications. ms.date: 11/12/2024 .NET Aspire overview :::row::: :::column::: :::image type=""icon"" border=""false"" source=""../../assets/dotnet-aspire-logo-128.svg""::: :::column-end::: :::column span=""3""::: .NET Aspire is a set of tools, templates, and packages for building observable, production ready apps.\u200b\u200b .NET Aspire is delivered through a collection of NuGet packages that bootstrap or improve specific challenges with modern app development. Today\'s apps generally consume a large number of services, such as databases, messaging, and caching, many of which are supported via .NET Aspire Integrations. For information on support, see the .NET Aspire Support Policy. :::column-end::: :::row-end::: Why .NET Aspire? .NET Aspire improves the experience of building apps that have a variety of projects and resources. With dev-time productivity enhancements that emulate deployed scenarios, you can quickly develop interconnected apps. Designed for flexibility, .NET Aspire allows you to replace or extend parts with your preferred tools and workflows. Key features include: Dev-Time Orchestration: .NET Aspire provides features for running and connecting multi-project applications, container resources, and other dependencies for local development environments. Integrations: .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects.  .NET Aspire integrations are NuGet packages for commonly used services, such as Redis or Postgres, with standardized interfaces ensuring they connect consistently and seamlessly with your app. Tooling: .NET Aspire comes with project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI to help you create and interact with .NET Aspire projects. Dev-time orchestration In .NET Aspire, ""orchestration"" primarily focuses on enhancing the local development experience by simplifying the management of your app\'s configuration and interconnections. It\'s important to note that .NET Aspire\'s orchestration isn\'t intended to replace the robust systems used in production environments, such as Kubernetes. Instead, it\'s a set of abstractions that streamline the setup of service discovery, environment variables, and container configurations, eliminating the need to deal with low-level implementation details. With .NET Aspire, your code has a consistent bootstrapping experience on any dev machine without the need for complex manual steps, making it easier to manage during the development phase. .NET Aspire orchestration assists with the following concerns: App composition: Specify the .NET projects, containers, executables, and cloud resources that make up the application. Service discovery and connection string management: The app host injects the right connection strings, network configurations, and service discovery information to simplify the developer experience. For example, using .NET Aspire, the following code creates a local Redis container resource, waits for it to become available, and then configures the appropriate connection string in the ""frontend"" project with a few helper method calls: ```csharp // Create a distributed application builder given the command line arguments. var builder = DistributedApplication.CreateBuilder(args); // Add a Redis server to the application. var cache = builder.AddRedis(""cache""); // Add the frontend project to the application and configure it to use the // Redis server, defined as a referenced dependency. builder.AddProject For more information, see .NET Aspire orchestration overview. [!IMPORTANT] The call to .NET Aspire integrations .NET Aspire integrations are NuGet packages designed to simplify connections to popular services and platforms, such as Redis or PostgreSQL. .NET Aspire integrations handle cloud resource setup and interaction for you through standardized patterns, such as adding health checks and telemetry. Integrations are two-fold - ""hosting"" integrations represents the service you\'re connecting to, and ""client"" integrations represents the client or consumer of that service. In other words, for many hosting packages there\'s a corresponding client package that handles the service connection within your code. Each integration is designed to work with the .NET Aspire app host, and their configurations are injected automatically by referencing named resources. In other words, if Example.ServiceFoo references Example.ServiceBar, Example.ServiceFoo inherits the integration\'s required configurations to allow them to communicate with each other automatically. For example, consider the following code using the .NET Aspire Service Bus integration: csharp builder.AddAzureServiceBusClient(""servicebus""); The Registers a Applies Enables corresponding health checks, logging, and telemetry specific to the Azure Service Bus usage. A full list of available integrations is detailed on the .NET Aspire integrations overview page.', '<2-hop>\n\nProject templates and tooling .NET Aspire provides a set of project templates and tooling experiences for Visual Studio, Visual Studio Code, and the .NET CLI. These templates are designed to help you create and interact with .NET Aspire projects, or add .NET Aspire into your existing codebase. The templates include a set of opinionated defaults to help you get started quickly - for example, it has boilerplate code for turning on health checks and logging in .NET apps. These defaults are fully customizable, so you can edit and adapt them to suit your needs. .NET Aspire templates also include boilerplate extension methods that handle common service configurations for you: csharp builder.AddServiceDefaults(); For more information on what AddServiceDefaults does, see .NET Aspire service defaults. When added to your :::no-loc text=""Program.cs""::: file, the preceding code handles the following concerns: OpenTelemetry: Sets up formatted logging, runtime metrics, built-in meters, and tracing for ASP.NET Core, gRPC, and HTTP. For more information, see .NET Aspire telemetry. Default health checks: Adds default health check endpoints that tools can query to monitor your app. For more information, see .NET app health checks in C#. Service discovery: Enables service discovery for the app and configures Next steps [!div class=""nextstepaction""] Quickstart: Build your first .NET Aspire project']",".NET Aspire project templates and integrations simplify the development of distributed applications by providing opinionated defaults and standardized patterns for common tasks. The project templates, available for Visual Studio, Visual Studio Code, and the .NET CLI, include boilerplate code for enabling health checks, logging, and service discovery, which can be customized to suit specific needs. For example, the 'AddServiceDefaults' method in the templates sets up OpenTelemetry for logging and metrics, default health check endpoints, and service discovery configurations. Additionally, .NET Aspire integrations, delivered as NuGet packages, streamline connections to popular services like Redis and PostgreSQL by automatically handling cloud resource setup, injecting required configurations, and enabling telemetry and health checks. These features collectively enhance developer productivity and ensure a consistent bootstrapping experience across development environments.",multi_hop_abstract_query_synthesizer
20,How do you install the NuGet packages for .NET Aspire RabbitMQ integration and enable health checks for both hosting and client setups?,"['<1-hop>\n\ntitle: .NET Aspire RabbitMQ integration description: Learn how to use the .NET Aspire RabbitMQ message-broker integration, which includes both hosting and client integrations. ms.date: 10/11/2024 uid: messaging/rabbitmq-integration .NET Aspire RabbitMQ integration [!INCLUDE includes-hosting-and-client] RabbitMQ is a reliable messaging and streaming broker, which is easy to deploy on cloud environments, on-premises, and on your local machine. The .NET Aspire RabbitMQ integration enables you to connect to existing RabbitMQ instances, or create new instances from .NET with the docker.io/library/rabbitmq container image. Hosting integration The RabbitMQ hosting integration models a RabbitMQ server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.RabbitMQ PackageReference xml <PackageReference Include=""Aspire.Hosting.RabbitMQ"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add RabbitMQ server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/rabbitmq image, it creates a new RabbitMQ server instance on your local machine. A reference to your RabbitMQ server (the rabbitmq variable) is added to the ExampleProject. The RabbitMQ server resource includes default credentials with a username of ""guest"" and randomly generated password using the The [!TIP] If you\'d rather connect to an existing RabbitMQ server, call Add RabbitMQ server resource with management plugin To add the RabbitMQ management plugin to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithManagementPlugin(); builder.AddProject // After adding all resources, run the app... ``` The RabbitMQ management plugin provides an HTTP-based API for management and monitoring of your RabbitMQ server. .NET Aspire adds another container image docker.io/library/rabbitmq-management to the app host that runs the management plugin. Add RabbitMQ server resource with data volume To add a data volume to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the RabbitMQ server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/rabbitmq path in the RabbitMQ server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add RabbitMQ server resource with data bind mount To add a data bind mount to the RabbitMQ server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbitmq = builder.AddRabbitMQ(""messaging"") .WithDataBindMount( source: @""C:\\RabbitMQ\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the RabbitMQ server data across container restarts. The data bind mount is mounted at the C:\\RabbitMQ\\Data on Windows (or /RabbitMQ/Data on Unix) path on the host machine in the RabbitMQ server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add RabbitMQ server resource with parameters When you want to explicitly provide the username and password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username"", secret: true); var password = builder.AddParameter(""password"", secret: true); var rabbitmq = builder.AddRabbitMQ(""messaging"", username, password); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Hosting integration health checks The RabbitMQ hosting integration automatically adds a health check for the RabbitMQ server resource. The health check verifies that the RabbitMQ server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Rabbitmq NuGet package.', '<2-hop>\n\nClient integration To get started with the .NET Aspire RabbitMQ client integration, install the ðŸ“¦ Aspire.RabbitMQ.Client NuGet package in the client-consuming project, that is, the project for the application that uses the RabbitMQ client. The RabbitMQ client integration registers an IConnection instance that you can use to interact with RabbitMQ. .NET CLI dotnetcli dotnet add package Aspire.RabbitMQ.Client PackageReference xml <PackageReference Include=""Aspire.RabbitMQ.Client"" Version=""*"" /> Add RabbitMQ client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddRabbitMQClient(connectionName: ""messaging""); [!TIP] The connectionName parameter must match the name used when adding the RabbitMQ server resource in the app host project. For more information, see Add RabbitMQ server resource. You can then retrieve the IConnection instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(IConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed RabbitMQ client There might be situations where you want to register multiple IConnection instances with different connection names. To register keyed RabbitMQ clients, call the csharp builder.AddKeyedRabbitMQClient(name: ""chat""); builder.AddKeyedRabbitMQClient(name: ""queue""); Then you can retrieve the IConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] IConnection chatConnection, [FromKeyedServices(""queue"")] IConnection queueConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire RabbitMQ integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddRabbitMQClient(connectionName: ""messaging""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""messaging"": ""amqp://username:password@localhost:5672"" } } For more information on how to format this connection string, see the RabbitMQ URI specification docs. Use configuration providers The .NET Aspire RabbitMQ integration supports json { ""Aspire"": { ""RabbitMQ"": { ""Client"": { ""ConnectionString"": ""amqp://username:password@localhost:5672"", ""DisableHealthChecks"": true, ""DisableTracing"": true, ""MaxConnectRetryCount"": 2 } } } } For the complete RabbitMQ client integration JSON schema, see Aspire.RabbitMQ.Client/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<RabbitMQClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddRabbitMQClient( ""messaging"", static settings => settings.DisableHealthChecks = true); You can also set up the IConnectionFactory using the Action<IConnectionFactory> configureConnectionFactory delegate parameter of the AddRabbitMQClient method. For example to set the client provided name for connections: csharp builder.AddRabbitMQClient( ""messaging"", configureConnectionFactory: static factory => factory.ClientProvidedName = ""MyApp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire RabbitMQ integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. Observability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations might only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire RabbitMQ integration uses the following log categories: RabbitMQ.Client Tracing The .NET Aspire RabbitMQ integration emits the following tracing activities using OpenTelemetry: Aspire.RabbitMQ.Client Metrics The .NET Aspire RabbitMQ integration currently doesn\'t support metrics by default. See also Send messages with RabbitMQ in .NET Aspire RabbitMQ .NET Client docs .NET Aspire integrations .NET Aspire GitHub repo']","To install the NuGet packages for .NET Aspire RabbitMQ integration, you need to add the respective packages for hosting and client setups. For hosting integration, use the command `dotnet add package Aspire.Hosting.RabbitMQ` to install the `Aspire.Hosting.RabbitMQ` package. For client integration, use the command `dotnet add package Aspire.RabbitMQ.Client` to install the `Aspire.RabbitMQ.Client` package. To enable health checks, the hosting integration automatically adds a health check for the RabbitMQ server resource, verifying that the server is running and a connection can be established. For the client integration, health checks are enabled by default and integrate with the `/health` HTTP endpoint, ensuring all registered health checks pass for the app to be considered ready to accept traffic.",multi_hop_abstract_query_synthesizer
21,"How does the .NET Aspire Cosmos DB Entity Framework Core integration support health monitoring and observability, and what role do logging and metrics play in this process?","['<1-hop>\n\ntitle: .NET Aspire Cosmos DB Entity Framework Core integration description: Learn how to install and configure the .NET Aspire Cosmos DB Entity Framework Core integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-entity-framework-integration .NET Aspire Cosmos DB Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.Cosmos"" Version=""*"" /> Add Cosmos DB context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmosdb that same name should be used when calling AddCosmosDbContext. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(MyDbContext context) { // Use context... } For more information on using Entity Framework Core with Azure Cosmos DB, see the Examples for Azure Cosmos DB for NoSQL SDK for .NET. Configuration The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddCosmosDbContext: csharp builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information, see the ConnectionString documentation. Use configuration providers The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""Cosmos"": { ""DisableTracing"": true } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json. Use inline delegates You can also pass the Action<EntityFrameworkCoreCosmosSettings> configureSettings delegate to set up some or all the csharp builder.AddCosmosDbContext<MyDbContext>( ""cosmosdb"", settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn\'t implement health checks, though this may change in future releases. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nLogging The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration uses the following log categories: Azure-Cosmos-Operation-Request-Diagnostics Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Query Tracing The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration will emit the following tracing activities using OpenTelemetry: Azure.Cosmos.Operation OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently supports the following metrics: Microsoft.EntityFrameworkCore ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second See also Azure Cosmos DB docs .NET Aspire integrations .NET Aspire GitHub repo', '<3-hop>\n\ntitle: Seed data in a database using .NET Aspire description: Learn about how to seed database data in .NET Aspire ms.date: 08/12/2024 ms.topic: how-to Seed data in a database using .NET Aspire In this article, you learn how to configure .NET Aspire projects to seed data in a database during app startup. .NET Aspire enables you to seed data using database scripts or Entity Framework Core for common platforms such as SQL Server, PostgreSQL and MySQL. When to seed data Seeding data pre-populates database tables with rows of data so they\'re ready for testing via your app. You may want to seed data for the following scenarios: Manually develop and test different features of your app against a meaningful set of data, such as a product catalog or list of customers. Run test suites to verify that features behave a specific way with a given set of data. Manually seeding data is tedious and time consuming, so you should automate the process when possible. Use volumes to run database scripts for .NET Aspire projects during startup. You can also seed your database using tools like Entity Framework Core, which handles many underlying concerns for you. Understand containerized databases By default, .NET Aspire database integrations rely on containerized databases, which create the following challenges when trying to seed data: .NET Aspire destroys and recreates containers every time the app restarts, which means by default you have to re-seed your database every time the app restarts. Depending on your selected database technology, the new container instance may or may not create a default database, which means you might also have to create the database itself. Even if a default database exists, it most likely will not have the desired name or schema for your specific app. .NET Aspire enables you to resolve these challenges using volumes and a few configurations to seed data effectively. Seed data using volumes and SQL scripts Volumes are the recommended way to automatically seed containerized databases when using SQL scripts. Volumes can store data for multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume mount, which is the physical location on your host. Target: The target path in the container of the data you want to persist. Consider the following volume configuration code from a :::no-loc text=""Program.cs""::: file in a sample AppHost project: csharp var todosDbName = ""Todos""; var todosDb = builder.AddPostgres(""postgres"") .WithEnvironment(""POSTGRES_DB"", todosDbName) .WithBindMount( ""../DatabaseContainers.ApiService/data/postgres"", ""/docker-entrypoint-initdb.d"") .AddDatabase(todosDbName); In this example, the .WithBindMount method parameters configure the following: ../DatabaseContainers.ApiService/data/postgres sets a path to the SQL script in your local project that you want to run in the container to seed data. /docker-entrypoint-initdb.d sets the path to an entry point in the container so your script will be run during container startup. The referenced SQL script located at ../DatabaseContainers.ApiService/data/postgres creates and seeds a Todos table: ```sql -- Postgres init script -- Create the Todos table CREATE TABLE IF NOT EXISTS Todos ( Id SERIAL PRIMARY KEY, Title text UNIQUE NOT NULL, IsComplete boolean NOT NULL DEFAULT false ); -- Insert some sample data into the Todos table INSERT INTO Todos (Title, IsComplete) VALUES (\'Give the dog a bath\', false), (\'Wash the dishes\', false), (\'Do the groceries\', false) ON CONFLICT DO NOTHING; ``` The script runs during startup every time a new container instance is created. Database seeding examples The following examples demonstrate how to seed data using SQL scripts and configurations applied using the .WithBindMount method for different database technologies: [!NOTE] Visit the Database Container Sample App to view the full project and file structure for each database option. SQL Server The configuration code in the .AppHost :::no-loc text=""Program.cs""::: file mounts the required database files and folders and configures an entrypoint so that they run during startup. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""37-49"" ::: The entrypoint.sh script lives in the mounted ./sqlserverconfig project folder and runs when the container starts. The script launches SQL Server and checks that it\'s running. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/sqlserverconfig/entrypoint.sh"" ::: The init.sql SQL script that lives in the mounted ../DatabaseContainers.ApiService/data/sqlserver project folder creates the database and tables. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/sqlserver/init.sql"" ::: PostgreSQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""3-15"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/postgres/init.sql"" ::: MySQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""20-32"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/mysql/init.sql"" :::']","The .NET Aspire Cosmos DB Entity Framework Core integration supports health monitoring through automatic health checks for the Cosmos DB resource. These health checks verify that the Cosmos DB is running and that a connection can be established, relying on the AspNetCore.HealthChecks.CosmosDb NuGet package. For observability, the integration uses logging and metrics extensively. Logging is categorized into areas such as Azure-Cosmos-Operation-Request-Diagnostics, Microsoft.EntityFrameworkCore.ChangeTracking, Microsoft.EntityFrameworkCore.Database.Command, Microsoft.EntityFrameworkCore.Infrastructure, and Microsoft.EntityFrameworkCore.Query. Additionally, tracing activities are emitted using OpenTelemetry, including Azure.Cosmos.Operation and OpenTelemetry.Instrumentation.EntityFrameworkCore. Metrics supported by the integration include active database contexts, total queries, queries per second, total save changes, save changes per second, compiled query cache hit rate, and optimistic concurrency failure rates. These features collectively enhance the monitoring and observability of applications using the integration.",multi_hop_abstract_query_synthesizer
22,How does .NET Aspire Redis integration support observability features like logging and tracing?,"['<1-hop>\n\ntitle: .NET Aspire Redis integration description: Learn how to use the .NET Aspire Redis integration, which includes both hosting and client integrations. ms.date: 11/05/2024 zone_pivot_groups: resp-host .NET Aspire RedisÂ®* integration [!INCLUDE includes-hosting-and-client] :::zone pivot=""redis"" Redis is the world\'s fastest data platform for caching, vector search, and NoSQL databases. The .NET Aspire Redis integration enables you to connect to existing Redis instances, or create new instances from .NET with the docker.io/library/redis container image. :::zone-end :::zone pivot=""garnet"" Garnet is a a high-performance cache-store from Microsoft Research and complies with the Redis serialization protocol (RESP). The .NET Aspire Redis integration enables you to connect to existing Garnet instances, or create new instances from .NET with the ghcr.io/microsoft/garnet container image. :::zone-end :::zone pivot=""valkey"" Valkey is a Redis fork and complies with the Redis serialization protocol (RESP). It\'s a high-performance key/value datastore that supports a variety of workloads such as caching, message queues, and can act as a primary database. The .NET Aspire Redis integration enables you to connect to existing Valkey instances, or create new instances from .NET with the docker.io/valkey/valkey container image. :::zone-end Hosting integration :::zone pivot=""redis"" [!INCLUDE redis-app-host] :::zone-end :::zone pivot=""garnet"" [!INCLUDE garnet-app-host] :::zone-end :::zone pivot=""valkey"" [!INCLUDE valkey-app-host] :::zone-end Hosting integration health checks [!INCLUDE redis-hosting-health-checks] Client integration To get started with the .NET Aspire Stack Exchange Redis client integration, install the ðŸ“¦ Aspire.StackExchange.Redis NuGet package in the client-consuming project, that is, the project for the application that uses the Redis client. The Redis client integration registers an an IConnectionMultiplexer instance that you can use to interact with Redis. .NET CLI dotnetcli dotnet add package Aspire.StackExchange.Redis PackageReference xml <PackageReference Include=""Aspire.StackExchange.Redis"" Version=""*"" /> Add Redis client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddRedisClient(connectionName: ""cache""); :::zone pivot=""redis"" [!TIP] The connectionName parameter must match the name used when adding the Redis resource in the app host project. For more information, see Add Redis resource. :::zone-end :::zone pivot=""garnet"" [!TIP] The connectionName parameter must match the name used when adding the Garnet resource in the app host project. For more information, see Add Garnet resource. :::zone-end :::zone pivot=""valkey"" [!TIP] The connectionName parameter must match the name used when adding the Valkey resource in the app host project. For more information, see Add Valkey resource. :::zone-end You can then retrieve the IConnection instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(IConnectionMultiplexer connectionMux) { // Use connection multiplexer... } For more information on dependency injection, see .NET dependency injection. Add keyed Redis client There might be situations where you want to register multiple IConnectionMultiplexer instances with different connection names. To register keyed Redis clients, call the csharp builder.AddKeyedRedisClient(name: ""chat""); builder.AddKeyedRedisClient(name: ""queue""); Then you can retrieve the IConnectionMultiplexer instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] IConnectionMultiplexer chatConnectionMux, [FromKeyedServices(""queue"")] IConnectionMultiplexer queueConnectionMux) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Stack Exchange Redis client integration provides multiple options to configure the Redis connection based on the requirements and conventions of your project. Use a connection string :::zone pivot=""redis"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddRedis(""cache""); :::zone-end :::zone pivot=""garnet"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddGarnet(""cache""); :::zone-end :::zone pivot=""valkey"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddValkey(""cache""); :::zone-end Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } For more information on how to format this connection string, see the Stack Exchange Redis configuration docs. Use configuration providers [!INCLUDE redis-client-json-settings] Use inline delegates You can also pass the Action<StackExchangeRedisSettings> delegate to set up some or all the options inline, for example to configure DisableTracing: csharp builder.AddRedisClient( ""cache"", static settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Stack Exchange Redis integration handles the following: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.', '<2-hop>\n\nObservability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations might only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire Stack Exchange Redis integration uses the following log categories: Aspire.StackExchange.Redis Tracing The .NET Aspire Stack Exchange Redis integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.StackExchangeRedis Metrics The .NET Aspire Stack Exchange Redis integration currently doesn\'t support metrics by default due to limitations with the StackExchange.Redis library. :::zone pivot=""redis"" [!INCLUDE azure-redis-app-host] [!INCLUDE azure-redis-client] :::zone-end See also Stack Exchange Redis docs .NET Aspire integrations .NET Aspire GitHub repo [!INCLUDE redis-trademark]']","The .NET Aspire Redis integration supports observability features by automatically setting up Logging and Tracing configurations. It uses the log category 'Aspire.StackExchange.Redis' for logging and emits tracing activities using OpenTelemetry with the category 'OpenTelemetry.Instrumentation.StackExchangeRedis'. However, metrics are not supported by default due to limitations with the StackExchange.Redis library.",multi_hop_abstract_query_synthesizer
23,"How does the .NET Aspire NATS integration enable both server hosting and client interaction, and what are the key features related to observability and telemetry?","['<1-hop>\n\ntitle: .NET Aspire NATS integration description: Learn how to use the .NET Aspire NATS integration to send logs and traces to a NATS Server. ms.date: 10/11/2024 uid: messaging/nats-integration .NET Aspire NATS integration [!INCLUDE includes-hosting-and-client] NATS is a high-performance, secure, distributed messaging system. The .NET Aspire NATS integration enables you to connect to existing NATS instances, or create new instances from .NET with the docker.io/library/nats container image. Hosting integration NATS hosting integration for .NET Aspire models a NATS server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Nats PackageReference xml <PackageReference Include=""Aspire.Hosting.Nats"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add NATS server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/nats image, it creates a new NATS server instance on your local machine. A reference to your NATS server (the nats variable) is added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing NATS server, call Add NATS server resource with JetStream To add the NATS JetStream to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithJetStream(); builder.AddProject // After adding all resources, run the app... ``` The NATS JetStream functionality provides a built-in persistence engine called JetStream which enables messages to be stored and replayed at a later time. You can optionally provide a srcMountPath parameter to specify the path to the JetStream data directory on the host machine (the provided mount path maps to the container\'s -sd argument). Add NATS server resource with data volume To add a data volume to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the NATS server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/nats path in the NATS server container. A name is generated at random unless you provide a set the name parameter. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add NATS server resource with data bind mount To add a data bind mount to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataBindMount( source: @""C:\\NATS\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the NATS server data across container restarts. The data bind mount is mounted at the C:\\NATS\\Data on Windows (or /NATS/Data on Unix) path on the host machine in the NATS server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The NATS hosting integration automatically adds a health check for the NATS server resource. The health check verifies that the NATS server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Nats NuGet package.', '<2-hop>\n\nClient integration To get started with the .NET Aspire NATS client integration, install the ðŸ“¦ Aspire.NATS.Net NuGet package in the client-consuming project, that is, the project for the application that uses the NATS client. The NATS client integration registers an INatsConnection instance that you can use to interact with NATS. .NET CLI dotnetcli dotnet add package Aspire.NATS.Net PackageReference xml <PackageReference Include=""Aspire.NATS.Net"" Version=""*"" /> Add NATS client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNatsClient(connectionName: ""nats""); [!TIP] The connectionName parameter must match the name used when adding the NATS server resource in the app host project. For more information, see Add NATS server resource. You can then retrieve the INatsConnection instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(INatsConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed NATS client There might be situations where you want to register multiple INatsConnection instances with different connection names. To register keyed NATS clients, call the csharp builder.AddKeyedNatsClient(name: ""chat""); builder.AddKeyedNatsClient(name: ""queue""); Then you can retrieve the IConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] INatsConnection chatConnection, [FromKeyedServices(""queue"")] INatsConnection queueConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire NATS integration provides multiple options to configure the NATS connection based on the requirements and conventions of your project. Use a connection string Provide the name of the connection string when you call builder.AddNatsClient: csharp builder.AddNatsClient(connectionName: ""nats""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""nats"": ""nats://nats:4222"" } } See the ConnectionString documentation for more information on how to format this connection string. Use configuration providers The .NET Aspire NATS integration supports json { ""Aspire"": { ""Nats"": { ""Client"": { ""ConnectionString"": ""nats://nats:4222"", ""DisableHealthChecks"": true, ""DisableTracing"": true } } } } For the complete NATS client integration JSON schema, see Aspire.NATS.Net/ConfigurationSchema.json. Use inline delegates Pass the Action<NatsClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddNatsClient( ""nats"", static settings => settings.DisableHealthChecks = true); NATS in the .NET Aspire manifest NATS isn\'t part of the .NET Aspire deployment manifest. It\'s recommended you set up a secure production NATS server outside of .NET Aspire. Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire NATS integration handles the following: Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. Observability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire NATS integration uses the following log categories: NATS Tracing The .NET Aspire NATS integration emits the following tracing activities: NATS.Net See also NATS.Net quickstart .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire NATS integration enables server hosting by allowing developers to create new NATS server instances using the docker.io/library/nats container image or connect to existing NATS servers. Hosting integration includes features like adding a NATS server resource, enabling JetStream for message persistence, and configuring data volumes or bind mounts for data persistence. Health checks are automatically added to verify the server's status and connectivity, relying on the AspNetCore.HealthChecks.Nats NuGet package.

For client interaction, the .NET Aspire NATS client integration provides an INatsConnection instance for interacting with NATS. Developers can register clients using the Aspire.NATS.Net NuGet package and configure them via connection strings, configuration providers, or inline delegates. Keyed NATS clients can also be registered for multiple connections.

Regarding observability and telemetry, the integration automatically sets up logging, tracing, and metrics configurations. These features, known as the pillars of observability, include logging categories and tracing activities specific to NATS. Telemetry features can be customized or disabled using configuration options. The integration also supports health checks for all services, ensuring readiness for traffic through the /health HTTP endpoint.",multi_hop_abstract_query_synthesizer
24,"How does the .NET Aspire SQL Server integration support health monitoring and observability, and how can it be combined with Azure integrations for resource management?","['<1-hop>\n\ntitle: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: Azure integrations overview description: Overview of the Azure integrations available in the .NET Aspire. ms.date: 12/17/2024 uid: dotnet/aspire/integrations/azure-overview .NET Aspire Azure integrations overview Azure is the most popular cloud platform for building and deploying .NET applications. The Azure SDK for .NET allows for easy management and use of Azure services. .NET Aspire provides a set of integrations with Azure services, where you\'re free to add new resources or connect to existing ones. This article details some common aspects of all Azure integrations in .NET Aspire and aims to help you understand how to use them. Add connection to existing Azure resources .NET Aspire provides the ability to connect to existing resources, including Azure resources. Expressing connection strings is useful when you have existing Azure resources that you want to use in your .NET Aspire app. The [!INCLUDE connection-strings-alert] Consider the following example, where in publish mode you add an Azure Storage resource while in run mode you add a connection string to an existing Azure Storage: ```csharp var builder = DistributedApplication.CreateBuilder(args); var storage = builder.ExecutionContext.IsPublishMode ? builder.AddAzureStorage(""storage"") : builder.AddConnectionString(""storage""); builder.AddProject // After adding all resources, run the app... ``` The preceding code: Creates a new builder instance. Adds a Azure Storage resource named storage in ""publish"" mode. Adds a connection string to an existing Azure Storage named storage in ""run"" mode. Adds a project named api to the builder. The api project references the storage resource regardless of the mode. The consuming API project uses the connection string information with no knowledge of how the app host configured it. In ""publish"" mode, the code adds a new Azure Storage resourceâ€”which would be reflected in the deployment manifest accordingly. When in ""run"" mode, the connection string corresponds to a configuration value visible to the app host. It\'s assumed that any and all role assignments for the target resource have been configured. This means, you\'d likely configure an environment variable or a user secret to store the connection string. The configuration is resolved from the ConnectionStrings__storage (or ConnectionStrings:storage) configuration key. These configuration values can be viewed when the app runs. For more information, see Resource details. Add Azure resources All .NET Aspire Azure hosting integrations expose Azure resources and by convention are added using AddAzure* APIs. When you add these resources to your .NET Aspire app host, they represent an Azure service. The AddAzure* API returns an <xref:Aspire.Hosting.ApplicationModel.IResourceBuilder1> whereTis the type of Azure resource. TheseIResourceBuilder Typical developer experience When your .NET Aspire app host contains Azure resources, and you run it locally (typical developer F5 or dotnet run experience), the Azure resources are provisioned in your Azure subscription. This allows you as the developer to debug against them locally in the context of your app host. .NET Aspire aims to minimize costs by defaulting to Basic or Standard Stock Keeping Unit (SKU) for its Azure integrations. While these sensible defaults are provided, you can customize the Azure resources to suit your needs. Additionally, some integrations support emulators or containers, which are useful for local development, testing, and debugging. By default, when you run your app locally, the Azure resources use the actual Azure service. However, you can configure them to use local emulators or containers, avoiding costs associated with the actual Azure service during local development.']","The .NET Aspire SQL Server integration supports health monitoring and observability by automatically adding health checks for the SQL Server resource. These health checks verify that the SQL Server is running and that a connection can be established. The integration relies on the AspNetCore.HealthChecks.SqlServer NuGet package and integrates with the /health HTTP endpoint, ensuring all registered health checks must pass for the app to be considered ready to accept traffic. Additionally, the .NET Aspire SQL Server integration provides options for configuring connections, such as using connection strings, configuration providers, or inline delegates to customize settings like disabling health checks. 

When combined with Azure integrations, .NET Aspire allows developers to connect to existing Azure resources or add new ones. For example, developers can use connection strings to link their app to Azure Storage resources or provision Azure resources locally during development. This combination enables seamless resource management and debugging while minimizing costs by defaulting to Basic or Standard SKUs for Azure services. Together, these integrations enhance the application's performance, health monitoring, and observability while leveraging Azure's cloud capabilities.",multi_hop_abstract_query_synthesizer
25,"How does the .NET Aspire SQL Server integration support health monitoring and observability, and what are the limitations regarding logging?","['<1-hop>\n\ntitle: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', ""<2-hop>\n\nLogging The .NET Aspire SQL Server integration currently doesn't enable logging by default due to limitations of the Tracing The .NET Aspire SQL Server integration emits the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.SqlClient Metrics The .NET Aspire SQL Server integration will emit the following metrics using OpenTelemetry: Microsoft.Data.SqlClient.EventSource active-hard-connections hard-connects hard-disconnects active-soft-connects soft-connects soft-disconnects number-of-non-pooled-connections number-of-pooled-connections number-of-active-connection-pool-groups number-of-inactive-connection-pool-groups number-of-active-connection-pools number-of-inactive-connection-pools number-of-active-connections number-of-free-connections number-of-stasis-connections number-of-reclaimed-connections See also Azure SQL Database SQL Server .NET Aspire database containers sample .NET Aspire integrations .NET Aspire GitHub repo""]","The .NET Aspire SQL Server integration supports health monitoring by automatically adding a health check for the SQL Server resource. This health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the AspNetCore.HealthChecks.SqlServer NuGet package and integrates with the /health HTTP endpoint, which specifies that all registered health checks must pass for the app to be considered ready to accept traffic. Observability is enhanced through tracing and metrics emitted using OpenTelemetry. Tracing activities include OpenTelemetry.Instrumentation.SqlClient, while metrics such as active-hard-connections, hard-connects, and number-of-pooled-connections are emitted using Microsoft.Data.SqlClient.EventSource. However, the integration does not enable logging by default due to certain limitations. For more information, developers can refer to the .NET Aspire integrations overview and related documentation.",multi_hop_abstract_query_synthesizer
26,"How does the .NET Aspire NATS integration utilize dependency injection to manage INatsConnection instances, and what are the benefits of using keyed services for multiple NATS client connections?","['<1-hop>\n\ntitle: .NET Aspire NATS integration description: Learn how to use the .NET Aspire NATS integration to send logs and traces to a NATS Server. ms.date: 10/11/2024 uid: messaging/nats-integration .NET Aspire NATS integration [!INCLUDE includes-hosting-and-client] NATS is a high-performance, secure, distributed messaging system. The .NET Aspire NATS integration enables you to connect to existing NATS instances, or create new instances from .NET with the docker.io/library/nats container image. Hosting integration NATS hosting integration for .NET Aspire models a NATS server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Nats PackageReference xml <PackageReference Include=""Aspire.Hosting.Nats"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add NATS server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/nats image, it creates a new NATS server instance on your local machine. A reference to your NATS server (the nats variable) is added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing NATS server, call Add NATS server resource with JetStream To add the NATS JetStream to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithJetStream(); builder.AddProject // After adding all resources, run the app... ``` The NATS JetStream functionality provides a built-in persistence engine called JetStream which enables messages to be stored and replayed at a later time. You can optionally provide a srcMountPath parameter to specify the path to the JetStream data directory on the host machine (the provided mount path maps to the container\'s -sd argument). Add NATS server resource with data volume To add a data volume to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the NATS server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/nats path in the NATS server container. A name is generated at random unless you provide a set the name parameter. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add NATS server resource with data bind mount To add a data bind mount to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataBindMount( source: @""C:\\NATS\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the NATS server data across container restarts. The data bind mount is mounted at the C:\\NATS\\Data on Windows (or /NATS/Data on Unix) path on the host machine in the NATS server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The NATS hosting integration automatically adds a health check for the NATS server resource. The health check verifies that the NATS server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Nats NuGet package.', '<2-hop>\n\nClient integration To get started with the .NET Aspire NATS client integration, install the ðŸ“¦ Aspire.NATS.Net NuGet package in the client-consuming project, that is, the project for the application that uses the NATS client. The NATS client integration registers an INatsConnection instance that you can use to interact with NATS. .NET CLI dotnetcli dotnet add package Aspire.NATS.Net PackageReference xml <PackageReference Include=""Aspire.NATS.Net"" Version=""*"" /> Add NATS client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNatsClient(connectionName: ""nats""); [!TIP] The connectionName parameter must match the name used when adding the NATS server resource in the app host project. For more information, see Add NATS server resource. You can then retrieve the INatsConnection instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(INatsConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed NATS client There might be situations where you want to register multiple INatsConnection instances with different connection names. To register keyed NATS clients, call the csharp builder.AddKeyedNatsClient(name: ""chat""); builder.AddKeyedNatsClient(name: ""queue""); Then you can retrieve the IConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] INatsConnection chatConnection, [FromKeyedServices(""queue"")] INatsConnection queueConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire NATS integration provides multiple options to configure the NATS connection based on the requirements and conventions of your project. Use a connection string Provide the name of the connection string when you call builder.AddNatsClient: csharp builder.AddNatsClient(connectionName: ""nats""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""nats"": ""nats://nats:4222"" } } See the ConnectionString documentation for more information on how to format this connection string. Use configuration providers The .NET Aspire NATS integration supports json { ""Aspire"": { ""Nats"": { ""Client"": { ""ConnectionString"": ""nats://nats:4222"", ""DisableHealthChecks"": true, ""DisableTracing"": true } } } } For the complete NATS client integration JSON schema, see Aspire.NATS.Net/ConfigurationSchema.json. Use inline delegates Pass the Action<NatsClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddNatsClient( ""nats"", static settings => settings.DisableHealthChecks = true); NATS in the .NET Aspire manifest NATS isn\'t part of the .NET Aspire deployment manifest. It\'s recommended you set up a secure production NATS server outside of .NET Aspire. Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire NATS integration handles the following: Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. Observability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire NATS integration uses the following log categories: NATS Tracing The .NET Aspire NATS integration emits the following tracing activities: NATS.Net See also NATS.Net quickstart .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire NATS integration uses dependency injection to manage INatsConnection instances by registering them in the client-consuming project. This is achieved by calling `builder.AddNatsClient(connectionName: ""nats"");` in the `Program.cs` file, where the `connectionName` parameter must match the name used when adding the NATS server resource in the app host project. The registered INatsConnection instance can then be retrieved from a service using dependency injection, as shown in the example: `public class ExampleService(INatsConnection connection) { // Use connection... }`. For scenarios requiring multiple NATS client connections, keyed services can be used. Keyed NATS clients are registered with unique names using `builder.AddKeyedNatsClient(name: ""chat"");` and `builder.AddKeyedNatsClient(name: ""queue"");`. These keyed connections can then be retrieved in a service using the `[FromKeyedServices]` attribute, for example: `public class ExampleService([FromKeyedServices(""chat"")] INatsConnection chatConnection, [FromKeyedServices(""queue"")] INatsConnection queueConnection) { // Use connections... }`. The benefits of using keyed services include the ability to manage multiple connections with different configurations or purposes within the same application, improving modularity and flexibility in handling NATS client interactions.",multi_hop_abstract_query_synthesizer
27,"How does the .NET Aspire Azure Event Hubs library support integration with Azure Event Hubs, and what are the configuration options for establishing a connection?","['<1-hop>\n\ntitle: .NET Aspire Azure Event Hubs integration description: This article describes the .NET Aspire Azure Event Hubs integration features and capabilities. ms.topic: how-to ms.date: 08/26/2024 .NET Aspire Azure Event Hubs integration In this article, you learn how to use the .NET Aspire Azure Event Hubs integration. The Aspire.Azure.Messaging.EventHubs library offers options for registering the following types: These type are registered in the DI container for connecting to Azure Event Hubs. Prerequisites Azure subscription: create one for free. Azure Event Hubs namespace: for more information, see add an Event Hubs namespace. Alternatively, you can use a connection string, which isn\'t recommended in production environments. Get started To get started with the .NET Aspire Azure Event Hubs integration, install the ðŸ“¦ Aspire.Azure.Messaging.EventHubs NuGet package in the client-consuming project, i.e., the project for the application that uses the Azure Event Hubs client. .NET CLI dotnetcli dotnet add package Aspire.Azure.Messaging.EventHubs PackageReference xml <PackageReference Include=""Aspire.Azure.Messaging.EventHubs"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Supported clients with options classes The following clients are supported by the library, along with their corresponding options and settings classes: Azure Client type Azure Options class .NET Aspire Settings class EventHubProducerClient EventHubProducerClientOptions AzureMessagingEventHubsProducerSettings EventHubBufferedProducerClient EventHubBufferedProducerClientOptions AzureMessagingEventHubsBufferedProducerSettings EventHubConsumerClient EventHubConsumerClientOptions AzureMessagingEventHubsConsumerSettings EventProcessorClient EventProcessorClientOptions AzureMessagingEventHubsProcessorSettings PartitionReceiver PartitionReceiverOptions AzureMessagingEventHubsPartitionReceiverSettings The client type are from the Azure SDK for .NET, as are the corresponding options classes. The settings classes are provided by the .NET Aspire Azure Event Hubs integration library. Example usage The following example assumes that you have an Azure Event Hubs namespace and an Event Hub created and wish to configure an EventHubProducerClient to send events to the Event Hub. The EventHubBufferedProducerClient, EventHubConsumerClient, EventProcessorClient, and PartitionReceiverare configured in a similar manner. In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the AddAzureEventHubProducerClient extension to register a EventHubProducerClient for use via the dependency injection container. csharp builder.AddAzureEventHubProducerClient(""eventHubsConnectionName""); You can then retrieve the EventHubProducerClient instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(EventHubProducerClient client) { // Use client... } For more information, see the Azure.Messaging.EventHubs documentation for examples on using the EventHubProducerClient. App host usage To add Azure Event Hub hosting support to your .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure.EventHubs PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure.EventHubs"" Version=""*"" /> In your app host project, add an Event Hubs connection and an Event Hub resource and consume the connection using the following methods: ```csharp var builder = DistributedApplication.CreateBuilder(args); var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .AddEventHub(""MyHub""); var exampleService = builder.AddProject The AddAzureEventHubs method will read connection information from the AppHost\'s configuration (for example, from ""user secrets"") under the ConnectionStrings:eventHubsConnectionName config key. The WithReference method passes that connection information into a connection string named eventHubsConnectionName in the ExampleService project. As of .NET Aspire 8.1, the Azure EventHubs extension for .NET Aspire supports launching a local emulator for EventHubs. You can use the emulator by applying the RunAsEmulator() extension method as follows: csharp var eventHubs = builder.AddAzureEventHubs(""eventHubsConnectionName"") .RunAsEmulator() .AddEventHub(""MyHub""); The emulator for Azure EventHubs results in two container resources being launched inside .NET Aspire derived from the name of the Event Hubs resource name. [!IMPORTANT] Even though we are creating an Event Hub using the AddEventHub at the same time as the namespace, as of .NET Aspire version preview-5, the connection string will not include the EntityPath property, so the EventHubName property must be set in the settings callback for the preferred client. Future versions of Aspire will include the EntityPath property in the connection string and will not require the EventHubName property to be set in this scenario. In the :::no-loc text=""Program.cs""::: file of ExampleService, the connection can be consumed using by calling of the supported Event Hubs client extension methods: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; });', '<2-hop>\n\nConfiguration The .NET Aspire Azure Event Hubs library provides multiple options to configure the Azure Event Hubs connection based on the requirements and conventions of your project. Either a FullyQualifiedNamespace or a ConnectionString is a required to be supplied. Use a connection string When using a connection string from the ConnectionStrings configuration section, provide the name of the connection string when calling builder.AddAzureEventHubProducerClient() and other supported Event Hubs clients. In this example, the connection string does not include the EntityPath property, so the EventHubName property must be set in the settings callback: csharp builder.AddAzureEventHubProducerClient( ""eventHubsConnectionName"", static settings => { settings.EventHubName = ""MyHub""; }); And then the connection information will be retrieved from the ConnectionStrings configuration section. Two connection formats are supported: Fully Qualified Namespace (FQN) The recommended approach is to use a fully qualified namespace, which works with the AzureMessagingEventHubsSettings.Credential property to establish a connection. If no credential is configured, the json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""{your_namespace}.servicebus.windows.net"" } } Connection string Alternatively, use a connection string: json { ""ConnectionStrings"": { ""eventHubsConnectionName"": ""Endpoint=sb://mynamespace.servicebus.windows.net/;SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey;EntityPath=MyHub"" } } Use configuration providers The .NET Aspire Azure Event Hubs library supports json { ""Aspire"": { ""Azure"": { ""Messaging"": { ""EventHubs"": { ""EventProcessorClient"": { ""EventHubName"": ""MyHub"", ""ClientOptions"": { ""Identifier"": ""PROCESSOR_ID"" } } } } } } } You can also setup the Options type using the optional Action<IAzureClientBuilder<EventProcessorClient, EventProcessorClientOptions>> configureClientBuilder parameter of the AddAzureEventProcessorClient method. For example, to set the processor\'s client ID for this client: csharp builder.AddAzureEventProcessorClient( ""eventHubsConnectionName"", configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions( options => options.Identifier = ""PROCESSOR_ID"")); [!INCLUDE integration-observability-and-telemetry] Logging The .NET Aspire Azure Event Hubs integration uses the following log categories: Azure.Core Azure.Identity Tracing The .NET Aspire Azure Event Hubs integration will emit the following tracing activities using OpenTelemetry: ""Azure.Messaging.EventHubs.*"" Metrics The .NET Aspire Azure Event Hubs integration currently doesn\'t support metrics by default due to limitations with the Azure SDK for .NET. If that changes in the future, this section will be updated to reflect those changes. See also Azure Event Hubs .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire Azure Event Hubs library supports integration with Azure Event Hubs by providing a set of tools and features for registering various client types in the dependency injection (DI) container. These clients include EventHubProducerClient, EventHubBufferedProducerClient, EventHubConsumerClient, EventProcessorClient, and PartitionReceiver, each with corresponding options and settings classes. To get started, developers need to install the Aspire.Azure.Messaging.EventHubs NuGet package in their client-consuming project. The library supports configuration through either a Fully Qualified Namespace (FQN) or a connection string. The recommended approach is to use an FQN, which works with the AzureMessagingEventHubsSettings.Credential property to establish a connection. Alternatively, a connection string can be used, but it must include the EntityPath property or have the EventHubName property set in the settings callback. Configuration providers such as JSON files can also be used to set up options like EventHubName and client-specific settings. Additionally, the library supports logging and tracing activities using OpenTelemetry, although metrics are not currently supported. Developers can also launch a local emulator for Event Hubs using the RunAsEmulator() extension method.",multi_hop_abstract_query_synthesizer
28,what new stuff in .NET Aspire 9.0 like dashboard UX enhancements and how it help devs with telemetry and health checks?,"['<1-hop>\n\ntitle: What\'s new in .NET Aspire 9.0 description: Learn what\'s new in the official general availability version of .NET Aspire 9.0. ms.date: 11/13/2024 What\'s new in .NET Aspire 9.0 ðŸ“¢ .NET Aspire 9.0 is the next major general availability (GA) release of .NET Aspire; it supports both: .NET 8.0 Long Term Support (LTS) or .NET 9.0 Standard Term Support (STS). [!NOTE] You\'re able to use .NET Aspire 9.0 with either .NET 8 or .NET 9! This release addresses some of the most highly requested features and pain points from the community. The best features are community-driven! To join the community on, visit us on :::image type=""icon"" source=""../media/discord-icon.svg"" border=""false""::: Discord to chat with team members and collaborate with us on :::image type=""icon"" source=""../media/github-mark.svg"" border=""false""::: GitHub. For more information on the official .NET version and .NET Aspire version support, see: .NET support policy: Definitions for LTS and STS. .NET Aspire support policy: Important unique product life cycle details. Upgrade to .NET Aspire 9 To upgrade from earlier versions of .NET Aspire to .NET Aspire 9, follow the instructions in the official Upgrade to .NET Aspire 9 guide. The guide provides detailed instructions on how to upgrade your existing .NET Aspire solutions to .NET Aspire 9. Regardless of you\'re doing it manually, or using the Upgrade Assistant, the guide makes short work of the process. Tooling improvements .NET Aspire 9 makes it simpler to configure your environment to develop .NET Aspire applications. You no longer need a .NET workload. Instead, you install the new .NET Aspire SDK into the app host project of your .NET Aspire solutions. For more information, see .NET Aspire setup and tooling. Templates have moved .NET Aspire 9 is moving the contents that used to be installed via the workload into separate NuGet packages. This includes the templates for creating new .NET Aspire projects and solutions. These templates are installed using the dotnet new install command. These can be installed by running the following command: dotnetcli dotnet new install Aspire.ProjectTemplates::9.0.0 [!TIP] If you already have the .NET Aspire workload installed, you need to pass the --force flag to overwrite the existing templates. Feel free to uninstall the .NET Aspire workload. For more information, see .NET Aspire templates.', '<2-hop>\n\nDashboard UX enhancements and new interactivity features The .NET Aspire dashboard continues to improve with each release. Manage resource lifecycle The most requested feature for the dashboard is to manage the life-cycles of your orchestrated named resources. Specifically, the ability to stop, start, and restart resources. This feature works for projects, containers, and executables. It enables restarting individual resources without having to restart the entire app host. For project resources, when the debugger is attached, it\'s reattached on restart. For more information, see .NET Aspire dashboard: Stop or Start a resource. Mobile and responsive support The .NET Aspire dashboard is now mobile-friendly, responsively adapting to a wide range of screen sizes and enabling on-the-go management of deployed .NET Aspire applications. Other accessibility improvements were made, including the display of settings and content overflow on mobile. Sensitive properties, volumes, and health checks in resource details The display of resource details contains several improvements: Properties can be marked as sensitive, automatically masking them in the dashboard UI. This security feature helps to avoid accidentally disclosing keys or passwords when screen sharing the dashboard with other people. For example, container arguments could pass sensitive information and so are masked by default. Configured container volumes are listed in resource details. .NET Aspire 9 adds support for health checks. Detailed information about these checks can now be viewed in the resource details pane, showing why a resource might be marked as unhealthy or degraded. Find out more about health checks here. Colorful console log ANSI escape codes format text in terminals by controlling colors (foreground and background) and styles like bold, underline, and italics. Previously, the dashboard\'s console logs page could only render one ANSI escape code at a time, failing when multiple codes were combined. For example, it could display red text, but not text that was both red and bold. A community contribution from @mangeg improved support for ANSI escape codes and removed this limitation. :::image type=""content"" source=""media/console-logs-ansi-text-format.png"" lightbox=""media/console-logs-ansi-text-format.png"" alt-text=""Colorful console logs""::: Another improvement to console logs is hiding unsupported escape codes. Codes that aren\'t related to displaying text, such as positioning the cursor or communicating with the operating system don\'t make sense in this UI, and are hidden. Telemetry user-centric additions Telemetry remains a vital aspect of .NET Aspire. In .NET Aspire 9, many new features were introduced to the Telemetry service. Improved telemetry filtering Traces can be filtered with attribute values. For example, if you only want to view traces for one endpoint in your app, the http.route attribute on HTTP requests can be filtered to a specified value. Telemetry filtering also supports autocomplete of existing values. The Add filter dialog provides a combo box for selecting from values that dashboard has available. This feature makes it much easier to filter to real data and helps avoid typos by entered a value yourself. For more information, see .NET Aspire dashboard: Filter traces. Combine telemetry from multiple resources When a resource has multiple replicas, you can now filter telemetry to view data from all instances at once. Select the parent resource, labeled (application). For more information, see .NET Aspire dashboard: Combine telemetry from multiple resources. Browser telemetry support The dashboard supports OpenTelemetry Protocol (OTLP) over HTTP and cross-origin resource sharing (CORS). These features unlock the ability to send OpenTelemetry from browser apps to the .NET Aspire dashboard. For example, a browser-based single page app (SPA) can configure the JavaScript OpenTelemetry SDK to send structured logs, traces, and metrics created in the browser to the dashboard. Browser telemetry is displayed alongside server telemetry. :::image type=""content"" source=""media/dashboard-browser-telemetry.png"" lightbox=""media/dashboard-browser-telemetry.png"" alt-text=""Trace detail page with browser telemetry""::: For more information on configuring browser telemetry, see Enable browser telemetry documentation.']",".NET Aspire 9.0 introduces several new features, including dashboard UX enhancements and improvements to telemetry and health checks. The dashboard now allows developers to manage the lifecycle of orchestrated resources, such as stopping, starting, and restarting individual resources without restarting the entire app host. It also includes mobile-friendly and responsive design, making it easier to manage applications on the go. Sensitive properties are masked in the UI to enhance security, and container volumes are now displayed in resource details. Health checks have been added, providing detailed information about why a resource might be unhealthy or degraded. Telemetry features have also been improved, allowing developers to filter traces by attribute values, combine telemetry from multiple resource replicas, and even send OpenTelemetry data from browser-based apps to the dashboard. These features collectively enhance the developer experience by improving resource management, security, and debugging capabilities.",multi_hop_abstract_query_synthesizer
29,How can .NET Aspire integrations be used to implement both output caching and distributed caching in an ASP.NET Core application?,"['<1-hop>\n\ntitle: Implement caching with .NET Aspire integrations description: Learn how to connect to Redis and cache data using .NET Aspire integrations. ms.date: 11/08/2024 ms.topic: tutorial Tutorial: Implement caching with .NET Aspire integrations Cloud-native apps often require various types of scalable caching solutions to improve performance. .NET Aspire integrations simplify the process of connecting to popular caching services such as Redis. In this article, you\'ll learn how to: [!div class=""checklist""] Create a basic ASP.NET core app that is set up to use .NET Aspire. Add .NET Aspire integrations to connect to Redis and implement caching. Configure the .NET Aspire integrations to meet specific requirements. This article explores how to use two different types of ASP.NET Core caching using .NET Aspire and Redis: Output caching: A configurable, extensible caching method for storing entire HTTP responses for future requests. Distributed caching: A cache shared by multiple app servers that allows you to cache specific pieces of data. A distributed cache is typically maintained as an external service to the app servers that access it and can improve the performance and scalability of an ASP.NET Core app. [!INCLUDE aspire-prereqs] Create the project At the top of Visual Studio, navigate to File > New > Project.... In the dialog window, enter .NET Aspire into the project template search box and select .NET Aspire Starter Application. Choose Next. On the Configure your new project screen: Enter a Project name of AspireRedis. Leave the rest of the values at their defaults and select Next. On the Additional information screen: Make sure .NET 9.0 is selected. Uncheck Use Redis for caching. You will implement your own caching setup. Select Create. Visual Studio creates a new .NET Aspire solution that consists of the following projects: AspireRedis.Web - A Blazor UI project with default .NET Aspire configurations. AspireRedis.ApiService - A Minimal API with default .NET Aspire configurations that provides the frontend with data. AspireRedis.AppHost - An orchestrator project designed to connect and configure the different projects and services of your app. AspireRedis.ServiceDefaults - A .NET Aspire shared project to manage configurations that are reused across the projects in your solution related to resilience, service discovery, and telemetry. Configure the App Host project Add the ðŸ“¦ Aspire.Hosting.Redis NuGet package to the AspireRedis.AppHost project: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Redis PackageReference xml <PackageReference Include=""Aspire.Hosting.Redis"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Update the :::no-loc text=""Program.cs""::: file of the AspireRedis.AppHost project to match the following code: ```csharp var builder = DistributedApplication.CreateBuilder(args); var redis = builder.AddRedis(""cache""); var apiservice = builder.AddProject builder.AddProject builder.Build().Run(); ``` The preceding code creates a local Redis container instance and configures the UI and API to use the instance automatically for both output and distributed caching. The code also configures communication between the frontend UI and the backend API using service discovery. With .NET Aspire\'s implicit service discovery, setting up and managing service connections is streamlined for developer productivity. In the context of this tutorial, the feature simplifies how you connect to Redis. Traditionally, you\'d manually specify the Redis connection string in each project\'s :::no-loc text=""appsettings.json""::: file: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } Configuring connection string with this method, while functional, requires duplicating the connection string across multiple projects, which can be cumbersome and error-prone.', '<2-hop>\n\nConfigure the UI with output caching Add the .NET Aspire Stack Exchange Redis output caching integration packages to your AspireRedis.Web app: dotnetcli dotnet add package Aspire.StackExchange.Redis.OutputCaching In the :::no-loc text=""Program.cs""::: file of the AspireRedis.Web Blazor project, immediately after the line var builder = WebApplication.CreateBuilder(args);, add a call to the csharp builder.AddRedisOutputCache(""cache""); This method accomplishes the following tasks: Configures ASP.NET Core output caching to use a Redis instance with the specified connection name. Automatically enables corresponding health checks, logging, and telemetry. Replace the contents of the Home.razor file of the AspireRedis.Web Blazor project with the following: ```razor @page ""/"" @attribute [OutputCache(Duration = 10)] Hello, world! Welcome to your new app on @DateTime.Now ``` The integration include the [OutputCache] attribute, which caches the entire rendered response. The page also include a call to @DateTime.Now to help verify that the response is cached. Configure the API with distributed caching Add the .NET Aspire Stack Exchange Redis distributed caching integration packages to your AspireRedis.ApiService app: dotnetcli dotnet add package Aspire.StackExchange.Redis.DistributedCaching Towards the top of the :::no-loc text=""Program.cs""::: file, add a call to csharp builder.AddRedisDistributedCache(""cache""); In the :::no-loc text=""Program.cs""::: file, add the following using statements: csharp using System.Text; using System.Text.Json; using Microsoft.Extensions.Caching.Distributed; In the :::no-loc text=""Program.cs""::: file, replace the existing /weatherforecast endpoint code with the following: ```csharp app.MapGet(""/weatherforecast"", async (IDistributedCache cache) => { var cachedForecast = await cache.GetAsync(""forecast""); if (cachedForecast is null) { var summaries = new[] { ""Freezing"", ""Bracing"", ""Chilly"", ""Cool"", ""Mild"", ""Warm"", ""Balmy"", ""Hot"", ""Sweltering"", ""Scorching"" }; var forecast = Enumerable.Range(1, 5).Select(index => new WeatherForecast ( DateOnly.FromDateTime(DateTime.Now.AddDays(index)), Random.Shared.Next(-20, 55), summaries[Random.Shared.Next(summaries.Length)] )) .ToArray(); await cache.SetAsync(""forecast"", Encoding.UTF8.GetBytes(JsonSerializer.Serialize(forecast)), new () { AbsoluteExpiration = DateTime.Now.AddSeconds(10) }); ; return forecast; } return JsonSerializer.Deserialize<IEnumerable<WeatherForecast>>(cachedForecast); }) .WithName(""GetWeatherForecast""); ``` Test the app locally Test the caching behavior of your app using the following steps: Run the app using Visual Studio by pressing F5. If the Start Docker Desktop dialog appears, select Yes to start the service. The .NET Aspire Dashboard loads in the browser and lists the UI and API projects. Test the output cache: On the projects page, in the webfrontend row, click the localhost link in the Endpoints column to open the UI of your app. The application will display the current time on the home page. Refresh the browser every few seconds to see the same page returned by output caching. After 10 seconds the cache expires and the page reloads with an updated time. Test the distributed cache: Navigate to the Weather page on the Blazor UI to load a table of randomized weather data. Refresh the browser every few seconds to see the same weather data returned by output caching. After 10 seconds the cache expires and the page reloads with updated weather data. Congratulations! You configured a ASP.NET Core app to use output and distributed caching with .NET Aspire.']","To implement both output caching and distributed caching in an ASP.NET Core application using .NET Aspire integrations, follow these steps: 

1. **Output Caching**: Add the `Aspire.StackExchange.Redis.OutputCaching` package to the `AspireRedis.Web` Blazor project. In the `Program.cs` file, call `builder.AddRedisOutputCache(""cache"");` to configure ASP.NET Core output caching to use a Redis instance. This setup enables caching of entire HTTP responses, along with health checks, logging, and telemetry. For example, you can use the `[OutputCache(Duration = 10)]` attribute in a Razor page to cache the rendered response for 10 seconds.

2. **Distributed Caching**: Add the `Aspire.StackExchange.Redis.DistributedCaching` package to the `AspireRedis.ApiService` project. In the `Program.cs` file, call `builder.AddRedisDistributedCache(""cache"");` to configure distributed caching. This allows caching of specific pieces of data shared across multiple app servers. For instance, you can cache weather forecast data by using `IDistributedCache` to store and retrieve serialized data with a 10-second expiration.

By combining these configurations, you can enhance the performance and scalability of your ASP.NET Core application with both output and distributed caching.",multi_hop_abstract_query_synthesizer
30,"How does the .NET Aspire Azure Cosmos DB integration enable local development with Azure resources, and what configuration options are available for provisioning and connecting to Cosmos DB?","['<1-hop>\n\ntitle: .NET Aspire Azure Cosmos DB integration description: Learn how to install and configure the .NET Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-integration .NET Aspire Azure Cosmos DB integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Azure Cosmos DB client integration, install the ðŸ“¦ Aspire.Microsoft.Azure.Cosmos NuGet package in the client-consuming project, that is, the project for the application that uses the Cosmos DB client. The Cosmos DB client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Azure.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.Azure.Cosmos"" Version=""*"" /> Add Cosmos DB client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddAzureCosmosClient(connectionName: ""cosmos-db""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmos-db that same name should be used when calling AddAzureCosmosClient. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(CosmosClient client) { // Use client... } For more information on dependency injection, see .NET dependency injection. Add keyed Cosmos DB client There might be situations where you want to register multiple CosmosClient instances with different connection names. To register keyed Cosmos DB clients, call the csharp builder.AddKeyedAzureCosmosClient(name: ""mainDb""); builder.AddKeyedAzureCosmosClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your Cosmos DB resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the CosmosClient instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] CosmosClient mainDbClient, [FromKeyedServices(""loggingDb"")] CosmosClient loggingDbClient) { // Use clients... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Azure Cosmos DB integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddAzureCosmosClient(""cosmos-db""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cosmos-db"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information on how to format this connection string, see the ConnectionString documentation. Use configuration providers The .NET Aspire Azure Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""Azure"": { ""Cosmos"": { ""DisableTracing"": false, } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.Azure.Cosmos/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftAzureCosmosSettings> configureSettings delegate to set up some or all the options inline, for example to disable tracing from code: csharp builder.AddAzureCosmosClient( ""cosmos-db"", static settings => settings.DisableTracing = true); You can also set up the csharp builder.AddAzureCosmosClient( ""cosmosConnectionName"", configureClientOptions: clientOptions => clientOptions.ApplicationName = ""myapp""); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Azure Cosmos DB integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: Local Azure provisioning description: Learn how to use Azure resources in your local development environment. ms.date: 12/13/2024 uid: dotnet/aspire/local-azure-provisioning Local Azure provisioning .NET Aspire simplifies local cloud-native app development with its compelling app host model. This model allows you to run your app locally with the same configuration and services as in Azure. In this article you learn how to provision Azure resources from your local development environment through the .NET Aspire app host. [!NOTE] To be clear, resources are provisioned in Azure, but the provisioning process is initiated from your local development environment. To optimize your local development experience, consider using emulator or containers when available. For more information, see Typical developer experience. Requirements This article assumes that you have an Azure account and subscription. If you don\'t have an Azure account, you can create a free one at Azure Free Account. For provisioning functionality to work correctly, you\'ll need to be authenticated with Azure. Ensure that you have the Azure Developer CLI installed. Additionally, you\'ll need to provide some configuration values so that the provisioning logic can create resources on your behalf. App host provisioning APIs The app host provides a set of APIs to express Azure resources. These APIs are available as extension methods in .NET Aspire Azure hosting libraries, extending the When the app host starts, the following provisioning logic is executed: The Azure configuration section is validated. When invalid the dashboard and app host output provides hints as to what\'s missing. For more information, see Missing configuration value hints. When valid Azure resources are conditionally provisioned: If an Azure deployment for a given resource doesn\'t exist, it\'s created and configured as a deployment. The configuration of said deployment is stamped with a checksum as a means to support only provisioning resources as necessary. Use existing Azure resources The app host automatically manages provisioning of Azure resources. The first time the app host runs, it provisions the resources specified in the app host. Subsequent runs don\'t provision the resources again unless the app host configuration changes. If you\'ve already provisioned Azure resources outside of the app host and want to use them, you can provide the connection string with the ```csharp // Service registration var secrets = builder.ExecutionContext.IsPublishMode ? builder.AddAzureKeyVault(""secrets"") : builder.AddConnectionString(""secrets""); // Service consumption builder.AddProject The preceding code snippet shows how to add an Azure Key Vault to the app host. The Alternatively, for some Azure resources, you can opt-in to running them as an emulator with the RunAsEmulator API. This API is available for Azure Cosmos DB and Azure Storage integrations. For example, to run Azure Cosmos DB as an emulator, you can use the following code snippet: csharp var cosmos = builder.AddAzureCosmosDB(""cosmos"") .RunAsEmulator(); The .NET Aspire Azure hosting integrations If you\'re using Azure resources in your app host, you\'re using one or more of the .NET Aspire Azure hosting integrations. These hosting libraries provide extension methods to the Configuration When utilizing Azure resources in your local development environment, you need to provide the necessary configuration values. Configuration values are specified under the Azure section: SubscriptionId: The Azure subscription ID. AllowResourceGroupCreation: A boolean value that indicates whether to create a new resource group. ResourceGroup: The name of the resource group to use. Location: The Azure region to use. Consider the following example :::no-loc text=""appsettings.json""::: configuration: json { ""Azure"": { ""SubscriptionId"": ""<Your subscription id>"", ""AllowResourceGroupCreation"": true, ""ResourceGroup"": ""<Valid resource group name>"", ""Location"": ""<Valid Azure location>"" } } [!IMPORTANT] It\'s recommended to store these values as app secrets. For more information, see Manage app secrets. After you\'ve configured the necessary values, you can start provisioning Azure resources in your local development environment. Azure provisioning credential store The .NET Aspire app host uses a credential store for Azure resource authentication and authorization. Depending on your subscription, the correct credential store may be needed for multi-tenant provisioning scenarios. With the ðŸ“¦ Aspire.Hosting.Azure NuGet package installed, and if your app host depends on Azure resources, the default Azure credential store relies on the json { ""Azure"": { ""CredentialSource"": ""AzureCli"" } } As with all configuration-based settings, you can configure these with alternative providers, such as user secrets or environment variables. The Azure:CredentialSource value can be set to one of the following values: AzureCli: Delegates to the AzurePowerShell: Delegates to the VisualStudio: Delegates to the VisualStudioCode: Delegates to the AzureDeveloperCli: Delegates to the InteractiveBrowser: Delegates to the [!TIP] For more information about the Azure SDK authentication and authorization, see Credential chains in the Azure Identity library for .NET. Tooling support In Visual Studio, you can use Connected Services to configure the default Azure provisioning settings. Select the app host project, right-click on the Connected Services node, and select Azure Resource Provisioning Settings: :::image type=""content"" loc-scope=""visual-studio"" source=""media/azure-resource-provisioning-settings.png"" lightbox=""media/azure-resource-provisioning-settings.png"" alt-text=""Visual Studio 2022: .NET Aspire App Host project, Connected Services context menu.""::: This will open a dialog where you can configure the Azure provisioning settings, as shown in the following screenshot: :::image type=""content"" loc-scope=""visual-studio"" source=""media/azure-provisioning-settings-dialog.png"" lightbox=""media/azure-provisioning-settings-dialog.png"" alt-text=""Visual Studio 2022: Azure Resource Provisioning Settings dialog.""::: Missing configuration value hints When the Azure configuration section is missing, has missing values, or is invalid, the .NET Aspire dashboard provides useful hints. For example, consider an app host that\'s missing the SubscriptionId configuration value that\'s attempting to use an Azure Key Vault resource. The Resources page indicates the State as Missing subscription configuration: :::image type=""content"" source=""media/resources-kv-missing-subscription.png"" alt-text="".NET Aspire dashboard: Missing subscription configuration.""::: Additionally, the Console logs display this information as well, consider the following screenshot: :::image type=""content"" source=""media/console-logs-kv-missing-subscription.png"" lightbox=""media/console-logs-kv-missing-subscription.png"" alt-text="".NET Aspire dashboard: Console logs, missing subscription configuration."":::']","The .NET Aspire Azure Cosmos DB integration facilitates local development with Azure resources by allowing developers to connect to existing Cosmos DB instances or create new ones using the Azure Cosmos DB emulator. This integration supports hosting and client configurations, including automatic health checks for Cosmos DB resources through the AspNetCore.HealthChecks.CosmosDb NuGet package. Developers can register Cosmos DB clients in their applications using the builder.AddAzureCosmosClient method, specifying connection names that match the app host project configuration. For scenarios requiring multiple Cosmos DB clients, keyed services can be registered using builder.AddKeyedAzureCosmosClient with unique connection names.

For provisioning Azure resources locally, the .NET Aspire app host provides APIs to express and manage Azure resources. These resources are provisioned in Azure but initiated from the local development environment. Configuration values such as SubscriptionId, ResourceGroup, and Location must be specified in the Azure section of the appsettings.json file. Developers can also use emulators, such as the RunAsEmulator API, to simulate Azure services like Cosmos DB locally. Additionally, the integration supports various configuration methods, including connection strings, inline delegates, and JSON-based configuration providers, to customize settings like tracing and application names. The app host also integrates with Azure credential stores for authentication and authorization, supporting multiple credential sources like Azure CLI and Visual Studio.",multi_hop_abstract_query_synthesizer
31,what new stuff in .NET Aspire 9.0 and how dashboard UX got better?,"['<1-hop>\n\ntitle: What\'s new in .NET Aspire 9.0 description: Learn what\'s new in the official general availability version of .NET Aspire 9.0. ms.date: 11/13/2024 What\'s new in .NET Aspire 9.0 ðŸ“¢ .NET Aspire 9.0 is the next major general availability (GA) release of .NET Aspire; it supports both: .NET 8.0 Long Term Support (LTS) or .NET 9.0 Standard Term Support (STS). [!NOTE] You\'re able to use .NET Aspire 9.0 with either .NET 8 or .NET 9! This release addresses some of the most highly requested features and pain points from the community. The best features are community-driven! To join the community on, visit us on :::image type=""icon"" source=""../media/discord-icon.svg"" border=""false""::: Discord to chat with team members and collaborate with us on :::image type=""icon"" source=""../media/github-mark.svg"" border=""false""::: GitHub. For more information on the official .NET version and .NET Aspire version support, see: .NET support policy: Definitions for LTS and STS. .NET Aspire support policy: Important unique product life cycle details. Upgrade to .NET Aspire 9 To upgrade from earlier versions of .NET Aspire to .NET Aspire 9, follow the instructions in the official Upgrade to .NET Aspire 9 guide. The guide provides detailed instructions on how to upgrade your existing .NET Aspire solutions to .NET Aspire 9. Regardless of you\'re doing it manually, or using the Upgrade Assistant, the guide makes short work of the process. Tooling improvements .NET Aspire 9 makes it simpler to configure your environment to develop .NET Aspire applications. You no longer need a .NET workload. Instead, you install the new .NET Aspire SDK into the app host project of your .NET Aspire solutions. For more information, see .NET Aspire setup and tooling. Templates have moved .NET Aspire 9 is moving the contents that used to be installed via the workload into separate NuGet packages. This includes the templates for creating new .NET Aspire projects and solutions. These templates are installed using the dotnet new install command. These can be installed by running the following command: dotnetcli dotnet new install Aspire.ProjectTemplates::9.0.0 [!TIP] If you already have the .NET Aspire workload installed, you need to pass the --force flag to overwrite the existing templates. Feel free to uninstall the .NET Aspire workload. For more information, see .NET Aspire templates.', '<2-hop>\n\nDashboard UX enhancements and new interactivity features The .NET Aspire dashboard continues to improve with each release. Manage resource lifecycle The most requested feature for the dashboard is to manage the life-cycles of your orchestrated named resources. Specifically, the ability to stop, start, and restart resources. This feature works for projects, containers, and executables. It enables restarting individual resources without having to restart the entire app host. For project resources, when the debugger is attached, it\'s reattached on restart. For more information, see .NET Aspire dashboard: Stop or Start a resource. Mobile and responsive support The .NET Aspire dashboard is now mobile-friendly, responsively adapting to a wide range of screen sizes and enabling on-the-go management of deployed .NET Aspire applications. Other accessibility improvements were made, including the display of settings and content overflow on mobile. Sensitive properties, volumes, and health checks in resource details The display of resource details contains several improvements: Properties can be marked as sensitive, automatically masking them in the dashboard UI. This security feature helps to avoid accidentally disclosing keys or passwords when screen sharing the dashboard with other people. For example, container arguments could pass sensitive information and so are masked by default. Configured container volumes are listed in resource details. .NET Aspire 9 adds support for health checks. Detailed information about these checks can now be viewed in the resource details pane, showing why a resource might be marked as unhealthy or degraded. Find out more about health checks here. Colorful console log ANSI escape codes format text in terminals by controlling colors (foreground and background) and styles like bold, underline, and italics. Previously, the dashboard\'s console logs page could only render one ANSI escape code at a time, failing when multiple codes were combined. For example, it could display red text, but not text that was both red and bold. A community contribution from @mangeg improved support for ANSI escape codes and removed this limitation. :::image type=""content"" source=""media/console-logs-ansi-text-format.png"" lightbox=""media/console-logs-ansi-text-format.png"" alt-text=""Colorful console logs""::: Another improvement to console logs is hiding unsupported escape codes. Codes that aren\'t related to displaying text, such as positioning the cursor or communicating with the operating system don\'t make sense in this UI, and are hidden. Telemetry user-centric additions Telemetry remains a vital aspect of .NET Aspire. In .NET Aspire 9, many new features were introduced to the Telemetry service. Improved telemetry filtering Traces can be filtered with attribute values. For example, if you only want to view traces for one endpoint in your app, the http.route attribute on HTTP requests can be filtered to a specified value. Telemetry filtering also supports autocomplete of existing values. The Add filter dialog provides a combo box for selecting from values that dashboard has available. This feature makes it much easier to filter to real data and helps avoid typos by entered a value yourself. For more information, see .NET Aspire dashboard: Filter traces. Combine telemetry from multiple resources When a resource has multiple replicas, you can now filter telemetry to view data from all instances at once. Select the parent resource, labeled (application). For more information, see .NET Aspire dashboard: Combine telemetry from multiple resources. Browser telemetry support The dashboard supports OpenTelemetry Protocol (OTLP) over HTTP and cross-origin resource sharing (CORS). These features unlock the ability to send OpenTelemetry from browser apps to the .NET Aspire dashboard. For example, a browser-based single page app (SPA) can configure the JavaScript OpenTelemetry SDK to send structured logs, traces, and metrics created in the browser to the dashboard. Browser telemetry is displayed alongside server telemetry. :::image type=""content"" source=""media/dashboard-browser-telemetry.png"" lightbox=""media/dashboard-browser-telemetry.png"" alt-text=""Trace detail page with browser telemetry""::: For more information on configuring browser telemetry, see Enable browser telemetry documentation.']",".NET Aspire 9.0 introduces several new features and improvements. It supports both .NET 8.0 Long Term Support (LTS) and .NET 9.0 Standard Term Support (STS). Tooling improvements include the ability to install the .NET Aspire SDK directly into the app host project, eliminating the need for a .NET workload. Templates for creating new projects have been moved to separate NuGet packages, which can be installed using the 'dotnet new install' command. Additionally, the dashboard UX has been enhanced with features like managing the lifecycle of orchestrated resources (stop, start, restart), mobile-friendly and responsive design, masking sensitive properties in the UI, improved health checks, and better support for ANSI escape codes in console logs. Telemetry features have also been expanded, including improved filtering, combining telemetry from multiple resources, and browser telemetry support.",multi_hop_abstract_query_synthesizer
32,"How does the .NET Aspire NATS integration enable both server hosting and client interaction, and what are the key features related to observability and telemetry?","['<1-hop>\n\ntitle: .NET Aspire NATS integration description: Learn how to use the .NET Aspire NATS integration to send logs and traces to a NATS Server. ms.date: 10/11/2024 uid: messaging/nats-integration .NET Aspire NATS integration [!INCLUDE includes-hosting-and-client] NATS is a high-performance, secure, distributed messaging system. The .NET Aspire NATS integration enables you to connect to existing NATS instances, or create new instances from .NET with the docker.io/library/nats container image. Hosting integration NATS hosting integration for .NET Aspire models a NATS server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Nats PackageReference xml <PackageReference Include=""Aspire.Hosting.Nats"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add NATS server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/nats image, it creates a new NATS server instance on your local machine. A reference to your NATS server (the nats variable) is added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing NATS server, call Add NATS server resource with JetStream To add the NATS JetStream to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithJetStream(); builder.AddProject // After adding all resources, run the app... ``` The NATS JetStream functionality provides a built-in persistence engine called JetStream which enables messages to be stored and replayed at a later time. You can optionally provide a srcMountPath parameter to specify the path to the JetStream data directory on the host machine (the provided mount path maps to the container\'s -sd argument). Add NATS server resource with data volume To add a data volume to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the NATS server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/nats path in the NATS server container. A name is generated at random unless you provide a set the name parameter. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add NATS server resource with data bind mount To add a data bind mount to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataBindMount( source: @""C:\\NATS\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the NATS server data across container restarts. The data bind mount is mounted at the C:\\NATS\\Data on Windows (or /NATS/Data on Unix) path on the host machine in the NATS server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The NATS hosting integration automatically adds a health check for the NATS server resource. The health check verifies that the NATS server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Nats NuGet package.', '<2-hop>\n\nClient integration To get started with the .NET Aspire NATS client integration, install the ðŸ“¦ Aspire.NATS.Net NuGet package in the client-consuming project, that is, the project for the application that uses the NATS client. The NATS client integration registers an INatsConnection instance that you can use to interact with NATS. .NET CLI dotnetcli dotnet add package Aspire.NATS.Net PackageReference xml <PackageReference Include=""Aspire.NATS.Net"" Version=""*"" /> Add NATS client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNatsClient(connectionName: ""nats""); [!TIP] The connectionName parameter must match the name used when adding the NATS server resource in the app host project. For more information, see Add NATS server resource. You can then retrieve the INatsConnection instance using dependency injection. For example, to retrieve the client from a service: csharp public class ExampleService(INatsConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed NATS client There might be situations where you want to register multiple INatsConnection instances with different connection names. To register keyed NATS clients, call the csharp builder.AddKeyedNatsClient(name: ""chat""); builder.AddKeyedNatsClient(name: ""queue""); Then you can retrieve the IConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] INatsConnection chatConnection, [FromKeyedServices(""queue"")] INatsConnection queueConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire NATS integration provides multiple options to configure the NATS connection based on the requirements and conventions of your project. Use a connection string Provide the name of the connection string when you call builder.AddNatsClient: csharp builder.AddNatsClient(connectionName: ""nats""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""nats"": ""nats://nats:4222"" } } See the ConnectionString documentation for more information on how to format this connection string. Use configuration providers The .NET Aspire NATS integration supports json { ""Aspire"": { ""Nats"": { ""Client"": { ""ConnectionString"": ""nats://nats:4222"", ""DisableHealthChecks"": true, ""DisableTracing"": true } } } } For the complete NATS client integration JSON schema, see Aspire.NATS.Net/ConfigurationSchema.json. Use inline delegates Pass the Action<NatsClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddNatsClient( ""nats"", static settings => settings.DisableHealthChecks = true); NATS in the .NET Aspire manifest NATS isn\'t part of the .NET Aspire deployment manifest. It\'s recommended you set up a secure production NATS server outside of .NET Aspire. Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire NATS integration handles the following: Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. Observability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire NATS integration uses the following log categories: NATS Tracing The .NET Aspire NATS integration emits the following tracing activities: NATS.Net See also NATS.Net quickstart .NET Aspire integrations .NET Aspire GitHub repo']","The .NET Aspire NATS integration enables server hosting by allowing developers to connect to existing NATS instances or create new instances using the docker.io/library/nats container image. Hosting integration includes features such as adding a NATS server resource, enabling JetStream for message persistence, and configuring data volumes or bind mounts for persisting server data. Health checks are automatically added to verify the server's status and connectivity, relying on the AspNetCore.HealthChecks.Nats NuGet package.

For client interaction, the .NET Aspire NATS client integration registers an INatsConnection instance, which can be used to interact with the NATS server. Developers can add a NATS client in the Program.cs file of the client-consuming project and retrieve the connection instance using dependency injection. Keyed NATS clients can also be registered for multiple connections with different names. Configuration options include using connection strings, configuration providers, or inline delegates to customize settings such as disabling health checks.

Regarding observability and telemetry, the integration automatically sets up logging, tracing, and metrics configurations, which are essential for monitoring and debugging. These features can be customized or disabled using configuration techniques. The integration also supports the /health HTTP endpoint to ensure all registered health checks pass before the application is considered ready to accept traffic.",multi_hop_abstract_query_synthesizer
33,"How can the .NET Aspire Community Toolkit be used to integrate Ollama hosting and client features, including adding models, caching LLMs, and enabling GPU support?","['<1-hop>\n\ntitle: .NET Aspire Community Toolkit Ollama integration description: Learn how to use the .NET Aspire Ollama hosting and client integration to host Ollama models using the Ollama container and accessing it via the OllamaSharp client. ms.date: 10/24/2024 .NET Aspire Community Toolkit Ollama integration [!INCLUDE includes-hosting-and-client] [!INCLUDE banner] Ollama is a powerful, open source language model that can be used to generate text based on a given prompt. The .NET Aspire Ollama integration provides a way to host Ollama models using the docker.io/ollama/ollama container image and access them via the OllamaSharp client.', '<2-hop>\n\nHosting integration The Ollama hosting integration models an Ollama server as the OllamaResource type, and provides the ability to add models to the server using the AddModel extension method, which represents the model as an OllamaModelResource type. To access these types and APIs that allow you to add the ðŸ“¦ CommunityToolkit.Aspire.Hosting.Ollama NuGet package in the app host project. .NET CLI dotnetcli dotnet add package CommunityToolkit.Aspire.Hosting.Ollama PackageReference xml <PackageReference Include=""CommunityToolkit.Aspire.Hosting.Ollama"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Ollama resource In the app host project, register and consume the Ollama integration using the AddOllama extension method to add the Ollama container to the application builder. You can then add models to the container, which downloads and run when the container starts, using the AddModel extension method. ```csharp var builder = DistributedApplication.CreateBuilder(args); var ollama = builder.AddOllama(""ollama""); var phi35 = ollama.AddModel(""phi3.5""); var exampleProject = builder.AddProject Alternatively, if you want to use a model from the Hugging Face model hub, you can use the AddHuggingFaceModel extension method. csharp var llama = ollama.AddHuggingFaceModel(""llama"", ""bartowski/Llama-3.2-1B-Instruct-GGUF:IQ4_XS""); When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/ollama/ollama image, it creates a new Ollama instance on your local machine. For more information, see Container resource lifecycle. Download the LLM When the Ollama container for this integration first spins up, it downloads the configured LLMs. The progress of this download displays in the State column for this integration on the .NET Aspire dashboard. [!IMPORTANT] Keep the .NET Aspire orchestration app open until the download is complete, otherwise the download will be cancelled. Cache the LLM One or more LLMs are downloaded into the container which Ollama is running from, and by default this container is ephemeral. If you need to persist one or more LLMs across container restarts, you need to mount a volume into the container using the WithDataVolume method. ```csharp var ollama = builder.AddOllama(""ollama"") .WithDataVolume(); var llama = ollama.AddModel(""llama3""); ``` Use GPUs when available One or more LLMs are downloaded into the container which Ollama is running from, and by default this container runs on CPU. If you need to run the container in GPU you need to pass a parameter to the container runtime args. Docker csharp var ollama = builder.AddOllama(""ollama"") .AddModel(""llama3"") .WithContainerRuntimeArgs(""--gpus=all""); For more information, see GPU support in Docker Desktop. Podman csharp var ollama = builder.AddOllama(""ollama"") .AddModel(""llama3"") .WithContainerRuntimeArgs(""--device"", ""nvidia.com/gpu=all""); For more information, see GPU support in Podman. Hosting integration health checks The Ollama hosting integration automatically adds a health check for the Ollama server and model resources. For the Ollama server, a health check is added to verify that the Ollama server is running and that a connection can be established to it. For the Ollama model resources, a health check is added to verify that the model is running and that the model is available, meaning the resource will be marked as unhealthy until the model has been downloaded. Open WebUI support The Ollama integration also provided support for running Open WebUI and having it communicate with the Ollama container. csharp var ollama = builder.AddOllama(""ollama"") .AddModel(""llama3"") .WithOpenWebUI();']","The .NET Aspire Community Toolkit provides integration for Ollama hosting and client features through the use of the CommunityToolkit.Aspire.Hosting.Ollama NuGet package. To integrate Ollama hosting, you can register the Ollama container in the application builder using the `AddOllama` extension method. Models can be added to the container using the `AddModel` method, which downloads and runs the models when the container starts. To cache LLMs across container restarts, you can use the `WithDataVolume` method to mount a volume into the container. Additionally, GPU support can be enabled by passing runtime arguments to the container, such as `--gpus=all` for Docker or `--device nvidia.com/gpu=all` for Podman. The integration also includes automatic health checks for the Ollama server and model resources, ensuring that the server is running and the models are available. Furthermore, Open WebUI support is provided, allowing communication with the Ollama container.",multi_hop_abstract_query_synthesizer
34,What are the differences in health check implementations between AspNetCore.HealthChecks.SqlServer and AspNetCore.HealthChecks.Oracle?,"['<1-hop>\n\ntitle: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: .NET Aspire Oracle Entity Framework Core integration description: Learn how to use the .NET Aspire Oracle Entity Framework Core integration, which includes both hosting and client integrations. ms.date: 01/21/2025 uid: database/oracle-entity-framework-integration .NET Aspire Oracle Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Oracle Database is a widely-used relational database management system owned and developed by Oracle. The .NET Aspire Oracle Entity Framework Core integration enables you to connect to existing Oracle servers or create new servers from .NET with the container-registry.orcale.com/databse/free container image. Hosting integration The .NET Aspire Oracle hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Oracle PackageReference xml <PackageReference Include=""Aspire.Hosting.Oracle"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Oracle server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Oracle database container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the container-registry.oracle.com/database/free image, it creates a new Oracle server on your local machine. A reference to your Oracle resource builder (the oracle variable) is used to add a database. The database is named oracledb and then added to the ExampleProject. The Oracle resource includes a random password generated using the The [!TIP] If you\'d rather connect to an existing Oracle server, call Add Oracle resource with password parameter The Oracle resource includes default credentials with a random password. Oracle supports configuration-based default passwords by using the environment variable ORACLE_PWD. When you want to provide a password explicitly, you can provide it as a parameter: ```csharp var password = builder.AddParameter(""password"", secret: true); var oracle = builder.AddOracle(""oracle"", password) .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddOracle API, and internally assigns the parameter to the ORACLE_PWD environment variable of the Oracle container. The password parameter is usually specified as a user secret: json { ""Parameters"": { ""password"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Oracle resource with data volume To add a data volume to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataVolume() .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracle""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Oracle data outside the lifecycle of its container. The data volume is mounted at the /opt/oracle/oradata path in the Oracle container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add Oracle resource with data bind mount To add a data bind mount to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataBindMount(source: @""C:\\Oracle\\Data""); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Oracle data across container restarts. The data bind mount is mounted at the C:\\Oracle\\Data on Windows (or /Oracle/Data on Unix) path on the host machine in the Oracle container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Oracle hosting integration automatically adds a health check for the Oracle resource. The health check verifies that the Oracle server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Oracle NuGet package.']","The health check implementation for AspNetCore.HealthChecks.SqlServer automatically verifies that the SQL Server is running and that a connection can be established to it. This is integrated with the hosting environment and relies on the AspNetCore.HealthChecks.SqlServer NuGet package. Similarly, the health check implementation for AspNetCore.HealthChecks.Oracle verifies that the Oracle server is running and that a connection can be established. This also integrates with the hosting environment but relies on the AspNetCore.HealthChecks.Oracle NuGet package. While both implementations serve the same purpose of ensuring the database server's availability, they are tailored to their respective database systems (SQL Server and Oracle).",multi_hop_specific_query_synthesizer
35,What are the differences in health check implementations between AspNetCore.HealthChecks.SqlServer and AspNetCore.HealthChecks.CosmosDb?,"['<1-hop>\n\ntitle: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: .NET Aspire Cosmos DB Entity Framework Core integration description: Learn how to install and configure the .NET Aspire Cosmos DB Entity Framework Core integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-entity-framework-integration .NET Aspire Cosmos DB Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.Cosmos"" Version=""*"" /> Add Cosmos DB context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmosdb that same name should be used when calling AddCosmosDbContext. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(MyDbContext context) { // Use context... } For more information on using Entity Framework Core with Azure Cosmos DB, see the Examples for Azure Cosmos DB for NoSQL SDK for .NET. Configuration The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddCosmosDbContext: csharp builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information, see the ConnectionString documentation. Use configuration providers The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""Cosmos"": { ""DisableTracing"": true } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json. Use inline delegates You can also pass the Action<EntityFrameworkCoreCosmosSettings> configureSettings delegate to set up some or all the csharp builder.AddCosmosDbContext<MyDbContext>( ""cosmosdb"", settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn\'t implement health checks, though this may change in future releases. [!INCLUDE integration-observability-and-telemetry]']","The AspNetCore.HealthChecks.SqlServer package automatically adds a health check for the SQL Server resource, verifying that the SQL Server is running and that a connection can be established. This health check integrates with the /health HTTP endpoint, ensuring all registered health checks must pass for the app to be considered ready to accept traffic. On the other hand, the AspNetCore.HealthChecks.CosmosDb package also adds a health check for the Cosmos DB resource, verifying its availability and connectivity. However, the Cosmos DB health check is part of the hosting integration and does not currently implement health checks for the client integration, though this may change in future releases.",multi_hop_specific_query_synthesizer
36,"How does the deployment process using Azure Developer CLI (azd) streamline the integration of Azure SQL Database and Azure Data Tables in .NET Aspire projects, and what recent updates have been made to Azure Data Tables integration in the .NET Aspire documentation?","['<1-hop>\n\nDeploy the app Tools such as the Azure Developer CLI (azd) support .NET Aspire SQL Server integration configurations to streamline deployments. azd consumes these settings and provisions properly configured resources for you. [!INCLUDE init-workflow] [!INCLUDE azd-up-workflow] Azure SQL Database The deployment process provisioned an Azure SQL Database resource due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-database.png"" alt-text=""A screenshot showing the deployed Azure SQL Database.""::: SQL Server Container The deployment process created a SQL Server app container due to the .AppHost configuration you provided. :::image type=""content"" loc-scope=""azure"" source=""media/resources-azure-sql-container.png"" alt-text=""A screenshot showing the containerized SQL Database.""::: [!INCLUDE clean-up-resources] See also .NET Aspire deployment via Azure Container Apps .NET Aspire Azure Container Apps deployment deep dive Deploy a .NET Aspire project using GitHub Actions', '<2-hop>\n\ntitle: "" .NET Aspire docs: What\'s new for October 2024"" description: ""What\'s new in the .NET Aspire docs for October 2024."" ms.custom: October-2024 ms.date: 11/01/2024 .NET Aspire docs: What\'s new for October 2024 Welcome to what\'s new in the .NET Aspire docs for October 2024. This article lists some of the major changes to docs during this period. Get started Updated articles Orchestrate Node.js apps in .NET Aspire - Fix broken links Quickstart: Build your first .NET Aspire solution - Make it easier to onboard with VS Code. Fundamentals New articles Enable browser telemetry Updated articles .NET Aspire dashboard overview Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. .NET Aspire integrations overview Add Meilisearch integeration docs Using nuget.org links for Community Toolkit packages Moving from Aspire.CommunityToolkit to CommunityToolkit.Aspire Moving package links to be Azure Artifacts not GitHub Packages Rewrite the non-Azure messaging integration articles Community Toolkit .NET Aspire orchestration overview - Rewrite the non-Azure messaging integration articles Dashboard configuration Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Enable browser telemetry minor text fixes Various dashboard and telemetry docs updates Add a link and sentence about browser telemetry. Security considerations for running the .NET Aspire dashboard - Various dashboard and telemetry docs updates Standalone .NET Aspire dashboard - Various dashboard and telemetry docs updates Tutorial: Use the .NET Aspire dashboard with Python apps - Various dashboard and telemetry docs updates Storage Updated articles .NET Aspire Azure Blob Storage integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Data Tables integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Queue Storage integration - Rewrite the non-Azure messaging integration articles Tutorial: Connect an ASP.NET Core app to .NET Aspire storage integrations - Rewrite the non-Azure messaging integration articles Database Updated articles .NET Aspire Azure Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Microsoft Entity Framework Core Cosmos DB integration - Rewrite the non-Azure messaging integration articles .NET Aspire Milvus database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MongoDB database integration - Rewrite the non-Azure messaging integration articles .NET Aspire MySQL database integration - Rewrite the non-Azure messaging integration articles .NET Aspire Oracle Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire Pomelo MySQL Entity Framework Component - Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL Entity Framework Core integration Rewrite both PostgreSQL integration docs Update postgresql-entity-framework-integration.md Rewrite the non-Azure messaging integration articles .NET Aspire PostgreSQL integration Rewrite both PostgreSQL integration docs Rewrite the non-Azure messaging integration articles .NET Aspire Qdrant integration - Rewrite the non-Azure messaging integration articles .NET Aspire SQL Server integration - Rewrite the non-Azure messaging integration articles .NET Aspire SqlServer Entity Framework Core integration - Rewrite the non-Azure messaging integration articles Messaging New articles .NET Aspire RabbitMQ integration Updated articles .NET Aspire Apache Kafka integration Fix Kafka integration documentation Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire Azure Event Hubs integration - Rewrite the non-Azure messaging integration articles .NET Aspire Azure Service Bus integration Rewrite the non-Azure messaging integration articles Use correct method name in ServiceBus .NET Aspire Azure Web PubSub integration - Rewrite the non-Azure messaging integration articles .NET Aspire NATS integration Demote messaging integration headings Rewrite the non-Azure messaging integration articles .NET Aspire RabbitMQ integration Rewrite both PostgreSQL integration docs Redis rewrite Demote messaging integration headings Rewrite the non-Azure messaging integration articles']","The deployment process using Azure Developer CLI (azd) streamlines the integration of Azure SQL Database and Azure Data Tables in .NET Aspire projects by consuming configuration settings provided in the .AppHost file. This allows azd to provision properly configured resources, such as an Azure SQL Database and a SQL Server container, during deployment. Recent updates to the .NET Aspire documentation include a rewrite of the Azure Data Tables integration articles, focusing on improving clarity and aligning with the latest best practices for non-Azure messaging integrations.",multi_hop_specific_query_synthesizer
37,how to use Aspire.StackExchange.Redis.OutputCaching and what observability features it got?,"['<1-hop>\n\nConfigure the UI with output caching Add the .NET Aspire Stack Exchange Redis output caching integration packages to your AspireRedis.Web app: dotnetcli dotnet add package Aspire.StackExchange.Redis.OutputCaching In the :::no-loc text=""Program.cs""::: file of the AspireRedis.Web Blazor project, immediately after the line var builder = WebApplication.CreateBuilder(args);, add a call to the csharp builder.AddRedisOutputCache(""cache""); This method accomplishes the following tasks: Configures ASP.NET Core output caching to use a Redis instance with the specified connection name. Automatically enables corresponding health checks, logging, and telemetry. Replace the contents of the Home.razor file of the AspireRedis.Web Blazor project with the following: ```razor @page ""/"" @attribute [OutputCache(Duration = 10)] Hello, world! Welcome to your new app on @DateTime.Now ``` The integration include the [OutputCache] attribute, which caches the entire rendered response. The page also include a call to @DateTime.Now to help verify that the response is cached. Configure the API with distributed caching Add the .NET Aspire Stack Exchange Redis distributed caching integration packages to your AspireRedis.ApiService app: dotnetcli dotnet add package Aspire.StackExchange.Redis.DistributedCaching Towards the top of the :::no-loc text=""Program.cs""::: file, add a call to csharp builder.AddRedisDistributedCache(""cache""); In the :::no-loc text=""Program.cs""::: file, add the following using statements: csharp using System.Text; using System.Text.Json; using Microsoft.Extensions.Caching.Distributed; In the :::no-loc text=""Program.cs""::: file, replace the existing /weatherforecast endpoint code with the following: ```csharp app.MapGet(""/weatherforecast"", async (IDistributedCache cache) => { var cachedForecast = await cache.GetAsync(""forecast""); if (cachedForecast is null) { var summaries = new[] { ""Freezing"", ""Bracing"", ""Chilly"", ""Cool"", ""Mild"", ""Warm"", ""Balmy"", ""Hot"", ""Sweltering"", ""Scorching"" }; var forecast = Enumerable.Range(1, 5).Select(index => new WeatherForecast ( DateOnly.FromDateTime(DateTime.Now.AddDays(index)), Random.Shared.Next(-20, 55), summaries[Random.Shared.Next(summaries.Length)] )) .ToArray(); await cache.SetAsync(""forecast"", Encoding.UTF8.GetBytes(JsonSerializer.Serialize(forecast)), new () { AbsoluteExpiration = DateTime.Now.AddSeconds(10) }); ; return forecast; } return JsonSerializer.Deserialize<IEnumerable<WeatherForecast>>(cachedForecast); }) .WithName(""GetWeatherForecast""); ``` Test the app locally Test the caching behavior of your app using the following steps: Run the app using Visual Studio by pressing F5. If the Start Docker Desktop dialog appears, select Yes to start the service. The .NET Aspire Dashboard loads in the browser and lists the UI and API projects. Test the output cache: On the projects page, in the webfrontend row, click the localhost link in the Endpoints column to open the UI of your app. The application will display the current time on the home page. Refresh the browser every few seconds to see the same page returned by output caching. After 10 seconds the cache expires and the page reloads with an updated time. Test the distributed cache: Navigate to the Weather page on the Blazor UI to load a table of randomized weather data. Refresh the browser every few seconds to see the same weather data returned by output caching. After 10 seconds the cache expires and the page reloads with updated weather data. Congratulations! You configured a ASP.NET Core app to use output and distributed caching with .NET Aspire.', '<2-hop>\n\nObservability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations might only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire Stack Exchange Redis integration uses the following log categories: Aspire.StackExchange.Redis Tracing The .NET Aspire Stack Exchange Redis integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.StackExchangeRedis Metrics The .NET Aspire Stack Exchange Redis integration currently doesn\'t support metrics by default due to limitations with the StackExchange.Redis library. :::zone pivot=""redis"" [!INCLUDE azure-redis-app-host] [!INCLUDE azure-redis-client] :::zone-end See also Stack Exchange Redis docs .NET Aspire integrations .NET Aspire GitHub repo [!INCLUDE redis-trademark]']","To use Aspire.StackExchange.Redis.OutputCaching, you need to add the integration package to your AspireRedis.Web app using the command `dotnet add package Aspire.StackExchange.Redis.OutputCaching`. In the `Program.cs` file, after the line `var builder = WebApplication.CreateBuilder(args);`, add the call `builder.AddRedisOutputCache(""cache"");`. This configures ASP.NET Core output caching to use a Redis instance with the specified connection name and automatically enables health checks, logging, and telemetry. The [OutputCache] attribute can be used to cache the entire rendered response, as demonstrated in the Home.razor file example. 

Regarding observability, the .NET Aspire Stack Exchange Redis integration automatically sets up logging and tracing configurations. It uses the log category `Aspire.StackExchange.Redis` and emits tracing activities using `OpenTelemetry.Instrumentation.StackExchangeRedis`. However, it does not support metrics by default due to limitations with the StackExchange.Redis library.",multi_hop_specific_query_synthesizer
38,How do the AspNetCore.HealthChecks.Npgsql and AspNetCore.HealthChecks.Oracle NuGet packages facilitate health monitoring for PostgreSQL and Oracle databases in .NET Aspire applications?,"['<1-hop>\n\ntitle: .NET Aspire PostgreSQL integration description: Learn how to integrate PostgreSQL with .NET Aspire applications, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-integration .NET Aspire PostgreSQL integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL client integration, install the ðŸ“¦ Aspire.Npgsql NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The PostgreSQL client integration registers an NpgsqlDataSource instance that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql PackageReference xml <PackageReference Include=""Aspire.Npgsql"" Version=""*"" /> Add Npgsql client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDataSource(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding NpgsqlDataSource to the builder, you can get the NpgsqlDataSource instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(NpgsqlDataSource dataSource) { // Use dataSource... } For more information on dependency injection, see .NET dependency injection. Add keyed Npgsql client There might be situations where you want to register multiple NpgsqlDataSource instances with different connection names. To register keyed Npgsql clients, call the csharp builder.AddKeyedNpgsqlDataSource(name: ""chat""); builder.AddKeyedNpgsqlDataSource(name: ""queue""); Then you can retrieve the NpgsqlDataSource instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] NpgsqlDataSource chatDataSource, [FromKeyedServices(""queue"")] NpgsqlDataSource queueDataSource) { // Use data sources... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire PostgreSQL integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddNpgsqlDataSource(""postgresdb""); Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""postgresdb"": ""Host=myserver;Database=postgresdb"" } } For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DisableHealthChecks"": false, ""DisableTracing"": true, ""DisableMetrics"": false } } } For the complete PostgreSQL client integration JSON schema, see Aspire.Npgsql/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks: csharp builder.AddNpgsqlDataSource( ""postgresdb"", static settings => settings.DisableHealthChecks = true); [!INCLUDE integration-health-checks] Adds the NpgSqlHealthCheck, which verifies that commands can be successfully executed against the underlying Postgres Database. Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: .NET Aspire Oracle Entity Framework Core integration description: Learn how to use the .NET Aspire Oracle Entity Framework Core integration, which includes both hosting and client integrations. ms.date: 01/21/2025 uid: database/oracle-entity-framework-integration .NET Aspire Oracle Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Oracle Database is a widely-used relational database management system owned and developed by Oracle. The .NET Aspire Oracle Entity Framework Core integration enables you to connect to existing Oracle servers or create new servers from .NET with the container-registry.orcale.com/databse/free container image. Hosting integration The .NET Aspire Oracle hosting integration models the server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Oracle PackageReference xml <PackageReference Include=""Aspire.Hosting.Oracle"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add Oracle server and database resources In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The Oracle database container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the container-registry.oracle.com/database/free image, it creates a new Oracle server on your local machine. A reference to your Oracle resource builder (the oracle variable) is used to add a database. The database is named oracledb and then added to the ExampleProject. The Oracle resource includes a random password generated using the The [!TIP] If you\'d rather connect to an existing Oracle server, call Add Oracle resource with password parameter The Oracle resource includes default credentials with a random password. Oracle supports configuration-based default passwords by using the environment variable ORACLE_PWD. When you want to provide a password explicitly, you can provide it as a parameter: ```csharp var password = builder.AddParameter(""password"", secret: true); var oracle = builder.AddOracle(""oracle"", password) .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracledb""); var myService = builder.AddProject The preceding code gets a parameter to pass to the AddOracle API, and internally assigns the parameter to the ORACLE_PWD environment variable of the Oracle container. The password parameter is usually specified as a user secret: json { ""Parameters"": { ""password"": ""Non-default-P@ssw0rd"" } } For more information, see External parameters. Add Oracle resource with data volume To add a data volume to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataVolume() .WithLifetime(ContainerLifetime.Persistent); var oracledb = oracle.AddDatabase(""oracle""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the Oracle data outside the lifecycle of its container. The data volume is mounted at the /opt/oracle/oradata path in the Oracle container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add Oracle resource with data bind mount To add a data bind mount to the Oracle resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var oracle = builder.AddOracle(""oracle"") .WithDataBindMount(source: @""C:\\Oracle\\Data""); var oracledb = oracle.AddDatabase(""oracledb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the Oracle data across container restarts. The data bind mount is mounted at the C:\\Oracle\\Data on Windows (or /Oracle/Data on Unix) path on the host machine in the Oracle container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The Oracle hosting integration automatically adds a health check for the Oracle resource. The health check verifies that the Oracle server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Oracle NuGet package.']","The AspNetCore.HealthChecks.Npgsql NuGet package facilitates health monitoring for PostgreSQL databases in .NET Aspire applications by automatically adding a health check for the PostgreSQL server resource. This health check verifies that the PostgreSQL server is running and that a connection can be established to it. Similarly, the AspNetCore.HealthChecks.Oracle NuGet package provides health monitoring for Oracle databases by adding a health check for the Oracle resource. This health check ensures that the Oracle server is running and that a connection can be established. Both packages integrate with the /health HTTP endpoint, which specifies that all registered health checks must pass for the application to be considered ready to accept traffic.",multi_hop_specific_query_synthesizer
39,"How can the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration be configured for an existing .NET microservices app, and what are the steps to enable health checks for Cosmos DB connections?","['<1-hop>\n\ntitle: .NET Aspire Cosmos DB Entity Framework Core integration description: Learn how to install and configure the .NET Aspire Cosmos DB Entity Framework Core integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-entity-framework-integration .NET Aspire Cosmos DB Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.Cosmos"" Version=""*"" /> Add Cosmos DB context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmosdb that same name should be used when calling AddCosmosDbContext. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(MyDbContext context) { // Use context... } For more information on using Entity Framework Core with Azure Cosmos DB, see the Examples for Azure Cosmos DB for NoSQL SDK for .NET. Configuration The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddCosmosDbContext: csharp builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information, see the ConnectionString documentation. Use configuration providers The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""Cosmos"": { ""DisableTracing"": true } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json. Use inline delegates You can also pass the Action<EntityFrameworkCoreCosmosSettings> configureSettings delegate to set up some or all the csharp builder.AddCosmosDbContext<MyDbContext>( ""cosmosdb"", settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn\'t implement health checks, though this may change in future releases. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: Add .NET Aspire to an existing .NET app description: Learn how to add .NET Aspire integrations, orchestration, and tooling to a microservices app that already exists. ms.date: 11/08/2024 ms.topic: how-to zone_pivot_groups: dev-environment Tutorial: Add .NET Aspire to an existing .NET app If you have existing microservices and .NET web app, you can add .NET Aspire to it and get all the included features and benefits. In this article, you add .NET Aspire orchestration to a simple, preexisting .NET 9 project. You learn how to: [!div class=""checklist""] Understand the structure of the existing microservices app. Enroll existing projects in .NET Aspire orchestration. Understand the changes enrollment makes in the projects. Start the .NET Aspire project. [!INCLUDE aspire-prereqs] Get started Let\'s start by obtaining the code for the solution: Open a command prompt and change directories to where you want to store the code. To clone to .NET 9 example solution, use the following git clone command: bash git clone https://github.com/MicrosoftDocs/mslearn-dotnet-cloudnative-devops.git eShopLite']","The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration can be configured for an existing .NET microservices app by following these steps: 

1. **Install Required NuGet Packages**: Install the `Aspire.Microsoft.EntityFrameworkCore.Cosmos` NuGet package in the client-consuming project to enable Cosmos DB integration. Additionally, install the `AspNetCore.HealthChecks.CosmosDb` NuGet package to enable health checks for Cosmos DB resources.

2. **Add Cosmos DB Context**: In the `Program.cs` file of the client-consuming project, call `builder.AddCosmosDbContext<MyDbContext>(""cosmosdb"");`. Ensure that the `connectionName` parameter matches the name used when adding the Cosmos DB resource in the app host project.

3. **Configure Connection Strings**: Use a connection string from the `ConnectionStrings` configuration section. For example, you can define the connection string in the configuration file as follows:
   ```json
   {
       ""ConnectionStrings"": {
           ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};""
       }
   }
   ```
   Then, retrieve the connection string by calling `builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection"");`.

4. **Use Configuration Providers or Inline Delegates**: You can configure additional settings using JSON configuration providers or inline delegates. For example, to disable tracing, you can use:
   ```csharp
   builder.AddCosmosDbContext<MyDbContext>(""cosmosdb"", settings => settings.DisableTracing = true);
   ```

5. **Enable Health Checks**: The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. This health check verifies that the Cosmos DB is running and that a connection can be established. However, note that the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently does not implement health checks by default, though this may change in future releases.

For an existing .NET microservices app, you can add .NET Aspire orchestration by enrolling the projects in .NET Aspire orchestration. This involves understanding the structure of the existing app, enrolling the projects, and starting the .NET Aspire project. The code for a sample solution can be cloned using the following command:
```bash
git clone https://github.com/MicrosoftDocs/mslearn-dotnet-cloudnative-devops.git eShopLite
```",multi_hop_specific_query_synthesizer
40,How do OpenTelemetry.Instrumentation.SqlClient and OpenTelemetry.Instrumentation.StackExchangeRedis differ in their support for metrics and tracing in .NET Aspire integrations?,"[""<1-hop>\n\nLogging The .NET Aspire SQL Server integration currently doesn't enable logging by default due to limitations of the Tracing The .NET Aspire SQL Server integration emits the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.SqlClient Metrics The .NET Aspire SQL Server integration will emit the following metrics using OpenTelemetry: Microsoft.Data.SqlClient.EventSource active-hard-connections hard-connects hard-disconnects active-soft-connects soft-connects soft-disconnects number-of-non-pooled-connections number-of-pooled-connections number-of-active-connection-pool-groups number-of-inactive-connection-pool-groups number-of-active-connection-pools number-of-inactive-connection-pools number-of-active-connections number-of-free-connections number-of-stasis-connections number-of-reclaimed-connections See also Azure SQL Database SQL Server .NET Aspire database containers sample .NET Aspire integrations .NET Aspire GitHub repo"", '<2-hop>\n\nObservability and telemetry .NET Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as the pillars of observability. For more information about integration observability and telemetry, see .NET Aspire integrations overview. Depending on the backing service, some integrations might only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the Configuration section. Logging The .NET Aspire Stack Exchange Redis integration uses the following log categories: Aspire.StackExchange.Redis Tracing The .NET Aspire Stack Exchange Redis integration will emit the following tracing activities using OpenTelemetry: OpenTelemetry.Instrumentation.StackExchangeRedis Metrics The .NET Aspire Stack Exchange Redis integration currently doesn\'t support metrics by default due to limitations with the StackExchange.Redis library. :::zone pivot=""redis"" [!INCLUDE azure-redis-app-host] [!INCLUDE azure-redis-client] :::zone-end See also Stack Exchange Redis docs .NET Aspire integrations .NET Aspire GitHub repo [!INCLUDE redis-trademark]']","OpenTelemetry.Instrumentation.SqlClient in .NET Aspire integrations supports both tracing and metrics, emitting various metrics such as active-hard-connections, hard-connects, and number-of-pooled-connections. In contrast, OpenTelemetry.Instrumentation.StackExchangeRedis supports tracing but does not support metrics by default due to limitations with the StackExchange.Redis library.",multi_hop_specific_query_synthesizer
41,What is Garnet from Microsoft Research and how does it integrate with .NET Aspire for Redis caching?,"['<1-hop>\n\ntitle: Stack Exchange Redis caching overview description: Learn about Stack Exchange Redis caching and how to use it in your applications. ms.date: 11/05/2024 Stack Exchange RedisÂ®* caching overview With .NET Aspire, there are several ways to use caching in your applications. One popular option is to use Stack Exchange Redis, which is a high-performance data store that can be used to store frequently accessed data. This article provides an overview of Stack Exchange Redis caching and links to resources that help you use it in your applications. To use multiple Redis caching integrations in your application, see Tutorial: Implement caching with .NET Aspire integrations. If you\'re interested in using the Redis Cache for Azure, see Tutorial: Deploy a .NET Aspire project with a Redis Cache to Azure. Redis serialization protocol (RESP) The Redis serialization protocol (RESP) is a binary-safe protocol that Redis uses to communicate with clients. RESP is a simple, text-based protocol that is easy to implement and efficient to parse. RESP is used to send commands to Redis and receive responses from Redis. RESP is designed to be fast and efficient, making it well-suited for use in high-performance applications. For more information, see Redis serialization protocol specification. In addition to Redis itself, there are two well-maintained implementations of RESP for .NET: Garnet: Garnet is a remote cache-store from Microsoft Research that offers strong performance (throughput and latency), scalability, storage, recovery, cluster sharding, key migration, and replication features. Garnet can work with existing Redis clients. Valkey: A flexible distributed key-value datastore that supports both caching and beyond caching workloads. .NET Aspire lets you easily model either the Redis, Garnet, or Valkey RESP protocol in your applications and you can choose which one to use based on your requirements. All of the .NET Aspire Redis integrations can be used with either the Redis, Garnet, or Valkey RESP protocol. Caching Caching is a technique used to store frequently accessed data in memory. This helps to reduce the time it takes to retrieve the data from the original source, such as a database or a web service. Caching can significantly improve the performance of an application by reducing the number of requests made to the original source. To access the Redis IConnectionMultiplexer object, you use the Aspire.StackExchange.Redis NuGet package: [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis integration [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis integration (Garnet) [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis integration (Valkey) Distributed caching Distributed caching is a type of caching that stores data across multiple servers. This allows the data to be shared between multiple instances of an application, which can help to improve scalability and performance. Distributed caching can be used to store a wide variety of data, such as session state, user profiles, and frequently accessed data. To use Redis distributed caching in your application (the IDistributedCache interface), use the Aspire.StackExchange.Redis.DistributedCaching NuGet package: [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis distributed caching integration [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis distributed caching integration (Garnet) [!div class=""nextstepaction""] .NET Aspire Stack Exchange Redis distributed caching integration (Valkey)', '<2-hop>\n\ntitle: .NET Aspire Redis integration description: Learn how to use the .NET Aspire Redis integration, which includes both hosting and client integrations. ms.date: 11/05/2024 zone_pivot_groups: resp-host .NET Aspire RedisÂ®* integration [!INCLUDE includes-hosting-and-client] :::zone pivot=""redis"" Redis is the world\'s fastest data platform for caching, vector search, and NoSQL databases. The .NET Aspire Redis integration enables you to connect to existing Redis instances, or create new instances from .NET with the docker.io/library/redis container image. :::zone-end :::zone pivot=""garnet"" Garnet is a a high-performance cache-store from Microsoft Research and complies with the Redis serialization protocol (RESP). The .NET Aspire Redis integration enables you to connect to existing Garnet instances, or create new instances from .NET with the ghcr.io/microsoft/garnet container image. :::zone-end :::zone pivot=""valkey"" Valkey is a Redis fork and complies with the Redis serialization protocol (RESP). It\'s a high-performance key/value datastore that supports a variety of workloads such as caching, message queues, and can act as a primary database. The .NET Aspire Redis integration enables you to connect to existing Valkey instances, or create new instances from .NET with the docker.io/valkey/valkey container image. :::zone-end Hosting integration :::zone pivot=""redis"" [!INCLUDE redis-app-host] :::zone-end :::zone pivot=""garnet"" [!INCLUDE garnet-app-host] :::zone-end :::zone pivot=""valkey"" [!INCLUDE valkey-app-host] :::zone-end Hosting integration health checks [!INCLUDE redis-hosting-health-checks] Client integration To get started with the .NET Aspire Stack Exchange Redis client integration, install the ðŸ“¦ Aspire.StackExchange.Redis NuGet package in the client-consuming project, that is, the project for the application that uses the Redis client. The Redis client integration registers an an IConnectionMultiplexer instance that you can use to interact with Redis. .NET CLI dotnetcli dotnet add package Aspire.StackExchange.Redis PackageReference xml <PackageReference Include=""Aspire.StackExchange.Redis"" Version=""*"" /> Add Redis client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddRedisClient(connectionName: ""cache""); :::zone pivot=""redis"" [!TIP] The connectionName parameter must match the name used when adding the Redis resource in the app host project. For more information, see Add Redis resource. :::zone-end :::zone pivot=""garnet"" [!TIP] The connectionName parameter must match the name used when adding the Garnet resource in the app host project. For more information, see Add Garnet resource. :::zone-end :::zone pivot=""valkey"" [!TIP] The connectionName parameter must match the name used when adding the Valkey resource in the app host project. For more information, see Add Valkey resource. :::zone-end You can then retrieve the IConnection instance using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService(IConnectionMultiplexer connectionMux) { // Use connection multiplexer... } For more information on dependency injection, see .NET dependency injection. Add keyed Redis client There might be situations where you want to register multiple IConnectionMultiplexer instances with different connection names. To register keyed Redis clients, call the csharp builder.AddKeyedRedisClient(name: ""chat""); builder.AddKeyedRedisClient(name: ""queue""); Then you can retrieve the IConnectionMultiplexer instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] IConnectionMultiplexer chatConnectionMux, [FromKeyedServices(""queue"")] IConnectionMultiplexer queueConnectionMux) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire Stack Exchange Redis client integration provides multiple options to configure the Redis connection based on the requirements and conventions of your project. Use a connection string :::zone pivot=""redis"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddRedis(""cache""); :::zone-end :::zone pivot=""garnet"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddGarnet(""cache""); :::zone-end :::zone pivot=""valkey"" When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling csharp builder.AddValkey(""cache""); :::zone-end Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""cache"": ""localhost:6379"" } } For more information on how to format this connection string, see the Stack Exchange Redis configuration docs. Use configuration providers [!INCLUDE redis-client-json-settings] Use inline delegates You can also pass the Action<StackExchangeRedisSettings> delegate to set up some or all the options inline, for example to configure DisableTracing: csharp builder.AddRedisClient( ""cache"", static settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Stack Exchange Redis integration handles the following: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.']","Garnet is a high-performance cache-store developed by Microsoft Research that complies with the Redis serialization protocol (RESP). It offers features such as strong performance (throughput and latency), scalability, storage, recovery, cluster sharding, key migration, and replication. Garnet can work with existing Redis clients. The .NET Aspire Redis integration enables developers to connect to existing Garnet instances or create new ones using the ghcr.io/microsoft/garnet container image. Developers can also use the Aspire.StackExchange.Redis NuGet package to integrate Garnet into their applications, allowing them to register and retrieve IConnectionMultiplexer instances for interacting with Garnet.",multi_hop_specific_query_synthesizer
42,How does the app host in .NET Aspire utilize launch settings and health checks to manage resource dependencies and ensure readiness during startup?,"['<1-hop>\n\nInternal settings that .NET Aspire uses to run the app host. These are set internally but can be accessed by integrations that extend .NET Aspire. App host configuration is provided by the app host launch profile. The app host has a launch settings file call launchSettings.json which has a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } } } } The preceding launch settings file: Has one launch profile named https. Configures an .NET Aspire app host project: The applicationUrl property configures the dashboard launch address (ASPNETCORE_URLS). Environment variables such as DOTNET_DASHBOARD_OTLP_ENDPOINT_URL and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL are set on the app host. For more information, see .NET Aspire and launch profiles. [!NOTE] Configuration described on this page is for .NET Aspire app host project. To configure the standalone dashboard, see dashboard configuration. Common configuration Option Default value Description ASPIRE_ALLOW_UNSECURED_TRANSPORT false Allows communication with the app host without https. ASPNETCORE_URLS (dashboard address) and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL (app host resource service address) must be secured with HTTPS unless true. DOTNET_ASPIRE_CONTAINER_RUNTIME docker Allows the user of alternative container runtimes for resources backed by containers. Possible values are docker (default) or podman . See Setup and tooling overview for more details . Resource service A resource service is hosted by the app host. The resource service is used by the dashboard to fetch information about resources which are being orchestrated by .NET Aspire. Option Default value Description DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null Configures the address of the resource service hosted by the app host. Automatically generated with launchSettings.json to have a random port on localhost. For example, https://localhost:17037 . DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key is required if the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . Dashboard By default, the dashboard is automatically started by the app host. The dashboard supports its own set of configuration, and some settings can be configured from the app host. Option Default value Description ASPNETCORE_URLS null Dashboard address. Must be https unless ASPIRE_ALLOW_UNSECURED_TRANSPORT or DistributedApplicationOptions.AllowUnsecuredTransport is true. Automatically generated with launchSettings.json to have a random port on localhost. The value in launch settings is set on the applicationUrls property. ASPNETCORE_ENVIRONMENT Production Configures the environment the dashboard runs as. For more information, see Use multiple environments in ASP.NET Core . DOTNET_DASHBOARD_OTLP_ENDPOINT_URL http://localhost:18889 if no gRPC endpoint is configured. Configures the dashboard OTLP gRPC address. Used by the dashboard to receive telemetry over OTLP. Set on resources as the OTEL_EXPORTER_OTLP_ENDPOINT env var. The OTEL_EXPORTER_OTLP_PROTOCOL env var is grpc . Automatically generated with launchSettings.json to have a random port on localhost. DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL null Configures the dashboard OTLP HTTP address. Used by the dashboard to receive telemetry over OTLP. If only DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL is configured then it is set on resources as the OTEL_EXPORTER_OTLP_ENDPOINT env var. The OTEL_EXPORTER_OTLP_PROTOCOL env var is http/protobuf . DOTNET_DASHBOARD_FRONTEND_BROWSERTOKEN Automatically generated 128-bit entropy token. Configures the frontend browser token. This is the value that must be entered to access the dashboard when the auth mode is BrowserToken. If no browser token is specified then a new token is generated each time the app host is launched. Internal Internal settings are used by the app host and integrations. Internal settings aren\'t designed to be configured directly. Option Default value Description AppHost:Directory The content root if there\'s no project. Directory of the project where the app host is located. Accessible from the . AppHost:Path The directory combined with the application name. The path to the app host. It combines the directory with the application name. AppHost:Sha256 It is created from the app host name when the app host is in publish mode. Otherwise it is created from the app host path. Hex encoded hash for the current application. The hash is based on the location of the app on the current machine so it is stable between launches of the app host. AppHost:OtlpApiKey Automatically generated 128-bit entropy token. The API key used to authenticate requests sent to the dashboard OTLP service. The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . AppHost:BrowserToken Automatically generated 128-bit entropy token. The browser token used to authenticate browsing to the dashboard when it is launched by the app host. The browser token can be set by DOTNET_DASHBOARD_FRONTEND_BROWSERTOKEN . The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . AppHost:ResourceService:AuthMode ApiKey . If DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS is true then the value is Unsecured . The authentication mode used to access the resource service. The value is present if needed: the app host is in run mode and the dashboard isn\'t disabled. AppHost:ResourceService:ApiKey Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key can be set by DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY . The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS .', '<2-hop>\n\nApp Host (Orchestration) The .NET Aspire app host is one of the most important features of .NET Aspire. In .NET Aspire 9, several new features were added specific to the app host. Waiting for dependencies If you\'ve been following along with .NET Aspire, you already know that your app host project is where you define your app model. You create a distributed application builder, add and configure resources, and express their dependencies. Now, you can specify that a resource should wait for another resource before starting. This can help avoid connection errors during startup by only starting resources when their dependencies are ""ready."" ```csharp var builder = DistributedApplication.CreateBuilder(args); var rabbit = builder.AddRabbitMQ(""rabbit""); builder.AddProject builder.Build().Run(); ``` When the app host starts, it waits for the rabbit resource to be ready before starting the api resource. There are two methods exposed to wait for a resource: For more information, see .NET Aspire app host: Waiting for resources. Resource health checks The WaitFor API uses standard .NET health checks to determine if a resource is ready. But what does ""a resource being ready"" mean? The best part is, that\'s configurable by the consumer beyond their default values. When a resource doesn\'t expose any health checks (no health checks registered in the app), the app host waits for the resource to be in the For resources that expose HTTP endpoints, you can easily add a health check that polls a specific path for an HTTP 200 response. ```csharp var builder = DistributedApplication.CreateBuilder(args); var catalogApi = builder.AddContainer(""catalog-api"", ""catalog-api"") .WithHttpEndpoint(targetPort: 8080) .WithHttpHealthCheck(""/health""); builder.AddProject builder.Build().Run(); ``` The preceding example adds a health check to the catalog-api resource. The app host waits for the health check to return a healthy status before starting the store resource. It determines that the resource is ready when the /health endpoint returns an HTTP 200 status code. While store is waiting for catalog-api to become healthy, the resources in the dashboard appear as: :::image type=""content"" source=""media/waiting-for-unhealthy-resource.png"" lightbox=""media/waiting-for-unhealthy-resource.png"" alt-text=""Waiting for an unhealthy resource before starting""::: The app host\'s health check mechanism builds upon the Health checks report data, which is displayed in the dashboard: :::image type=""content"" source=""media/health-check-details.png"" lightbox=""media/health-check-details.png"" alt-text=""Health check details in the dashboard\'s resource details view""::: Creating a custom health check is straightforward. Start by defining the health check, then associate its name with any resources it applies to. ```csharp var builder = DistributedApplication.CreateBuilder(args); var healthyAfter = DateTime.Now.AddSeconds(20); builder.Services.AddHealthChecks().AddCheck( ""delay20secs"", () => DateTime.Now > healthyAfter ? HealthCheckResult.Healthy() : HealthCheckResult.Unhealthy() ); var cache = builder.AddRedis(""cache"") .WithHealthCheck(""delay20secs""); builder.AddProject The preceding example adds a health check to the cache resource, which reports it as unhealthy for the first 20 seconds after the app host starts. So, the myapp resource waits for 20 seconds before starting, ensuring the cache resource is healthy. The Persistent containers The app host now supports persistent containers. Persistent containers deviate from the typical container life cycle of .NET Aspire orchestrated apps. While they\'re created and started (when not already available) by the .NET Aspire orchestrator, they\'re not destroyed by .NET Aspire. This is useful when you want to keep the container running even after the app host has stopped. [!IMPORTANT] To delete these containers, you must manually stop them using the container runtime. To define an IResourceBuilder<ContainerResource> with a persistent lifetime, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var queue = builder.AddRabbitMQ(""rabbit"") .WithLifetime(ContainerLifetime.Persistent); builder.AddProject builder.Build().Run(); ``` The dashboard shows persistent containers with a pin icon: :::image type=""content"" source=""media/persistent-container.png"" lightbox=""media/persistent-container.png"" alt-text=""Persistent containers""::: After the app host is stopped, the container will continue to run: :::image type=""content"" source=""media/persistent-container-docker-desktop.png"" lightbox=""media/persistent-container-docker-desktop.png"" alt-text=""Docker desktop showing RabbitMQ.""::: The container persistence mechanism attempts to identify when you might wish to recreate the container. For example, if the environment for the container changes, then the container is restarted so that you don\'t need to manually stop the container if the input configuration for the resource has changed. Resource commands The app host supports adding custom commands to resources. This is useful when you want to add custom functionality that is not natively supported by the app host. There\'s likely many opportunities where exposing custom extension methods on resources will be useful. The .NET Aspire Community Toolkit might be a good place to share these extensions. When you define a custom command, it\'s available in the dashboard as a user experience feature. [!IMPORTANT] These .NET Aspire dashboard commands are only available when running the dashboard locally. They\'re not available when running the dashboard in Azure Container Apps. For more information on creating custom resource commands, see How-to: Create custom resource commands in .NET Aspire. Container networking The app host now adds all containers to a common network named default-aspire-network. This is useful when you want to communicate between containers without going through the host network. This also makes it easier to migrate from docker compose to the app host, as containers can communicate with each other using the container name. Eventing model The eventing model allows developers to hook into the lifecycle of the application and resources. This is useful for running custom code at specific points in the application lifecycle. There are various ways to subscribe to events, including global events and per-resource events. Global events: The global events are analogous to the app host life cycle events. For more information, see App host life cycles. Per-resource events: For more information, see Eventing in .NET Aspire. Integrations .NET Aspire continues to add integrations that make it easy to get started with your favorite services and tools. For more information, see .NET Aspire integrations overview. Redis Insight Support for Redis Insights is available on a Redis resource: ```csharp var builder = DistributedApplication.CreateBuilder(args); builder.AddRedis(""redis"") .WithRedisInsight(); // Starts a Redis Insight container image // that is pre-configured to work with the // Redis instance. ``` The :::image type=""content"" source=""media/redis-insight.png"" lightbox=""media/redis-insight.png"" alt-text=""Redis Insight dashboard showing multiple Redis instances""::: For more information, see Add Redis resource with Redis Insights. OpenAI (Preview) Starting with .NET Aspire 9, an additional OpenAI integration is available which allows to use the latest official OpenAI dotnet library directly. The']","The app host in .NET Aspire uses the `launchSettings.json` file to configure its launch profiles, which include properties like `applicationUrl` for the dashboard address and environment variables such as `DOTNET_DASHBOARD_OTLP_ENDPOINT_URL` and `DOTNET_RESOURCE_SERVICE_ENDPOINT_URL`. These settings define how the app host starts and integrates with resources. Additionally, the app host employs health checks to manage resource dependencies and ensure readiness during startup. For example, the `WaitFor` API leverages standard .NET health checks to determine if a resource is ready. Developers can configure health checks, such as polling an HTTP endpoint for a 200 response, to signal that a resource is healthy. This mechanism ensures that dependent resources only start when their prerequisites are ready, avoiding connection errors and improving startup reliability.",multi_hop_specific_query_synthesizer
43,How do the AspNetCore.HealthChecks.MongoDb and AspNetCore.HealthChecks.CosmosDb packages support hosting integration health checks for MongoDB and Cosmos DB in .NET Aspire?,"['<1-hop>\n\ntitle: .NET Aspire Cosmos DB Entity Framework Core integration description: Learn how to install and configure the .NET Aspire Cosmos DB Entity Framework Core integration to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. ms.date: 12/18/2024 uid: dotnet/aspire/azure-cosmos-db-entity-framework-integration .NET Aspire Cosmos DB Entity Framework Core integration [!INCLUDE includes-hosting-and-client] Azure Cosmos DB is a fully managed NoSQL database service for modern app development. The .NET Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator. Hosting integration [!INCLUDE cosmos-app-host] Hosting integration health checks The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.CosmosDb NuGet package. Client integration To get started with the .NET Aspire Microsoft Entity Framework Core Cosmos DB integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.Cosmos NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.Cosmos"" Version=""*"" /> Add Cosmos DB context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddCosmosDbContext<MyDbContext>(""cosmosdb""); [!TIP] The connectionName parameter must match the name used when adding the Cosmos DB resource in the app host project. In other words, when you call AddAzureCosmosDB and provide a name of cosmosdb that same name should be used when calling AddCosmosDbContext. For more information, see Add Azure Cosmos DB resource. You can then retrieve the csharp public class ExampleService(MyDbContext context) { // Use context... } For more information on using Entity Framework Core with Azure Cosmos DB, see the Examples for Azure Cosmos DB for NoSQL SDK for .NET. Configuration The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling builder.AddCosmosDbContext: csharp builder.AddCosmosDbContext<MyDbContext>(""CosmosConnection""); And then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""CosmosConnection"": ""AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"" } } For more information, see the ConnectionString documentation. Use configuration providers The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration supports json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""Cosmos"": { ""DisableTracing"": true } } } } } For the complete Cosmos DB client integration JSON schema, see Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json. Use inline delegates You can also pass the Action<EntityFrameworkCoreCosmosSettings> configureSettings delegate to set up some or all the csharp builder.AddCosmosDbContext<MyDbContext>( ""cosmosdb"", settings => settings.DisableTracing = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn\'t implement health checks, though this may change in future releases. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\nAdd MongoDB server resource and database resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithLifetime(ContainerLifetime.Persistent); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!NOTE] The MongoDB container can be slow to start, so it\'s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see Container resource lifetime. When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/mongo image, it creates a new MongoDB instance on your local machine. A reference to your MongoDB server resource builder (the mongo variable) is used to add a database. The database is named mongodb and then added to the ExampleProject. The MongoDB server resource includes default credentials: MONGO_INITDB_ROOT_USERNAME: A value of admin. MONGO_INITDB_ROOT_PASSWORD: Random password generated using the When the app host runs, the password is stored in the app host\'s secret store. It\'s added to the Parameters section, for example: json { ""Parameters:mongo-password"": ""<THE_GENERATED_PASSWORD>"" } The name of the parameter is mongo-password, but really it\'s just formatting the resource name with a -password suffix. For more information, see Safe storage of app secrets in development in ASP.NET Core and Add MongoDB server resource with parameters. The [!TIP] If you\'d rather connect to an existing MongoDB server, call Add MongoDB server resource with data volume To add a data volume to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithDataVolume(); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the MongoDB server data outside the lifecycle of its container. The data volume is mounted at the /data/db path in the MongoDB server container and when a name parameter isn\'t provided, the name is generated at random. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. [!WARNING] The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume. Add MongoDB server resource with data bind mount To add a data bind mount to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithDataBindMount(@""C:\\MongoDB\\Data""); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the MongoDB server data across container restarts. The data bind mount is mounted at the C:\\MongoDB\\Data on Windows (or /MongoDB/Data on Unix) path on the host machine in the MongoDB server container. For more information on data bind mounts, see Docker docs: Bind mounts. Add MongoDB server resource with initialization data bind mount To add an initialization folder data bind mount to the MongoDB server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithInitBindMount(@""C:\\MongoDB\\Init""); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` The initialization data bind mount is used to initialize the MongoDB server with data. The initialization data bind mount is mounted at the C:\\MongoDB\\Init on Windows (or /MongoDB/Init on Unix) path on the host machine in the MongoDB server container and maps to the /docker-entrypoint-initdb.d path in the MongoDB server container. MongoDB executes the scripts found in this folder, which is useful for loading data into the database. Add MongoDB server resource with parameters When you want to explicitly provide the password used by the container image, you can provide these credentials as parameters. Consider the following alternative example: ```csharp var builder = DistributedApplication.CreateBuilder(args); var username = builder.AddParameter(""username""); var password = builder.AddParameter(""password"", secret: true); var mongo = builder.AddMongoDB(""mongo"", username, password); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` For more information on providing parameters, see External parameters. Add MongoDB Express resource MongoDB Express is a web-based MongoDB admin user interface. To add a MongoDB Express resource that corresponds to the docker.io/library/mongo-express container image, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var mongo = builder.AddMongoDB(""mongo"") .WithMongoExpress(); var mongodb = mongo.AddDatabase(""mongodb""); builder.AddProject // After adding all resources, run the app... ``` [!TIP] To configure the host port for the The preceding code adds a MongoDB Express resource that is configured to connect to the MongoDB server resource. The default credentials are: ME_CONFIG_MONGODB_SERVER: The name assigned to the parent MongoDBServerResource, in this case it would be mongo. ME_CONFIG_BASICAUTH: A value of false. ME_CONFIG_MONGODB_PORT: Assigned from the primary endpoint\'s target port of the parent MongoDBServerResource. ME_CONFIG_MONGODB_ADMINUSERNAME: The same username as configured in the parent MongoDBServerResource. ME_CONFIG_MONGODB_ADMINPASSWORD: The same password as configured in the parent MongoDBServerResource. Additionally, the WithMongoExpress API exposes an optional configureContainer parameter of type Action<IResourceBuilder<MongoExpressContainerResource>> that you use to configure the MongoDB Express container resource. Hosting integration health checks The MongoDB hosting integration automatically adds a health check for the MongoDB server resource. The health check verifies that the MongoDB server resource is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.MongoDb NuGet package.']","The AspNetCore.HealthChecks.MongoDb and AspNetCore.HealthChecks.CosmosDb packages support hosting integration health checks in .NET Aspire by verifying the availability and connectivity of their respective database resources. For MongoDB, the hosting integration automatically adds a health check for the MongoDB server resource to ensure it is running and a connection can be established. Similarly, for Cosmos DB, the hosting integration adds a health check to verify that the Cosmos DB resource is operational and accessible. These health checks are integrated into the hosting environment to provide observability and ensure the reliability of the database connections.",multi_hop_specific_query_synthesizer
44,How can the Aspire.Hosting.NodeJS and Aspire.Hosting.Azure packages be used together to integrate Node.js apps into a .NET Aspire project and deploy them to Azure using Bicep templates?,"[""<1-hop>\n\ntitle: Orchestrate Node.js apps in .NET Aspire description: Learn how to integrate Node.js and npm apps into a .NET Aspire App Host project. ms.date: 11/20/2024 Orchestrate Node.js apps in .NET Aspire In this article, you learn how to use Node.js and Node Package Manager (npm) apps in a .NET Aspire project. The sample app in this article demonstrates Angular, React, and Vue client experiences. The following .NET Aspire APIs exist to support these scenariosâ€”and they're part of the Aspire.Hosting.NodeJS NuGet package: Node.js: npm apps: The difference between these two APIs is that the former is used to host Node.js apps, while the latter is used to host apps that execute from a package.json file's scripts sectionâ€”and the corresponding npm run <script-name> command. [!TIP] The sample source code for this article is available on GitHub, and there are details available on the Code Samples: .NET Aspire with Angular, React and Vue page. [!IMPORTANT] While this article is focused on Single-Page App (SPA) frontend bits, there's an additional Node.js sample available on the Code Samples: .NET Aspire Node.js sample page, that demonstrates how to use Node.js as a server app with express. [!INCLUDE aspire-prereqs] Additionally, you need to install Node.js on your machine. The sample app in this article was built with Node.js version 20.12.2 and npm version 10.5.1. To verify your Node.js and npm versions, run the following commands: nodejs node --version nodejs npm --version To download Node.js (including npm), see the Node.js download page. Clone sample source code To clone the sample source code from GitHub, run the following command: bash git clone https://github.com/dotnet/aspire-samples.git After cloning the repository, navigate to the samples/AspireWithJavaScript folder: bash cd samples/AspireWithJavaScript From this directory, there are six child directories described in the following list: AspireJavaScript.Angular: An Angular app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.AppHost: A .NET Aspire project that orchestrates the other apps in this sample. For more information, see .NET Aspire orchestration overview. AspireJavaScript.MinimalApi: An HTTP API that returns randomly generated weather forecast data. AspireJavaScript.React: A React app that consumes the weather forecast API and displays the data in a table. AspireJavaScript.ServiceDefaults: The default shared project for .NET Aspire projects. For more information, see .NET Aspire service defaults. AspireJavaScript.Vue: A Vue app that consumes the weather forecast API and displays the data in a table. Install client dependencies The sample app demonstrates how to use JavaScript client apps that are built on top of Node.js. Each client app was written either using a npm create template command or manually. The following table lists the template commands used to create each client app, along with the default port: App type Create template command Default port Angular npm create @angular@latest 4200 React Didn't use a template. PORT env var Vue npm create vue@latest 5173 [!TIP] You don't need to run any of these commands, since the sample app already includes the clients. Instead, this is a point of reference from which the clients were created. For more information, see npm-init. To run the app, you first need to install the dependencies for each client. To do so, navigate to each client folder and run npm install (or the install alias npm i) commands. Install Angular dependencies nodejs npm i ./AspireJavaScript.Angular/ For more information on the Angular app, see explore the Angular client. Install React dependencies nodejs npm i ./AspireJavaScript.React/ For more information on the React app, see explore the React client. Install Vue dependencies nodejs npm i ./AspireJavaScript.Vue/ For more information on the Vue app, see explore the Vue client."", '<2-hop>\n\nIt aims to drastically simplify the authoring experience with a cleaner syntax and better support for modularity and code reuse. While .NET Aspire provides a set of prebuilt Bicep templates, there might be times when you either want to customize the templates or create your own. This section explains the concepts and corresponding APIs that you can use to customize the Bicep templates. [!IMPORTANT] This section isn\'t intended to teach you Bicep, but rather to provide guidance on how to create custom Bicep templates for use with .NET Aspire. As part of the Azure deployment story for .NET Aspire, the Azure Developer CLI (azd) provides an understanding of your .NET Aspire project and the ability to deploy it to Azure. The azd CLI uses the Bicep templates to deploy the application to Azure. Install Aspire.Hosting.Azure package When you want to reference Bicep files, it\'s possible that you\'re not using any of the Azure hosting integrations. In this case, you can still reference Bicep files by installing the Aspire.Hosting.Azure package. This package provides the necessary APIs to reference Bicep files and customize the Azure resources. [!TIP] If you\'re using any of the Azure hosting integrations, you don\'t need to install the Aspire.Hosting.Azure package, as it\'s a transitive dependency. To use any of this functionality, the ðŸ“¦ Aspire.Hosting.Azure NuGet package must be installed: .NET CLI dotnetcli dotnet add package Aspire.Hosting.Azure PackageReference xml <PackageReference Include=""Aspire.Hosting.Azure"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. What to expect from the examples All the examples in this section assume that you\'re using the ```csharp using Aspire.Hosting.Azure; var builder = DistributedApplication.CreateBuilder(args); // Examples go here... builder.Build().Run(); ``` By default, when you call any of the Bicep-related APIs, a call is also made to Reference Bicep files Imagine that you have a Bicep template in a file named storage.bicep that provisions an Azure Storage Account: :::code language=""bicep"" source=""snippets/AppHost.Bicep/storage.bicep""::: To add a reference to the Bicep file on disk, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.ReferenceBicep.cs"" id=""addfile""::: The preceding code adds a reference to a Bicep file located at ../infra/storage.bicep. The file paths should be relative to the app host project. This reference results in an Reference Bicep inline While having a Bicep file on disk is the most common scenario, you can also add Bicep templates inline. Inline templates can be useful when you want to define a template in code or when you want to generate the template dynamically. To add an inline Bicep template, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.InlineBicep.cs"" id=""addinline""::: In this example, the Bicep template is defined as an inline string and added to the application\'s resources collection with the name ""ai"". This example provisions an Azure AI resource. Pass parameters to Bicep templates Bicep supports accepting parameters, which can be used to customize the behavior of the template. To pass parameters to a Bicep template from .NET Aspire, chain calls to the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.PassParameter.cs"" id=""addparameter""::: The preceding code: Adds a parameter named ""region"" to the builder instance. Adds a reference to a Bicep file located at ../infra/storage.bicep. Passes the ""region"" parameter to the Bicep template, which is resolved using the standard parameter resolution. Passes the ""storageName"" parameter to the Bicep template with a hardcoded value. Passes the ""tags"" parameter to the Bicep template with an array of strings. For more information, see External parameters. Well-known parameters .NET Aspire provides a set of well-known parameters that can be passed to Bicep templates. These parameters are used to provide information about the application and the environment to the Bicep templates. The following well-known parameters are available: Field Description Value The name of the key vault resource used to store secret outputs. ""keyVaultName"" The location of the resource. This is required for all resources. ""location"" The resource ID of the log analytics workspace. ""logAnalyticsWorkspaceId"" The principal ID of the current user or managed identity. ""principalId"" The principal name of the current user or managed identity. ""principalName"" The principal type of the current user or managed identity. Either User or ServicePrincipal . ""principalType"" To use a well-known parameter, pass the parameter name to the Consider an example where you want to set up an Azure Event Grid webhook. You might define the Bicep template as follows: :::code language=""bicep"" source=""snippets/AppHost.Bicep/event-grid-webhook.bicep"" highlight=""3-4,27-35""::: This Bicep template defines several parameters, including the topicName, webHookEndpoint, principalId, principalType, and the optional location. To pass these parameters to the Bicep template, you can use the following code snippet: :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.PassParameter.cs"" id=""addwellknownparams""::: The webHookApi project is added as a reference to the builder. The topicName parameter is passed a hardcoded name value. The webHookEndpoint parameter is passed as an expression that resolves to the URL from the api project references\' ""https"" endpoint with the /hook route. The principalId and principalType parameters are passed as well-known parameters. The well-known parameters are convention-based and shouldn\'t be accompanied with a corresponding value when passed using the WithParameter API. Well-known parameters simplify some common functionality, such as role assignments, when added to the Bicep templates, as shown in the preceding example. Role assignments are required for the Event Grid webhook to send events to the specified endpoint. For more information, see Event Grid Data Sender role assignment. Get outputs from Bicep references In addition to passing parameters to Bicep templates, you can also get outputs from the Bicep templates. Consider the following Bicep template, as it defines an output named endpoint: :::code language=""bicep"" source=""snippets/AppHost.Bicep/storage-out.bicep""::: The Bicep defines an output named endpoint. To get the output from the Bicep template, call the :::code language=""csharp"" source=""snippets/AppHost.Bicep/Program.GetOutputReference.cs"" id=""getoutput""::: In this example, the output from the Bicep template is retrieved and stored in an endpoint variable. Typically, you would pass this output as an environment variable to another resource that relies on it. For instance, if you had an ASP.NET Core Minimal API project that depended on this endpoint, you could pass the output as an environment variable to the project using the following code snippet: ```csharp var storage = builder.AddBicepTemplate( name: ""storage"", bicepFile: ""../infra/storage.bicep"" );']","The Aspire.Hosting.NodeJS package allows the integration of Node.js apps into a .NET Aspire project by providing APIs to host Node.js applications or execute npm scripts defined in a package.json file. For deployment to Azure, the Aspire.Hosting.Azure package can be used to reference and customize Bicep templates, which define Azure resources. By combining these packages, you can orchestrate Node.js apps within a .NET Aspire project and deploy them to Azure. For example, you can use the Aspire.Hosting.NodeJS package to manage the Node.js app and the Aspire.Hosting.Azure package to define and deploy the necessary Azure infrastructure, such as storage accounts or webhooks, using Bicep templates. Parameters and outputs from the Bicep templates can also be passed and retrieved to further integrate the Node.js app with Azure services.",multi_hop_specific_query_synthesizer
45,how use AspNetCore.HealthChecks.SqlServer and AspNetCore.HealthChecks.Npgsql for health check setup?,"['<1-hop>\n\ntitle: .NET Aspire PostgreSQL Entity Framework Core integration description: Learn how to integrate PostgreSQL with .NET Aspire applications using Entity Framework Core, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-ef-core-integration .NET Aspire PostgreSQL Entity Framework Core integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL Entity Framework Core integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL Entity Framework Core client integration, install the ðŸ“¦ Aspire.Npgsql.EntityFrameworkCore.PostgreSQL NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The .NET Aspire PostgreSQL Entity Framework Core client integration registers your desired DbContext subclass instances that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql.EntityFrameworkCore.PostgreSQL PackageReference xml <PackageReference Include=""Aspire.Npgsql.EntityFrameworkCore.PostgreSQL"" Version=""*"" /> Add Npgsql database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDbContext<YourDbContext>(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding YourDbContext to the builder, you can get the YourDbContext instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(YourDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add Npgsql database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichNpgsqlDbContext<YourDbContext>( connectionName: ""postgresdb"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30; }); The settings parameter is an instance of the Configuration The .NET Aspire PostgreSQL Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling the csharp builder.AddNpgsqlDbContext<MyDbContext>(""pgdb""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""pgdb"": ""Host=myserver;Database=test"" } } The EnrichNpgsqlDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it\'s called. For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL Entity Framework Core integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""EntityFrameworkCore"": { ""PostgreSQL"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true } } } } } For the complete PostgreSQL Entity Framework Core client integration JSON schema, see Aspire.Npgsql.EntityFrameworkCore.PostgreSQL/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlEntityFrameworkCorePostgreSQLSettings> delegate to set up some or all the options inline, for example to set the ConnectionString: csharp builder.AddNpgsqlDbContext<YourDbContext>( ""pgdb"", static settings => settings.ConnectionString = ""<YOUR CONNECTION STRING>""); Configure multiple DbContext classes If you want to register more than one json { ""Aspire"": { ""Npgsql"": { ""EntityFrameworkCore"": { ""PostgreSQL"": { ""ConnectionString"": ""<YOUR CONNECTION STRING>"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""AnotherDbContext"": { ""ConnectionString"": ""<ANOTHER CONNECTION STRING>"", ""DisableTracing"": false } } } } } } Then calling the csharp builder.AddNpgsqlDbContext<AnotherDbContext>(); [!INCLUDE integration-health-checks] By default, the .NET Aspire PostgreSQL Entity Framework Core integrations handles the following: Adds the DbContextHealthCheck, which calls EF Core\'s Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: .NET Aspire SQL Server Entity Framework Core integration description: Learn how to use the .NET Aspire SQL Server Entity Framework integration, which includes both hosting and client integrations. ms.date: 12/02/2024 uid: database/sql-server-ef-core-integration .NET Aspire SQL Server Entity Framework Core integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server Entity Framework Core integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server Entity Framework Core integration, install the ðŸ“¦ Aspire.Microsoft.EntityFrameworkCore.SqlServer NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server Entity Framework Core client. .NET CLI dotnetcli dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer PackageReference xml <PackageReference Include=""Aspire.Microsoft.EntityFrameworkCore.SqlServer"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add SQL Server database context In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerDbContext. For more information, see Add SQL Server resource and database resource. To retrieve ExampleDbContext object from a service: csharp public class ExampleService(ExampleDbContext context) { // Use context... } For more information on dependency injection, see .NET dependency injection. Add SQL Server database context with enrichment To enrich the DbContext with additional services, such as automatic retries, health checks, logging and telemetry, call the csharp builder.EnrichSqlServerDbContext<ExampleDbContext>( connectionName: ""database"", configureSettings: settings => { settings.DisableRetry = false; settings.CommandTimeout = 30 // seconds }); The settings parameter is an instance of the Configuration The .NET Aspire SQL Server Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use connection string When using a connection string from the ConnectionStrings configuration section, you provide the name of the connection string when calling builder.AddSqlServerDbContext<TContext>(): csharp builder.AddSqlServerDbContext<ExampleDbContext>(""sql""); The connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""sql"": ""Data Source=myserver;Initial Catalog=master"" } } The EnrichSqlServerDbContext won\'t make use of the ConnectionStrings configuration section since it expects a DbContext to be registered at the point it\'s called. For more information, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server Entity Framework Core integration supports The following is an example of an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""SqlServer"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableMetrics"": false } } } } } Use inline configurations You can also pass the Action<MicrosoftEntityFrameworkCoreSqlServerSettings> delegate to set up some or all the options inline, for example to turn off the metrics: csharp builder.AddSqlServerDbContext<YourDbContext>( ""sql"", static settings => settings.DisableMetrics = true); Configure multiple DbContext connections If you want to register more than one DbContext with different configuration, you can use $""Aspire.Microsoft.EntityFrameworkCore.SqlServer:{typeof(TContext).Name}"" configuration section name. The json configuration would look like: json { ""Aspire"": { ""Microsoft"": { ""EntityFrameworkCore"": { ""SqlServer"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DbContextPooling"": true, ""DisableHealthChecks"": true, ""DisableTracing"": true, ""DisableMetrics"": false, ""AnotherDbContext"": { ""ConnectionString"": ""AnotherDbContext_CONNECTIONSTRING"", ""DisableTracing"": false } } } } } } Then calling the AddSqlServerDbContext method with AnotherDbContext type parameter would load the settings from Aspire:Microsoft:EntityFrameworkCore:SqlServer:AnotherDbContext section. csharp builder.AddSqlServerDbContext<AnotherDbContext>(""another-sql""); Configuration options Here are the configurable options with corresponding default values: Name Description ConnectionString The connection string of the SQL Server database to connect to. DbContextPooling A boolean value that indicates whether the db context will be pooled or explicitly created every time it\'s requested MaxRetryCount The maximum number of retry attempts. Default value is 6, set it to 0 to disable the retry mechanism. DisableHealthChecks A boolean value that indicates whether the database health check is disabled or not. DisableTracing A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. DisableMetrics A boolean value that indicates whether the OpenTelemetry metrics are disabled or not. Timeout The time in seconds to wait for the command to execute. [!INCLUDE integration-health-checks] By default, the .NET Aspire Sql Server Entity Framework Core integration handles the following: Adds the DbContextHealthCheck, which calls EF Core\'s Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]']","To set up health checks using AspNetCore.HealthChecks.SqlServer, you can integrate it with the .NET Aspire SQL Server Entity Framework Core hosting integration. This automatically adds a health check for the SQL Server resource, verifying that the server is running and a connection can be established. Similarly, for PostgreSQL, the AspNetCore.HealthChecks.Npgsql package is used in the .NET Aspire PostgreSQL Entity Framework Core hosting integration to add a health check for the PostgreSQL server resource, ensuring it is operational and accessible.",multi_hop_specific_query_synthesizer
46,"How does the .NET Aspire SQL Server integration support health monitoring and observability, and how can it be added to an existing .NET microservices app?","['<1-hop>\n\ntitle: .NET Aspire SQL Server integration description: Learn how to use the .NET Aspire SQL Server integration, which includes both hosting and client integrations. ms.date: 11/20/2024 uid: database/sql-server-integration .NET Aspire SQL Server integration [!INCLUDE includes-hosting-and-client] SQL Server is a relational database management system developed by Microsoft. The .NET Aspire SQL Server integration enables you to connect to existing SQL Server instances or create new instances from .NET with the mcr.microsoft.com/mssql/server container image. Hosting integration [!INCLUDE sql-app-host] Hosting integration health checks The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.SqlServer NuGet package. Client integration To get started with the .NET Aspire SQL Server client integration, install the ðŸ“¦ Aspire.Microsoft.Data.SqlClient NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a .NET CLI dotnetcli dotnet add package Aspire.Microsoft.Data.SqlClient PackageReference xml <PackageReference Include=""Aspire.Microsoft.Data.SqlClient"" Version=""*"" /> Add SQL Server client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddSqlServerClient(connectionName: ""database""); [!TIP] The connectionName parameter must match the name used when adding the SQL Server database resource in the app host project. In other words, when you call AddDatabase and provide a name of database that same name should be used when calling AddSqlServerClient. For more information, see Add SQL Server resource and database resource. You can then retrieve the csharp public class ExampleService(SqlConnection connection) { // Use connection... } For more information on dependency injection, see .NET dependency injection. Add keyed SQL Server client There might be situations where you want to register multiple SqlConnection instances with different connection names. To register keyed SQL Server clients, call the csharp builder.AddKeyedSqlServerClient(name: ""mainDb""); builder.AddKeyedSqlServerClient(name: ""loggingDb""); [!IMPORTANT] When using keyed services, it\'s expected that your SQL Server resource configured two named databases, one for the mainDb and one for the loggingDb. Then you can retrieve the SqlConnection instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""mainDb"")] SqlConnection mainDbConnection, [FromKeyedServices(""loggingDb"")] SqlConnection loggingDbConnection) { // Use connections... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddSqlServerClient(connectionName: ""sql""); Then the connection string is retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""database"": ""Data Source=myserver;Initial Catalog=master"" } } For more information on how to format this connection string, see the ConnectionString. Use configuration providers The .NET Aspire SQL Server integration supports json { ""Aspire"": { ""Microsoft"": { ""Data"": { ""SqlClient"": { ""ConnectionString"": ""YOUR_CONNECTIONSTRING"", ""DisableHealthChecks"": false, ""DisableMetrics"": true } } } } } For the complete SQL Server client integration JSON schema, see Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json. Use inline delegates Also you can pass the Action<MicrosoftDataSqlClientSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks from code: csharp builder.AddSqlServerClient( ""database"", static settings => settings.DisableHealthChecks = true); Client integration health checks By default, .NET Aspire integrations enable health checks for all services. For more information, see .NET Aspire integrations overview. The .NET Aspire SQL Server integration: Adds the health check when Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic. [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: Add .NET Aspire to an existing .NET app description: Learn how to add .NET Aspire integrations, orchestration, and tooling to a microservices app that already exists. ms.date: 11/08/2024 ms.topic: how-to zone_pivot_groups: dev-environment Tutorial: Add .NET Aspire to an existing .NET app If you have existing microservices and .NET web app, you can add .NET Aspire to it and get all the included features and benefits. In this article, you add .NET Aspire orchestration to a simple, preexisting .NET 9 project. You learn how to: [!div class=""checklist""] Understand the structure of the existing microservices app. Enroll existing projects in .NET Aspire orchestration. Understand the changes enrollment makes in the projects. Start the .NET Aspire project. [!INCLUDE aspire-prereqs] Get started Let\'s start by obtaining the code for the solution: Open a command prompt and change directories to where you want to store the code. To clone to .NET 9 example solution, use the following git clone command: bash git clone https://github.com/MicrosoftDocs/mslearn-dotnet-cloudnative-devops.git eShopLite']","The .NET Aspire SQL Server integration supports health monitoring and observability by automatically adding health checks for the SQL Server resource. These health checks verify that the SQL Server is running and that a connection can be established. The integration relies on the AspNetCore.HealthChecks.SqlServer NuGet package and integrates with the /health HTTP endpoint, ensuring all registered health checks must pass for the app to be considered ready to accept traffic. Additionally, the integration supports telemetry by allowing configuration options such as enabling or disabling health checks and metrics through JSON configuration or inline delegates.

To add .NET Aspire to an existing .NET microservices app, you can enroll the projects in .NET Aspire orchestration. This process involves understanding the structure of the existing app, enrolling the projects, and making necessary changes to integrate the orchestration. For example, you can clone a preexisting .NET 9 project, such as the eShopLite solution from MicrosoftDocs, and follow the steps to integrate .NET Aspire features, including SQL Server integration, health monitoring, and observability.",multi_hop_specific_query_synthesizer
47,How do the AspNetCore.HealthChecks.Npgsql and AspNetCore.HealthChecks.Nats packages contribute to health monitoring in .NET Aspire applications?,"['<1-hop>\n\ntitle: .NET Aspire PostgreSQL integration description: Learn how to integrate PostgreSQL with .NET Aspire applications, using both hosting and client integrations. ms.date: 11/05/2024 uid: database/postgresql-integration .NET Aspire PostgreSQL integration [!INCLUDE includes-hosting-and-client] PostgreSQL is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The .NET Aspire PostgreSQL integration provides a way to connect to existing PostgreSQL databases, or create new instances from .NET with the docker.io/library/postgres container image. Hosting integration [!INCLUDE postgresql-app-host] Hosting integration health checks The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Npgsql NuGet package. Client integration To get started with the .NET Aspire PostgreSQL client integration, install the ðŸ“¦ Aspire.Npgsql NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The PostgreSQL client integration registers an NpgsqlDataSource instance that you can use to interact with PostgreSQL. .NET CLI dotnetcli dotnet add package Aspire.Npgsql PackageReference xml <PackageReference Include=""Aspire.Npgsql"" Version=""*"" /> Add Npgsql client In the :::no-loc text=""Program.cs""::: file of your client-consuming project, call the csharp builder.AddNpgsqlDataSource(connectionName: ""postgresdb""); [!TIP] The connectionName parameter must match the name used when adding the PostgreSQL server resource in the app host project. For more information, see Add PostgreSQL server resource. After adding NpgsqlDataSource to the builder, you can get the NpgsqlDataSource instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the ExampleService class is registered with the dependency injection container: csharp public class ExampleService(NpgsqlDataSource dataSource) { // Use dataSource... } For more information on dependency injection, see .NET dependency injection. Add keyed Npgsql client There might be situations where you want to register multiple NpgsqlDataSource instances with different connection names. To register keyed Npgsql clients, call the csharp builder.AddKeyedNpgsqlDataSource(name: ""chat""); builder.AddKeyedNpgsqlDataSource(name: ""queue""); Then you can retrieve the NpgsqlDataSource instances using dependency injection. For example, to retrieve the connection from an example service: csharp public class ExampleService( [FromKeyedServices(""chat"")] NpgsqlDataSource chatDataSource, [FromKeyedServices(""queue"")] NpgsqlDataSource queueDataSource) { // Use data sources... } For more information on keyed services, see .NET dependency injection: Keyed services. Configuration The .NET Aspire PostgreSQL integration provides multiple configuration approaches and options to meet the requirements and conventions of your project. Use a connection string When using a connection string from the ConnectionStrings configuration section, you can provide the name of the connection string when calling the csharp builder.AddNpgsqlDataSource(""postgresdb""); Then the connection string will be retrieved from the ConnectionStrings configuration section: json { ""ConnectionStrings"": { ""postgresdb"": ""Host=myserver;Database=postgresdb"" } } For more information, see the ConnectionString. Use configuration providers The .NET Aspire PostgreSQL integration supports The following example shows an :::no-loc text=""appsettings.json""::: file that configures some of the available options: json { ""Aspire"": { ""Npgsql"": { ""ConnectionString"": ""Host=myserver;Database=postgresdb"", ""DisableHealthChecks"": false, ""DisableTracing"": true, ""DisableMetrics"": false } } } For the complete PostgreSQL client integration JSON schema, see Aspire.Npgsql/ConfigurationSchema.json. Use inline delegates You can also pass the Action<NpgsqlSettings> configureSettings delegate to set up some or all the options inline, for example to disable health checks: csharp builder.AddNpgsqlDataSource( ""postgresdb"", static settings => settings.DisableHealthChecks = true); [!INCLUDE integration-health-checks] Adds the NpgSqlHealthCheck, which verifies that commands can be successfully executed against the underlying Postgres Database. Integrates with the /health HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic [!INCLUDE integration-observability-and-telemetry]', '<2-hop>\n\ntitle: .NET Aspire NATS integration description: Learn how to use the .NET Aspire NATS integration to send logs and traces to a NATS Server. ms.date: 10/11/2024 uid: messaging/nats-integration .NET Aspire NATS integration [!INCLUDE includes-hosting-and-client] NATS is a high-performance, secure, distributed messaging system. The .NET Aspire NATS integration enables you to connect to existing NATS instances, or create new instances from .NET with the docker.io/library/nats container image. Hosting integration NATS hosting integration for .NET Aspire models a NATS server as the .NET CLI dotnetcli dotnet add package Aspire.Hosting.Nats PackageReference xml <PackageReference Include=""Aspire.Hosting.Nats"" Version=""*"" /> For more information, see dotnet add package or Manage package dependencies in .NET applications. Add NATS server resource In your app host project, call ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); builder.AddProject // After adding all resources, run the app... ``` When .NET Aspire adds a container image to the app host, as shown in the preceding example with the docker.io/library/nats image, it creates a new NATS server instance on your local machine. A reference to your NATS server (the nats variable) is added to the ExampleProject. The [!TIP] If you\'d rather connect to an existing NATS server, call Add NATS server resource with JetStream To add the NATS JetStream to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithJetStream(); builder.AddProject // After adding all resources, run the app... ``` The NATS JetStream functionality provides a built-in persistence engine called JetStream which enables messages to be stored and replayed at a later time. You can optionally provide a srcMountPath parameter to specify the path to the JetStream data directory on the host machine (the provided mount path maps to the container\'s -sd argument). Add NATS server resource with data volume To add a data volume to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataVolume(isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` The data volume is used to persist the NATS server data outside the lifecycle of its container. The data volume is mounted at the /var/lib/nats path in the NATS server container. A name is generated at random unless you provide a set the name parameter. For more information on data volumes and details on why they\'re preferred over bind mounts, see Docker docs: Volumes. Add NATS server resource with data bind mount To add a data bind mount to the NATS server resource, call the ```csharp var builder = DistributedApplication.CreateBuilder(args); var nats = builder.AddNats(""nats""); .WithDataBindMount( source: @""C:\\NATS\\Data"", isReadOnly: false); builder.AddProject // After adding all resources, run the app... ``` [!INCLUDE data-bind-mount-vs-volumes] Data bind mounts rely on the host machine\'s filesystem to persist the NATS server data across container restarts. The data bind mount is mounted at the C:\\NATS\\Data on Windows (or /NATS/Data on Unix) path on the host machine in the NATS server container. For more information on data bind mounts, see Docker docs: Bind mounts. Hosting integration health checks The NATS hosting integration automatically adds a health check for the NATS server resource. The health check verifies that the NATS server is running and that a connection can be established to it. The hosting integration relies on the ðŸ“¦ AspNetCore.HealthChecks.Nats NuGet package.']","The AspNetCore.HealthChecks.Npgsql package is used in the .NET Aspire PostgreSQL hosting integration to automatically add a health check for the PostgreSQL server resource. This health check verifies that the PostgreSQL server is running and that a connection can be established to it. Similarly, the AspNetCore.HealthChecks.Nats package is used in the .NET Aspire NATS hosting integration to add a health check for the NATS server resource. This health check ensures that the NATS server is running and that a connection can be established. Both packages integrate with the /health HTTP endpoint, which specifies that all registered health checks must pass for the application to be considered ready to accept traffic.",multi_hop_specific_query_synthesizer
48,how apphost use sql scripts for seedin data and what launchsettings.json do?,"['<1-hop>\n\ntitle: Seed data in a database using .NET Aspire description: Learn about how to seed database data in .NET Aspire ms.date: 08/12/2024 ms.topic: how-to Seed data in a database using .NET Aspire In this article, you learn how to configure .NET Aspire projects to seed data in a database during app startup. .NET Aspire enables you to seed data using database scripts or Entity Framework Core for common platforms such as SQL Server, PostgreSQL and MySQL. When to seed data Seeding data pre-populates database tables with rows of data so they\'re ready for testing via your app. You may want to seed data for the following scenarios: Manually develop and test different features of your app against a meaningful set of data, such as a product catalog or list of customers. Run test suites to verify that features behave a specific way with a given set of data. Manually seeding data is tedious and time consuming, so you should automate the process when possible. Use volumes to run database scripts for .NET Aspire projects during startup. You can also seed your database using tools like Entity Framework Core, which handles many underlying concerns for you. Understand containerized databases By default, .NET Aspire database integrations rely on containerized databases, which create the following challenges when trying to seed data: .NET Aspire destroys and recreates containers every time the app restarts, which means by default you have to re-seed your database every time the app restarts. Depending on your selected database technology, the new container instance may or may not create a default database, which means you might also have to create the database itself. Even if a default database exists, it most likely will not have the desired name or schema for your specific app. .NET Aspire enables you to resolve these challenges using volumes and a few configurations to seed data effectively. Seed data using volumes and SQL scripts Volumes are the recommended way to automatically seed containerized databases when using SQL scripts. Volumes can store data for multiple containers at a time, offer high performance and are easy to back up or migrate. With .NET Aspire, you configure a volume for each resource container using the Source: The source path of the volume mount, which is the physical location on your host. Target: The target path in the container of the data you want to persist. Consider the following volume configuration code from a :::no-loc text=""Program.cs""::: file in a sample AppHost project: csharp var todosDbName = ""Todos""; var todosDb = builder.AddPostgres(""postgres"") .WithEnvironment(""POSTGRES_DB"", todosDbName) .WithBindMount( ""../DatabaseContainers.ApiService/data/postgres"", ""/docker-entrypoint-initdb.d"") .AddDatabase(todosDbName); In this example, the .WithBindMount method parameters configure the following: ../DatabaseContainers.ApiService/data/postgres sets a path to the SQL script in your local project that you want to run in the container to seed data. /docker-entrypoint-initdb.d sets the path to an entry point in the container so your script will be run during container startup. The referenced SQL script located at ../DatabaseContainers.ApiService/data/postgres creates and seeds a Todos table: ```sql -- Postgres init script -- Create the Todos table CREATE TABLE IF NOT EXISTS Todos ( Id SERIAL PRIMARY KEY, Title text UNIQUE NOT NULL, IsComplete boolean NOT NULL DEFAULT false ); -- Insert some sample data into the Todos table INSERT INTO Todos (Title, IsComplete) VALUES (\'Give the dog a bath\', false), (\'Wash the dishes\', false), (\'Do the groceries\', false) ON CONFLICT DO NOTHING; ``` The script runs during startup every time a new container instance is created. Database seeding examples The following examples demonstrate how to seed data using SQL scripts and configurations applied using the .WithBindMount method for different database technologies: [!NOTE] Visit the Database Container Sample App to view the full project and file structure for each database option. SQL Server The configuration code in the .AppHost :::no-loc text=""Program.cs""::: file mounts the required database files and folders and configures an entrypoint so that they run during startup. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""37-49"" ::: The entrypoint.sh script lives in the mounted ./sqlserverconfig project folder and runs when the container starts. The script launches SQL Server and checks that it\'s running. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/sqlserverconfig/entrypoint.sh"" ::: The init.sql SQL script that lives in the mounted ../DatabaseContainers.ApiService/data/sqlserver project folder creates the database and tables. :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/sqlserver/init.sql"" ::: PostgreSQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""3-15"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/postgres/init.sql"" ::: MySQL Configuration code in the .AppHost project: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.AppHost/Program.cs"" range=""20-32"" ::: Corresponding SQL script included in the app: :::code source=""~/aspire-samples/samples/DatabaseContainers/DatabaseContainers.ApiService/data/mysql/init.sql"" :::', '<2-hop>\n\nInternal settings that .NET Aspire uses to run the app host. These are set internally but can be accessed by integrations that extend .NET Aspire. App host configuration is provided by the app host launch profile. The app host has a launch settings file call launchSettings.json which has a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } } } } The preceding launch settings file: Has one launch profile named https. Configures an .NET Aspire app host project: The applicationUrl property configures the dashboard launch address (ASPNETCORE_URLS). Environment variables such as DOTNET_DASHBOARD_OTLP_ENDPOINT_URL and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL are set on the app host. For more information, see .NET Aspire and launch profiles. [!NOTE] Configuration described on this page is for .NET Aspire app host project. To configure the standalone dashboard, see dashboard configuration. Common configuration Option Default value Description ASPIRE_ALLOW_UNSECURED_TRANSPORT false Allows communication with the app host without https. ASPNETCORE_URLS (dashboard address) and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL (app host resource service address) must be secured with HTTPS unless true. DOTNET_ASPIRE_CONTAINER_RUNTIME docker Allows the user of alternative container runtimes for resources backed by containers. Possible values are docker (default) or podman . See Setup and tooling overview for more details . Resource service A resource service is hosted by the app host. The resource service is used by the dashboard to fetch information about resources which are being orchestrated by .NET Aspire. Option Default value Description DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null Configures the address of the resource service hosted by the app host. Automatically generated with launchSettings.json to have a random port on localhost. For example, https://localhost:17037 . DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key is required if the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . Dashboard By default, the dashboard is automatically started by the app host. The dashboard supports its own set of configuration, and some settings can be configured from the app host. Option Default value Description ASPNETCORE_URLS null Dashboard address. Must be https unless ASPIRE_ALLOW_UNSECURED_TRANSPORT or DistributedApplicationOptions.AllowUnsecuredTransport is true. Automatically generated with launchSettings.json to have a random port on localhost. The value in launch settings is set on the applicationUrls property. ASPNETCORE_ENVIRONMENT Production Configures the environment the dashboard runs as. For more information, see Use multiple environments in ASP.NET Core . DOTNET_DASHBOARD_OTLP_ENDPOINT_URL http://localhost:18889 if no gRPC endpoint is configured. Configures the dashboard OTLP gRPC address. Used by the dashboard to receive telemetry over OTLP. Set on resources as the OTEL_EXPORTER_OTLP_ENDPOINT env var. The OTEL_EXPORTER_OTLP_PROTOCOL env var is grpc . Automatically generated with launchSettings.json to have a random port on localhost. DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL null Configures the dashboard OTLP HTTP address. Used by the dashboard to receive telemetry over OTLP. If only DOTNET_DASHBOARD_OTLP_HTTP_ENDPOINT_URL is configured then it is set on resources as the OTEL_EXPORTER_OTLP_ENDPOINT env var. The OTEL_EXPORTER_OTLP_PROTOCOL env var is http/protobuf . DOTNET_DASHBOARD_FRONTEND_BROWSERTOKEN Automatically generated 128-bit entropy token. Configures the frontend browser token. This is the value that must be entered to access the dashboard when the auth mode is BrowserToken. If no browser token is specified then a new token is generated each time the app host is launched. Internal Internal settings are used by the app host and integrations. Internal settings aren\'t designed to be configured directly. Option Default value Description AppHost:Directory The content root if there\'s no project. Directory of the project where the app host is located. Accessible from the . AppHost:Path The directory combined with the application name. The path to the app host. It combines the directory with the application name. AppHost:Sha256 It is created from the app host name when the app host is in publish mode. Otherwise it is created from the app host path. Hex encoded hash for the current application. The hash is based on the location of the app on the current machine so it is stable between launches of the app host. AppHost:OtlpApiKey Automatically generated 128-bit entropy token. The API key used to authenticate requests sent to the dashboard OTLP service. The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . AppHost:BrowserToken Automatically generated 128-bit entropy token. The browser token used to authenticate browsing to the dashboard when it is launched by the app host. The browser token can be set by DOTNET_DASHBOARD_FRONTEND_BROWSERTOKEN . The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . AppHost:ResourceService:AuthMode ApiKey . If DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS is true then the value is Unsecured . The authentication mode used to access the resource service. The value is present if needed: the app host is in run mode and the dashboard isn\'t disabled. AppHost:ResourceService:ApiKey Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key can be set by DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY . The value is present if needed: the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS .']","AppHost uses SQL scripts for seeding data by configuring volumes in the application. For example, the .WithBindMount method in the Program.cs file specifies the source path of the SQL script and the target path in the container where the script will run during startup. This allows the database to be seeded automatically every time a new container instance is created. The launchSettings.json file in AppHost provides configuration for how the application is launched. It includes profiles that define options such as the application URL, environment variables, and other settings like DOTNET_DASHBOARD_OTLP_ENDPOINT_URL for telemetry and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL for resource service integration.",multi_hop_specific_query_synthesizer
49,"How does the configuration of the launchSettings.json file in a .NET Aspire app host project enable telemetry integration with a Python application, and what role does the ASPIRE_ALLOW_UNSECURED_TRANSPORT environment variable play in this process?","['<1-hop>\n\nAdd telemetry support. To add a bit of observability, add telemetry to help monitor the dependant Python app. In the Python project, add the following OpenTelemetry package as a dependency in the requirements.txt file: :::code language=""python"" source=""snippets/PythonSample/hello-python/requirements.txt"" highlight=""2-5""::: The preceding requirement update, adds the OpenTelemetry package and the OTLP exporter. Next, re-install the Python app requirements into the virtual environment by running the following command: python python -m pip install -r requirements.txt The preceding command installs the OpenTelemetry package and the OTLP exporter, in the virtual environment. Update the Python app to include the OpenTelemetry code, by replacing the existing main.py code with the following: :::code language=""python"" source=""snippets/PythonSample/hello-python/main.py""::: Update the app host project\'s launchSettings.json file to include the ASPIRE_ALLOW_UNSECURED_TRANSPORT environment variable: :::code language=""json"" source=""snippets/PythonSample/PythonSample.AppHost/Properties/launchSettings.json""::: The ASPIRE_ALLOW_UNSECURED_TRANSPORT variable is required because when running locally the OpenTelemetry client in Python rejects the local development certificate. Launch the app host again: dotnetcli dotnet run --project ../PythonSample.AppHost/PythonSample.AppHost.csproj Once the app host has launched navigate to the dashboard and note that in addition to console log output, structured logging is also being routed through to the dashboard. :::image source=""media/python-telemetry-in-dashboard.png"" lightbox=""media/python-telemetry-in-dashboard.png"" alt-text="".NET Aspire dashboard: Structured logging from Python process.""::: Summary While there are several considerations that are beyond the scope of this article, you learned how to build .NET Aspire solution that integrates with Python. You also learned how to use the AddPythonApp API to host Python apps. See also GitHub: .NET Aspire Samplesâ€”Python hosting integration', '<2-hop>\n\ntitle: .NET Aspire app host configuration description: Learn about the .NET Aspire app host configuration options. ms.date: 11/21/2024 ms.topic: reference App host configuration The app host project configures and starts your distributed application ( Configuration includes: Settings for hosting the resource service, such as the address and authentication options. Settings used to start the .NET Aspire dashboard, such the dashboard\'s frontend and OpenTelemetry Protocol (OTLP) addresses. Internal settings that .NET Aspire uses to run the app host. These are set internally but can be accessed by integrations that extend .NET Aspire. App host configuration is provided by the app host launch profile. The app host has a launch settings file call launchSettings.json which has a list of launch profiles. Each launch profile is a collection of related options which defines how you would like dotnet to start your application. json { ""$schema"": ""https://json.schemastore.org/launchsettings.json"", ""profiles"": { ""https"": { ""commandName"": ""Project"", ""dotnetRunMessages"": true, ""launchBrowser"": true, ""applicationUrl"": ""https://localhost:17134;http://localhost:15170"", ""environmentVariables"": { ""ASPNETCORE_ENVIRONMENT"": ""Development"", ""DOTNET_ENVIRONMENT"": ""Development"", ""DOTNET_DASHBOARD_OTLP_ENDPOINT_URL"": ""https://localhost:21030"", ""DOTNET_RESOURCE_SERVICE_ENDPOINT_URL"": ""https://localhost:22057"" } } } } The preceding launch settings file: Has one launch profile named https. Configures an .NET Aspire app host project: The applicationUrl property configures the dashboard launch address (ASPNETCORE_URLS). Environment variables such as DOTNET_DASHBOARD_OTLP_ENDPOINT_URL and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL are set on the app host. For more information, see .NET Aspire and launch profiles. [!NOTE] Configuration described on this page is for .NET Aspire app host project. To configure the standalone dashboard, see dashboard configuration. Common configuration Option Default value Description ASPIRE_ALLOW_UNSECURED_TRANSPORT false Allows communication with the app host without https. ASPNETCORE_URLS (dashboard address) and DOTNET_RESOURCE_SERVICE_ENDPOINT_URL (app host resource service address) must be secured with HTTPS unless true. DOTNET_ASPIRE_CONTAINER_RUNTIME docker Allows the user of alternative container runtimes for resources backed by containers. Possible values are docker (default) or podman . See Setup and tooling overview for more details . Resource service A resource service is hosted by the app host. The resource service is used by the dashboard to fetch information about resources which are being orchestrated by .NET Aspire. Option Default value Description DOTNET_RESOURCE_SERVICE_ENDPOINT_URL null Configures the address of the resource service hosted by the app host. Automatically generated with launchSettings.json to have a random port on localhost. For example, https://localhost:17037 . DOTNET_DASHBOARD_RESOURCESERVICE_APIKEY Automatically generated 128-bit entropy token. The API key used to authenticate requests made to the app host\'s resource service. The API key is required if the app host is in run mode, the dashboard isn\'t disabled, and the dashboard isn\'t configured to allow anonymous access with DOTNET_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS . ']","The configuration of the launchSettings.json file in a .NET Aspire app host project enables telemetry integration with a Python application by defining environment variables and settings necessary for the app host to function correctly. Specifically, the file includes a launch profile that sets properties such as applicationUrl for the dashboard and environment variables like DOTNET_DASHBOARD_OTLP_ENDPOINT_URL, which specifies the OpenTelemetry Protocol (OTLP) endpoint for structured logging. The ASPIRE_ALLOW_UNSECURED_TRANSPORT environment variable is particularly important when running locally, as it allows communication with the app host without HTTPS. This is necessary because the OpenTelemetry client in Python rejects the local development certificate by default. By setting this variable, the app host can successfully integrate with the Python application for telemetry purposes, enabling structured logging to be routed to the .NET Aspire dashboard.",multi_hop_specific_query_synthesizer
50,"How do the logging and tracing capabilities of Microsoft.EntityFrameworkCore.Query differ between the Cosmos DB and SQL Server integrations in .NET Aspire, and what metrics are supported for each integration?","['<1-hop>\n\nLogging The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration uses the following log categories: Azure-Cosmos-Operation-Request-Diagnostics Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Query Tracing The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration will emit the following tracing activities using OpenTelemetry: Azure.Cosmos.Operation OpenTelemetry.Instrumentation.EntityFrameworkCore Metrics The .NET Aspire Microsoft Entity Framework Core Cosmos DB integration currently supports the following metrics: Microsoft.EntityFrameworkCore ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second See also Azure Cosmos DB docs .NET Aspire integrations .NET Aspire GitHub repo', '<2-hop>\n\nLogging The .NET Aspire SQL Server Entity Framework Core integration uses the following Log categories: Microsoft.EntityFrameworkCore.ChangeTracking Microsoft.EntityFrameworkCore.Database.Command Microsoft.EntityFrameworkCore.Database.Connection Microsoft.EntityFrameworkCore.Database.Transaction Microsoft.EntityFrameworkCore.Infrastructure Microsoft.EntityFrameworkCore.Migrations Microsoft.EntityFrameworkCore.Model Microsoft.EntityFrameworkCore.Model.Validation Microsoft.EntityFrameworkCore.Query Microsoft.EntityFrameworkCore.Update Tracing The .NET Aspire SQL Server Entity Framework Core integration will emit the following Tracing activities using OpenTelemetry: ""OpenTelemetry.Instrumentation.EntityFrameworkCore"" Metrics The .NET Aspire SQL Server Entity Framework Core integration will emit the following metrics using OpenTelemetry: Microsoft.EntityFrameworkCore: ec_Microsoft_EntityFrameworkCore_active_db_contexts ec_Microsoft_EntityFrameworkCore_total_queries ec_Microsoft_EntityFrameworkCore_queries_per_second ec_Microsoft_EntityFrameworkCore_total_save_changes ec_Microsoft_EntityFrameworkCore_save_changes_per_second ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate ec_Microsoft_Entity_total_execution_strategy_operation_failures ec_Microsoft_E_execution_strategy_operation_failures_per_second ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second See also Azure SQL Database documentation .NET Aspire integrations .NET Aspire GitHub repo']","The logging capabilities of Microsoft.EntityFrameworkCore.Query in the .NET Aspire Cosmos DB integration include the log category 'Microsoft.EntityFrameworkCore.Query,' while the SQL Server integration also includes 'Microsoft.EntityFrameworkCore.Query' as a log category. For tracing, both integrations emit activities using 'OpenTelemetry.Instrumentation.EntityFrameworkCore.' Regarding metrics, both integrations support similar metrics such as 'ec_Microsoft_EntityFrameworkCore_active_db_contexts,' 'ec_Microsoft_EntityFrameworkCore_total_queries,' 'ec_Microsoft_EntityFrameworkCore_queries_per_second,' 'ec_Microsoft_EntityFrameworkCore_total_save_changes,' 'ec_Microsoft_EntityFrameworkCore_save_changes_per_second,' 'ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate,' 'ec_Microsoft_Entity_total_execution_strategy_operation_failures,' 'ec_Microsoft_E_execution_strategy_operation_failures_per_second,' 'ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures,' and 'ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second.' These metrics are emitted using OpenTelemetry for both integrations, ensuring consistent telemetry support across Cosmos DB and SQL Server.",multi_hop_specific_query_synthesizer
